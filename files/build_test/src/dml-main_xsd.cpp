#include "dml-main_xsd.h"
#include <stdlib.h>
#include <sstream>
#include <algorithm>
#include <functional>
#include <assert.h>
#include "shared-relationshipReference_xsd.h"
#include "shared-commonSimpleTypes_xsd.h"
#include "dml-diagram_xsd.h"
#include "dml-chart_xsd.h"
#include "dml-picture_xsd.h"
#include "dml-lockedCanvas_xsd.h"
namespace ns_a {
using namespace std;

// Element

// Attribute

// ST_StyleMatrixColumnIndex
ST_StyleMatrixColumnIndex::ST_StyleMatrixColumnIndex()
    :m_has_unsignedInt(false),
     m_unsignedInt(0)
{
}
ST_StyleMatrixColumnIndex::ST_StyleMatrixColumnIndex(const XSD::unsignedInt_& _unsignedInt)
    :m_has_unsignedInt(true)
{

    set_unsignedInt(_unsignedInt);
}
ST_StyleMatrixColumnIndex::~ST_StyleMatrixColumnIndex()
{
    clear();
}
bool ST_StyleMatrixColumnIndex::has_unsignedInt() const
{
    return m_has_unsignedInt;
}

void ST_StyleMatrixColumnIndex::set_unsignedInt(const XSD::unsignedInt_& _unsignedInt)
{
    m_has_unsignedInt = true;
    m_unsignedInt = _unsignedInt;
}

const XSD::unsignedInt_& ST_StyleMatrixColumnIndex::get_unsignedInt() const
{
    return m_unsignedInt;
}

void ST_StyleMatrixColumnIndex::clear()
{
    m_has_unsignedInt = false;
    m_unsignedInt = 0;;
}

void ST_StyleMatrixColumnIndex::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_unsignedInt)
    {
        _outStream << " " << _attrName << "=\"" << m_unsignedInt << "\"";;
    }
}

const ST_StyleMatrixColumnIndex& ST_StyleMatrixColumnIndex::default_instance()
{
    if (!ST_StyleMatrixColumnIndex::default_instance_)
    {
        ST_StyleMatrixColumnIndex::default_instance_ = new ST_StyleMatrixColumnIndex();
    }
    return *ST_StyleMatrixColumnIndex::default_instance_;
}

std::string ST_StyleMatrixColumnIndex::toString() const
{
    std::stringstream strStream;
    strStream << get_unsignedInt();
    return strStream.str();
}

ST_StyleMatrixColumnIndex* ST_StyleMatrixColumnIndex::default_instance_ = NULL;

// ST_FontCollectionIndex
ST_FontCollectionIndex::ST_FontCollectionIndex()
    :m_has_type(false)
{
}
ST_FontCollectionIndex::ST_FontCollectionIndex(const ST_FontCollectionIndex::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_FontCollectionIndex::~ST_FontCollectionIndex()
{
    clear();
}
bool ST_FontCollectionIndex::has_type() const
{
    return m_has_type;
}

void ST_FontCollectionIndex::set_type(const ST_FontCollectionIndex::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_FontCollectionIndex::Type& ST_FontCollectionIndex::get_type() const
{
    return m_type;
}

std::string ST_FontCollectionIndex::toString() const
{
    return ST_FontCollectionIndex::TypeStrList[m_type];
}

void ST_FontCollectionIndex::clear()
{
    m_has_type = false;
}

void ST_FontCollectionIndex::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_FontCollectionIndex& ST_FontCollectionIndex::default_instance()
{
    if (!ST_FontCollectionIndex::default_instance_)
    {
        ST_FontCollectionIndex::default_instance_ = new ST_FontCollectionIndex();
    }
    return *ST_FontCollectionIndex::default_instance_;
}

const std::string ST_FontCollectionIndex::TypeStrList[] =
{
    "major",
    "minor",
    "none"
};
ST_FontCollectionIndex* ST_FontCollectionIndex::default_instance_ = NULL;

// ST_ColorSchemeIndex
ST_ColorSchemeIndex::ST_ColorSchemeIndex()
    :m_has_type(false)
{
}
ST_ColorSchemeIndex::ST_ColorSchemeIndex(const ST_ColorSchemeIndex::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_ColorSchemeIndex::~ST_ColorSchemeIndex()
{
    clear();
}
bool ST_ColorSchemeIndex::has_type() const
{
    return m_has_type;
}

void ST_ColorSchemeIndex::set_type(const ST_ColorSchemeIndex::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_ColorSchemeIndex::Type& ST_ColorSchemeIndex::get_type() const
{
    return m_type;
}

std::string ST_ColorSchemeIndex::toString() const
{
    return ST_ColorSchemeIndex::TypeStrList[m_type];
}

void ST_ColorSchemeIndex::clear()
{
    m_has_type = false;
}

void ST_ColorSchemeIndex::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_ColorSchemeIndex& ST_ColorSchemeIndex::default_instance()
{
    if (!ST_ColorSchemeIndex::default_instance_)
    {
        ST_ColorSchemeIndex::default_instance_ = new ST_ColorSchemeIndex();
    }
    return *ST_ColorSchemeIndex::default_instance_;
}

const std::string ST_ColorSchemeIndex::TypeStrList[] =
{
    "dk1",
    "lt1",
    "dk2",
    "lt2",
    "accent1",
    "accent2",
    "accent3",
    "accent4",
    "accent5",
    "accent6",
    "hlink",
    "folHlink"
};
ST_ColorSchemeIndex* ST_ColorSchemeIndex::default_instance_ = NULL;

// ST_Coordinate
ST_Coordinate::ST_Coordinate()
    :m_has_ST_CoordinateUnqualified(false),
     m_ST_CoordinateUnqualified(NULL),
     m_has_ST_UniversalMeasure(false),
     m_ST_UniversalMeasure(NULL)
{
}
ST_Coordinate::ST_Coordinate(const ST_Coordinate& _ST_Coordinate)
    :m_has_ST_CoordinateUnqualified(false),
     m_ST_CoordinateUnqualified(NULL),
     m_has_ST_UniversalMeasure(false),
     m_ST_UniversalMeasure(NULL)
{

    m_has_ST_CoordinateUnqualified = _ST_Coordinate.has_ST_CoordinateUnqualified();
    if (_ST_Coordinate.has_ST_CoordinateUnqualified())
    {
        m_ST_CoordinateUnqualified = new ST_CoordinateUnqualified(_ST_Coordinate.get_ST_CoordinateUnqualified());
    }


    m_has_ST_UniversalMeasure = _ST_Coordinate.has_ST_UniversalMeasure();
    if (_ST_Coordinate.has_ST_UniversalMeasure())
    {
        m_ST_UniversalMeasure = new ns_s::ST_UniversalMeasure(_ST_Coordinate.get_ST_UniversalMeasure());
    }
}
ST_Coordinate::~ST_Coordinate()
{
    clear();
}
bool ST_Coordinate::has_ST_CoordinateUnqualified() const
{
    return m_has_ST_CoordinateUnqualified;
}

ST_CoordinateUnqualified* ST_Coordinate::mutable_ST_CoordinateUnqualified()
{
    clear_ST_UniversalMeasure();
    m_has_ST_CoordinateUnqualified = true;
    if (!m_ST_CoordinateUnqualified)
    {
        m_ST_CoordinateUnqualified = new ST_CoordinateUnqualified();
    }
    return m_ST_CoordinateUnqualified;
}

const ST_CoordinateUnqualified& ST_Coordinate::get_ST_CoordinateUnqualified() const
{
    if (m_ST_CoordinateUnqualified)
    {
        return *m_ST_CoordinateUnqualified;
    }
    return ST_CoordinateUnqualified::default_instance();
}

void ST_Coordinate::clear_ST_CoordinateUnqualified()
{
    m_has_ST_CoordinateUnqualified = false;
    if (m_ST_CoordinateUnqualified)
    {
        delete m_ST_CoordinateUnqualified;
        m_ST_CoordinateUnqualified = NULL;
    }
}

bool ST_Coordinate::has_ST_UniversalMeasure() const
{
    return m_has_ST_UniversalMeasure;
}

ns_s::ST_UniversalMeasure* ST_Coordinate::mutable_ST_UniversalMeasure()
{
    clear_ST_CoordinateUnqualified();
    m_has_ST_UniversalMeasure = true;
    if (!m_ST_UniversalMeasure)
    {
        m_ST_UniversalMeasure = new ns_s::ST_UniversalMeasure();
    }
    return m_ST_UniversalMeasure;
}

const ns_s::ST_UniversalMeasure& ST_Coordinate::get_ST_UniversalMeasure() const
{
    if (m_ST_UniversalMeasure)
    {
        return *m_ST_UniversalMeasure;
    }
    return ns_s::ST_UniversalMeasure::default_instance();
}

void ST_Coordinate::clear_ST_UniversalMeasure()
{
    m_has_ST_UniversalMeasure = false;
    if (m_ST_UniversalMeasure)
    {
        delete m_ST_UniversalMeasure;
        m_ST_UniversalMeasure = NULL;
    }
}

std::string ST_Coordinate::toString() const
{
    if (m_has_ST_CoordinateUnqualified)
    {
        return m_ST_CoordinateUnqualified->toString();
    }

    if (m_has_ST_UniversalMeasure)
    {
        return m_ST_UniversalMeasure->toString();
    }

    return string();
}

void ST_Coordinate::clear()
{   clear_ST_CoordinateUnqualified();
    clear_ST_UniversalMeasure();
}

void ST_Coordinate::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_ST_CoordinateUnqualified)
    {
        m_ST_CoordinateUnqualified->toXmlAttr(_attrName, _outStream);
        return;
    }

    if (m_has_ST_UniversalMeasure)
    {
        m_ST_UniversalMeasure->toXmlAttr(_attrName, _outStream);
        return;
    }
}

const ST_Coordinate& ST_Coordinate::default_instance()
{
    if (!ST_Coordinate::default_instance_)
    {
        ST_Coordinate::default_instance_ = new ST_Coordinate();
    }
    return *ST_Coordinate::default_instance_;
}

ST_Coordinate* ST_Coordinate::default_instance_ = NULL;

// ST_CoordinateUnqualified
ST_CoordinateUnqualified::ST_CoordinateUnqualified()
    :m_has_long(false),
     m_long(0)
{
}
ST_CoordinateUnqualified::ST_CoordinateUnqualified(const XSD::long_& _long)
    :m_has_long(true)
{

    set_long(_long);
}
ST_CoordinateUnqualified::~ST_CoordinateUnqualified()
{
    clear();
}
bool ST_CoordinateUnqualified::has_long() const
{
    return m_has_long;
}

void ST_CoordinateUnqualified::set_long(const XSD::long_& _long)
{   assert(-27273042329600 <= _long);
    assert(_long <= 27273042316900);

    m_has_long = true;
    m_long = _long;
}

const XSD::long_& ST_CoordinateUnqualified::get_long() const
{
    return m_long;
}

void ST_CoordinateUnqualified::clear()
{
    m_has_long = false;
    m_long = 0;;
}

void ST_CoordinateUnqualified::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_long)
    {
        _outStream << " " << _attrName << "=\"" << m_long << "\"";;
    }
}

const ST_CoordinateUnqualified& ST_CoordinateUnqualified::default_instance()
{
    if (!ST_CoordinateUnqualified::default_instance_)
    {
        ST_CoordinateUnqualified::default_instance_ = new ST_CoordinateUnqualified();
    }
    return *ST_CoordinateUnqualified::default_instance_;
}

std::string ST_CoordinateUnqualified::toString() const
{
    std::stringstream strStream;
    strStream << get_long();
    return strStream.str();
}

ST_CoordinateUnqualified* ST_CoordinateUnqualified::default_instance_ = NULL;

// ST_Coordinate32
ST_Coordinate32::ST_Coordinate32()
    :m_has_ST_Coordinate32Unqualified(false),
     m_ST_Coordinate32Unqualified(NULL),
     m_has_ST_UniversalMeasure(false),
     m_ST_UniversalMeasure(NULL)
{
}
ST_Coordinate32::ST_Coordinate32(const ST_Coordinate32& _ST_Coordinate32)
    :m_has_ST_Coordinate32Unqualified(false),
     m_ST_Coordinate32Unqualified(NULL),
     m_has_ST_UniversalMeasure(false),
     m_ST_UniversalMeasure(NULL)
{

    m_has_ST_Coordinate32Unqualified = _ST_Coordinate32.has_ST_Coordinate32Unqualified();
    if (_ST_Coordinate32.has_ST_Coordinate32Unqualified())
    {
        m_ST_Coordinate32Unqualified = new ST_Coordinate32Unqualified(_ST_Coordinate32.get_ST_Coordinate32Unqualified());
    }


    m_has_ST_UniversalMeasure = _ST_Coordinate32.has_ST_UniversalMeasure();
    if (_ST_Coordinate32.has_ST_UniversalMeasure())
    {
        m_ST_UniversalMeasure = new ns_s::ST_UniversalMeasure(_ST_Coordinate32.get_ST_UniversalMeasure());
    }
}
ST_Coordinate32::~ST_Coordinate32()
{
    clear();
}
bool ST_Coordinate32::has_ST_Coordinate32Unqualified() const
{
    return m_has_ST_Coordinate32Unqualified;
}

ST_Coordinate32Unqualified* ST_Coordinate32::mutable_ST_Coordinate32Unqualified()
{
    clear_ST_UniversalMeasure();
    m_has_ST_Coordinate32Unqualified = true;
    if (!m_ST_Coordinate32Unqualified)
    {
        m_ST_Coordinate32Unqualified = new ST_Coordinate32Unqualified();
    }
    return m_ST_Coordinate32Unqualified;
}

const ST_Coordinate32Unqualified& ST_Coordinate32::get_ST_Coordinate32Unqualified() const
{
    if (m_ST_Coordinate32Unqualified)
    {
        return *m_ST_Coordinate32Unqualified;
    }
    return ST_Coordinate32Unqualified::default_instance();
}

void ST_Coordinate32::clear_ST_Coordinate32Unqualified()
{
    m_has_ST_Coordinate32Unqualified = false;
    if (m_ST_Coordinate32Unqualified)
    {
        delete m_ST_Coordinate32Unqualified;
        m_ST_Coordinate32Unqualified = NULL;
    }
}

bool ST_Coordinate32::has_ST_UniversalMeasure() const
{
    return m_has_ST_UniversalMeasure;
}

ns_s::ST_UniversalMeasure* ST_Coordinate32::mutable_ST_UniversalMeasure()
{
    clear_ST_Coordinate32Unqualified();
    m_has_ST_UniversalMeasure = true;
    if (!m_ST_UniversalMeasure)
    {
        m_ST_UniversalMeasure = new ns_s::ST_UniversalMeasure();
    }
    return m_ST_UniversalMeasure;
}

const ns_s::ST_UniversalMeasure& ST_Coordinate32::get_ST_UniversalMeasure() const
{
    if (m_ST_UniversalMeasure)
    {
        return *m_ST_UniversalMeasure;
    }
    return ns_s::ST_UniversalMeasure::default_instance();
}

void ST_Coordinate32::clear_ST_UniversalMeasure()
{
    m_has_ST_UniversalMeasure = false;
    if (m_ST_UniversalMeasure)
    {
        delete m_ST_UniversalMeasure;
        m_ST_UniversalMeasure = NULL;
    }
}

std::string ST_Coordinate32::toString() const
{
    if (m_has_ST_Coordinate32Unqualified)
    {
        return m_ST_Coordinate32Unqualified->toString();
    }

    if (m_has_ST_UniversalMeasure)
    {
        return m_ST_UniversalMeasure->toString();
    }

    return string();
}

void ST_Coordinate32::clear()
{   clear_ST_Coordinate32Unqualified();
    clear_ST_UniversalMeasure();
}

void ST_Coordinate32::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_ST_Coordinate32Unqualified)
    {
        m_ST_Coordinate32Unqualified->toXmlAttr(_attrName, _outStream);
        return;
    }

    if (m_has_ST_UniversalMeasure)
    {
        m_ST_UniversalMeasure->toXmlAttr(_attrName, _outStream);
        return;
    }
}

const ST_Coordinate32& ST_Coordinate32::default_instance()
{
    if (!ST_Coordinate32::default_instance_)
    {
        ST_Coordinate32::default_instance_ = new ST_Coordinate32();
    }
    return *ST_Coordinate32::default_instance_;
}

ST_Coordinate32* ST_Coordinate32::default_instance_ = NULL;

// ST_Coordinate32Unqualified
ST_Coordinate32Unqualified::ST_Coordinate32Unqualified()
    :m_has_int(false),
     m_int(0)
{
}
ST_Coordinate32Unqualified::ST_Coordinate32Unqualified(const XSD::int_& _int)
    :m_has_int(true)
{

    set_int(_int);
}
ST_Coordinate32Unqualified::~ST_Coordinate32Unqualified()
{
    clear();
}
bool ST_Coordinate32Unqualified::has_int() const
{
    return m_has_int;
}

void ST_Coordinate32Unqualified::set_int(const XSD::int_& _int)
{
    m_has_int = true;
    m_int = _int;
}

const XSD::int_& ST_Coordinate32Unqualified::get_int() const
{
    return m_int;
}

void ST_Coordinate32Unqualified::clear()
{
    m_has_int = false;
    m_int = 0;;
}

void ST_Coordinate32Unqualified::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_int)
    {
        _outStream << " " << _attrName << "=\"" << m_int << "\"";;
    }
}

const ST_Coordinate32Unqualified& ST_Coordinate32Unqualified::default_instance()
{
    if (!ST_Coordinate32Unqualified::default_instance_)
    {
        ST_Coordinate32Unqualified::default_instance_ = new ST_Coordinate32Unqualified();
    }
    return *ST_Coordinate32Unqualified::default_instance_;
}

std::string ST_Coordinate32Unqualified::toString() const
{
    std::stringstream strStream;
    strStream << get_int();
    return strStream.str();
}

ST_Coordinate32Unqualified* ST_Coordinate32Unqualified::default_instance_ = NULL;

// ST_PositiveCoordinate
ST_PositiveCoordinate::ST_PositiveCoordinate()
    :m_has_long(false),
     m_long(0)
{
}
ST_PositiveCoordinate::ST_PositiveCoordinate(const XSD::long_& _long)
    :m_has_long(true)
{

    set_long(_long);
}
ST_PositiveCoordinate::~ST_PositiveCoordinate()
{
    clear();
}
bool ST_PositiveCoordinate::has_long() const
{
    return m_has_long;
}

void ST_PositiveCoordinate::set_long(const XSD::long_& _long)
{   assert(0 <= _long);
    assert(_long <= 27273042316900);

    m_has_long = true;
    m_long = _long;
}

const XSD::long_& ST_PositiveCoordinate::get_long() const
{
    return m_long;
}

void ST_PositiveCoordinate::clear()
{
    m_has_long = false;
    m_long = 0;;
}

void ST_PositiveCoordinate::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_long)
    {
        _outStream << " " << _attrName << "=\"" << m_long << "\"";;
    }
}

const ST_PositiveCoordinate& ST_PositiveCoordinate::default_instance()
{
    if (!ST_PositiveCoordinate::default_instance_)
    {
        ST_PositiveCoordinate::default_instance_ = new ST_PositiveCoordinate();
    }
    return *ST_PositiveCoordinate::default_instance_;
}

std::string ST_PositiveCoordinate::toString() const
{
    std::stringstream strStream;
    strStream << get_long();
    return strStream.str();
}

ST_PositiveCoordinate* ST_PositiveCoordinate::default_instance_ = NULL;

// ST_PositiveCoordinate32
ST_PositiveCoordinate32::ST_PositiveCoordinate32()

{
}
ST_PositiveCoordinate32::ST_PositiveCoordinate32(const ST_Coordinate32Unqualified& _ST_Coordinate32Unqualified)
    :ST_Coordinate32Unqualified(_ST_Coordinate32Unqualified)
{
}
ST_PositiveCoordinate32::~ST_PositiveCoordinate32()
{
    clear();
}
const ST_PositiveCoordinate32& ST_PositiveCoordinate32::default_instance()
{
    if (!ST_PositiveCoordinate32::default_instance_)
    {
        ST_PositiveCoordinate32::default_instance_ = new ST_PositiveCoordinate32();
    }
    return *ST_PositiveCoordinate32::default_instance_;
}

ST_PositiveCoordinate32* ST_PositiveCoordinate32::default_instance_ = NULL;

// ST_Angle
ST_Angle::ST_Angle()
    :m_has_int(false),
     m_int(0)
{
}
ST_Angle::ST_Angle(const XSD::int_& _int)
    :m_has_int(true)
{

    set_int(_int);
}
ST_Angle::~ST_Angle()
{
    clear();
}
bool ST_Angle::has_int() const
{
    return m_has_int;
}

void ST_Angle::set_int(const XSD::int_& _int)
{
    m_has_int = true;
    m_int = _int;
}

const XSD::int_& ST_Angle::get_int() const
{
    return m_int;
}

void ST_Angle::clear()
{
    m_has_int = false;
    m_int = 0;;
}

void ST_Angle::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_int)
    {
        _outStream << " " << _attrName << "=\"" << m_int << "\"";;
    }
}

const ST_Angle& ST_Angle::default_instance()
{
    if (!ST_Angle::default_instance_)
    {
        ST_Angle::default_instance_ = new ST_Angle();
    }
    return *ST_Angle::default_instance_;
}

std::string ST_Angle::toString() const
{
    std::stringstream strStream;
    strStream << get_int();
    return strStream.str();
}

ST_Angle* ST_Angle::default_instance_ = NULL;

// ST_FixedAngle
ST_FixedAngle::ST_FixedAngle()

{
}
ST_FixedAngle::ST_FixedAngle(const ST_Angle& _ST_Angle)
    :ST_Angle(_ST_Angle)
{
}
ST_FixedAngle::~ST_FixedAngle()
{
    clear();
}
const ST_FixedAngle& ST_FixedAngle::default_instance()
{
    if (!ST_FixedAngle::default_instance_)
    {
        ST_FixedAngle::default_instance_ = new ST_FixedAngle();
    }
    return *ST_FixedAngle::default_instance_;
}

ST_FixedAngle* ST_FixedAngle::default_instance_ = NULL;

// ST_PositiveFixedAngle
ST_PositiveFixedAngle::ST_PositiveFixedAngle()

{
}
ST_PositiveFixedAngle::ST_PositiveFixedAngle(const ST_Angle& _ST_Angle)
    :ST_Angle(_ST_Angle)
{
}
ST_PositiveFixedAngle::~ST_PositiveFixedAngle()
{
    clear();
}
const ST_PositiveFixedAngle& ST_PositiveFixedAngle::default_instance()
{
    if (!ST_PositiveFixedAngle::default_instance_)
    {
        ST_PositiveFixedAngle::default_instance_ = new ST_PositiveFixedAngle();
    }
    return *ST_PositiveFixedAngle::default_instance_;
}

ST_PositiveFixedAngle* ST_PositiveFixedAngle::default_instance_ = NULL;

// ST_Percentage
ST_Percentage::ST_Percentage()
    :m_has_ST_PercentageDecimal(false),
     m_ST_PercentageDecimal(NULL),
     m_has_ST_Percentage(false),
     m_ST_Percentage(NULL)
{
}
ST_Percentage::ST_Percentage(const ST_Percentage& _ST_Percentage)
    :m_has_ST_PercentageDecimal(false),
     m_ST_PercentageDecimal(NULL),
     m_has_ST_Percentage(false),
     m_ST_Percentage(NULL)
{

    m_has_ST_PercentageDecimal = _ST_Percentage.has_ST_PercentageDecimal();
    if (_ST_Percentage.has_ST_PercentageDecimal())
    {
        m_ST_PercentageDecimal = new ST_PercentageDecimal(_ST_Percentage.get_ST_PercentageDecimal());
    }


    m_has_ST_Percentage = _ST_Percentage.has_ST_Percentage();
    if (_ST_Percentage.has_ST_Percentage())
    {
        m_ST_Percentage = new ns_s::ST_Percentage(_ST_Percentage.get_ST_Percentage());
    }
}
ST_Percentage::~ST_Percentage()
{
    clear();
}
bool ST_Percentage::has_ST_PercentageDecimal() const
{
    return m_has_ST_PercentageDecimal;
}

ST_PercentageDecimal* ST_Percentage::mutable_ST_PercentageDecimal()
{
    clear_ST_Percentage();
    m_has_ST_PercentageDecimal = true;
    if (!m_ST_PercentageDecimal)
    {
        m_ST_PercentageDecimal = new ST_PercentageDecimal();
    }
    return m_ST_PercentageDecimal;
}

const ST_PercentageDecimal& ST_Percentage::get_ST_PercentageDecimal() const
{
    if (m_ST_PercentageDecimal)
    {
        return *m_ST_PercentageDecimal;
    }
    return ST_PercentageDecimal::default_instance();
}

void ST_Percentage::clear_ST_PercentageDecimal()
{
    m_has_ST_PercentageDecimal = false;
    if (m_ST_PercentageDecimal)
    {
        delete m_ST_PercentageDecimal;
        m_ST_PercentageDecimal = NULL;
    }
}

bool ST_Percentage::has_ST_Percentage() const
{
    return m_has_ST_Percentage;
}

ns_s::ST_Percentage* ST_Percentage::mutable_ST_Percentage()
{
    clear_ST_PercentageDecimal();
    m_has_ST_Percentage = true;
    if (!m_ST_Percentage)
    {
        m_ST_Percentage = new ns_s::ST_Percentage();
    }
    return m_ST_Percentage;
}

const ns_s::ST_Percentage& ST_Percentage::get_ST_Percentage() const
{
    if (m_ST_Percentage)
    {
        return *m_ST_Percentage;
    }
    return ns_s::ST_Percentage::default_instance();
}

void ST_Percentage::clear_ST_Percentage()
{
    m_has_ST_Percentage = false;
    if (m_ST_Percentage)
    {
        delete m_ST_Percentage;
        m_ST_Percentage = NULL;
    }
}

std::string ST_Percentage::toString() const
{
    if (m_has_ST_PercentageDecimal)
    {
        return m_ST_PercentageDecimal->toString();
    }

    if (m_has_ST_Percentage)
    {
        return m_ST_Percentage->toString();
    }

    return string();
}

void ST_Percentage::clear()
{   clear_ST_PercentageDecimal();
    clear_ST_Percentage();
}

void ST_Percentage::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_ST_PercentageDecimal)
    {
        m_ST_PercentageDecimal->toXmlAttr(_attrName, _outStream);
        return;
    }

    if (m_has_ST_Percentage)
    {
        m_ST_Percentage->toXmlAttr(_attrName, _outStream);
        return;
    }
}

const ST_Percentage& ST_Percentage::default_instance()
{
    if (!ST_Percentage::default_instance_)
    {
        ST_Percentage::default_instance_ = new ST_Percentage();
    }
    return *ST_Percentage::default_instance_;
}

ST_Percentage* ST_Percentage::default_instance_ = NULL;

// ST_PercentageDecimal
ST_PercentageDecimal::ST_PercentageDecimal()
    :m_has_int(false),
     m_int(0)
{
}
ST_PercentageDecimal::ST_PercentageDecimal(const XSD::int_& _int)
    :m_has_int(true)
{

    set_int(_int);
}
ST_PercentageDecimal::~ST_PercentageDecimal()
{
    clear();
}
bool ST_PercentageDecimal::has_int() const
{
    return m_has_int;
}

void ST_PercentageDecimal::set_int(const XSD::int_& _int)
{
    m_has_int = true;
    m_int = _int;
}

const XSD::int_& ST_PercentageDecimal::get_int() const
{
    return m_int;
}

void ST_PercentageDecimal::clear()
{
    m_has_int = false;
    m_int = 0;;
}

void ST_PercentageDecimal::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_int)
    {
        _outStream << " " << _attrName << "=\"" << m_int << "\"";;
    }
}

const ST_PercentageDecimal& ST_PercentageDecimal::default_instance()
{
    if (!ST_PercentageDecimal::default_instance_)
    {
        ST_PercentageDecimal::default_instance_ = new ST_PercentageDecimal();
    }
    return *ST_PercentageDecimal::default_instance_;
}

std::string ST_PercentageDecimal::toString() const
{
    std::stringstream strStream;
    strStream << get_int();
    return strStream.str();
}

ST_PercentageDecimal* ST_PercentageDecimal::default_instance_ = NULL;

// ST_PositivePercentage
ST_PositivePercentage::ST_PositivePercentage()
    :m_has_ST_PositivePercentageDecimal(false),
     m_ST_PositivePercentageDecimal(NULL),
     m_has_ST_PositivePercentage(false),
     m_ST_PositivePercentage(NULL)
{
}
ST_PositivePercentage::ST_PositivePercentage(const ST_PositivePercentage& _ST_PositivePercentage)
    :m_has_ST_PositivePercentageDecimal(false),
     m_ST_PositivePercentageDecimal(NULL),
     m_has_ST_PositivePercentage(false),
     m_ST_PositivePercentage(NULL)
{

    m_has_ST_PositivePercentageDecimal = _ST_PositivePercentage.has_ST_PositivePercentageDecimal();
    if (_ST_PositivePercentage.has_ST_PositivePercentageDecimal())
    {
        m_ST_PositivePercentageDecimal = new ST_PositivePercentageDecimal(_ST_PositivePercentage.get_ST_PositivePercentageDecimal());
    }


    m_has_ST_PositivePercentage = _ST_PositivePercentage.has_ST_PositivePercentage();
    if (_ST_PositivePercentage.has_ST_PositivePercentage())
    {
        m_ST_PositivePercentage = new ns_s::ST_PositivePercentage(_ST_PositivePercentage.get_ST_PositivePercentage());
    }
}
ST_PositivePercentage::~ST_PositivePercentage()
{
    clear();
}
bool ST_PositivePercentage::has_ST_PositivePercentageDecimal() const
{
    return m_has_ST_PositivePercentageDecimal;
}

ST_PositivePercentageDecimal* ST_PositivePercentage::mutable_ST_PositivePercentageDecimal()
{
    clear_ST_PositivePercentage();
    m_has_ST_PositivePercentageDecimal = true;
    if (!m_ST_PositivePercentageDecimal)
    {
        m_ST_PositivePercentageDecimal = new ST_PositivePercentageDecimal();
    }
    return m_ST_PositivePercentageDecimal;
}

const ST_PositivePercentageDecimal& ST_PositivePercentage::get_ST_PositivePercentageDecimal() const
{
    if (m_ST_PositivePercentageDecimal)
    {
        return *m_ST_PositivePercentageDecimal;
    }
    return ST_PositivePercentageDecimal::default_instance();
}

void ST_PositivePercentage::clear_ST_PositivePercentageDecimal()
{
    m_has_ST_PositivePercentageDecimal = false;
    if (m_ST_PositivePercentageDecimal)
    {
        delete m_ST_PositivePercentageDecimal;
        m_ST_PositivePercentageDecimal = NULL;
    }
}

bool ST_PositivePercentage::has_ST_PositivePercentage() const
{
    return m_has_ST_PositivePercentage;
}

ns_s::ST_PositivePercentage* ST_PositivePercentage::mutable_ST_PositivePercentage()
{
    clear_ST_PositivePercentageDecimal();
    m_has_ST_PositivePercentage = true;
    if (!m_ST_PositivePercentage)
    {
        m_ST_PositivePercentage = new ns_s::ST_PositivePercentage();
    }
    return m_ST_PositivePercentage;
}

const ns_s::ST_PositivePercentage& ST_PositivePercentage::get_ST_PositivePercentage() const
{
    if (m_ST_PositivePercentage)
    {
        return *m_ST_PositivePercentage;
    }
    return ns_s::ST_PositivePercentage::default_instance();
}

void ST_PositivePercentage::clear_ST_PositivePercentage()
{
    m_has_ST_PositivePercentage = false;
    if (m_ST_PositivePercentage)
    {
        delete m_ST_PositivePercentage;
        m_ST_PositivePercentage = NULL;
    }
}

std::string ST_PositivePercentage::toString() const
{
    if (m_has_ST_PositivePercentageDecimal)
    {
        return m_ST_PositivePercentageDecimal->toString();
    }

    if (m_has_ST_PositivePercentage)
    {
        return m_ST_PositivePercentage->toString();
    }

    return string();
}

void ST_PositivePercentage::clear()
{   clear_ST_PositivePercentageDecimal();
    clear_ST_PositivePercentage();
}

void ST_PositivePercentage::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_ST_PositivePercentageDecimal)
    {
        m_ST_PositivePercentageDecimal->toXmlAttr(_attrName, _outStream);
        return;
    }

    if (m_has_ST_PositivePercentage)
    {
        m_ST_PositivePercentage->toXmlAttr(_attrName, _outStream);
        return;
    }
}

const ST_PositivePercentage& ST_PositivePercentage::default_instance()
{
    if (!ST_PositivePercentage::default_instance_)
    {
        ST_PositivePercentage::default_instance_ = new ST_PositivePercentage();
    }
    return *ST_PositivePercentage::default_instance_;
}

ST_PositivePercentage* ST_PositivePercentage::default_instance_ = NULL;

// ST_PositivePercentageDecimal
ST_PositivePercentageDecimal::ST_PositivePercentageDecimal()

{
}
ST_PositivePercentageDecimal::ST_PositivePercentageDecimal(const ST_PercentageDecimal& _ST_PercentageDecimal)
    :ST_PercentageDecimal(_ST_PercentageDecimal)
{
}
ST_PositivePercentageDecimal::~ST_PositivePercentageDecimal()
{
    clear();
}
const ST_PositivePercentageDecimal& ST_PositivePercentageDecimal::default_instance()
{
    if (!ST_PositivePercentageDecimal::default_instance_)
    {
        ST_PositivePercentageDecimal::default_instance_ = new ST_PositivePercentageDecimal();
    }
    return *ST_PositivePercentageDecimal::default_instance_;
}

ST_PositivePercentageDecimal* ST_PositivePercentageDecimal::default_instance_ = NULL;

// ST_FixedPercentage
ST_FixedPercentage::ST_FixedPercentage()
    :m_has_ST_FixedPercentageDecimal(false),
     m_ST_FixedPercentageDecimal(NULL),
     m_has_ST_FixedPercentage(false),
     m_ST_FixedPercentage(NULL)
{
}
ST_FixedPercentage::ST_FixedPercentage(const ST_FixedPercentage& _ST_FixedPercentage)
    :m_has_ST_FixedPercentageDecimal(false),
     m_ST_FixedPercentageDecimal(NULL),
     m_has_ST_FixedPercentage(false),
     m_ST_FixedPercentage(NULL)
{

    m_has_ST_FixedPercentageDecimal = _ST_FixedPercentage.has_ST_FixedPercentageDecimal();
    if (_ST_FixedPercentage.has_ST_FixedPercentageDecimal())
    {
        m_ST_FixedPercentageDecimal = new ST_FixedPercentageDecimal(_ST_FixedPercentage.get_ST_FixedPercentageDecimal());
    }


    m_has_ST_FixedPercentage = _ST_FixedPercentage.has_ST_FixedPercentage();
    if (_ST_FixedPercentage.has_ST_FixedPercentage())
    {
        m_ST_FixedPercentage = new ns_s::ST_FixedPercentage(_ST_FixedPercentage.get_ST_FixedPercentage());
    }
}
ST_FixedPercentage::~ST_FixedPercentage()
{
    clear();
}
bool ST_FixedPercentage::has_ST_FixedPercentageDecimal() const
{
    return m_has_ST_FixedPercentageDecimal;
}

ST_FixedPercentageDecimal* ST_FixedPercentage::mutable_ST_FixedPercentageDecimal()
{
    clear_ST_FixedPercentage();
    m_has_ST_FixedPercentageDecimal = true;
    if (!m_ST_FixedPercentageDecimal)
    {
        m_ST_FixedPercentageDecimal = new ST_FixedPercentageDecimal();
    }
    return m_ST_FixedPercentageDecimal;
}

const ST_FixedPercentageDecimal& ST_FixedPercentage::get_ST_FixedPercentageDecimal() const
{
    if (m_ST_FixedPercentageDecimal)
    {
        return *m_ST_FixedPercentageDecimal;
    }
    return ST_FixedPercentageDecimal::default_instance();
}

void ST_FixedPercentage::clear_ST_FixedPercentageDecimal()
{
    m_has_ST_FixedPercentageDecimal = false;
    if (m_ST_FixedPercentageDecimal)
    {
        delete m_ST_FixedPercentageDecimal;
        m_ST_FixedPercentageDecimal = NULL;
    }
}

bool ST_FixedPercentage::has_ST_FixedPercentage() const
{
    return m_has_ST_FixedPercentage;
}

ns_s::ST_FixedPercentage* ST_FixedPercentage::mutable_ST_FixedPercentage()
{
    clear_ST_FixedPercentageDecimal();
    m_has_ST_FixedPercentage = true;
    if (!m_ST_FixedPercentage)
    {
        m_ST_FixedPercentage = new ns_s::ST_FixedPercentage();
    }
    return m_ST_FixedPercentage;
}

const ns_s::ST_FixedPercentage& ST_FixedPercentage::get_ST_FixedPercentage() const
{
    if (m_ST_FixedPercentage)
    {
        return *m_ST_FixedPercentage;
    }
    return ns_s::ST_FixedPercentage::default_instance();
}

void ST_FixedPercentage::clear_ST_FixedPercentage()
{
    m_has_ST_FixedPercentage = false;
    if (m_ST_FixedPercentage)
    {
        delete m_ST_FixedPercentage;
        m_ST_FixedPercentage = NULL;
    }
}

std::string ST_FixedPercentage::toString() const
{
    if (m_has_ST_FixedPercentageDecimal)
    {
        return m_ST_FixedPercentageDecimal->toString();
    }

    if (m_has_ST_FixedPercentage)
    {
        return m_ST_FixedPercentage->toString();
    }

    return string();
}

void ST_FixedPercentage::clear()
{   clear_ST_FixedPercentageDecimal();
    clear_ST_FixedPercentage();
}

void ST_FixedPercentage::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_ST_FixedPercentageDecimal)
    {
        m_ST_FixedPercentageDecimal->toXmlAttr(_attrName, _outStream);
        return;
    }

    if (m_has_ST_FixedPercentage)
    {
        m_ST_FixedPercentage->toXmlAttr(_attrName, _outStream);
        return;
    }
}

const ST_FixedPercentage& ST_FixedPercentage::default_instance()
{
    if (!ST_FixedPercentage::default_instance_)
    {
        ST_FixedPercentage::default_instance_ = new ST_FixedPercentage();
    }
    return *ST_FixedPercentage::default_instance_;
}

ST_FixedPercentage* ST_FixedPercentage::default_instance_ = NULL;

// ST_FixedPercentageDecimal
ST_FixedPercentageDecimal::ST_FixedPercentageDecimal()

{
}
ST_FixedPercentageDecimal::ST_FixedPercentageDecimal(const ST_PercentageDecimal& _ST_PercentageDecimal)
    :ST_PercentageDecimal(_ST_PercentageDecimal)
{
}
ST_FixedPercentageDecimal::~ST_FixedPercentageDecimal()
{
    clear();
}
const ST_FixedPercentageDecimal& ST_FixedPercentageDecimal::default_instance()
{
    if (!ST_FixedPercentageDecimal::default_instance_)
    {
        ST_FixedPercentageDecimal::default_instance_ = new ST_FixedPercentageDecimal();
    }
    return *ST_FixedPercentageDecimal::default_instance_;
}

ST_FixedPercentageDecimal* ST_FixedPercentageDecimal::default_instance_ = NULL;

// ST_PositiveFixedPercentage
ST_PositiveFixedPercentage::ST_PositiveFixedPercentage()
    :m_has_ST_PositiveFixedPercentageDecimal(false),
     m_ST_PositiveFixedPercentageDecimal(NULL),
     m_has_ST_PositiveFixedPercentage(false),
     m_ST_PositiveFixedPercentage(NULL)
{
}
ST_PositiveFixedPercentage::ST_PositiveFixedPercentage(const ST_PositiveFixedPercentage& _ST_PositiveFixedPercentage)
    :m_has_ST_PositiveFixedPercentageDecimal(false),
     m_ST_PositiveFixedPercentageDecimal(NULL),
     m_has_ST_PositiveFixedPercentage(false),
     m_ST_PositiveFixedPercentage(NULL)
{

    m_has_ST_PositiveFixedPercentageDecimal = _ST_PositiveFixedPercentage.has_ST_PositiveFixedPercentageDecimal();
    if (_ST_PositiveFixedPercentage.has_ST_PositiveFixedPercentageDecimal())
    {
        m_ST_PositiveFixedPercentageDecimal = new ST_PositiveFixedPercentageDecimal(_ST_PositiveFixedPercentage.get_ST_PositiveFixedPercentageDecimal());
    }


    m_has_ST_PositiveFixedPercentage = _ST_PositiveFixedPercentage.has_ST_PositiveFixedPercentage();
    if (_ST_PositiveFixedPercentage.has_ST_PositiveFixedPercentage())
    {
        m_ST_PositiveFixedPercentage = new ns_s::ST_PositiveFixedPercentage(_ST_PositiveFixedPercentage.get_ST_PositiveFixedPercentage());
    }
}
ST_PositiveFixedPercentage::~ST_PositiveFixedPercentage()
{
    clear();
}
bool ST_PositiveFixedPercentage::has_ST_PositiveFixedPercentageDecimal() const
{
    return m_has_ST_PositiveFixedPercentageDecimal;
}

ST_PositiveFixedPercentageDecimal* ST_PositiveFixedPercentage::mutable_ST_PositiveFixedPercentageDecimal()
{
    clear_ST_PositiveFixedPercentage();
    m_has_ST_PositiveFixedPercentageDecimal = true;
    if (!m_ST_PositiveFixedPercentageDecimal)
    {
        m_ST_PositiveFixedPercentageDecimal = new ST_PositiveFixedPercentageDecimal();
    }
    return m_ST_PositiveFixedPercentageDecimal;
}

const ST_PositiveFixedPercentageDecimal& ST_PositiveFixedPercentage::get_ST_PositiveFixedPercentageDecimal() const
{
    if (m_ST_PositiveFixedPercentageDecimal)
    {
        return *m_ST_PositiveFixedPercentageDecimal;
    }
    return ST_PositiveFixedPercentageDecimal::default_instance();
}

void ST_PositiveFixedPercentage::clear_ST_PositiveFixedPercentageDecimal()
{
    m_has_ST_PositiveFixedPercentageDecimal = false;
    if (m_ST_PositiveFixedPercentageDecimal)
    {
        delete m_ST_PositiveFixedPercentageDecimal;
        m_ST_PositiveFixedPercentageDecimal = NULL;
    }
}

bool ST_PositiveFixedPercentage::has_ST_PositiveFixedPercentage() const
{
    return m_has_ST_PositiveFixedPercentage;
}

ns_s::ST_PositiveFixedPercentage* ST_PositiveFixedPercentage::mutable_ST_PositiveFixedPercentage()
{
    clear_ST_PositiveFixedPercentageDecimal();
    m_has_ST_PositiveFixedPercentage = true;
    if (!m_ST_PositiveFixedPercentage)
    {
        m_ST_PositiveFixedPercentage = new ns_s::ST_PositiveFixedPercentage();
    }
    return m_ST_PositiveFixedPercentage;
}

const ns_s::ST_PositiveFixedPercentage& ST_PositiveFixedPercentage::get_ST_PositiveFixedPercentage() const
{
    if (m_ST_PositiveFixedPercentage)
    {
        return *m_ST_PositiveFixedPercentage;
    }
    return ns_s::ST_PositiveFixedPercentage::default_instance();
}

void ST_PositiveFixedPercentage::clear_ST_PositiveFixedPercentage()
{
    m_has_ST_PositiveFixedPercentage = false;
    if (m_ST_PositiveFixedPercentage)
    {
        delete m_ST_PositiveFixedPercentage;
        m_ST_PositiveFixedPercentage = NULL;
    }
}

std::string ST_PositiveFixedPercentage::toString() const
{
    if (m_has_ST_PositiveFixedPercentageDecimal)
    {
        return m_ST_PositiveFixedPercentageDecimal->toString();
    }

    if (m_has_ST_PositiveFixedPercentage)
    {
        return m_ST_PositiveFixedPercentage->toString();
    }

    return string();
}

void ST_PositiveFixedPercentage::clear()
{   clear_ST_PositiveFixedPercentageDecimal();
    clear_ST_PositiveFixedPercentage();
}

void ST_PositiveFixedPercentage::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_ST_PositiveFixedPercentageDecimal)
    {
        m_ST_PositiveFixedPercentageDecimal->toXmlAttr(_attrName, _outStream);
        return;
    }

    if (m_has_ST_PositiveFixedPercentage)
    {
        m_ST_PositiveFixedPercentage->toXmlAttr(_attrName, _outStream);
        return;
    }
}

const ST_PositiveFixedPercentage& ST_PositiveFixedPercentage::default_instance()
{
    if (!ST_PositiveFixedPercentage::default_instance_)
    {
        ST_PositiveFixedPercentage::default_instance_ = new ST_PositiveFixedPercentage();
    }
    return *ST_PositiveFixedPercentage::default_instance_;
}

ST_PositiveFixedPercentage* ST_PositiveFixedPercentage::default_instance_ = NULL;

// ST_PositiveFixedPercentageDecimal
ST_PositiveFixedPercentageDecimal::ST_PositiveFixedPercentageDecimal()

{
}
ST_PositiveFixedPercentageDecimal::ST_PositiveFixedPercentageDecimal(const ST_PercentageDecimal& _ST_PercentageDecimal)
    :ST_PercentageDecimal(_ST_PercentageDecimal)
{
}
ST_PositiveFixedPercentageDecimal::~ST_PositiveFixedPercentageDecimal()
{
    clear();
}
const ST_PositiveFixedPercentageDecimal& ST_PositiveFixedPercentageDecimal::default_instance()
{
    if (!ST_PositiveFixedPercentageDecimal::default_instance_)
    {
        ST_PositiveFixedPercentageDecimal::default_instance_ = new ST_PositiveFixedPercentageDecimal();
    }
    return *ST_PositiveFixedPercentageDecimal::default_instance_;
}

ST_PositiveFixedPercentageDecimal* ST_PositiveFixedPercentageDecimal::default_instance_ = NULL;

// ST_SystemColorVal
ST_SystemColorVal::ST_SystemColorVal()
    :m_has_type(false)
{
}
ST_SystemColorVal::ST_SystemColorVal(const ST_SystemColorVal::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_SystemColorVal::~ST_SystemColorVal()
{
    clear();
}
bool ST_SystemColorVal::has_type() const
{
    return m_has_type;
}

void ST_SystemColorVal::set_type(const ST_SystemColorVal::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_SystemColorVal::Type& ST_SystemColorVal::get_type() const
{
    return m_type;
}

std::string ST_SystemColorVal::toString() const
{
    return ST_SystemColorVal::TypeStrList[m_type];
}

void ST_SystemColorVal::clear()
{
    m_has_type = false;
}

void ST_SystemColorVal::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_SystemColorVal& ST_SystemColorVal::default_instance()
{
    if (!ST_SystemColorVal::default_instance_)
    {
        ST_SystemColorVal::default_instance_ = new ST_SystemColorVal();
    }
    return *ST_SystemColorVal::default_instance_;
}

const std::string ST_SystemColorVal::TypeStrList[] =
{
    "scrollBar",
    "background",
    "activeCaption",
    "inactiveCaption",
    "menu",
    "window",
    "windowFrame",
    "menuText",
    "windowText",
    "captionText",
    "activeBorder",
    "inactiveBorder",
    "appWorkspace",
    "highlight",
    "highlightText",
    "btnFace",
    "btnShadow",
    "grayText",
    "btnText",
    "inactiveCaptionText",
    "btnHighlight",
    "3dDkShadow",
    "3dLight",
    "infoText",
    "infoBk",
    "hotLight",
    "gradientActiveCaption",
    "gradientInactiveCaption",
    "menuHighlight",
    "menuBar"
};
ST_SystemColorVal* ST_SystemColorVal::default_instance_ = NULL;

// ST_SchemeColorVal
ST_SchemeColorVal::ST_SchemeColorVal()
    :m_has_type(false)
{
}
ST_SchemeColorVal::ST_SchemeColorVal(const ST_SchemeColorVal::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_SchemeColorVal::~ST_SchemeColorVal()
{
    clear();
}
bool ST_SchemeColorVal::has_type() const
{
    return m_has_type;
}

void ST_SchemeColorVal::set_type(const ST_SchemeColorVal::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_SchemeColorVal::Type& ST_SchemeColorVal::get_type() const
{
    return m_type;
}

std::string ST_SchemeColorVal::toString() const
{
    return ST_SchemeColorVal::TypeStrList[m_type];
}

void ST_SchemeColorVal::clear()
{
    m_has_type = false;
}

void ST_SchemeColorVal::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_SchemeColorVal& ST_SchemeColorVal::default_instance()
{
    if (!ST_SchemeColorVal::default_instance_)
    {
        ST_SchemeColorVal::default_instance_ = new ST_SchemeColorVal();
    }
    return *ST_SchemeColorVal::default_instance_;
}

const std::string ST_SchemeColorVal::TypeStrList[] =
{
    "bg1",
    "tx1",
    "bg2",
    "tx2",
    "accent1",
    "accent2",
    "accent3",
    "accent4",
    "accent5",
    "accent6",
    "hlink",
    "folHlink",
    "phClr",
    "dk1",
    "lt1",
    "dk2",
    "lt2"
};
ST_SchemeColorVal* ST_SchemeColorVal::default_instance_ = NULL;

// ST_PresetColorVal
ST_PresetColorVal::ST_PresetColorVal()
    :m_has_type(false)
{
}
ST_PresetColorVal::ST_PresetColorVal(const ST_PresetColorVal::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_PresetColorVal::~ST_PresetColorVal()
{
    clear();
}
bool ST_PresetColorVal::has_type() const
{
    return m_has_type;
}

void ST_PresetColorVal::set_type(const ST_PresetColorVal::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_PresetColorVal::Type& ST_PresetColorVal::get_type() const
{
    return m_type;
}

std::string ST_PresetColorVal::toString() const
{
    return ST_PresetColorVal::TypeStrList[m_type];
}

void ST_PresetColorVal::clear()
{
    m_has_type = false;
}

void ST_PresetColorVal::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_PresetColorVal& ST_PresetColorVal::default_instance()
{
    if (!ST_PresetColorVal::default_instance_)
    {
        ST_PresetColorVal::default_instance_ = new ST_PresetColorVal();
    }
    return *ST_PresetColorVal::default_instance_;
}

const std::string ST_PresetColorVal::TypeStrList[] =
{
    "aliceBlue",
    "antiqueWhite",
    "aqua",
    "aquamarine",
    "azure",
    "beige",
    "bisque",
    "black",
    "blanchedAlmond",
    "blue",
    "blueViolet",
    "brown",
    "burlyWood",
    "cadetBlue",
    "chartreuse",
    "chocolate",
    "coral",
    "cornflowerBlue",
    "cornsilk",
    "crimson",
    "cyan",
    "darkBlue",
    "darkCyan",
    "darkGoldenrod",
    "darkGray",
    "darkGrey",
    "darkGreen",
    "darkKhaki",
    "darkMagenta",
    "darkOliveGreen",
    "darkOrange",
    "darkOrchid",
    "darkRed",
    "darkSalmon",
    "darkSeaGreen",
    "darkSlateBlue",
    "darkSlateGray",
    "darkSlateGrey",
    "darkTurquoise",
    "darkViolet",
    "dkBlue",
    "dkCyan",
    "dkGoldenrod",
    "dkGray",
    "dkGrey",
    "dkGreen",
    "dkKhaki",
    "dkMagenta",
    "dkOliveGreen",
    "dkOrange",
    "dkOrchid",
    "dkRed",
    "dkSalmon",
    "dkSeaGreen",
    "dkSlateBlue",
    "dkSlateGray",
    "dkSlateGrey",
    "dkTurquoise",
    "dkViolet",
    "deepPink",
    "deepSkyBlue",
    "dimGray",
    "dimGrey",
    "dodgerBlue",
    "firebrick",
    "floralWhite",
    "forestGreen",
    "fuchsia",
    "gainsboro",
    "ghostWhite",
    "gold",
    "goldenrod",
    "gray",
    "grey",
    "green",
    "greenYellow",
    "honeydew",
    "hotPink",
    "indianRed",
    "indigo",
    "ivory",
    "khaki",
    "lavender",
    "lavenderBlush",
    "lawnGreen",
    "lemonChiffon",
    "lightBlue",
    "lightCoral",
    "lightCyan",
    "lightGoldenrodYellow",
    "lightGray",
    "lightGrey",
    "lightGreen",
    "lightPink",
    "lightSalmon",
    "lightSeaGreen",
    "lightSkyBlue",
    "lightSlateGray",
    "lightSlateGrey",
    "lightSteelBlue",
    "lightYellow",
    "ltBlue",
    "ltCoral",
    "ltCyan",
    "ltGoldenrodYellow",
    "ltGray",
    "ltGrey",
    "ltGreen",
    "ltPink",
    "ltSalmon",
    "ltSeaGreen",
    "ltSkyBlue",
    "ltSlateGray",
    "ltSlateGrey",
    "ltSteelBlue",
    "ltYellow",
    "lime",
    "limeGreen",
    "linen",
    "magenta",
    "maroon",
    "medAquamarine",
    "medBlue",
    "medOrchid",
    "medPurple",
    "medSeaGreen",
    "medSlateBlue",
    "medSpringGreen",
    "medTurquoise",
    "medVioletRed",
    "mediumAquamarine",
    "mediumBlue",
    "mediumOrchid",
    "mediumPurple",
    "mediumSeaGreen",
    "mediumSlateBlue",
    "mediumSpringGreen",
    "mediumTurquoise",
    "mediumVioletRed",
    "midnightBlue",
    "mintCream",
    "mistyRose",
    "moccasin",
    "navajoWhite",
    "navy",
    "oldLace",
    "olive",
    "oliveDrab",
    "orange",
    "orangeRed",
    "orchid",
    "paleGoldenrod",
    "paleGreen",
    "paleTurquoise",
    "paleVioletRed",
    "papayaWhip",
    "peachPuff",
    "peru",
    "pink",
    "plum",
    "powderBlue",
    "purple",
    "red",
    "rosyBrown",
    "royalBlue",
    "saddleBrown",
    "salmon",
    "sandyBrown",
    "seaGreen",
    "seaShell",
    "sienna",
    "silver",
    "skyBlue",
    "slateBlue",
    "slateGray",
    "slateGrey",
    "snow",
    "springGreen",
    "steelBlue",
    "tan",
    "teal",
    "thistle",
    "tomato",
    "turquoise",
    "violet",
    "wheat",
    "white",
    "whiteSmoke",
    "yellow",
    "yellowGreen"
};
ST_PresetColorVal* ST_PresetColorVal::default_instance_ = NULL;

// ST_RectAlignment
ST_RectAlignment::ST_RectAlignment()
    :m_has_type(false)
{
}
ST_RectAlignment::ST_RectAlignment(const ST_RectAlignment::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_RectAlignment::~ST_RectAlignment()
{
    clear();
}
bool ST_RectAlignment::has_type() const
{
    return m_has_type;
}

void ST_RectAlignment::set_type(const ST_RectAlignment::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_RectAlignment::Type& ST_RectAlignment::get_type() const
{
    return m_type;
}

std::string ST_RectAlignment::toString() const
{
    return ST_RectAlignment::TypeStrList[m_type];
}

void ST_RectAlignment::clear()
{
    m_has_type = false;
}

void ST_RectAlignment::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_RectAlignment& ST_RectAlignment::default_instance()
{
    if (!ST_RectAlignment::default_instance_)
    {
        ST_RectAlignment::default_instance_ = new ST_RectAlignment();
    }
    return *ST_RectAlignment::default_instance_;
}

const std::string ST_RectAlignment::TypeStrList[] =
{
    "tl",
    "t",
    "tr",
    "l",
    "ctr",
    "r",
    "bl",
    "b",
    "br"
};
ST_RectAlignment* ST_RectAlignment::default_instance_ = NULL;

// ST_BlackWhiteMode
ST_BlackWhiteMode::ST_BlackWhiteMode()
    :m_has_type(false)
{
}
ST_BlackWhiteMode::ST_BlackWhiteMode(const ST_BlackWhiteMode::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_BlackWhiteMode::~ST_BlackWhiteMode()
{
    clear();
}
bool ST_BlackWhiteMode::has_type() const
{
    return m_has_type;
}

void ST_BlackWhiteMode::set_type(const ST_BlackWhiteMode::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_BlackWhiteMode::Type& ST_BlackWhiteMode::get_type() const
{
    return m_type;
}

std::string ST_BlackWhiteMode::toString() const
{
    return ST_BlackWhiteMode::TypeStrList[m_type];
}

void ST_BlackWhiteMode::clear()
{
    m_has_type = false;
}

void ST_BlackWhiteMode::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_BlackWhiteMode& ST_BlackWhiteMode::default_instance()
{
    if (!ST_BlackWhiteMode::default_instance_)
    {
        ST_BlackWhiteMode::default_instance_ = new ST_BlackWhiteMode();
    }
    return *ST_BlackWhiteMode::default_instance_;
}

const std::string ST_BlackWhiteMode::TypeStrList[] =
{
    "clr",
    "auto",
    "gray",
    "ltGray",
    "invGray",
    "grayWhite",
    "blackGray",
    "blackWhite",
    "black",
    "white",
    "hidden"
};
ST_BlackWhiteMode* ST_BlackWhiteMode::default_instance_ = NULL;

// ST_DrawingElementId
ST_DrawingElementId::ST_DrawingElementId()
    :m_has_unsignedInt(false),
     m_unsignedInt(0)
{
}
ST_DrawingElementId::ST_DrawingElementId(const XSD::unsignedInt_& _unsignedInt)
    :m_has_unsignedInt(true)
{

    set_unsignedInt(_unsignedInt);
}
ST_DrawingElementId::~ST_DrawingElementId()
{
    clear();
}
bool ST_DrawingElementId::has_unsignedInt() const
{
    return m_has_unsignedInt;
}

void ST_DrawingElementId::set_unsignedInt(const XSD::unsignedInt_& _unsignedInt)
{
    m_has_unsignedInt = true;
    m_unsignedInt = _unsignedInt;
}

const XSD::unsignedInt_& ST_DrawingElementId::get_unsignedInt() const
{
    return m_unsignedInt;
}

void ST_DrawingElementId::clear()
{
    m_has_unsignedInt = false;
    m_unsignedInt = 0;;
}

void ST_DrawingElementId::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_unsignedInt)
    {
        _outStream << " " << _attrName << "=\"" << m_unsignedInt << "\"";;
    }
}

const ST_DrawingElementId& ST_DrawingElementId::default_instance()
{
    if (!ST_DrawingElementId::default_instance_)
    {
        ST_DrawingElementId::default_instance_ = new ST_DrawingElementId();
    }
    return *ST_DrawingElementId::default_instance_;
}

std::string ST_DrawingElementId::toString() const
{
    std::stringstream strStream;
    strStream << get_unsignedInt();
    return strStream.str();
}

ST_DrawingElementId* ST_DrawingElementId::default_instance_ = NULL;

// ST_ChartBuildStep
ST_ChartBuildStep::ST_ChartBuildStep()
    :m_has_type(false)
{
}
ST_ChartBuildStep::ST_ChartBuildStep(const ST_ChartBuildStep::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_ChartBuildStep::~ST_ChartBuildStep()
{
    clear();
}
bool ST_ChartBuildStep::has_type() const
{
    return m_has_type;
}

void ST_ChartBuildStep::set_type(const ST_ChartBuildStep::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_ChartBuildStep::Type& ST_ChartBuildStep::get_type() const
{
    return m_type;
}

std::string ST_ChartBuildStep::toString() const
{
    return ST_ChartBuildStep::TypeStrList[m_type];
}

void ST_ChartBuildStep::clear()
{
    m_has_type = false;
}

void ST_ChartBuildStep::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_ChartBuildStep& ST_ChartBuildStep::default_instance()
{
    if (!ST_ChartBuildStep::default_instance_)
    {
        ST_ChartBuildStep::default_instance_ = new ST_ChartBuildStep();
    }
    return *ST_ChartBuildStep::default_instance_;
}

const std::string ST_ChartBuildStep::TypeStrList[] =
{
    "category",
    "ptInCategory",
    "series",
    "ptInSeries",
    "allPts",
    "gridLegend"
};
ST_ChartBuildStep* ST_ChartBuildStep::default_instance_ = NULL;

// ST_DgmBuildStep
ST_DgmBuildStep::ST_DgmBuildStep()
    :m_has_type(false)
{
}
ST_DgmBuildStep::ST_DgmBuildStep(const ST_DgmBuildStep::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_DgmBuildStep::~ST_DgmBuildStep()
{
    clear();
}
bool ST_DgmBuildStep::has_type() const
{
    return m_has_type;
}

void ST_DgmBuildStep::set_type(const ST_DgmBuildStep::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_DgmBuildStep::Type& ST_DgmBuildStep::get_type() const
{
    return m_type;
}

std::string ST_DgmBuildStep::toString() const
{
    return ST_DgmBuildStep::TypeStrList[m_type];
}

void ST_DgmBuildStep::clear()
{
    m_has_type = false;
}

void ST_DgmBuildStep::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_DgmBuildStep& ST_DgmBuildStep::default_instance()
{
    if (!ST_DgmBuildStep::default_instance_)
    {
        ST_DgmBuildStep::default_instance_ = new ST_DgmBuildStep();
    }
    return *ST_DgmBuildStep::default_instance_;
}

const std::string ST_DgmBuildStep::TypeStrList[] =
{
    "sp",
    "bg"
};
ST_DgmBuildStep* ST_DgmBuildStep::default_instance_ = NULL;

// ST_AnimationBuildType
ST_AnimationBuildType::ST_AnimationBuildType()
    :m_has_type(false)
{
}
ST_AnimationBuildType::ST_AnimationBuildType(const ST_AnimationBuildType::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_AnimationBuildType::~ST_AnimationBuildType()
{
    clear();
}
bool ST_AnimationBuildType::has_type() const
{
    return m_has_type;
}

void ST_AnimationBuildType::set_type(const ST_AnimationBuildType::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_AnimationBuildType::Type& ST_AnimationBuildType::get_type() const
{
    return m_type;
}

std::string ST_AnimationBuildType::toString() const
{
    return ST_AnimationBuildType::TypeStrList[m_type];
}

void ST_AnimationBuildType::clear()
{
    m_has_type = false;
}

void ST_AnimationBuildType::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_AnimationBuildType& ST_AnimationBuildType::default_instance()
{
    if (!ST_AnimationBuildType::default_instance_)
    {
        ST_AnimationBuildType::default_instance_ = new ST_AnimationBuildType();
    }
    return *ST_AnimationBuildType::default_instance_;
}

const std::string ST_AnimationBuildType::TypeStrList[] =
{
    "allAtOnce"
};
ST_AnimationBuildType* ST_AnimationBuildType::default_instance_ = NULL;

// ST_AnimationDgmOnlyBuildType
ST_AnimationDgmOnlyBuildType::ST_AnimationDgmOnlyBuildType()
    :m_has_type(false)
{
}
ST_AnimationDgmOnlyBuildType::ST_AnimationDgmOnlyBuildType(const ST_AnimationDgmOnlyBuildType::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_AnimationDgmOnlyBuildType::~ST_AnimationDgmOnlyBuildType()
{
    clear();
}
bool ST_AnimationDgmOnlyBuildType::has_type() const
{
    return m_has_type;
}

void ST_AnimationDgmOnlyBuildType::set_type(const ST_AnimationDgmOnlyBuildType::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_AnimationDgmOnlyBuildType::Type& ST_AnimationDgmOnlyBuildType::get_type() const
{
    return m_type;
}

std::string ST_AnimationDgmOnlyBuildType::toString() const
{
    return ST_AnimationDgmOnlyBuildType::TypeStrList[m_type];
}

void ST_AnimationDgmOnlyBuildType::clear()
{
    m_has_type = false;
}

void ST_AnimationDgmOnlyBuildType::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_AnimationDgmOnlyBuildType& ST_AnimationDgmOnlyBuildType::default_instance()
{
    if (!ST_AnimationDgmOnlyBuildType::default_instance_)
    {
        ST_AnimationDgmOnlyBuildType::default_instance_ = new ST_AnimationDgmOnlyBuildType();
    }
    return *ST_AnimationDgmOnlyBuildType::default_instance_;
}

const std::string ST_AnimationDgmOnlyBuildType::TypeStrList[] =
{
    "one",
    "lvlOne",
    "lvlAtOnce"
};
ST_AnimationDgmOnlyBuildType* ST_AnimationDgmOnlyBuildType::default_instance_ = NULL;

// ST_AnimationDgmBuildType
ST_AnimationDgmBuildType::ST_AnimationDgmBuildType()
    :m_has_ST_AnimationBuildType(false),
     m_ST_AnimationBuildType(NULL),
     m_has_ST_AnimationDgmOnlyBuildType(false),
     m_ST_AnimationDgmOnlyBuildType(NULL)
{
}
ST_AnimationDgmBuildType::ST_AnimationDgmBuildType(const ST_AnimationDgmBuildType& _ST_AnimationDgmBuildType)
    :m_has_ST_AnimationBuildType(false),
     m_ST_AnimationBuildType(NULL),
     m_has_ST_AnimationDgmOnlyBuildType(false),
     m_ST_AnimationDgmOnlyBuildType(NULL)
{

    m_has_ST_AnimationBuildType = _ST_AnimationDgmBuildType.has_ST_AnimationBuildType();
    if (_ST_AnimationDgmBuildType.has_ST_AnimationBuildType())
    {
        m_ST_AnimationBuildType = new ST_AnimationBuildType(_ST_AnimationDgmBuildType.get_ST_AnimationBuildType());
    }


    m_has_ST_AnimationDgmOnlyBuildType = _ST_AnimationDgmBuildType.has_ST_AnimationDgmOnlyBuildType();
    if (_ST_AnimationDgmBuildType.has_ST_AnimationDgmOnlyBuildType())
    {
        m_ST_AnimationDgmOnlyBuildType = new ST_AnimationDgmOnlyBuildType(_ST_AnimationDgmBuildType.get_ST_AnimationDgmOnlyBuildType());
    }
}
ST_AnimationDgmBuildType::~ST_AnimationDgmBuildType()
{
    clear();
}
bool ST_AnimationDgmBuildType::has_ST_AnimationBuildType() const
{
    return m_has_ST_AnimationBuildType;
}

ST_AnimationBuildType* ST_AnimationDgmBuildType::mutable_ST_AnimationBuildType()
{
    clear_ST_AnimationDgmOnlyBuildType();
    m_has_ST_AnimationBuildType = true;
    if (!m_ST_AnimationBuildType)
    {
        m_ST_AnimationBuildType = new ST_AnimationBuildType();
    }
    return m_ST_AnimationBuildType;
}

const ST_AnimationBuildType& ST_AnimationDgmBuildType::get_ST_AnimationBuildType() const
{
    if (m_ST_AnimationBuildType)
    {
        return *m_ST_AnimationBuildType;
    }
    return ST_AnimationBuildType::default_instance();
}

void ST_AnimationDgmBuildType::clear_ST_AnimationBuildType()
{
    m_has_ST_AnimationBuildType = false;
    if (m_ST_AnimationBuildType)
    {
        delete m_ST_AnimationBuildType;
        m_ST_AnimationBuildType = NULL;
    }
}

bool ST_AnimationDgmBuildType::has_ST_AnimationDgmOnlyBuildType() const
{
    return m_has_ST_AnimationDgmOnlyBuildType;
}

ST_AnimationDgmOnlyBuildType* ST_AnimationDgmBuildType::mutable_ST_AnimationDgmOnlyBuildType()
{
    clear_ST_AnimationBuildType();
    m_has_ST_AnimationDgmOnlyBuildType = true;
    if (!m_ST_AnimationDgmOnlyBuildType)
    {
        m_ST_AnimationDgmOnlyBuildType = new ST_AnimationDgmOnlyBuildType();
    }
    return m_ST_AnimationDgmOnlyBuildType;
}

const ST_AnimationDgmOnlyBuildType& ST_AnimationDgmBuildType::get_ST_AnimationDgmOnlyBuildType() const
{
    if (m_ST_AnimationDgmOnlyBuildType)
    {
        return *m_ST_AnimationDgmOnlyBuildType;
    }
    return ST_AnimationDgmOnlyBuildType::default_instance();
}

void ST_AnimationDgmBuildType::clear_ST_AnimationDgmOnlyBuildType()
{
    m_has_ST_AnimationDgmOnlyBuildType = false;
    if (m_ST_AnimationDgmOnlyBuildType)
    {
        delete m_ST_AnimationDgmOnlyBuildType;
        m_ST_AnimationDgmOnlyBuildType = NULL;
    }
}

std::string ST_AnimationDgmBuildType::toString() const
{
    if (m_has_ST_AnimationBuildType)
    {
        return m_ST_AnimationBuildType->toString();
    }

    if (m_has_ST_AnimationDgmOnlyBuildType)
    {
        return m_ST_AnimationDgmOnlyBuildType->toString();
    }

    return string();
}

void ST_AnimationDgmBuildType::clear()
{   clear_ST_AnimationBuildType();
    clear_ST_AnimationDgmOnlyBuildType();
}

void ST_AnimationDgmBuildType::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_ST_AnimationBuildType)
    {
        m_ST_AnimationBuildType->toXmlAttr(_attrName, _outStream);
        return;
    }

    if (m_has_ST_AnimationDgmOnlyBuildType)
    {
        m_ST_AnimationDgmOnlyBuildType->toXmlAttr(_attrName, _outStream);
        return;
    }
}

const ST_AnimationDgmBuildType& ST_AnimationDgmBuildType::default_instance()
{
    if (!ST_AnimationDgmBuildType::default_instance_)
    {
        ST_AnimationDgmBuildType::default_instance_ = new ST_AnimationDgmBuildType();
    }
    return *ST_AnimationDgmBuildType::default_instance_;
}

ST_AnimationDgmBuildType* ST_AnimationDgmBuildType::default_instance_ = NULL;

// ST_AnimationChartOnlyBuildType
ST_AnimationChartOnlyBuildType::ST_AnimationChartOnlyBuildType()
    :m_has_type(false)
{
}
ST_AnimationChartOnlyBuildType::ST_AnimationChartOnlyBuildType(const ST_AnimationChartOnlyBuildType::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_AnimationChartOnlyBuildType::~ST_AnimationChartOnlyBuildType()
{
    clear();
}
bool ST_AnimationChartOnlyBuildType::has_type() const
{
    return m_has_type;
}

void ST_AnimationChartOnlyBuildType::set_type(const ST_AnimationChartOnlyBuildType::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_AnimationChartOnlyBuildType::Type& ST_AnimationChartOnlyBuildType::get_type() const
{
    return m_type;
}

std::string ST_AnimationChartOnlyBuildType::toString() const
{
    return ST_AnimationChartOnlyBuildType::TypeStrList[m_type];
}

void ST_AnimationChartOnlyBuildType::clear()
{
    m_has_type = false;
}

void ST_AnimationChartOnlyBuildType::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_AnimationChartOnlyBuildType& ST_AnimationChartOnlyBuildType::default_instance()
{
    if (!ST_AnimationChartOnlyBuildType::default_instance_)
    {
        ST_AnimationChartOnlyBuildType::default_instance_ = new ST_AnimationChartOnlyBuildType();
    }
    return *ST_AnimationChartOnlyBuildType::default_instance_;
}

const std::string ST_AnimationChartOnlyBuildType::TypeStrList[] =
{
    "series",
    "category",
    "seriesEl",
    "categoryEl"
};
ST_AnimationChartOnlyBuildType* ST_AnimationChartOnlyBuildType::default_instance_ = NULL;

// ST_AnimationChartBuildType
ST_AnimationChartBuildType::ST_AnimationChartBuildType()
    :m_has_ST_AnimationBuildType(false),
     m_ST_AnimationBuildType(NULL),
     m_has_ST_AnimationChartOnlyBuildType(false),
     m_ST_AnimationChartOnlyBuildType(NULL)
{
}
ST_AnimationChartBuildType::ST_AnimationChartBuildType(const ST_AnimationChartBuildType& _ST_AnimationChartBuildType)
    :m_has_ST_AnimationBuildType(false),
     m_ST_AnimationBuildType(NULL),
     m_has_ST_AnimationChartOnlyBuildType(false),
     m_ST_AnimationChartOnlyBuildType(NULL)
{

    m_has_ST_AnimationBuildType = _ST_AnimationChartBuildType.has_ST_AnimationBuildType();
    if (_ST_AnimationChartBuildType.has_ST_AnimationBuildType())
    {
        m_ST_AnimationBuildType = new ST_AnimationBuildType(_ST_AnimationChartBuildType.get_ST_AnimationBuildType());
    }


    m_has_ST_AnimationChartOnlyBuildType = _ST_AnimationChartBuildType.has_ST_AnimationChartOnlyBuildType();
    if (_ST_AnimationChartBuildType.has_ST_AnimationChartOnlyBuildType())
    {
        m_ST_AnimationChartOnlyBuildType = new ST_AnimationChartOnlyBuildType(_ST_AnimationChartBuildType.get_ST_AnimationChartOnlyBuildType());
    }
}
ST_AnimationChartBuildType::~ST_AnimationChartBuildType()
{
    clear();
}
bool ST_AnimationChartBuildType::has_ST_AnimationBuildType() const
{
    return m_has_ST_AnimationBuildType;
}

ST_AnimationBuildType* ST_AnimationChartBuildType::mutable_ST_AnimationBuildType()
{
    clear_ST_AnimationChartOnlyBuildType();
    m_has_ST_AnimationBuildType = true;
    if (!m_ST_AnimationBuildType)
    {
        m_ST_AnimationBuildType = new ST_AnimationBuildType();
    }
    return m_ST_AnimationBuildType;
}

const ST_AnimationBuildType& ST_AnimationChartBuildType::get_ST_AnimationBuildType() const
{
    if (m_ST_AnimationBuildType)
    {
        return *m_ST_AnimationBuildType;
    }
    return ST_AnimationBuildType::default_instance();
}

void ST_AnimationChartBuildType::clear_ST_AnimationBuildType()
{
    m_has_ST_AnimationBuildType = false;
    if (m_ST_AnimationBuildType)
    {
        delete m_ST_AnimationBuildType;
        m_ST_AnimationBuildType = NULL;
    }
}

bool ST_AnimationChartBuildType::has_ST_AnimationChartOnlyBuildType() const
{
    return m_has_ST_AnimationChartOnlyBuildType;
}

ST_AnimationChartOnlyBuildType* ST_AnimationChartBuildType::mutable_ST_AnimationChartOnlyBuildType()
{
    clear_ST_AnimationBuildType();
    m_has_ST_AnimationChartOnlyBuildType = true;
    if (!m_ST_AnimationChartOnlyBuildType)
    {
        m_ST_AnimationChartOnlyBuildType = new ST_AnimationChartOnlyBuildType();
    }
    return m_ST_AnimationChartOnlyBuildType;
}

const ST_AnimationChartOnlyBuildType& ST_AnimationChartBuildType::get_ST_AnimationChartOnlyBuildType() const
{
    if (m_ST_AnimationChartOnlyBuildType)
    {
        return *m_ST_AnimationChartOnlyBuildType;
    }
    return ST_AnimationChartOnlyBuildType::default_instance();
}

void ST_AnimationChartBuildType::clear_ST_AnimationChartOnlyBuildType()
{
    m_has_ST_AnimationChartOnlyBuildType = false;
    if (m_ST_AnimationChartOnlyBuildType)
    {
        delete m_ST_AnimationChartOnlyBuildType;
        m_ST_AnimationChartOnlyBuildType = NULL;
    }
}

std::string ST_AnimationChartBuildType::toString() const
{
    if (m_has_ST_AnimationBuildType)
    {
        return m_ST_AnimationBuildType->toString();
    }

    if (m_has_ST_AnimationChartOnlyBuildType)
    {
        return m_ST_AnimationChartOnlyBuildType->toString();
    }

    return string();
}

void ST_AnimationChartBuildType::clear()
{   clear_ST_AnimationBuildType();
    clear_ST_AnimationChartOnlyBuildType();
}

void ST_AnimationChartBuildType::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_ST_AnimationBuildType)
    {
        m_ST_AnimationBuildType->toXmlAttr(_attrName, _outStream);
        return;
    }

    if (m_has_ST_AnimationChartOnlyBuildType)
    {
        m_ST_AnimationChartOnlyBuildType->toXmlAttr(_attrName, _outStream);
        return;
    }
}

const ST_AnimationChartBuildType& ST_AnimationChartBuildType::default_instance()
{
    if (!ST_AnimationChartBuildType::default_instance_)
    {
        ST_AnimationChartBuildType::default_instance_ = new ST_AnimationChartBuildType();
    }
    return *ST_AnimationChartBuildType::default_instance_;
}

ST_AnimationChartBuildType* ST_AnimationChartBuildType::default_instance_ = NULL;

// ST_PresetCameraType
ST_PresetCameraType::ST_PresetCameraType()
    :m_has_type(false)
{
}
ST_PresetCameraType::ST_PresetCameraType(const ST_PresetCameraType::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_PresetCameraType::~ST_PresetCameraType()
{
    clear();
}
bool ST_PresetCameraType::has_type() const
{
    return m_has_type;
}

void ST_PresetCameraType::set_type(const ST_PresetCameraType::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_PresetCameraType::Type& ST_PresetCameraType::get_type() const
{
    return m_type;
}

std::string ST_PresetCameraType::toString() const
{
    return ST_PresetCameraType::TypeStrList[m_type];
}

void ST_PresetCameraType::clear()
{
    m_has_type = false;
}

void ST_PresetCameraType::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_PresetCameraType& ST_PresetCameraType::default_instance()
{
    if (!ST_PresetCameraType::default_instance_)
    {
        ST_PresetCameraType::default_instance_ = new ST_PresetCameraType();
    }
    return *ST_PresetCameraType::default_instance_;
}

const std::string ST_PresetCameraType::TypeStrList[] =
{
    "legacyObliqueTopLeft",
    "legacyObliqueTop",
    "legacyObliqueTopRight",
    "legacyObliqueLeft",
    "legacyObliqueFront",
    "legacyObliqueRight",
    "legacyObliqueBottomLeft",
    "legacyObliqueBottom",
    "legacyObliqueBottomRight",
    "legacyPerspectiveTopLeft",
    "legacyPerspectiveTop",
    "legacyPerspectiveTopRight",
    "legacyPerspectiveLeft",
    "legacyPerspectiveFront",
    "legacyPerspectiveRight",
    "legacyPerspectiveBottomLeft",
    "legacyPerspectiveBottom",
    "legacyPerspectiveBottomRight",
    "orthographicFront",
    "isometricTopUp",
    "isometricTopDown",
    "isometricBottomUp",
    "isometricBottomDown",
    "isometricLeftUp",
    "isometricLeftDown",
    "isometricRightUp",
    "isometricRightDown",
    "isometricOffAxis1Left",
    "isometricOffAxis1Right",
    "isometricOffAxis1Top",
    "isometricOffAxis2Left",
    "isometricOffAxis2Right",
    "isometricOffAxis2Top",
    "isometricOffAxis3Left",
    "isometricOffAxis3Right",
    "isometricOffAxis3Bottom",
    "isometricOffAxis4Left",
    "isometricOffAxis4Right",
    "isometricOffAxis4Bottom",
    "obliqueTopLeft",
    "obliqueTop",
    "obliqueTopRight",
    "obliqueLeft",
    "obliqueRight",
    "obliqueBottomLeft",
    "obliqueBottom",
    "obliqueBottomRight",
    "perspectiveFront",
    "perspectiveLeft",
    "perspectiveRight",
    "perspectiveAbove",
    "perspectiveBelow",
    "perspectiveAboveLeftFacing",
    "perspectiveAboveRightFacing",
    "perspectiveContrastingLeftFacing",
    "perspectiveContrastingRightFacing",
    "perspectiveHeroicLeftFacing",
    "perspectiveHeroicRightFacing",
    "perspectiveHeroicExtremeLeftFacing",
    "perspectiveHeroicExtremeRightFacing",
    "perspectiveRelaxed",
    "perspectiveRelaxedModerately"
};
ST_PresetCameraType* ST_PresetCameraType::default_instance_ = NULL;

// ST_FOVAngle
ST_FOVAngle::ST_FOVAngle()

{
}
ST_FOVAngle::ST_FOVAngle(const ST_Angle& _ST_Angle)
    :ST_Angle(_ST_Angle)
{
}
ST_FOVAngle::~ST_FOVAngle()
{
    clear();
}
const ST_FOVAngle& ST_FOVAngle::default_instance()
{
    if (!ST_FOVAngle::default_instance_)
    {
        ST_FOVAngle::default_instance_ = new ST_FOVAngle();
    }
    return *ST_FOVAngle::default_instance_;
}

ST_FOVAngle* ST_FOVAngle::default_instance_ = NULL;

// ST_LightRigDirection
ST_LightRigDirection::ST_LightRigDirection()
    :m_has_type(false)
{
}
ST_LightRigDirection::ST_LightRigDirection(const ST_LightRigDirection::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_LightRigDirection::~ST_LightRigDirection()
{
    clear();
}
bool ST_LightRigDirection::has_type() const
{
    return m_has_type;
}

void ST_LightRigDirection::set_type(const ST_LightRigDirection::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_LightRigDirection::Type& ST_LightRigDirection::get_type() const
{
    return m_type;
}

std::string ST_LightRigDirection::toString() const
{
    return ST_LightRigDirection::TypeStrList[m_type];
}

void ST_LightRigDirection::clear()
{
    m_has_type = false;
}

void ST_LightRigDirection::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_LightRigDirection& ST_LightRigDirection::default_instance()
{
    if (!ST_LightRigDirection::default_instance_)
    {
        ST_LightRigDirection::default_instance_ = new ST_LightRigDirection();
    }
    return *ST_LightRigDirection::default_instance_;
}

const std::string ST_LightRigDirection::TypeStrList[] =
{
    "tl",
    "t",
    "tr",
    "l",
    "r",
    "bl",
    "b",
    "br"
};
ST_LightRigDirection* ST_LightRigDirection::default_instance_ = NULL;

// ST_LightRigType
ST_LightRigType::ST_LightRigType()
    :m_has_type(false)
{
}
ST_LightRigType::ST_LightRigType(const ST_LightRigType::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_LightRigType::~ST_LightRigType()
{
    clear();
}
bool ST_LightRigType::has_type() const
{
    return m_has_type;
}

void ST_LightRigType::set_type(const ST_LightRigType::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_LightRigType::Type& ST_LightRigType::get_type() const
{
    return m_type;
}

std::string ST_LightRigType::toString() const
{
    return ST_LightRigType::TypeStrList[m_type];
}

void ST_LightRigType::clear()
{
    m_has_type = false;
}

void ST_LightRigType::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_LightRigType& ST_LightRigType::default_instance()
{
    if (!ST_LightRigType::default_instance_)
    {
        ST_LightRigType::default_instance_ = new ST_LightRigType();
    }
    return *ST_LightRigType::default_instance_;
}

const std::string ST_LightRigType::TypeStrList[] =
{
    "legacyFlat1",
    "legacyFlat2",
    "legacyFlat3",
    "legacyFlat4",
    "legacyNormal1",
    "legacyNormal2",
    "legacyNormal3",
    "legacyNormal4",
    "legacyHarsh1",
    "legacyHarsh2",
    "legacyHarsh3",
    "legacyHarsh4",
    "threePt",
    "balanced",
    "soft",
    "harsh",
    "flood",
    "contrasting",
    "morning",
    "sunrise",
    "sunset",
    "chilly",
    "freezing",
    "flat",
    "twoPt",
    "glow",
    "brightRoom"
};
ST_LightRigType* ST_LightRigType::default_instance_ = NULL;

// ST_BevelPresetType
ST_BevelPresetType::ST_BevelPresetType()
    :m_has_type(false)
{
}
ST_BevelPresetType::ST_BevelPresetType(const ST_BevelPresetType::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_BevelPresetType::~ST_BevelPresetType()
{
    clear();
}
bool ST_BevelPresetType::has_type() const
{
    return m_has_type;
}

void ST_BevelPresetType::set_type(const ST_BevelPresetType::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_BevelPresetType::Type& ST_BevelPresetType::get_type() const
{
    return m_type;
}

std::string ST_BevelPresetType::toString() const
{
    return ST_BevelPresetType::TypeStrList[m_type];
}

void ST_BevelPresetType::clear()
{
    m_has_type = false;
}

void ST_BevelPresetType::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_BevelPresetType& ST_BevelPresetType::default_instance()
{
    if (!ST_BevelPresetType::default_instance_)
    {
        ST_BevelPresetType::default_instance_ = new ST_BevelPresetType();
    }
    return *ST_BevelPresetType::default_instance_;
}

const std::string ST_BevelPresetType::TypeStrList[] =
{
    "relaxedInset",
    "circle",
    "slope",
    "cross",
    "angle",
    "softRound",
    "convex",
    "coolSlant",
    "divot",
    "riblet",
    "hardEdge",
    "artDeco"
};
ST_BevelPresetType* ST_BevelPresetType::default_instance_ = NULL;

// ST_PresetMaterialType
ST_PresetMaterialType::ST_PresetMaterialType()
    :m_has_type(false)
{
}
ST_PresetMaterialType::ST_PresetMaterialType(const ST_PresetMaterialType::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_PresetMaterialType::~ST_PresetMaterialType()
{
    clear();
}
bool ST_PresetMaterialType::has_type() const
{
    return m_has_type;
}

void ST_PresetMaterialType::set_type(const ST_PresetMaterialType::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_PresetMaterialType::Type& ST_PresetMaterialType::get_type() const
{
    return m_type;
}

std::string ST_PresetMaterialType::toString() const
{
    return ST_PresetMaterialType::TypeStrList[m_type];
}

void ST_PresetMaterialType::clear()
{
    m_has_type = false;
}

void ST_PresetMaterialType::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_PresetMaterialType& ST_PresetMaterialType::default_instance()
{
    if (!ST_PresetMaterialType::default_instance_)
    {
        ST_PresetMaterialType::default_instance_ = new ST_PresetMaterialType();
    }
    return *ST_PresetMaterialType::default_instance_;
}

const std::string ST_PresetMaterialType::TypeStrList[] =
{
    "legacyMatte",
    "legacyPlastic",
    "legacyMetal",
    "legacyWireframe",
    "matte",
    "plastic",
    "metal",
    "warmMatte",
    "translucentPowder",
    "powder",
    "dkEdge",
    "softEdge",
    "clear",
    "flat",
    "softmetal"
};
ST_PresetMaterialType* ST_PresetMaterialType::default_instance_ = NULL;

// ST_PresetShadowVal
ST_PresetShadowVal::ST_PresetShadowVal()
    :m_has_type(false)
{
}
ST_PresetShadowVal::ST_PresetShadowVal(const ST_PresetShadowVal::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_PresetShadowVal::~ST_PresetShadowVal()
{
    clear();
}
bool ST_PresetShadowVal::has_type() const
{
    return m_has_type;
}

void ST_PresetShadowVal::set_type(const ST_PresetShadowVal::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_PresetShadowVal::Type& ST_PresetShadowVal::get_type() const
{
    return m_type;
}

std::string ST_PresetShadowVal::toString() const
{
    return ST_PresetShadowVal::TypeStrList[m_type];
}

void ST_PresetShadowVal::clear()
{
    m_has_type = false;
}

void ST_PresetShadowVal::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_PresetShadowVal& ST_PresetShadowVal::default_instance()
{
    if (!ST_PresetShadowVal::default_instance_)
    {
        ST_PresetShadowVal::default_instance_ = new ST_PresetShadowVal();
    }
    return *ST_PresetShadowVal::default_instance_;
}

const std::string ST_PresetShadowVal::TypeStrList[] =
{
    "shdw1",
    "shdw2",
    "shdw3",
    "shdw4",
    "shdw5",
    "shdw6",
    "shdw7",
    "shdw8",
    "shdw9",
    "shdw10",
    "shdw11",
    "shdw12",
    "shdw13",
    "shdw14",
    "shdw15",
    "shdw16",
    "shdw17",
    "shdw18",
    "shdw19",
    "shdw20"
};
ST_PresetShadowVal* ST_PresetShadowVal::default_instance_ = NULL;

// ST_PathShadeType
ST_PathShadeType::ST_PathShadeType()
    :m_has_type(false)
{
}
ST_PathShadeType::ST_PathShadeType(const ST_PathShadeType::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_PathShadeType::~ST_PathShadeType()
{
    clear();
}
bool ST_PathShadeType::has_type() const
{
    return m_has_type;
}

void ST_PathShadeType::set_type(const ST_PathShadeType::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_PathShadeType::Type& ST_PathShadeType::get_type() const
{
    return m_type;
}

std::string ST_PathShadeType::toString() const
{
    return ST_PathShadeType::TypeStrList[m_type];
}

void ST_PathShadeType::clear()
{
    m_has_type = false;
}

void ST_PathShadeType::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_PathShadeType& ST_PathShadeType::default_instance()
{
    if (!ST_PathShadeType::default_instance_)
    {
        ST_PathShadeType::default_instance_ = new ST_PathShadeType();
    }
    return *ST_PathShadeType::default_instance_;
}

const std::string ST_PathShadeType::TypeStrList[] =
{
    "shape",
    "circle",
    "rect"
};
ST_PathShadeType* ST_PathShadeType::default_instance_ = NULL;

// ST_TileFlipMode
ST_TileFlipMode::ST_TileFlipMode()
    :m_has_type(false)
{
}
ST_TileFlipMode::ST_TileFlipMode(const ST_TileFlipMode::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_TileFlipMode::~ST_TileFlipMode()
{
    clear();
}
bool ST_TileFlipMode::has_type() const
{
    return m_has_type;
}

void ST_TileFlipMode::set_type(const ST_TileFlipMode::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_TileFlipMode::Type& ST_TileFlipMode::get_type() const
{
    return m_type;
}

std::string ST_TileFlipMode::toString() const
{
    return ST_TileFlipMode::TypeStrList[m_type];
}

void ST_TileFlipMode::clear()
{
    m_has_type = false;
}

void ST_TileFlipMode::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_TileFlipMode& ST_TileFlipMode::default_instance()
{
    if (!ST_TileFlipMode::default_instance_)
    {
        ST_TileFlipMode::default_instance_ = new ST_TileFlipMode();
    }
    return *ST_TileFlipMode::default_instance_;
}

const std::string ST_TileFlipMode::TypeStrList[] =
{
    "none",
    "x",
    "y",
    "xy"
};
ST_TileFlipMode* ST_TileFlipMode::default_instance_ = NULL;

// ST_BlipCompression
ST_BlipCompression::ST_BlipCompression()
    :m_has_type(false)
{
}
ST_BlipCompression::ST_BlipCompression(const ST_BlipCompression::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_BlipCompression::~ST_BlipCompression()
{
    clear();
}
bool ST_BlipCompression::has_type() const
{
    return m_has_type;
}

void ST_BlipCompression::set_type(const ST_BlipCompression::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_BlipCompression::Type& ST_BlipCompression::get_type() const
{
    return m_type;
}

std::string ST_BlipCompression::toString() const
{
    return ST_BlipCompression::TypeStrList[m_type];
}

void ST_BlipCompression::clear()
{
    m_has_type = false;
}

void ST_BlipCompression::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_BlipCompression& ST_BlipCompression::default_instance()
{
    if (!ST_BlipCompression::default_instance_)
    {
        ST_BlipCompression::default_instance_ = new ST_BlipCompression();
    }
    return *ST_BlipCompression::default_instance_;
}

const std::string ST_BlipCompression::TypeStrList[] =
{
    "email",
    "screen",
    "print",
    "hqprint",
    "none"
};
ST_BlipCompression* ST_BlipCompression::default_instance_ = NULL;

// ST_PresetPatternVal
ST_PresetPatternVal::ST_PresetPatternVal()
    :m_has_type(false)
{
}
ST_PresetPatternVal::ST_PresetPatternVal(const ST_PresetPatternVal::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_PresetPatternVal::~ST_PresetPatternVal()
{
    clear();
}
bool ST_PresetPatternVal::has_type() const
{
    return m_has_type;
}

void ST_PresetPatternVal::set_type(const ST_PresetPatternVal::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_PresetPatternVal::Type& ST_PresetPatternVal::get_type() const
{
    return m_type;
}

std::string ST_PresetPatternVal::toString() const
{
    return ST_PresetPatternVal::TypeStrList[m_type];
}

void ST_PresetPatternVal::clear()
{
    m_has_type = false;
}

void ST_PresetPatternVal::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_PresetPatternVal& ST_PresetPatternVal::default_instance()
{
    if (!ST_PresetPatternVal::default_instance_)
    {
        ST_PresetPatternVal::default_instance_ = new ST_PresetPatternVal();
    }
    return *ST_PresetPatternVal::default_instance_;
}

const std::string ST_PresetPatternVal::TypeStrList[] =
{
    "pct5",
    "pct10",
    "pct20",
    "pct25",
    "pct30",
    "pct40",
    "pct50",
    "pct60",
    "pct70",
    "pct75",
    "pct80",
    "pct90",
    "horz",
    "vert",
    "ltHorz",
    "ltVert",
    "dkHorz",
    "dkVert",
    "narHorz",
    "narVert",
    "dashHorz",
    "dashVert",
    "cross",
    "dnDiag",
    "upDiag",
    "ltDnDiag",
    "ltUpDiag",
    "dkDnDiag",
    "dkUpDiag",
    "wdDnDiag",
    "wdUpDiag",
    "dashDnDiag",
    "dashUpDiag",
    "diagCross",
    "smCheck",
    "lgCheck",
    "smGrid",
    "lgGrid",
    "dotGrid",
    "smConfetti",
    "lgConfetti",
    "horzBrick",
    "diagBrick",
    "solidDmnd",
    "openDmnd",
    "dotDmnd",
    "plaid",
    "sphere",
    "weave",
    "divot",
    "shingle",
    "wave",
    "trellis",
    "zigZag"
};
ST_PresetPatternVal* ST_PresetPatternVal::default_instance_ = NULL;

// ST_BlendMode
ST_BlendMode::ST_BlendMode()
    :m_has_type(false)
{
}
ST_BlendMode::ST_BlendMode(const ST_BlendMode::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_BlendMode::~ST_BlendMode()
{
    clear();
}
bool ST_BlendMode::has_type() const
{
    return m_has_type;
}

void ST_BlendMode::set_type(const ST_BlendMode::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_BlendMode::Type& ST_BlendMode::get_type() const
{
    return m_type;
}

std::string ST_BlendMode::toString() const
{
    return ST_BlendMode::TypeStrList[m_type];
}

void ST_BlendMode::clear()
{
    m_has_type = false;
}

void ST_BlendMode::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_BlendMode& ST_BlendMode::default_instance()
{
    if (!ST_BlendMode::default_instance_)
    {
        ST_BlendMode::default_instance_ = new ST_BlendMode();
    }
    return *ST_BlendMode::default_instance_;
}

const std::string ST_BlendMode::TypeStrList[] =
{
    "over",
    "mult",
    "screen",
    "darken",
    "lighten"
};
ST_BlendMode* ST_BlendMode::default_instance_ = NULL;

// ST_EffectContainerType
ST_EffectContainerType::ST_EffectContainerType()
    :m_has_type(false)
{
}
ST_EffectContainerType::ST_EffectContainerType(const ST_EffectContainerType::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_EffectContainerType::~ST_EffectContainerType()
{
    clear();
}
bool ST_EffectContainerType::has_type() const
{
    return m_has_type;
}

void ST_EffectContainerType::set_type(const ST_EffectContainerType::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_EffectContainerType::Type& ST_EffectContainerType::get_type() const
{
    return m_type;
}

std::string ST_EffectContainerType::toString() const
{
    return ST_EffectContainerType::TypeStrList[m_type];
}

void ST_EffectContainerType::clear()
{
    m_has_type = false;
}

void ST_EffectContainerType::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_EffectContainerType& ST_EffectContainerType::default_instance()
{
    if (!ST_EffectContainerType::default_instance_)
    {
        ST_EffectContainerType::default_instance_ = new ST_EffectContainerType();
    }
    return *ST_EffectContainerType::default_instance_;
}

const std::string ST_EffectContainerType::TypeStrList[] =
{
    "sib",
    "tree"
};
ST_EffectContainerType* ST_EffectContainerType::default_instance_ = NULL;

// ST_ShapeType
ST_ShapeType::ST_ShapeType()
    :m_has_type(false)
{
}
ST_ShapeType::ST_ShapeType(const ST_ShapeType::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_ShapeType::~ST_ShapeType()
{
    clear();
}
bool ST_ShapeType::has_type() const
{
    return m_has_type;
}

void ST_ShapeType::set_type(const ST_ShapeType::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_ShapeType::Type& ST_ShapeType::get_type() const
{
    return m_type;
}

std::string ST_ShapeType::toString() const
{
    return ST_ShapeType::TypeStrList[m_type];
}

void ST_ShapeType::clear()
{
    m_has_type = false;
}

void ST_ShapeType::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_ShapeType& ST_ShapeType::default_instance()
{
    if (!ST_ShapeType::default_instance_)
    {
        ST_ShapeType::default_instance_ = new ST_ShapeType();
    }
    return *ST_ShapeType::default_instance_;
}

const std::string ST_ShapeType::TypeStrList[] =
{
    "line",
    "lineInv",
    "triangle",
    "rtTriangle",
    "rect",
    "diamond",
    "parallelogram",
    "trapezoid",
    "nonIsoscelesTrapezoid",
    "pentagon",
    "hexagon",
    "heptagon",
    "octagon",
    "decagon",
    "dodecagon",
    "star4",
    "star5",
    "star6",
    "star7",
    "star8",
    "star10",
    "star12",
    "star16",
    "star24",
    "star32",
    "roundRect",
    "round1Rect",
    "round2SameRect",
    "round2DiagRect",
    "snipRoundRect",
    "snip1Rect",
    "snip2SameRect",
    "snip2DiagRect",
    "plaque",
    "ellipse",
    "teardrop",
    "homePlate",
    "chevron",
    "pieWedge",
    "pie",
    "blockArc",
    "donut",
    "noSmoking",
    "rightArrow",
    "leftArrow",
    "upArrow",
    "downArrow",
    "stripedRightArrow",
    "notchedRightArrow",
    "bentUpArrow",
    "leftRightArrow",
    "upDownArrow",
    "leftUpArrow",
    "leftRightUpArrow",
    "quadArrow",
    "leftArrowCallout",
    "rightArrowCallout",
    "upArrowCallout",
    "downArrowCallout",
    "leftRightArrowCallout",
    "upDownArrowCallout",
    "quadArrowCallout",
    "bentArrow",
    "uturnArrow",
    "circularArrow",
    "leftCircularArrow",
    "leftRightCircularArrow",
    "curvedRightArrow",
    "curvedLeftArrow",
    "curvedUpArrow",
    "curvedDownArrow",
    "swooshArrow",
    "cube",
    "can",
    "lightningBolt",
    "heart",
    "sun",
    "moon",
    "smileyFace",
    "irregularSeal1",
    "irregularSeal2",
    "foldedCorner",
    "bevel",
    "frame",
    "halfFrame",
    "corner",
    "diagStripe",
    "chord",
    "arc",
    "leftBracket",
    "rightBracket",
    "leftBrace",
    "rightBrace",
    "bracketPair",
    "bracePair",
    "straightConnector1",
    "bentConnector2",
    "bentConnector3",
    "bentConnector4",
    "bentConnector5",
    "curvedConnector2",
    "curvedConnector3",
    "curvedConnector4",
    "curvedConnector5",
    "callout1",
    "callout2",
    "callout3",
    "accentCallout1",
    "accentCallout2",
    "accentCallout3",
    "borderCallout1",
    "borderCallout2",
    "borderCallout3",
    "accentBorderCallout1",
    "accentBorderCallout2",
    "accentBorderCallout3",
    "wedgeRectCallout",
    "wedgeRoundRectCallout",
    "wedgeEllipseCallout",
    "cloudCallout",
    "cloud",
    "ribbon",
    "ribbon2",
    "ellipseRibbon",
    "ellipseRibbon2",
    "leftRightRibbon",
    "verticalScroll",
    "horizontalScroll",
    "wave",
    "doubleWave",
    "plus",
    "flowChartProcess",
    "flowChartDecision",
    "flowChartInputOutput",
    "flowChartPredefinedProcess",
    "flowChartInternalStorage",
    "flowChartDocument",
    "flowChartMultidocument",
    "flowChartTerminator",
    "flowChartPreparation",
    "flowChartManualInput",
    "flowChartManualOperation",
    "flowChartConnector",
    "flowChartPunchedCard",
    "flowChartPunchedTape",
    "flowChartSummingJunction",
    "flowChartOr",
    "flowChartCollate",
    "flowChartSort",
    "flowChartExtract",
    "flowChartMerge",
    "flowChartOfflineStorage",
    "flowChartOnlineStorage",
    "flowChartMagneticTape",
    "flowChartMagneticDisk",
    "flowChartMagneticDrum",
    "flowChartDisplay",
    "flowChartDelay",
    "flowChartAlternateProcess",
    "flowChartOffpageConnector",
    "actionButtonBlank",
    "actionButtonHome",
    "actionButtonHelp",
    "actionButtonInformation",
    "actionButtonForwardNext",
    "actionButtonBackPrevious",
    "actionButtonEnd",
    "actionButtonBeginning",
    "actionButtonReturn",
    "actionButtonDocument",
    "actionButtonSound",
    "actionButtonMovie",
    "gear6",
    "gear9",
    "funnel",
    "mathPlus",
    "mathMinus",
    "mathMultiply",
    "mathDivide",
    "mathEqual",
    "mathNotEqual",
    "cornerTabs",
    "squareTabs",
    "plaqueTabs",
    "chartX",
    "chartStar",
    "chartPlus"
};
ST_ShapeType* ST_ShapeType::default_instance_ = NULL;

// ST_TextShapeType
ST_TextShapeType::ST_TextShapeType()
    :m_has_type(false)
{
}
ST_TextShapeType::ST_TextShapeType(const ST_TextShapeType::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_TextShapeType::~ST_TextShapeType()
{
    clear();
}
bool ST_TextShapeType::has_type() const
{
    return m_has_type;
}

void ST_TextShapeType::set_type(const ST_TextShapeType::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_TextShapeType::Type& ST_TextShapeType::get_type() const
{
    return m_type;
}

std::string ST_TextShapeType::toString() const
{
    return ST_TextShapeType::TypeStrList[m_type];
}

void ST_TextShapeType::clear()
{
    m_has_type = false;
}

void ST_TextShapeType::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_TextShapeType& ST_TextShapeType::default_instance()
{
    if (!ST_TextShapeType::default_instance_)
    {
        ST_TextShapeType::default_instance_ = new ST_TextShapeType();
    }
    return *ST_TextShapeType::default_instance_;
}

const std::string ST_TextShapeType::TypeStrList[] =
{
    "textNoShape",
    "textPlain",
    "textStop",
    "textTriangle",
    "textTriangleInverted",
    "textChevron",
    "textChevronInverted",
    "textRingInside",
    "textRingOutside",
    "textArchUp",
    "textArchDown",
    "textCircle",
    "textButton",
    "textArchUpPour",
    "textArchDownPour",
    "textCirclePour",
    "textButtonPour",
    "textCurveUp",
    "textCurveDown",
    "textCanUp",
    "textCanDown",
    "textWave1",
    "textWave2",
    "textDoubleWave1",
    "textWave4",
    "textInflate",
    "textDeflate",
    "textInflateBottom",
    "textDeflateBottom",
    "textInflateTop",
    "textDeflateTop",
    "textDeflateInflate",
    "textDeflateInflateDeflate",
    "textFadeRight",
    "textFadeLeft",
    "textFadeUp",
    "textFadeDown",
    "textSlantUp",
    "textSlantDown",
    "textCascadeUp",
    "textCascadeDown"
};
ST_TextShapeType* ST_TextShapeType::default_instance_ = NULL;

// ST_GeomGuideName
ST_GeomGuideName::ST_GeomGuideName()
    :m_has_token(false),
     m_token("")
{
}
ST_GeomGuideName::ST_GeomGuideName(const XSD::token_& _token)
    :m_has_token(true)
{

    set_token(_token);
}
ST_GeomGuideName::~ST_GeomGuideName()
{
    clear();
}
bool ST_GeomGuideName::has_token() const
{
    return m_has_token;
}

void ST_GeomGuideName::set_token(const XSD::token_& _token)
{
    m_has_token = true;
    m_token = _token;
}

const XSD::token_& ST_GeomGuideName::get_token() const
{
    return m_token;
}

void ST_GeomGuideName::clear()
{
    m_has_token = false;
    m_token.clear();;
}

void ST_GeomGuideName::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_token)
    {
        _outStream << " " << _attrName << "=\"" << m_token << "\"";;
    }
}

const ST_GeomGuideName& ST_GeomGuideName::default_instance()
{
    if (!ST_GeomGuideName::default_instance_)
    {
        ST_GeomGuideName::default_instance_ = new ST_GeomGuideName();
    }
    return *ST_GeomGuideName::default_instance_;
}

std::string ST_GeomGuideName::toString() const
{
    std::stringstream strStream;
    strStream << get_token();
    return strStream.str();
}

ST_GeomGuideName* ST_GeomGuideName::default_instance_ = NULL;

// ST_GeomGuideFormula
ST_GeomGuideFormula::ST_GeomGuideFormula()
    :m_has_string(false),
     m_string("")
{
}
ST_GeomGuideFormula::ST_GeomGuideFormula(const XSD::string_& _string)
    :m_has_string(true)
{

    set_string(_string);
}
ST_GeomGuideFormula::~ST_GeomGuideFormula()
{
    clear();
}
bool ST_GeomGuideFormula::has_string() const
{
    return m_has_string;
}

void ST_GeomGuideFormula::set_string(const XSD::string_& _string)
{
    m_has_string = true;
    m_string = _string;
}

const XSD::string_& ST_GeomGuideFormula::get_string() const
{
    return m_string;
}

void ST_GeomGuideFormula::clear()
{
    m_has_string = false;
    m_string.clear();;
}

void ST_GeomGuideFormula::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_string)
    {
        _outStream << " " << _attrName << "=\"" << m_string << "\"";;
    }
}

const ST_GeomGuideFormula& ST_GeomGuideFormula::default_instance()
{
    if (!ST_GeomGuideFormula::default_instance_)
    {
        ST_GeomGuideFormula::default_instance_ = new ST_GeomGuideFormula();
    }
    return *ST_GeomGuideFormula::default_instance_;
}

std::string ST_GeomGuideFormula::toString() const
{
    std::stringstream strStream;
    strStream << get_string();
    return strStream.str();
}

ST_GeomGuideFormula* ST_GeomGuideFormula::default_instance_ = NULL;

// ST_AdjCoordinate
ST_AdjCoordinate::ST_AdjCoordinate()
    :m_has_ST_Coordinate(false),
     m_ST_Coordinate(NULL),
     m_has_ST_GeomGuideName(false),
     m_ST_GeomGuideName(NULL)
{
}
ST_AdjCoordinate::ST_AdjCoordinate(const ST_AdjCoordinate& _ST_AdjCoordinate)
    :m_has_ST_Coordinate(false),
     m_ST_Coordinate(NULL),
     m_has_ST_GeomGuideName(false),
     m_ST_GeomGuideName(NULL)
{

    m_has_ST_Coordinate = _ST_AdjCoordinate.has_ST_Coordinate();
    if (_ST_AdjCoordinate.has_ST_Coordinate())
    {
        m_ST_Coordinate = new ST_Coordinate(_ST_AdjCoordinate.get_ST_Coordinate());
    }


    m_has_ST_GeomGuideName = _ST_AdjCoordinate.has_ST_GeomGuideName();
    if (_ST_AdjCoordinate.has_ST_GeomGuideName())
    {
        m_ST_GeomGuideName = new ST_GeomGuideName(_ST_AdjCoordinate.get_ST_GeomGuideName());
    }
}
ST_AdjCoordinate::~ST_AdjCoordinate()
{
    clear();
}
bool ST_AdjCoordinate::has_ST_Coordinate() const
{
    return m_has_ST_Coordinate;
}

ST_Coordinate* ST_AdjCoordinate::mutable_ST_Coordinate()
{
    clear_ST_GeomGuideName();
    m_has_ST_Coordinate = true;
    if (!m_ST_Coordinate)
    {
        m_ST_Coordinate = new ST_Coordinate();
    }
    return m_ST_Coordinate;
}

const ST_Coordinate& ST_AdjCoordinate::get_ST_Coordinate() const
{
    if (m_ST_Coordinate)
    {
        return *m_ST_Coordinate;
    }
    return ST_Coordinate::default_instance();
}

void ST_AdjCoordinate::clear_ST_Coordinate()
{
    m_has_ST_Coordinate = false;
    if (m_ST_Coordinate)
    {
        delete m_ST_Coordinate;
        m_ST_Coordinate = NULL;
    }
}

bool ST_AdjCoordinate::has_ST_GeomGuideName() const
{
    return m_has_ST_GeomGuideName;
}

ST_GeomGuideName* ST_AdjCoordinate::mutable_ST_GeomGuideName()
{
    clear_ST_Coordinate();
    m_has_ST_GeomGuideName = true;
    if (!m_ST_GeomGuideName)
    {
        m_ST_GeomGuideName = new ST_GeomGuideName();
    }
    return m_ST_GeomGuideName;
}

const ST_GeomGuideName& ST_AdjCoordinate::get_ST_GeomGuideName() const
{
    if (m_ST_GeomGuideName)
    {
        return *m_ST_GeomGuideName;
    }
    return ST_GeomGuideName::default_instance();
}

void ST_AdjCoordinate::clear_ST_GeomGuideName()
{
    m_has_ST_GeomGuideName = false;
    if (m_ST_GeomGuideName)
    {
        delete m_ST_GeomGuideName;
        m_ST_GeomGuideName = NULL;
    }
}

std::string ST_AdjCoordinate::toString() const
{
    if (m_has_ST_Coordinate)
    {
        return m_ST_Coordinate->toString();
    }

    if (m_has_ST_GeomGuideName)
    {
        return m_ST_GeomGuideName->toString();
    }

    return string();
}

void ST_AdjCoordinate::clear()
{   clear_ST_Coordinate();
    clear_ST_GeomGuideName();
}

void ST_AdjCoordinate::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_ST_Coordinate)
    {
        m_ST_Coordinate->toXmlAttr(_attrName, _outStream);
        return;
    }

    if (m_has_ST_GeomGuideName)
    {
        m_ST_GeomGuideName->toXmlAttr(_attrName, _outStream);
        return;
    }
}

const ST_AdjCoordinate& ST_AdjCoordinate::default_instance()
{
    if (!ST_AdjCoordinate::default_instance_)
    {
        ST_AdjCoordinate::default_instance_ = new ST_AdjCoordinate();
    }
    return *ST_AdjCoordinate::default_instance_;
}

ST_AdjCoordinate* ST_AdjCoordinate::default_instance_ = NULL;

// ST_AdjAngle
ST_AdjAngle::ST_AdjAngle()
    :m_has_ST_Angle(false),
     m_ST_Angle(NULL),
     m_has_ST_GeomGuideName(false),
     m_ST_GeomGuideName(NULL)
{
}
ST_AdjAngle::ST_AdjAngle(const ST_AdjAngle& _ST_AdjAngle)
    :m_has_ST_Angle(false),
     m_ST_Angle(NULL),
     m_has_ST_GeomGuideName(false),
     m_ST_GeomGuideName(NULL)
{

    m_has_ST_Angle = _ST_AdjAngle.has_ST_Angle();
    if (_ST_AdjAngle.has_ST_Angle())
    {
        m_ST_Angle = new ST_Angle(_ST_AdjAngle.get_ST_Angle());
    }


    m_has_ST_GeomGuideName = _ST_AdjAngle.has_ST_GeomGuideName();
    if (_ST_AdjAngle.has_ST_GeomGuideName())
    {
        m_ST_GeomGuideName = new ST_GeomGuideName(_ST_AdjAngle.get_ST_GeomGuideName());
    }
}
ST_AdjAngle::~ST_AdjAngle()
{
    clear();
}
bool ST_AdjAngle::has_ST_Angle() const
{
    return m_has_ST_Angle;
}

ST_Angle* ST_AdjAngle::mutable_ST_Angle()
{
    clear_ST_GeomGuideName();
    m_has_ST_Angle = true;
    if (!m_ST_Angle)
    {
        m_ST_Angle = new ST_Angle();
    }
    return m_ST_Angle;
}

const ST_Angle& ST_AdjAngle::get_ST_Angle() const
{
    if (m_ST_Angle)
    {
        return *m_ST_Angle;
    }
    return ST_Angle::default_instance();
}

void ST_AdjAngle::clear_ST_Angle()
{
    m_has_ST_Angle = false;
    if (m_ST_Angle)
    {
        delete m_ST_Angle;
        m_ST_Angle = NULL;
    }
}

bool ST_AdjAngle::has_ST_GeomGuideName() const
{
    return m_has_ST_GeomGuideName;
}

ST_GeomGuideName* ST_AdjAngle::mutable_ST_GeomGuideName()
{
    clear_ST_Angle();
    m_has_ST_GeomGuideName = true;
    if (!m_ST_GeomGuideName)
    {
        m_ST_GeomGuideName = new ST_GeomGuideName();
    }
    return m_ST_GeomGuideName;
}

const ST_GeomGuideName& ST_AdjAngle::get_ST_GeomGuideName() const
{
    if (m_ST_GeomGuideName)
    {
        return *m_ST_GeomGuideName;
    }
    return ST_GeomGuideName::default_instance();
}

void ST_AdjAngle::clear_ST_GeomGuideName()
{
    m_has_ST_GeomGuideName = false;
    if (m_ST_GeomGuideName)
    {
        delete m_ST_GeomGuideName;
        m_ST_GeomGuideName = NULL;
    }
}

std::string ST_AdjAngle::toString() const
{
    if (m_has_ST_Angle)
    {
        return m_ST_Angle->toString();
    }

    if (m_has_ST_GeomGuideName)
    {
        return m_ST_GeomGuideName->toString();
    }

    return string();
}

void ST_AdjAngle::clear()
{   clear_ST_Angle();
    clear_ST_GeomGuideName();
}

void ST_AdjAngle::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_ST_Angle)
    {
        m_ST_Angle->toXmlAttr(_attrName, _outStream);
        return;
    }

    if (m_has_ST_GeomGuideName)
    {
        m_ST_GeomGuideName->toXmlAttr(_attrName, _outStream);
        return;
    }
}

const ST_AdjAngle& ST_AdjAngle::default_instance()
{
    if (!ST_AdjAngle::default_instance_)
    {
        ST_AdjAngle::default_instance_ = new ST_AdjAngle();
    }
    return *ST_AdjAngle::default_instance_;
}

ST_AdjAngle* ST_AdjAngle::default_instance_ = NULL;

// ST_PathFillMode
ST_PathFillMode::ST_PathFillMode()
    :m_has_type(false)
{
}
ST_PathFillMode::ST_PathFillMode(const ST_PathFillMode::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_PathFillMode::~ST_PathFillMode()
{
    clear();
}
bool ST_PathFillMode::has_type() const
{
    return m_has_type;
}

void ST_PathFillMode::set_type(const ST_PathFillMode::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_PathFillMode::Type& ST_PathFillMode::get_type() const
{
    return m_type;
}

std::string ST_PathFillMode::toString() const
{
    return ST_PathFillMode::TypeStrList[m_type];
}

void ST_PathFillMode::clear()
{
    m_has_type = false;
}

void ST_PathFillMode::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_PathFillMode& ST_PathFillMode::default_instance()
{
    if (!ST_PathFillMode::default_instance_)
    {
        ST_PathFillMode::default_instance_ = new ST_PathFillMode();
    }
    return *ST_PathFillMode::default_instance_;
}

const std::string ST_PathFillMode::TypeStrList[] =
{
    "none",
    "norm",
    "lighten",
    "lightenLess",
    "darken",
    "darkenLess"
};
ST_PathFillMode* ST_PathFillMode::default_instance_ = NULL;

// ST_LineEndType
ST_LineEndType::ST_LineEndType()
    :m_has_type(false)
{
}
ST_LineEndType::ST_LineEndType(const ST_LineEndType::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_LineEndType::~ST_LineEndType()
{
    clear();
}
bool ST_LineEndType::has_type() const
{
    return m_has_type;
}

void ST_LineEndType::set_type(const ST_LineEndType::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_LineEndType::Type& ST_LineEndType::get_type() const
{
    return m_type;
}

std::string ST_LineEndType::toString() const
{
    return ST_LineEndType::TypeStrList[m_type];
}

void ST_LineEndType::clear()
{
    m_has_type = false;
}

void ST_LineEndType::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_LineEndType& ST_LineEndType::default_instance()
{
    if (!ST_LineEndType::default_instance_)
    {
        ST_LineEndType::default_instance_ = new ST_LineEndType();
    }
    return *ST_LineEndType::default_instance_;
}

const std::string ST_LineEndType::TypeStrList[] =
{
    "none",
    "triangle",
    "stealth",
    "diamond",
    "oval",
    "arrow"
};
ST_LineEndType* ST_LineEndType::default_instance_ = NULL;

// ST_LineEndWidth
ST_LineEndWidth::ST_LineEndWidth()
    :m_has_type(false)
{
}
ST_LineEndWidth::ST_LineEndWidth(const ST_LineEndWidth::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_LineEndWidth::~ST_LineEndWidth()
{
    clear();
}
bool ST_LineEndWidth::has_type() const
{
    return m_has_type;
}

void ST_LineEndWidth::set_type(const ST_LineEndWidth::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_LineEndWidth::Type& ST_LineEndWidth::get_type() const
{
    return m_type;
}

std::string ST_LineEndWidth::toString() const
{
    return ST_LineEndWidth::TypeStrList[m_type];
}

void ST_LineEndWidth::clear()
{
    m_has_type = false;
}

void ST_LineEndWidth::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_LineEndWidth& ST_LineEndWidth::default_instance()
{
    if (!ST_LineEndWidth::default_instance_)
    {
        ST_LineEndWidth::default_instance_ = new ST_LineEndWidth();
    }
    return *ST_LineEndWidth::default_instance_;
}

const std::string ST_LineEndWidth::TypeStrList[] =
{
    "sm",
    "med",
    "lg"
};
ST_LineEndWidth* ST_LineEndWidth::default_instance_ = NULL;

// ST_LineEndLength
ST_LineEndLength::ST_LineEndLength()
    :m_has_type(false)
{
}
ST_LineEndLength::ST_LineEndLength(const ST_LineEndLength::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_LineEndLength::~ST_LineEndLength()
{
    clear();
}
bool ST_LineEndLength::has_type() const
{
    return m_has_type;
}

void ST_LineEndLength::set_type(const ST_LineEndLength::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_LineEndLength::Type& ST_LineEndLength::get_type() const
{
    return m_type;
}

std::string ST_LineEndLength::toString() const
{
    return ST_LineEndLength::TypeStrList[m_type];
}

void ST_LineEndLength::clear()
{
    m_has_type = false;
}

void ST_LineEndLength::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_LineEndLength& ST_LineEndLength::default_instance()
{
    if (!ST_LineEndLength::default_instance_)
    {
        ST_LineEndLength::default_instance_ = new ST_LineEndLength();
    }
    return *ST_LineEndLength::default_instance_;
}

const std::string ST_LineEndLength::TypeStrList[] =
{
    "sm",
    "med",
    "lg"
};
ST_LineEndLength* ST_LineEndLength::default_instance_ = NULL;

// ST_PresetLineDashVal
ST_PresetLineDashVal::ST_PresetLineDashVal()
    :m_has_type(false)
{
}
ST_PresetLineDashVal::ST_PresetLineDashVal(const ST_PresetLineDashVal::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_PresetLineDashVal::~ST_PresetLineDashVal()
{
    clear();
}
bool ST_PresetLineDashVal::has_type() const
{
    return m_has_type;
}

void ST_PresetLineDashVal::set_type(const ST_PresetLineDashVal::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_PresetLineDashVal::Type& ST_PresetLineDashVal::get_type() const
{
    return m_type;
}

std::string ST_PresetLineDashVal::toString() const
{
    return ST_PresetLineDashVal::TypeStrList[m_type];
}

void ST_PresetLineDashVal::clear()
{
    m_has_type = false;
}

void ST_PresetLineDashVal::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_PresetLineDashVal& ST_PresetLineDashVal::default_instance()
{
    if (!ST_PresetLineDashVal::default_instance_)
    {
        ST_PresetLineDashVal::default_instance_ = new ST_PresetLineDashVal();
    }
    return *ST_PresetLineDashVal::default_instance_;
}

const std::string ST_PresetLineDashVal::TypeStrList[] =
{
    "solid",
    "dot",
    "dash",
    "lgDash",
    "dashDot",
    "lgDashDot",
    "lgDashDotDot",
    "sysDash",
    "sysDot",
    "sysDashDot",
    "sysDashDotDot"
};
ST_PresetLineDashVal* ST_PresetLineDashVal::default_instance_ = NULL;

// ST_LineCap
ST_LineCap::ST_LineCap()
    :m_has_type(false)
{
}
ST_LineCap::ST_LineCap(const ST_LineCap::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_LineCap::~ST_LineCap()
{
    clear();
}
bool ST_LineCap::has_type() const
{
    return m_has_type;
}

void ST_LineCap::set_type(const ST_LineCap::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_LineCap::Type& ST_LineCap::get_type() const
{
    return m_type;
}

std::string ST_LineCap::toString() const
{
    return ST_LineCap::TypeStrList[m_type];
}

void ST_LineCap::clear()
{
    m_has_type = false;
}

void ST_LineCap::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_LineCap& ST_LineCap::default_instance()
{
    if (!ST_LineCap::default_instance_)
    {
        ST_LineCap::default_instance_ = new ST_LineCap();
    }
    return *ST_LineCap::default_instance_;
}

const std::string ST_LineCap::TypeStrList[] =
{
    "rnd",
    "sq",
    "flat"
};
ST_LineCap* ST_LineCap::default_instance_ = NULL;

// ST_LineWidth
ST_LineWidth::ST_LineWidth()

{
}
ST_LineWidth::ST_LineWidth(const ST_Coordinate32Unqualified& _ST_Coordinate32Unqualified)
    :ST_Coordinate32Unqualified(_ST_Coordinate32Unqualified)
{
}
ST_LineWidth::~ST_LineWidth()
{
    clear();
}
const ST_LineWidth& ST_LineWidth::default_instance()
{
    if (!ST_LineWidth::default_instance_)
    {
        ST_LineWidth::default_instance_ = new ST_LineWidth();
    }
    return *ST_LineWidth::default_instance_;
}

ST_LineWidth* ST_LineWidth::default_instance_ = NULL;

// ST_PenAlignment
ST_PenAlignment::ST_PenAlignment()
    :m_has_type(false)
{
}
ST_PenAlignment::ST_PenAlignment(const ST_PenAlignment::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_PenAlignment::~ST_PenAlignment()
{
    clear();
}
bool ST_PenAlignment::has_type() const
{
    return m_has_type;
}

void ST_PenAlignment::set_type(const ST_PenAlignment::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_PenAlignment::Type& ST_PenAlignment::get_type() const
{
    return m_type;
}

std::string ST_PenAlignment::toString() const
{
    return ST_PenAlignment::TypeStrList[m_type];
}

void ST_PenAlignment::clear()
{
    m_has_type = false;
}

void ST_PenAlignment::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_PenAlignment& ST_PenAlignment::default_instance()
{
    if (!ST_PenAlignment::default_instance_)
    {
        ST_PenAlignment::default_instance_ = new ST_PenAlignment();
    }
    return *ST_PenAlignment::default_instance_;
}

const std::string ST_PenAlignment::TypeStrList[] =
{
    "ctr",
    "in"
};
ST_PenAlignment* ST_PenAlignment::default_instance_ = NULL;

// ST_CompoundLine
ST_CompoundLine::ST_CompoundLine()
    :m_has_type(false)
{
}
ST_CompoundLine::ST_CompoundLine(const ST_CompoundLine::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_CompoundLine::~ST_CompoundLine()
{
    clear();
}
bool ST_CompoundLine::has_type() const
{
    return m_has_type;
}

void ST_CompoundLine::set_type(const ST_CompoundLine::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_CompoundLine::Type& ST_CompoundLine::get_type() const
{
    return m_type;
}

std::string ST_CompoundLine::toString() const
{
    return ST_CompoundLine::TypeStrList[m_type];
}

void ST_CompoundLine::clear()
{
    m_has_type = false;
}

void ST_CompoundLine::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_CompoundLine& ST_CompoundLine::default_instance()
{
    if (!ST_CompoundLine::default_instance_)
    {
        ST_CompoundLine::default_instance_ = new ST_CompoundLine();
    }
    return *ST_CompoundLine::default_instance_;
}

const std::string ST_CompoundLine::TypeStrList[] =
{
    "sng",
    "dbl",
    "thickThin",
    "thinThick",
    "tri"
};
ST_CompoundLine* ST_CompoundLine::default_instance_ = NULL;

// ST_ShapeID
ST_ShapeID::ST_ShapeID()
    :m_has_token(false),
     m_token("")
{
}
ST_ShapeID::ST_ShapeID(const XSD::token_& _token)
    :m_has_token(true)
{

    set_token(_token);
}
ST_ShapeID::~ST_ShapeID()
{
    clear();
}
bool ST_ShapeID::has_token() const
{
    return m_has_token;
}

void ST_ShapeID::set_token(const XSD::token_& _token)
{
    m_has_token = true;
    m_token = _token;
}

const XSD::token_& ST_ShapeID::get_token() const
{
    return m_token;
}

void ST_ShapeID::clear()
{
    m_has_token = false;
    m_token.clear();;
}

void ST_ShapeID::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_token)
    {
        _outStream << " " << _attrName << "=\"" << m_token << "\"";;
    }
}

const ST_ShapeID& ST_ShapeID::default_instance()
{
    if (!ST_ShapeID::default_instance_)
    {
        ST_ShapeID::default_instance_ = new ST_ShapeID();
    }
    return *ST_ShapeID::default_instance_;
}

std::string ST_ShapeID::toString() const
{
    std::stringstream strStream;
    strStream << get_token();
    return strStream.str();
}

ST_ShapeID* ST_ShapeID::default_instance_ = NULL;

// ST_OnOffStyleType
ST_OnOffStyleType::ST_OnOffStyleType()
    :m_has_type(false)
{
}
ST_OnOffStyleType::ST_OnOffStyleType(const ST_OnOffStyleType::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_OnOffStyleType::~ST_OnOffStyleType()
{
    clear();
}
bool ST_OnOffStyleType::has_type() const
{
    return m_has_type;
}

void ST_OnOffStyleType::set_type(const ST_OnOffStyleType::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_OnOffStyleType::Type& ST_OnOffStyleType::get_type() const
{
    return m_type;
}

std::string ST_OnOffStyleType::toString() const
{
    return ST_OnOffStyleType::TypeStrList[m_type];
}

void ST_OnOffStyleType::clear()
{
    m_has_type = false;
}

void ST_OnOffStyleType::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_OnOffStyleType& ST_OnOffStyleType::default_instance()
{
    if (!ST_OnOffStyleType::default_instance_)
    {
        ST_OnOffStyleType::default_instance_ = new ST_OnOffStyleType();
    }
    return *ST_OnOffStyleType::default_instance_;
}

const std::string ST_OnOffStyleType::TypeStrList[] =
{
    "on",
    "off",
    "def"
};
ST_OnOffStyleType* ST_OnOffStyleType::default_instance_ = NULL;

// ST_TextAnchoringType
ST_TextAnchoringType::ST_TextAnchoringType()
    :m_has_type(false)
{
}
ST_TextAnchoringType::ST_TextAnchoringType(const ST_TextAnchoringType::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_TextAnchoringType::~ST_TextAnchoringType()
{
    clear();
}
bool ST_TextAnchoringType::has_type() const
{
    return m_has_type;
}

void ST_TextAnchoringType::set_type(const ST_TextAnchoringType::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_TextAnchoringType::Type& ST_TextAnchoringType::get_type() const
{
    return m_type;
}

std::string ST_TextAnchoringType::toString() const
{
    return ST_TextAnchoringType::TypeStrList[m_type];
}

void ST_TextAnchoringType::clear()
{
    m_has_type = false;
}

void ST_TextAnchoringType::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_TextAnchoringType& ST_TextAnchoringType::default_instance()
{
    if (!ST_TextAnchoringType::default_instance_)
    {
        ST_TextAnchoringType::default_instance_ = new ST_TextAnchoringType();
    }
    return *ST_TextAnchoringType::default_instance_;
}

const std::string ST_TextAnchoringType::TypeStrList[] =
{
    "t",
    "ctr",
    "b",
    "just",
    "dist"
};
ST_TextAnchoringType* ST_TextAnchoringType::default_instance_ = NULL;

// ST_TextVertOverflowType
ST_TextVertOverflowType::ST_TextVertOverflowType()
    :m_has_type(false)
{
}
ST_TextVertOverflowType::ST_TextVertOverflowType(const ST_TextVertOverflowType::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_TextVertOverflowType::~ST_TextVertOverflowType()
{
    clear();
}
bool ST_TextVertOverflowType::has_type() const
{
    return m_has_type;
}

void ST_TextVertOverflowType::set_type(const ST_TextVertOverflowType::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_TextVertOverflowType::Type& ST_TextVertOverflowType::get_type() const
{
    return m_type;
}

std::string ST_TextVertOverflowType::toString() const
{
    return ST_TextVertOverflowType::TypeStrList[m_type];
}

void ST_TextVertOverflowType::clear()
{
    m_has_type = false;
}

void ST_TextVertOverflowType::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_TextVertOverflowType& ST_TextVertOverflowType::default_instance()
{
    if (!ST_TextVertOverflowType::default_instance_)
    {
        ST_TextVertOverflowType::default_instance_ = new ST_TextVertOverflowType();
    }
    return *ST_TextVertOverflowType::default_instance_;
}

const std::string ST_TextVertOverflowType::TypeStrList[] =
{
    "overflow",
    "ellipsis",
    "clip"
};
ST_TextVertOverflowType* ST_TextVertOverflowType::default_instance_ = NULL;

// ST_TextHorzOverflowType
ST_TextHorzOverflowType::ST_TextHorzOverflowType()
    :m_has_type(false)
{
}
ST_TextHorzOverflowType::ST_TextHorzOverflowType(const ST_TextHorzOverflowType::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_TextHorzOverflowType::~ST_TextHorzOverflowType()
{
    clear();
}
bool ST_TextHorzOverflowType::has_type() const
{
    return m_has_type;
}

void ST_TextHorzOverflowType::set_type(const ST_TextHorzOverflowType::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_TextHorzOverflowType::Type& ST_TextHorzOverflowType::get_type() const
{
    return m_type;
}

std::string ST_TextHorzOverflowType::toString() const
{
    return ST_TextHorzOverflowType::TypeStrList[m_type];
}

void ST_TextHorzOverflowType::clear()
{
    m_has_type = false;
}

void ST_TextHorzOverflowType::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_TextHorzOverflowType& ST_TextHorzOverflowType::default_instance()
{
    if (!ST_TextHorzOverflowType::default_instance_)
    {
        ST_TextHorzOverflowType::default_instance_ = new ST_TextHorzOverflowType();
    }
    return *ST_TextHorzOverflowType::default_instance_;
}

const std::string ST_TextHorzOverflowType::TypeStrList[] =
{
    "overflow",
    "clip"
};
ST_TextHorzOverflowType* ST_TextHorzOverflowType::default_instance_ = NULL;

// ST_TextVerticalType
ST_TextVerticalType::ST_TextVerticalType()
    :m_has_type(false)
{
}
ST_TextVerticalType::ST_TextVerticalType(const ST_TextVerticalType::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_TextVerticalType::~ST_TextVerticalType()
{
    clear();
}
bool ST_TextVerticalType::has_type() const
{
    return m_has_type;
}

void ST_TextVerticalType::set_type(const ST_TextVerticalType::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_TextVerticalType::Type& ST_TextVerticalType::get_type() const
{
    return m_type;
}

std::string ST_TextVerticalType::toString() const
{
    return ST_TextVerticalType::TypeStrList[m_type];
}

void ST_TextVerticalType::clear()
{
    m_has_type = false;
}

void ST_TextVerticalType::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_TextVerticalType& ST_TextVerticalType::default_instance()
{
    if (!ST_TextVerticalType::default_instance_)
    {
        ST_TextVerticalType::default_instance_ = new ST_TextVerticalType();
    }
    return *ST_TextVerticalType::default_instance_;
}

const std::string ST_TextVerticalType::TypeStrList[] =
{
    "horz",
    "vert",
    "vert270",
    "wordArtVert",
    "eaVert",
    "mongolianVert",
    "wordArtVertRtl"
};
ST_TextVerticalType* ST_TextVerticalType::default_instance_ = NULL;

// ST_TextWrappingType
ST_TextWrappingType::ST_TextWrappingType()
    :m_has_type(false)
{
}
ST_TextWrappingType::ST_TextWrappingType(const ST_TextWrappingType::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_TextWrappingType::~ST_TextWrappingType()
{
    clear();
}
bool ST_TextWrappingType::has_type() const
{
    return m_has_type;
}

void ST_TextWrappingType::set_type(const ST_TextWrappingType::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_TextWrappingType::Type& ST_TextWrappingType::get_type() const
{
    return m_type;
}

std::string ST_TextWrappingType::toString() const
{
    return ST_TextWrappingType::TypeStrList[m_type];
}

void ST_TextWrappingType::clear()
{
    m_has_type = false;
}

void ST_TextWrappingType::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_TextWrappingType& ST_TextWrappingType::default_instance()
{
    if (!ST_TextWrappingType::default_instance_)
    {
        ST_TextWrappingType::default_instance_ = new ST_TextWrappingType();
    }
    return *ST_TextWrappingType::default_instance_;
}

const std::string ST_TextWrappingType::TypeStrList[] =
{
    "none",
    "square"
};
ST_TextWrappingType* ST_TextWrappingType::default_instance_ = NULL;

// ST_TextColumnCount
ST_TextColumnCount::ST_TextColumnCount()
    :m_has_int(false),
     m_int(0)
{
}
ST_TextColumnCount::ST_TextColumnCount(const XSD::int_& _int)
    :m_has_int(true)
{

    set_int(_int);
}
ST_TextColumnCount::~ST_TextColumnCount()
{
    clear();
}
bool ST_TextColumnCount::has_int() const
{
    return m_has_int;
}

void ST_TextColumnCount::set_int(const XSD::int_& _int)
{   assert(1 <= _int);
    assert(_int <= 16);

    m_has_int = true;
    m_int = _int;
}

const XSD::int_& ST_TextColumnCount::get_int() const
{
    return m_int;
}

void ST_TextColumnCount::clear()
{
    m_has_int = false;
    m_int = 0;;
}

void ST_TextColumnCount::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_int)
    {
        _outStream << " " << _attrName << "=\"" << m_int << "\"";;
    }
}

const ST_TextColumnCount& ST_TextColumnCount::default_instance()
{
    if (!ST_TextColumnCount::default_instance_)
    {
        ST_TextColumnCount::default_instance_ = new ST_TextColumnCount();
    }
    return *ST_TextColumnCount::default_instance_;
}

std::string ST_TextColumnCount::toString() const
{
    std::stringstream strStream;
    strStream << get_int();
    return strStream.str();
}

ST_TextColumnCount* ST_TextColumnCount::default_instance_ = NULL;

// ST_TextFontScalePercentOrPercentString
ST_TextFontScalePercentOrPercentString::ST_TextFontScalePercentOrPercentString()
    :m_has_ST_TextFontScalePercent(false),
     m_ST_TextFontScalePercent(NULL),
     m_has_ST_Percentage(false),
     m_ST_Percentage(NULL)
{
}
ST_TextFontScalePercentOrPercentString::ST_TextFontScalePercentOrPercentString(const ST_TextFontScalePercentOrPercentString& _ST_TextFontScalePercentOrPercentString)
    :m_has_ST_TextFontScalePercent(false),
     m_ST_TextFontScalePercent(NULL),
     m_has_ST_Percentage(false),
     m_ST_Percentage(NULL)
{

    m_has_ST_TextFontScalePercent = _ST_TextFontScalePercentOrPercentString.has_ST_TextFontScalePercent();
    if (_ST_TextFontScalePercentOrPercentString.has_ST_TextFontScalePercent())
    {
        m_ST_TextFontScalePercent = new ST_TextFontScalePercent(_ST_TextFontScalePercentOrPercentString.get_ST_TextFontScalePercent());
    }


    m_has_ST_Percentage = _ST_TextFontScalePercentOrPercentString.has_ST_Percentage();
    if (_ST_TextFontScalePercentOrPercentString.has_ST_Percentage())
    {
        m_ST_Percentage = new ns_s::ST_Percentage(_ST_TextFontScalePercentOrPercentString.get_ST_Percentage());
    }
}
ST_TextFontScalePercentOrPercentString::~ST_TextFontScalePercentOrPercentString()
{
    clear();
}
bool ST_TextFontScalePercentOrPercentString::has_ST_TextFontScalePercent() const
{
    return m_has_ST_TextFontScalePercent;
}

ST_TextFontScalePercent* ST_TextFontScalePercentOrPercentString::mutable_ST_TextFontScalePercent()
{
    clear_ST_Percentage();
    m_has_ST_TextFontScalePercent = true;
    if (!m_ST_TextFontScalePercent)
    {
        m_ST_TextFontScalePercent = new ST_TextFontScalePercent();
    }
    return m_ST_TextFontScalePercent;
}

const ST_TextFontScalePercent& ST_TextFontScalePercentOrPercentString::get_ST_TextFontScalePercent() const
{
    if (m_ST_TextFontScalePercent)
    {
        return *m_ST_TextFontScalePercent;
    }
    return ST_TextFontScalePercent::default_instance();
}

void ST_TextFontScalePercentOrPercentString::clear_ST_TextFontScalePercent()
{
    m_has_ST_TextFontScalePercent = false;
    if (m_ST_TextFontScalePercent)
    {
        delete m_ST_TextFontScalePercent;
        m_ST_TextFontScalePercent = NULL;
    }
}

bool ST_TextFontScalePercentOrPercentString::has_ST_Percentage() const
{
    return m_has_ST_Percentage;
}

ns_s::ST_Percentage* ST_TextFontScalePercentOrPercentString::mutable_ST_Percentage()
{
    clear_ST_TextFontScalePercent();
    m_has_ST_Percentage = true;
    if (!m_ST_Percentage)
    {
        m_ST_Percentage = new ns_s::ST_Percentage();
    }
    return m_ST_Percentage;
}

const ns_s::ST_Percentage& ST_TextFontScalePercentOrPercentString::get_ST_Percentage() const
{
    if (m_ST_Percentage)
    {
        return *m_ST_Percentage;
    }
    return ns_s::ST_Percentage::default_instance();
}

void ST_TextFontScalePercentOrPercentString::clear_ST_Percentage()
{
    m_has_ST_Percentage = false;
    if (m_ST_Percentage)
    {
        delete m_ST_Percentage;
        m_ST_Percentage = NULL;
    }
}

std::string ST_TextFontScalePercentOrPercentString::toString() const
{
    if (m_has_ST_TextFontScalePercent)
    {
        return m_ST_TextFontScalePercent->toString();
    }

    if (m_has_ST_Percentage)
    {
        return m_ST_Percentage->toString();
    }

    return string();
}

void ST_TextFontScalePercentOrPercentString::clear()
{   clear_ST_TextFontScalePercent();
    clear_ST_Percentage();
}

void ST_TextFontScalePercentOrPercentString::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_ST_TextFontScalePercent)
    {
        m_ST_TextFontScalePercent->toXmlAttr(_attrName, _outStream);
        return;
    }

    if (m_has_ST_Percentage)
    {
        m_ST_Percentage->toXmlAttr(_attrName, _outStream);
        return;
    }
}

const ST_TextFontScalePercentOrPercentString& ST_TextFontScalePercentOrPercentString::default_instance()
{
    if (!ST_TextFontScalePercentOrPercentString::default_instance_)
    {
        ST_TextFontScalePercentOrPercentString::default_instance_ = new ST_TextFontScalePercentOrPercentString();
    }
    return *ST_TextFontScalePercentOrPercentString::default_instance_;
}

ST_TextFontScalePercentOrPercentString* ST_TextFontScalePercentOrPercentString::default_instance_ = NULL;

// ST_TextFontScalePercent
ST_TextFontScalePercent::ST_TextFontScalePercent()

{
}
ST_TextFontScalePercent::ST_TextFontScalePercent(const ST_PercentageDecimal& _ST_PercentageDecimal)
    :ST_PercentageDecimal(_ST_PercentageDecimal)
{
}
ST_TextFontScalePercent::~ST_TextFontScalePercent()
{
    clear();
}
const ST_TextFontScalePercent& ST_TextFontScalePercent::default_instance()
{
    if (!ST_TextFontScalePercent::default_instance_)
    {
        ST_TextFontScalePercent::default_instance_ = new ST_TextFontScalePercent();
    }
    return *ST_TextFontScalePercent::default_instance_;
}

ST_TextFontScalePercent* ST_TextFontScalePercent::default_instance_ = NULL;

// ST_TextBulletStartAtNum
ST_TextBulletStartAtNum::ST_TextBulletStartAtNum()
    :m_has_int(false),
     m_int(0)
{
}
ST_TextBulletStartAtNum::ST_TextBulletStartAtNum(const XSD::int_& _int)
    :m_has_int(true)
{

    set_int(_int);
}
ST_TextBulletStartAtNum::~ST_TextBulletStartAtNum()
{
    clear();
}
bool ST_TextBulletStartAtNum::has_int() const
{
    return m_has_int;
}

void ST_TextBulletStartAtNum::set_int(const XSD::int_& _int)
{   assert(1 <= _int);
    assert(_int <= 32767);

    m_has_int = true;
    m_int = _int;
}

const XSD::int_& ST_TextBulletStartAtNum::get_int() const
{
    return m_int;
}

void ST_TextBulletStartAtNum::clear()
{
    m_has_int = false;
    m_int = 0;;
}

void ST_TextBulletStartAtNum::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_int)
    {
        _outStream << " " << _attrName << "=\"" << m_int << "\"";;
    }
}

const ST_TextBulletStartAtNum& ST_TextBulletStartAtNum::default_instance()
{
    if (!ST_TextBulletStartAtNum::default_instance_)
    {
        ST_TextBulletStartAtNum::default_instance_ = new ST_TextBulletStartAtNum();
    }
    return *ST_TextBulletStartAtNum::default_instance_;
}

std::string ST_TextBulletStartAtNum::toString() const
{
    std::stringstream strStream;
    strStream << get_int();
    return strStream.str();
}

ST_TextBulletStartAtNum* ST_TextBulletStartAtNum::default_instance_ = NULL;

// ST_TextAutonumberScheme
ST_TextAutonumberScheme::ST_TextAutonumberScheme()
    :m_has_type(false)
{
}
ST_TextAutonumberScheme::ST_TextAutonumberScheme(const ST_TextAutonumberScheme::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_TextAutonumberScheme::~ST_TextAutonumberScheme()
{
    clear();
}
bool ST_TextAutonumberScheme::has_type() const
{
    return m_has_type;
}

void ST_TextAutonumberScheme::set_type(const ST_TextAutonumberScheme::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_TextAutonumberScheme::Type& ST_TextAutonumberScheme::get_type() const
{
    return m_type;
}

std::string ST_TextAutonumberScheme::toString() const
{
    return ST_TextAutonumberScheme::TypeStrList[m_type];
}

void ST_TextAutonumberScheme::clear()
{
    m_has_type = false;
}

void ST_TextAutonumberScheme::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_TextAutonumberScheme& ST_TextAutonumberScheme::default_instance()
{
    if (!ST_TextAutonumberScheme::default_instance_)
    {
        ST_TextAutonumberScheme::default_instance_ = new ST_TextAutonumberScheme();
    }
    return *ST_TextAutonumberScheme::default_instance_;
}

const std::string ST_TextAutonumberScheme::TypeStrList[] =
{
    "alphaLcParenBoth",
    "alphaUcParenBoth",
    "alphaLcParenR",
    "alphaUcParenR",
    "alphaLcPeriod",
    "alphaUcPeriod",
    "arabicParenBoth",
    "arabicParenR",
    "arabicPeriod",
    "arabicPlain",
    "romanLcParenBoth",
    "romanUcParenBoth",
    "romanLcParenR",
    "romanUcParenR",
    "romanLcPeriod",
    "romanUcPeriod",
    "circleNumDbPlain",
    "circleNumWdBlackPlain",
    "circleNumWdWhitePlain",
    "arabicDbPeriod",
    "arabicDbPlain",
    "ea1ChsPeriod",
    "ea1ChsPlain",
    "ea1ChtPeriod",
    "ea1ChtPlain",
    "ea1JpnChsDbPeriod",
    "ea1JpnKorPlain",
    "ea1JpnKorPeriod",
    "arabic1Minus",
    "arabic2Minus",
    "hebrew2Minus",
    "thaiAlphaPeriod",
    "thaiAlphaParenR",
    "thaiAlphaParenBoth",
    "thaiNumPeriod",
    "thaiNumParenR",
    "thaiNumParenBoth",
    "hindiAlphaPeriod",
    "hindiNumPeriod",
    "hindiNumParenR",
    "hindiAlpha1Period"
};
ST_TextAutonumberScheme* ST_TextAutonumberScheme::default_instance_ = NULL;

// ST_TextBulletSize
ST_TextBulletSize::ST_TextBulletSize()
    :m_has_ST_TextBulletSizePercent(false),
     m_ST_TextBulletSizePercent(NULL),
     m_has_ST_TextBulletSizeDecimal(false),
     m_ST_TextBulletSizeDecimal(NULL)
{
}
ST_TextBulletSize::ST_TextBulletSize(const ST_TextBulletSize& _ST_TextBulletSize)
    :m_has_ST_TextBulletSizePercent(false),
     m_ST_TextBulletSizePercent(NULL),
     m_has_ST_TextBulletSizeDecimal(false),
     m_ST_TextBulletSizeDecimal(NULL)
{

    m_has_ST_TextBulletSizePercent = _ST_TextBulletSize.has_ST_TextBulletSizePercent();
    if (_ST_TextBulletSize.has_ST_TextBulletSizePercent())
    {
        m_ST_TextBulletSizePercent = new ST_TextBulletSizePercent(_ST_TextBulletSize.get_ST_TextBulletSizePercent());
    }


    m_has_ST_TextBulletSizeDecimal = _ST_TextBulletSize.has_ST_TextBulletSizeDecimal();
    if (_ST_TextBulletSize.has_ST_TextBulletSizeDecimal())
    {
        m_ST_TextBulletSizeDecimal = new ST_TextBulletSizeDecimal(_ST_TextBulletSize.get_ST_TextBulletSizeDecimal());
    }
}
ST_TextBulletSize::~ST_TextBulletSize()
{
    clear();
}
bool ST_TextBulletSize::has_ST_TextBulletSizePercent() const
{
    return m_has_ST_TextBulletSizePercent;
}

ST_TextBulletSizePercent* ST_TextBulletSize::mutable_ST_TextBulletSizePercent()
{
    clear_ST_TextBulletSizeDecimal();
    m_has_ST_TextBulletSizePercent = true;
    if (!m_ST_TextBulletSizePercent)
    {
        m_ST_TextBulletSizePercent = new ST_TextBulletSizePercent();
    }
    return m_ST_TextBulletSizePercent;
}

const ST_TextBulletSizePercent& ST_TextBulletSize::get_ST_TextBulletSizePercent() const
{
    if (m_ST_TextBulletSizePercent)
    {
        return *m_ST_TextBulletSizePercent;
    }
    return ST_TextBulletSizePercent::default_instance();
}

void ST_TextBulletSize::clear_ST_TextBulletSizePercent()
{
    m_has_ST_TextBulletSizePercent = false;
    if (m_ST_TextBulletSizePercent)
    {
        delete m_ST_TextBulletSizePercent;
        m_ST_TextBulletSizePercent = NULL;
    }
}

bool ST_TextBulletSize::has_ST_TextBulletSizeDecimal() const
{
    return m_has_ST_TextBulletSizeDecimal;
}

ST_TextBulletSizeDecimal* ST_TextBulletSize::mutable_ST_TextBulletSizeDecimal()
{
    clear_ST_TextBulletSizePercent();
    m_has_ST_TextBulletSizeDecimal = true;
    if (!m_ST_TextBulletSizeDecimal)
    {
        m_ST_TextBulletSizeDecimal = new ST_TextBulletSizeDecimal();
    }
    return m_ST_TextBulletSizeDecimal;
}

const ST_TextBulletSizeDecimal& ST_TextBulletSize::get_ST_TextBulletSizeDecimal() const
{
    if (m_ST_TextBulletSizeDecimal)
    {
        return *m_ST_TextBulletSizeDecimal;
    }
    return ST_TextBulletSizeDecimal::default_instance();
}

void ST_TextBulletSize::clear_ST_TextBulletSizeDecimal()
{
    m_has_ST_TextBulletSizeDecimal = false;
    if (m_ST_TextBulletSizeDecimal)
    {
        delete m_ST_TextBulletSizeDecimal;
        m_ST_TextBulletSizeDecimal = NULL;
    }
}

std::string ST_TextBulletSize::toString() const
{
    if (m_has_ST_TextBulletSizePercent)
    {
        return m_ST_TextBulletSizePercent->toString();
    }

    if (m_has_ST_TextBulletSizeDecimal)
    {
        return m_ST_TextBulletSizeDecimal->toString();
    }

    return string();
}

void ST_TextBulletSize::clear()
{   clear_ST_TextBulletSizePercent();
    clear_ST_TextBulletSizeDecimal();
}

void ST_TextBulletSize::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_ST_TextBulletSizePercent)
    {
        m_ST_TextBulletSizePercent->toXmlAttr(_attrName, _outStream);
        return;
    }

    if (m_has_ST_TextBulletSizeDecimal)
    {
        m_ST_TextBulletSizeDecimal->toXmlAttr(_attrName, _outStream);
        return;
    }
}

const ST_TextBulletSize& ST_TextBulletSize::default_instance()
{
    if (!ST_TextBulletSize::default_instance_)
    {
        ST_TextBulletSize::default_instance_ = new ST_TextBulletSize();
    }
    return *ST_TextBulletSize::default_instance_;
}

ST_TextBulletSize* ST_TextBulletSize::default_instance_ = NULL;

// ST_TextBulletSizePercent
ST_TextBulletSizePercent::ST_TextBulletSizePercent()
    :m_has_string(false),
     m_string("")
{
}
ST_TextBulletSizePercent::ST_TextBulletSizePercent(const XSD::string_& _string)
    :m_has_string(true)
{

    set_string(_string);
}
ST_TextBulletSizePercent::~ST_TextBulletSizePercent()
{
    clear();
}
bool ST_TextBulletSizePercent::has_string() const
{
    return m_has_string;
}

void ST_TextBulletSizePercent::set_string(const XSD::string_& _string)
{
    m_has_string = true;
    m_string = _string;
}

const XSD::string_& ST_TextBulletSizePercent::get_string() const
{
    return m_string;
}

void ST_TextBulletSizePercent::clear()
{
    m_has_string = false;
    m_string.clear();;
}

void ST_TextBulletSizePercent::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_string)
    {
        _outStream << " " << _attrName << "=\"" << m_string << "\"";;
    }
}

const ST_TextBulletSizePercent& ST_TextBulletSizePercent::default_instance()
{
    if (!ST_TextBulletSizePercent::default_instance_)
    {
        ST_TextBulletSizePercent::default_instance_ = new ST_TextBulletSizePercent();
    }
    return *ST_TextBulletSizePercent::default_instance_;
}

std::string ST_TextBulletSizePercent::toString() const
{
    std::stringstream strStream;
    strStream << get_string();
    return strStream.str();
}

ST_TextBulletSizePercent* ST_TextBulletSizePercent::default_instance_ = NULL;

// ST_TextBulletSizeDecimal
ST_TextBulletSizeDecimal::ST_TextBulletSizeDecimal()

{
}
ST_TextBulletSizeDecimal::ST_TextBulletSizeDecimal(const ST_PercentageDecimal& _ST_PercentageDecimal)
    :ST_PercentageDecimal(_ST_PercentageDecimal)
{
}
ST_TextBulletSizeDecimal::~ST_TextBulletSizeDecimal()
{
    clear();
}
const ST_TextBulletSizeDecimal& ST_TextBulletSizeDecimal::default_instance()
{
    if (!ST_TextBulletSizeDecimal::default_instance_)
    {
        ST_TextBulletSizeDecimal::default_instance_ = new ST_TextBulletSizeDecimal();
    }
    return *ST_TextBulletSizeDecimal::default_instance_;
}

ST_TextBulletSizeDecimal* ST_TextBulletSizeDecimal::default_instance_ = NULL;

// ST_TextPoint
ST_TextPoint::ST_TextPoint()
    :m_has_ST_TextPointUnqualified(false),
     m_ST_TextPointUnqualified(NULL),
     m_has_ST_UniversalMeasure(false),
     m_ST_UniversalMeasure(NULL)
{
}
ST_TextPoint::ST_TextPoint(const ST_TextPoint& _ST_TextPoint)
    :m_has_ST_TextPointUnqualified(false),
     m_ST_TextPointUnqualified(NULL),
     m_has_ST_UniversalMeasure(false),
     m_ST_UniversalMeasure(NULL)
{

    m_has_ST_TextPointUnqualified = _ST_TextPoint.has_ST_TextPointUnqualified();
    if (_ST_TextPoint.has_ST_TextPointUnqualified())
    {
        m_ST_TextPointUnqualified = new ST_TextPointUnqualified(_ST_TextPoint.get_ST_TextPointUnqualified());
    }


    m_has_ST_UniversalMeasure = _ST_TextPoint.has_ST_UniversalMeasure();
    if (_ST_TextPoint.has_ST_UniversalMeasure())
    {
        m_ST_UniversalMeasure = new ns_s::ST_UniversalMeasure(_ST_TextPoint.get_ST_UniversalMeasure());
    }
}
ST_TextPoint::~ST_TextPoint()
{
    clear();
}
bool ST_TextPoint::has_ST_TextPointUnqualified() const
{
    return m_has_ST_TextPointUnqualified;
}

ST_TextPointUnqualified* ST_TextPoint::mutable_ST_TextPointUnqualified()
{
    clear_ST_UniversalMeasure();
    m_has_ST_TextPointUnqualified = true;
    if (!m_ST_TextPointUnqualified)
    {
        m_ST_TextPointUnqualified = new ST_TextPointUnqualified();
    }
    return m_ST_TextPointUnqualified;
}

const ST_TextPointUnqualified& ST_TextPoint::get_ST_TextPointUnqualified() const
{
    if (m_ST_TextPointUnqualified)
    {
        return *m_ST_TextPointUnqualified;
    }
    return ST_TextPointUnqualified::default_instance();
}

void ST_TextPoint::clear_ST_TextPointUnqualified()
{
    m_has_ST_TextPointUnqualified = false;
    if (m_ST_TextPointUnqualified)
    {
        delete m_ST_TextPointUnqualified;
        m_ST_TextPointUnqualified = NULL;
    }
}

bool ST_TextPoint::has_ST_UniversalMeasure() const
{
    return m_has_ST_UniversalMeasure;
}

ns_s::ST_UniversalMeasure* ST_TextPoint::mutable_ST_UniversalMeasure()
{
    clear_ST_TextPointUnqualified();
    m_has_ST_UniversalMeasure = true;
    if (!m_ST_UniversalMeasure)
    {
        m_ST_UniversalMeasure = new ns_s::ST_UniversalMeasure();
    }
    return m_ST_UniversalMeasure;
}

const ns_s::ST_UniversalMeasure& ST_TextPoint::get_ST_UniversalMeasure() const
{
    if (m_ST_UniversalMeasure)
    {
        return *m_ST_UniversalMeasure;
    }
    return ns_s::ST_UniversalMeasure::default_instance();
}

void ST_TextPoint::clear_ST_UniversalMeasure()
{
    m_has_ST_UniversalMeasure = false;
    if (m_ST_UniversalMeasure)
    {
        delete m_ST_UniversalMeasure;
        m_ST_UniversalMeasure = NULL;
    }
}

std::string ST_TextPoint::toString() const
{
    if (m_has_ST_TextPointUnqualified)
    {
        return m_ST_TextPointUnqualified->toString();
    }

    if (m_has_ST_UniversalMeasure)
    {
        return m_ST_UniversalMeasure->toString();
    }

    return string();
}

void ST_TextPoint::clear()
{   clear_ST_TextPointUnqualified();
    clear_ST_UniversalMeasure();
}

void ST_TextPoint::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_ST_TextPointUnqualified)
    {
        m_ST_TextPointUnqualified->toXmlAttr(_attrName, _outStream);
        return;
    }

    if (m_has_ST_UniversalMeasure)
    {
        m_ST_UniversalMeasure->toXmlAttr(_attrName, _outStream);
        return;
    }
}

const ST_TextPoint& ST_TextPoint::default_instance()
{
    if (!ST_TextPoint::default_instance_)
    {
        ST_TextPoint::default_instance_ = new ST_TextPoint();
    }
    return *ST_TextPoint::default_instance_;
}

ST_TextPoint* ST_TextPoint::default_instance_ = NULL;

// ST_TextPointUnqualified
ST_TextPointUnqualified::ST_TextPointUnqualified()
    :m_has_int(false),
     m_int(0)
{
}
ST_TextPointUnqualified::ST_TextPointUnqualified(const XSD::int_& _int)
    :m_has_int(true)
{

    set_int(_int);
}
ST_TextPointUnqualified::~ST_TextPointUnqualified()
{
    clear();
}
bool ST_TextPointUnqualified::has_int() const
{
    return m_has_int;
}

void ST_TextPointUnqualified::set_int(const XSD::int_& _int)
{   assert(-400000 <= _int);
    assert(_int <= 400000);

    m_has_int = true;
    m_int = _int;
}

const XSD::int_& ST_TextPointUnqualified::get_int() const
{
    return m_int;
}

void ST_TextPointUnqualified::clear()
{
    m_has_int = false;
    m_int = 0;;
}

void ST_TextPointUnqualified::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_int)
    {
        _outStream << " " << _attrName << "=\"" << m_int << "\"";;
    }
}

const ST_TextPointUnqualified& ST_TextPointUnqualified::default_instance()
{
    if (!ST_TextPointUnqualified::default_instance_)
    {
        ST_TextPointUnqualified::default_instance_ = new ST_TextPointUnqualified();
    }
    return *ST_TextPointUnqualified::default_instance_;
}

std::string ST_TextPointUnqualified::toString() const
{
    std::stringstream strStream;
    strStream << get_int();
    return strStream.str();
}

ST_TextPointUnqualified* ST_TextPointUnqualified::default_instance_ = NULL;

// ST_TextNonNegativePoint
ST_TextNonNegativePoint::ST_TextNonNegativePoint()
    :m_has_int(false),
     m_int(0)
{
}
ST_TextNonNegativePoint::ST_TextNonNegativePoint(const XSD::int_& _int)
    :m_has_int(true)
{

    set_int(_int);
}
ST_TextNonNegativePoint::~ST_TextNonNegativePoint()
{
    clear();
}
bool ST_TextNonNegativePoint::has_int() const
{
    return m_has_int;
}

void ST_TextNonNegativePoint::set_int(const XSD::int_& _int)
{   assert(0 <= _int);
    assert(_int <= 400000);

    m_has_int = true;
    m_int = _int;
}

const XSD::int_& ST_TextNonNegativePoint::get_int() const
{
    return m_int;
}

void ST_TextNonNegativePoint::clear()
{
    m_has_int = false;
    m_int = 0;;
}

void ST_TextNonNegativePoint::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_int)
    {
        _outStream << " " << _attrName << "=\"" << m_int << "\"";;
    }
}

const ST_TextNonNegativePoint& ST_TextNonNegativePoint::default_instance()
{
    if (!ST_TextNonNegativePoint::default_instance_)
    {
        ST_TextNonNegativePoint::default_instance_ = new ST_TextNonNegativePoint();
    }
    return *ST_TextNonNegativePoint::default_instance_;
}

std::string ST_TextNonNegativePoint::toString() const
{
    std::stringstream strStream;
    strStream << get_int();
    return strStream.str();
}

ST_TextNonNegativePoint* ST_TextNonNegativePoint::default_instance_ = NULL;

// ST_TextFontSize
ST_TextFontSize::ST_TextFontSize()
    :m_has_int(false),
     m_int(0)
{
}
ST_TextFontSize::ST_TextFontSize(const XSD::int_& _int)
    :m_has_int(true)
{

    set_int(_int);
}
ST_TextFontSize::~ST_TextFontSize()
{
    clear();
}
bool ST_TextFontSize::has_int() const
{
    return m_has_int;
}

void ST_TextFontSize::set_int(const XSD::int_& _int)
{   assert(100 <= _int);
    assert(_int <= 400000);

    m_has_int = true;
    m_int = _int;
}

const XSD::int_& ST_TextFontSize::get_int() const
{
    return m_int;
}

void ST_TextFontSize::clear()
{
    m_has_int = false;
    m_int = 0;;
}

void ST_TextFontSize::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_int)
    {
        _outStream << " " << _attrName << "=\"" << m_int << "\"";;
    }
}

const ST_TextFontSize& ST_TextFontSize::default_instance()
{
    if (!ST_TextFontSize::default_instance_)
    {
        ST_TextFontSize::default_instance_ = new ST_TextFontSize();
    }
    return *ST_TextFontSize::default_instance_;
}

std::string ST_TextFontSize::toString() const
{
    std::stringstream strStream;
    strStream << get_int();
    return strStream.str();
}

ST_TextFontSize* ST_TextFontSize::default_instance_ = NULL;

// ST_TextTypeface
ST_TextTypeface::ST_TextTypeface()
    :m_has_string(false),
     m_string("")
{
}
ST_TextTypeface::ST_TextTypeface(const XSD::string_& _string)
    :m_has_string(true)
{

    set_string(_string);
}
ST_TextTypeface::~ST_TextTypeface()
{
    clear();
}
bool ST_TextTypeface::has_string() const
{
    return m_has_string;
}

void ST_TextTypeface::set_string(const XSD::string_& _string)
{
    m_has_string = true;
    m_string = _string;
}

const XSD::string_& ST_TextTypeface::get_string() const
{
    return m_string;
}

void ST_TextTypeface::clear()
{
    m_has_string = false;
    m_string.clear();;
}

void ST_TextTypeface::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_string)
    {
        _outStream << " " << _attrName << "=\"" << m_string << "\"";;
    }
}

const ST_TextTypeface& ST_TextTypeface::default_instance()
{
    if (!ST_TextTypeface::default_instance_)
    {
        ST_TextTypeface::default_instance_ = new ST_TextTypeface();
    }
    return *ST_TextTypeface::default_instance_;
}

std::string ST_TextTypeface::toString() const
{
    std::stringstream strStream;
    strStream << get_string();
    return strStream.str();
}

ST_TextTypeface* ST_TextTypeface::default_instance_ = NULL;

// ST_PitchFamily
ST_PitchFamily::ST_PitchFamily()
    :m_has_type(false)
{
}
ST_PitchFamily::ST_PitchFamily(const ST_PitchFamily::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_PitchFamily::~ST_PitchFamily()
{
    clear();
}
bool ST_PitchFamily::has_type() const
{
    return m_has_type;
}

void ST_PitchFamily::set_type(const ST_PitchFamily::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_PitchFamily::Type& ST_PitchFamily::get_type() const
{
    return m_type;
}

std::string ST_PitchFamily::toString() const
{
    return ST_PitchFamily::TypeStrList[m_type];
}

void ST_PitchFamily::clear()
{
    m_has_type = false;
}

void ST_PitchFamily::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_PitchFamily& ST_PitchFamily::default_instance()
{
    if (!ST_PitchFamily::default_instance_)
    {
        ST_PitchFamily::default_instance_ = new ST_PitchFamily();
    }
    return *ST_PitchFamily::default_instance_;
}

const std::string ST_PitchFamily::TypeStrList[] =
{
    "00",
    "01",
    "02",
    "16",
    "17",
    "18",
    "32",
    "33",
    "34",
    "48",
    "49",
    "50",
    "64",
    "65",
    "66",
    "80",
    "81",
    "82"
};
ST_PitchFamily* ST_PitchFamily::default_instance_ = NULL;

// ST_TextUnderlineType
ST_TextUnderlineType::ST_TextUnderlineType()
    :m_has_type(false)
{
}
ST_TextUnderlineType::ST_TextUnderlineType(const ST_TextUnderlineType::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_TextUnderlineType::~ST_TextUnderlineType()
{
    clear();
}
bool ST_TextUnderlineType::has_type() const
{
    return m_has_type;
}

void ST_TextUnderlineType::set_type(const ST_TextUnderlineType::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_TextUnderlineType::Type& ST_TextUnderlineType::get_type() const
{
    return m_type;
}

std::string ST_TextUnderlineType::toString() const
{
    return ST_TextUnderlineType::TypeStrList[m_type];
}

void ST_TextUnderlineType::clear()
{
    m_has_type = false;
}

void ST_TextUnderlineType::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_TextUnderlineType& ST_TextUnderlineType::default_instance()
{
    if (!ST_TextUnderlineType::default_instance_)
    {
        ST_TextUnderlineType::default_instance_ = new ST_TextUnderlineType();
    }
    return *ST_TextUnderlineType::default_instance_;
}

const std::string ST_TextUnderlineType::TypeStrList[] =
{
    "none",
    "words",
    "sng",
    "dbl",
    "heavy",
    "dotted",
    "dottedHeavy",
    "dash",
    "dashHeavy",
    "dashLong",
    "dashLongHeavy",
    "dotDash",
    "dotDashHeavy",
    "dotDotDash",
    "dotDotDashHeavy",
    "wavy",
    "wavyHeavy",
    "wavyDbl"
};
ST_TextUnderlineType* ST_TextUnderlineType::default_instance_ = NULL;

// ST_TextStrikeType
ST_TextStrikeType::ST_TextStrikeType()
    :m_has_type(false)
{
}
ST_TextStrikeType::ST_TextStrikeType(const ST_TextStrikeType::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_TextStrikeType::~ST_TextStrikeType()
{
    clear();
}
bool ST_TextStrikeType::has_type() const
{
    return m_has_type;
}

void ST_TextStrikeType::set_type(const ST_TextStrikeType::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_TextStrikeType::Type& ST_TextStrikeType::get_type() const
{
    return m_type;
}

std::string ST_TextStrikeType::toString() const
{
    return ST_TextStrikeType::TypeStrList[m_type];
}

void ST_TextStrikeType::clear()
{
    m_has_type = false;
}

void ST_TextStrikeType::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_TextStrikeType& ST_TextStrikeType::default_instance()
{
    if (!ST_TextStrikeType::default_instance_)
    {
        ST_TextStrikeType::default_instance_ = new ST_TextStrikeType();
    }
    return *ST_TextStrikeType::default_instance_;
}

const std::string ST_TextStrikeType::TypeStrList[] =
{
    "noStrike",
    "sngStrike",
    "dblStrike"
};
ST_TextStrikeType* ST_TextStrikeType::default_instance_ = NULL;

// ST_TextCapsType
ST_TextCapsType::ST_TextCapsType()
    :m_has_type(false)
{
}
ST_TextCapsType::ST_TextCapsType(const ST_TextCapsType::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_TextCapsType::~ST_TextCapsType()
{
    clear();
}
bool ST_TextCapsType::has_type() const
{
    return m_has_type;
}

void ST_TextCapsType::set_type(const ST_TextCapsType::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_TextCapsType::Type& ST_TextCapsType::get_type() const
{
    return m_type;
}

std::string ST_TextCapsType::toString() const
{
    return ST_TextCapsType::TypeStrList[m_type];
}

void ST_TextCapsType::clear()
{
    m_has_type = false;
}

void ST_TextCapsType::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_TextCapsType& ST_TextCapsType::default_instance()
{
    if (!ST_TextCapsType::default_instance_)
    {
        ST_TextCapsType::default_instance_ = new ST_TextCapsType();
    }
    return *ST_TextCapsType::default_instance_;
}

const std::string ST_TextCapsType::TypeStrList[] =
{
    "none",
    "small",
    "all"
};
ST_TextCapsType* ST_TextCapsType::default_instance_ = NULL;

// ST_TextSpacingPoint
ST_TextSpacingPoint::ST_TextSpacingPoint()
    :m_has_int(false),
     m_int(0)
{
}
ST_TextSpacingPoint::ST_TextSpacingPoint(const XSD::int_& _int)
    :m_has_int(true)
{

    set_int(_int);
}
ST_TextSpacingPoint::~ST_TextSpacingPoint()
{
    clear();
}
bool ST_TextSpacingPoint::has_int() const
{
    return m_has_int;
}

void ST_TextSpacingPoint::set_int(const XSD::int_& _int)
{   assert(0 <= _int);
    assert(_int <= 158400);

    m_has_int = true;
    m_int = _int;
}

const XSD::int_& ST_TextSpacingPoint::get_int() const
{
    return m_int;
}

void ST_TextSpacingPoint::clear()
{
    m_has_int = false;
    m_int = 0;;
}

void ST_TextSpacingPoint::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_int)
    {
        _outStream << " " << _attrName << "=\"" << m_int << "\"";;
    }
}

const ST_TextSpacingPoint& ST_TextSpacingPoint::default_instance()
{
    if (!ST_TextSpacingPoint::default_instance_)
    {
        ST_TextSpacingPoint::default_instance_ = new ST_TextSpacingPoint();
    }
    return *ST_TextSpacingPoint::default_instance_;
}

std::string ST_TextSpacingPoint::toString() const
{
    std::stringstream strStream;
    strStream << get_int();
    return strStream.str();
}

ST_TextSpacingPoint* ST_TextSpacingPoint::default_instance_ = NULL;

// ST_TextSpacingPercentOrPercentString
ST_TextSpacingPercentOrPercentString::ST_TextSpacingPercentOrPercentString()
    :m_has_ST_TextSpacingPercent(false),
     m_ST_TextSpacingPercent(NULL),
     m_has_ST_Percentage(false),
     m_ST_Percentage(NULL)
{
}
ST_TextSpacingPercentOrPercentString::ST_TextSpacingPercentOrPercentString(const ST_TextSpacingPercentOrPercentString& _ST_TextSpacingPercentOrPercentString)
    :m_has_ST_TextSpacingPercent(false),
     m_ST_TextSpacingPercent(NULL),
     m_has_ST_Percentage(false),
     m_ST_Percentage(NULL)
{

    m_has_ST_TextSpacingPercent = _ST_TextSpacingPercentOrPercentString.has_ST_TextSpacingPercent();
    if (_ST_TextSpacingPercentOrPercentString.has_ST_TextSpacingPercent())
    {
        m_ST_TextSpacingPercent = new ST_TextSpacingPercent(_ST_TextSpacingPercentOrPercentString.get_ST_TextSpacingPercent());
    }


    m_has_ST_Percentage = _ST_TextSpacingPercentOrPercentString.has_ST_Percentage();
    if (_ST_TextSpacingPercentOrPercentString.has_ST_Percentage())
    {
        m_ST_Percentage = new ns_s::ST_Percentage(_ST_TextSpacingPercentOrPercentString.get_ST_Percentage());
    }
}
ST_TextSpacingPercentOrPercentString::~ST_TextSpacingPercentOrPercentString()
{
    clear();
}
bool ST_TextSpacingPercentOrPercentString::has_ST_TextSpacingPercent() const
{
    return m_has_ST_TextSpacingPercent;
}

ST_TextSpacingPercent* ST_TextSpacingPercentOrPercentString::mutable_ST_TextSpacingPercent()
{
    clear_ST_Percentage();
    m_has_ST_TextSpacingPercent = true;
    if (!m_ST_TextSpacingPercent)
    {
        m_ST_TextSpacingPercent = new ST_TextSpacingPercent();
    }
    return m_ST_TextSpacingPercent;
}

const ST_TextSpacingPercent& ST_TextSpacingPercentOrPercentString::get_ST_TextSpacingPercent() const
{
    if (m_ST_TextSpacingPercent)
    {
        return *m_ST_TextSpacingPercent;
    }
    return ST_TextSpacingPercent::default_instance();
}

void ST_TextSpacingPercentOrPercentString::clear_ST_TextSpacingPercent()
{
    m_has_ST_TextSpacingPercent = false;
    if (m_ST_TextSpacingPercent)
    {
        delete m_ST_TextSpacingPercent;
        m_ST_TextSpacingPercent = NULL;
    }
}

bool ST_TextSpacingPercentOrPercentString::has_ST_Percentage() const
{
    return m_has_ST_Percentage;
}

ns_s::ST_Percentage* ST_TextSpacingPercentOrPercentString::mutable_ST_Percentage()
{
    clear_ST_TextSpacingPercent();
    m_has_ST_Percentage = true;
    if (!m_ST_Percentage)
    {
        m_ST_Percentage = new ns_s::ST_Percentage();
    }
    return m_ST_Percentage;
}

const ns_s::ST_Percentage& ST_TextSpacingPercentOrPercentString::get_ST_Percentage() const
{
    if (m_ST_Percentage)
    {
        return *m_ST_Percentage;
    }
    return ns_s::ST_Percentage::default_instance();
}

void ST_TextSpacingPercentOrPercentString::clear_ST_Percentage()
{
    m_has_ST_Percentage = false;
    if (m_ST_Percentage)
    {
        delete m_ST_Percentage;
        m_ST_Percentage = NULL;
    }
}

std::string ST_TextSpacingPercentOrPercentString::toString() const
{
    if (m_has_ST_TextSpacingPercent)
    {
        return m_ST_TextSpacingPercent->toString();
    }

    if (m_has_ST_Percentage)
    {
        return m_ST_Percentage->toString();
    }

    return string();
}

void ST_TextSpacingPercentOrPercentString::clear()
{   clear_ST_TextSpacingPercent();
    clear_ST_Percentage();
}

void ST_TextSpacingPercentOrPercentString::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_ST_TextSpacingPercent)
    {
        m_ST_TextSpacingPercent->toXmlAttr(_attrName, _outStream);
        return;
    }

    if (m_has_ST_Percentage)
    {
        m_ST_Percentage->toXmlAttr(_attrName, _outStream);
        return;
    }
}

const ST_TextSpacingPercentOrPercentString& ST_TextSpacingPercentOrPercentString::default_instance()
{
    if (!ST_TextSpacingPercentOrPercentString::default_instance_)
    {
        ST_TextSpacingPercentOrPercentString::default_instance_ = new ST_TextSpacingPercentOrPercentString();
    }
    return *ST_TextSpacingPercentOrPercentString::default_instance_;
}

ST_TextSpacingPercentOrPercentString* ST_TextSpacingPercentOrPercentString::default_instance_ = NULL;

// ST_TextSpacingPercent
ST_TextSpacingPercent::ST_TextSpacingPercent()

{
}
ST_TextSpacingPercent::ST_TextSpacingPercent(const ST_PercentageDecimal& _ST_PercentageDecimal)
    :ST_PercentageDecimal(_ST_PercentageDecimal)
{
}
ST_TextSpacingPercent::~ST_TextSpacingPercent()
{
    clear();
}
const ST_TextSpacingPercent& ST_TextSpacingPercent::default_instance()
{
    if (!ST_TextSpacingPercent::default_instance_)
    {
        ST_TextSpacingPercent::default_instance_ = new ST_TextSpacingPercent();
    }
    return *ST_TextSpacingPercent::default_instance_;
}

ST_TextSpacingPercent* ST_TextSpacingPercent::default_instance_ = NULL;

// ST_TextMargin
ST_TextMargin::ST_TextMargin()

{
}
ST_TextMargin::ST_TextMargin(const ST_Coordinate32Unqualified& _ST_Coordinate32Unqualified)
    :ST_Coordinate32Unqualified(_ST_Coordinate32Unqualified)
{
}
ST_TextMargin::~ST_TextMargin()
{
    clear();
}
const ST_TextMargin& ST_TextMargin::default_instance()
{
    if (!ST_TextMargin::default_instance_)
    {
        ST_TextMargin::default_instance_ = new ST_TextMargin();
    }
    return *ST_TextMargin::default_instance_;
}

ST_TextMargin* ST_TextMargin::default_instance_ = NULL;

// ST_TextIndent
ST_TextIndent::ST_TextIndent()

{
}
ST_TextIndent::ST_TextIndent(const ST_Coordinate32Unqualified& _ST_Coordinate32Unqualified)
    :ST_Coordinate32Unqualified(_ST_Coordinate32Unqualified)
{
}
ST_TextIndent::~ST_TextIndent()
{
    clear();
}
const ST_TextIndent& ST_TextIndent::default_instance()
{
    if (!ST_TextIndent::default_instance_)
    {
        ST_TextIndent::default_instance_ = new ST_TextIndent();
    }
    return *ST_TextIndent::default_instance_;
}

ST_TextIndent* ST_TextIndent::default_instance_ = NULL;

// ST_TextTabAlignType
ST_TextTabAlignType::ST_TextTabAlignType()
    :m_has_type(false)
{
}
ST_TextTabAlignType::ST_TextTabAlignType(const ST_TextTabAlignType::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_TextTabAlignType::~ST_TextTabAlignType()
{
    clear();
}
bool ST_TextTabAlignType::has_type() const
{
    return m_has_type;
}

void ST_TextTabAlignType::set_type(const ST_TextTabAlignType::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_TextTabAlignType::Type& ST_TextTabAlignType::get_type() const
{
    return m_type;
}

std::string ST_TextTabAlignType::toString() const
{
    return ST_TextTabAlignType::TypeStrList[m_type];
}

void ST_TextTabAlignType::clear()
{
    m_has_type = false;
}

void ST_TextTabAlignType::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_TextTabAlignType& ST_TextTabAlignType::default_instance()
{
    if (!ST_TextTabAlignType::default_instance_)
    {
        ST_TextTabAlignType::default_instance_ = new ST_TextTabAlignType();
    }
    return *ST_TextTabAlignType::default_instance_;
}

const std::string ST_TextTabAlignType::TypeStrList[] =
{
    "l",
    "ctr",
    "r",
    "dec"
};
ST_TextTabAlignType* ST_TextTabAlignType::default_instance_ = NULL;

// ST_TextAlignType
ST_TextAlignType::ST_TextAlignType()
    :m_has_type(false)
{
}
ST_TextAlignType::ST_TextAlignType(const ST_TextAlignType::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_TextAlignType::~ST_TextAlignType()
{
    clear();
}
bool ST_TextAlignType::has_type() const
{
    return m_has_type;
}

void ST_TextAlignType::set_type(const ST_TextAlignType::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_TextAlignType::Type& ST_TextAlignType::get_type() const
{
    return m_type;
}

std::string ST_TextAlignType::toString() const
{
    return ST_TextAlignType::TypeStrList[m_type];
}

void ST_TextAlignType::clear()
{
    m_has_type = false;
}

void ST_TextAlignType::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_TextAlignType& ST_TextAlignType::default_instance()
{
    if (!ST_TextAlignType::default_instance_)
    {
        ST_TextAlignType::default_instance_ = new ST_TextAlignType();
    }
    return *ST_TextAlignType::default_instance_;
}

const std::string ST_TextAlignType::TypeStrList[] =
{
    "l",
    "ctr",
    "r",
    "just",
    "justLow",
    "dist",
    "thaiDist"
};
ST_TextAlignType* ST_TextAlignType::default_instance_ = NULL;

// ST_TextFontAlignType
ST_TextFontAlignType::ST_TextFontAlignType()
    :m_has_type(false)
{
}
ST_TextFontAlignType::ST_TextFontAlignType(const ST_TextFontAlignType::Type& _type)
    :m_has_type(true),
     m_type(_type)
{
}
ST_TextFontAlignType::~ST_TextFontAlignType()
{
    clear();
}
bool ST_TextFontAlignType::has_type() const
{
    return m_has_type;
}

void ST_TextFontAlignType::set_type(const ST_TextFontAlignType::Type& _type)
{
    m_has_type = true;
    m_type = _type;
}

const ST_TextFontAlignType::Type& ST_TextFontAlignType::get_type() const
{
    return m_type;
}

std::string ST_TextFontAlignType::toString() const
{
    return ST_TextFontAlignType::TypeStrList[m_type];
}

void ST_TextFontAlignType::clear()
{
    m_has_type = false;
}

void ST_TextFontAlignType::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_type)
    {
        _outStream << " " << _attrName << "=\"" << toString() << "\"";
    }
}

const ST_TextFontAlignType& ST_TextFontAlignType::default_instance()
{
    if (!ST_TextFontAlignType::default_instance_)
    {
        ST_TextFontAlignType::default_instance_ = new ST_TextFontAlignType();
    }
    return *ST_TextFontAlignType::default_instance_;
}

const std::string ST_TextFontAlignType::TypeStrList[] =
{
    "auto",
    "t",
    "ctr",
    "base",
    "b"
};
ST_TextFontAlignType* ST_TextFontAlignType::default_instance_ = NULL;

// ST_TextIndentLevelType
ST_TextIndentLevelType::ST_TextIndentLevelType()
    :m_has_int(false),
     m_int(0)
{
}
ST_TextIndentLevelType::ST_TextIndentLevelType(const XSD::int_& _int)
    :m_has_int(true)
{

    set_int(_int);
}
ST_TextIndentLevelType::~ST_TextIndentLevelType()
{
    clear();
}
bool ST_TextIndentLevelType::has_int() const
{
    return m_has_int;
}

void ST_TextIndentLevelType::set_int(const XSD::int_& _int)
{   assert(0 <= _int);
    assert(_int <= 8);

    m_has_int = true;
    m_int = _int;
}

const XSD::int_& ST_TextIndentLevelType::get_int() const
{
    return m_int;
}

void ST_TextIndentLevelType::clear()
{
    m_has_int = false;
    m_int = 0;;
}

void ST_TextIndentLevelType::toXmlAttr(const std::string& _attrName, std::ostream& _outStream) const
{
    if (m_has_int)
    {
        _outStream << " " << _attrName << "=\"" << m_int << "\"";;
    }
}

const ST_TextIndentLevelType& ST_TextIndentLevelType::default_instance()
{
    if (!ST_TextIndentLevelType::default_instance_)
    {
        ST_TextIndentLevelType::default_instance_ = new ST_TextIndentLevelType();
    }
    return *ST_TextIndentLevelType::default_instance_;
}

std::string ST_TextIndentLevelType::toString() const
{
    std::stringstream strStream;
    strStream << get_int();
    return strStream.str();
}

ST_TextIndentLevelType* ST_TextIndentLevelType::default_instance_ = NULL;

// CT_AudioFile
CT_AudioFile::CT_AudioFile()
    :m_has_extLst(false),
     m_extLst(NULL),
     m_has_r_link_attr(false),
     m_r_link_attr(NULL),
     m_has_contentType_attr(false),
     m_contentType_attr("")
{
}
CT_AudioFile::~CT_AudioFile()
{
    clear();
}
bool CT_AudioFile::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_AudioFile::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_AudioFile::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_AudioFile::clear()
{
    m_has_r_link_attr = false;

    if (m_r_link_attr)
    {
        delete m_r_link_attr;
        m_r_link_attr = NULL;
    }


    m_has_contentType_attr = false;
    m_contentType_attr.clear();

    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_AudioFile::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_r_link_attr);
    if (m_has_r_link_attr)
    {
        m_r_link_attr->toXmlAttr("r:link", _outStream);
    }



    if (m_has_contentType_attr)
    {
        _outStream << " " << "contentType" << "=\"" << m_contentType_attr << "\"";
    }

    _outStream << ">";


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_AudioFile& CT_AudioFile::default_instance()
{
    if (!CT_AudioFile::default_instance_)
    {
        CT_AudioFile::default_instance_ = new CT_AudioFile();
    }
    return *CT_AudioFile::default_instance_;
}

bool CT_AudioFile::has_r_link_attr() const
{
    return m_has_r_link_attr;
}

void CT_AudioFile::set_r_link_attr(const ns_r::ST_RelationshipId& _r_link_attr)
{
    m_has_r_link_attr = true;
    m_r_link_attr = new ns_r::ST_RelationshipId(_r_link_attr);
}

const ns_r::ST_RelationshipId& CT_AudioFile::get_r_link_attr() const
{
    if (m_r_link_attr)
    {
        return *m_r_link_attr;
    }
    return ns_r::ST_RelationshipId::default_instance();
}

bool CT_AudioFile::has_contentType_attr() const
{
    return m_has_contentType_attr;
}

void CT_AudioFile::set_contentType_attr(const XSD::string_& _contentType_attr)
{
    m_has_contentType_attr = true;
    m_contentType_attr = _contentType_attr;
}

const XSD::string_& CT_AudioFile::get_contentType_attr() const
{
    return m_contentType_attr;
}

CT_AudioFile* CT_AudioFile::default_instance_ = NULL;

// CT_VideoFile
CT_VideoFile::CT_VideoFile()
    :m_has_extLst(false),
     m_extLst(NULL),
     m_has_r_link_attr(false),
     m_r_link_attr(NULL),
     m_has_contentType_attr(false),
     m_contentType_attr("")
{
}
CT_VideoFile::~CT_VideoFile()
{
    clear();
}
bool CT_VideoFile::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_VideoFile::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_VideoFile::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_VideoFile::clear()
{
    m_has_r_link_attr = false;

    if (m_r_link_attr)
    {
        delete m_r_link_attr;
        m_r_link_attr = NULL;
    }


    m_has_contentType_attr = false;
    m_contentType_attr.clear();

    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_VideoFile::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_r_link_attr);
    if (m_has_r_link_attr)
    {
        m_r_link_attr->toXmlAttr("r:link", _outStream);
    }



    if (m_has_contentType_attr)
    {
        _outStream << " " << "contentType" << "=\"" << m_contentType_attr << "\"";
    }

    _outStream << ">";


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_VideoFile& CT_VideoFile::default_instance()
{
    if (!CT_VideoFile::default_instance_)
    {
        CT_VideoFile::default_instance_ = new CT_VideoFile();
    }
    return *CT_VideoFile::default_instance_;
}

bool CT_VideoFile::has_r_link_attr() const
{
    return m_has_r_link_attr;
}

void CT_VideoFile::set_r_link_attr(const ns_r::ST_RelationshipId& _r_link_attr)
{
    m_has_r_link_attr = true;
    m_r_link_attr = new ns_r::ST_RelationshipId(_r_link_attr);
}

const ns_r::ST_RelationshipId& CT_VideoFile::get_r_link_attr() const
{
    if (m_r_link_attr)
    {
        return *m_r_link_attr;
    }
    return ns_r::ST_RelationshipId::default_instance();
}

bool CT_VideoFile::has_contentType_attr() const
{
    return m_has_contentType_attr;
}

void CT_VideoFile::set_contentType_attr(const XSD::string_& _contentType_attr)
{
    m_has_contentType_attr = true;
    m_contentType_attr = _contentType_attr;
}

const XSD::string_& CT_VideoFile::get_contentType_attr() const
{
    return m_contentType_attr;
}

CT_VideoFile* CT_VideoFile::default_instance_ = NULL;

// CT_QuickTimeFile
CT_QuickTimeFile::CT_QuickTimeFile()
    :m_has_extLst(false),
     m_extLst(NULL),
     m_has_r_link_attr(false),
     m_r_link_attr(NULL)
{
}
CT_QuickTimeFile::~CT_QuickTimeFile()
{
    clear();
}
bool CT_QuickTimeFile::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_QuickTimeFile::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_QuickTimeFile::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_QuickTimeFile::clear()
{
    m_has_r_link_attr = false;

    if (m_r_link_attr)
    {
        delete m_r_link_attr;
        m_r_link_attr = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_QuickTimeFile::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_r_link_attr);
    if (m_has_r_link_attr)
    {
        m_r_link_attr->toXmlAttr("r:link", _outStream);
    }

    _outStream << ">";


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_QuickTimeFile& CT_QuickTimeFile::default_instance()
{
    if (!CT_QuickTimeFile::default_instance_)
    {
        CT_QuickTimeFile::default_instance_ = new CT_QuickTimeFile();
    }
    return *CT_QuickTimeFile::default_instance_;
}

bool CT_QuickTimeFile::has_r_link_attr() const
{
    return m_has_r_link_attr;
}

void CT_QuickTimeFile::set_r_link_attr(const ns_r::ST_RelationshipId& _r_link_attr)
{
    m_has_r_link_attr = true;
    m_r_link_attr = new ns_r::ST_RelationshipId(_r_link_attr);
}

const ns_r::ST_RelationshipId& CT_QuickTimeFile::get_r_link_attr() const
{
    if (m_r_link_attr)
    {
        return *m_r_link_attr;
    }
    return ns_r::ST_RelationshipId::default_instance();
}

CT_QuickTimeFile* CT_QuickTimeFile::default_instance_ = NULL;

// CT_AudioCDTime
CT_AudioCDTime::CT_AudioCDTime()
    :m_has_track_attr(false),
     m_track_attr(0),
     m_has_time_attr(false),
     m_time_attr(0)
{
}
CT_AudioCDTime::~CT_AudioCDTime()
{
    clear();
}
void CT_AudioCDTime::clear()
{
    m_has_track_attr = false;
    m_track_attr = 0;

    m_has_time_attr = false;
    m_time_attr = 0;
}

void CT_AudioCDTime::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_track_attr);
    if (m_has_track_attr)
    {
        _outStream << " " << "track" << "=\"" << m_track_attr << "\"";
    }



    if (m_has_time_attr)
    {
        _outStream << " " << "time" << "=\"" << m_time_attr << "\"";
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_AudioCDTime& CT_AudioCDTime::default_instance()
{
    if (!CT_AudioCDTime::default_instance_)
    {
        CT_AudioCDTime::default_instance_ = new CT_AudioCDTime();
    }
    return *CT_AudioCDTime::default_instance_;
}

bool CT_AudioCDTime::has_track_attr() const
{
    return m_has_track_attr;
}

void CT_AudioCDTime::set_track_attr(const XSD::unsignedByte_& _track_attr)
{
    m_has_track_attr = true;
    m_track_attr = _track_attr;
}

const XSD::unsignedByte_& CT_AudioCDTime::get_track_attr() const
{
    return m_track_attr;
}

bool CT_AudioCDTime::has_time_attr() const
{
    return m_has_time_attr;
}

void CT_AudioCDTime::set_time_attr(const XSD::unsignedInt_& _time_attr)
{
    m_has_time_attr = true;
    m_time_attr = _time_attr;
}

const XSD::unsignedInt_& CT_AudioCDTime::get_time_attr() const
{
    return m_time_attr;
}

CT_AudioCDTime* CT_AudioCDTime::default_instance_ = NULL;

// CT_AudioCD
CT_AudioCD::CT_AudioCD()
    :m_has_st(false),
     m_st(NULL),
     m_has_end(false),
     m_end(NULL),
     m_has_extLst(false),
     m_extLst(NULL)
{
}
CT_AudioCD::~CT_AudioCD()
{
    clear();
}
bool CT_AudioCD::has_st() const
{
    return m_has_st;
}

CT_AudioCDTime* CT_AudioCD::mutable_st()
{
    m_has_st = true;
    if (!m_st)
    {
        m_st = new CT_AudioCDTime();
    }
    return m_st;
}

const CT_AudioCDTime& CT_AudioCD::get_st() const
{
    if (m_st)
    {
        return *m_st;
    }
    return CT_AudioCDTime::default_instance();
}

bool CT_AudioCD::has_end() const
{
    return m_has_end;
}

CT_AudioCDTime* CT_AudioCD::mutable_end()
{
    m_has_end = true;
    if (!m_end)
    {
        m_end = new CT_AudioCDTime();
    }
    return m_end;
}

const CT_AudioCDTime& CT_AudioCD::get_end() const
{
    if (m_end)
    {
        return *m_end;
    }
    return CT_AudioCDTime::default_instance();
}

bool CT_AudioCD::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_AudioCD::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_AudioCD::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_AudioCD::clear()
{
    m_has_st = false;

    if (m_st)
    {
        delete m_st;
        m_st = NULL;
    }


    m_has_end = false;

    if (m_end)
    {
        delete m_end;
        m_end = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_AudioCD::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    assert(m_has_st);


    assert(m_has_end);


    if (m_has_st)
    {
        m_st->toXmlElem("a:st", "", _outStream);
    }


    if (m_has_end)
    {
        m_end->toXmlElem("a:end", "", _outStream);
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_AudioCD& CT_AudioCD::default_instance()
{
    if (!CT_AudioCD::default_instance_)
    {
        CT_AudioCD::default_instance_ = new CT_AudioCD();
    }
    return *CT_AudioCD::default_instance_;
}

CT_AudioCD* CT_AudioCD::default_instance_ = NULL;

// CT_ColorScheme
CT_ColorScheme::CT_ColorScheme()
    :m_has_dk1(false),
     m_dk1(NULL),
     m_has_lt1(false),
     m_lt1(NULL),
     m_has_dk2(false),
     m_dk2(NULL),
     m_has_lt2(false),
     m_lt2(NULL),
     m_has_accent1(false),
     m_accent1(NULL),
     m_has_accent2(false),
     m_accent2(NULL),
     m_has_accent3(false),
     m_accent3(NULL),
     m_has_accent4(false),
     m_accent4(NULL),
     m_has_accent5(false),
     m_accent5(NULL),
     m_has_accent6(false),
     m_accent6(NULL),
     m_has_hlink(false),
     m_hlink(NULL),
     m_has_folHlink(false),
     m_folHlink(NULL),
     m_has_extLst(false),
     m_extLst(NULL),
     m_has_name_attr(false),
     m_name_attr("")
{
}
CT_ColorScheme::~CT_ColorScheme()
{
    clear();
}
bool CT_ColorScheme::has_dk1() const
{
    return m_has_dk1;
}

CT_Color* CT_ColorScheme::mutable_dk1()
{
    m_has_dk1 = true;
    if (!m_dk1)
    {
        m_dk1 = new CT_Color();
    }
    return m_dk1;
}

const CT_Color& CT_ColorScheme::get_dk1() const
{
    if (m_dk1)
    {
        return *m_dk1;
    }
    return CT_Color::default_instance();
}

bool CT_ColorScheme::has_lt1() const
{
    return m_has_lt1;
}

CT_Color* CT_ColorScheme::mutable_lt1()
{
    m_has_lt1 = true;
    if (!m_lt1)
    {
        m_lt1 = new CT_Color();
    }
    return m_lt1;
}

const CT_Color& CT_ColorScheme::get_lt1() const
{
    if (m_lt1)
    {
        return *m_lt1;
    }
    return CT_Color::default_instance();
}

bool CT_ColorScheme::has_dk2() const
{
    return m_has_dk2;
}

CT_Color* CT_ColorScheme::mutable_dk2()
{
    m_has_dk2 = true;
    if (!m_dk2)
    {
        m_dk2 = new CT_Color();
    }
    return m_dk2;
}

const CT_Color& CT_ColorScheme::get_dk2() const
{
    if (m_dk2)
    {
        return *m_dk2;
    }
    return CT_Color::default_instance();
}

bool CT_ColorScheme::has_lt2() const
{
    return m_has_lt2;
}

CT_Color* CT_ColorScheme::mutable_lt2()
{
    m_has_lt2 = true;
    if (!m_lt2)
    {
        m_lt2 = new CT_Color();
    }
    return m_lt2;
}

const CT_Color& CT_ColorScheme::get_lt2() const
{
    if (m_lt2)
    {
        return *m_lt2;
    }
    return CT_Color::default_instance();
}

bool CT_ColorScheme::has_accent1() const
{
    return m_has_accent1;
}

CT_Color* CT_ColorScheme::mutable_accent1()
{
    m_has_accent1 = true;
    if (!m_accent1)
    {
        m_accent1 = new CT_Color();
    }
    return m_accent1;
}

const CT_Color& CT_ColorScheme::get_accent1() const
{
    if (m_accent1)
    {
        return *m_accent1;
    }
    return CT_Color::default_instance();
}

bool CT_ColorScheme::has_accent2() const
{
    return m_has_accent2;
}

CT_Color* CT_ColorScheme::mutable_accent2()
{
    m_has_accent2 = true;
    if (!m_accent2)
    {
        m_accent2 = new CT_Color();
    }
    return m_accent2;
}

const CT_Color& CT_ColorScheme::get_accent2() const
{
    if (m_accent2)
    {
        return *m_accent2;
    }
    return CT_Color::default_instance();
}

bool CT_ColorScheme::has_accent3() const
{
    return m_has_accent3;
}

CT_Color* CT_ColorScheme::mutable_accent3()
{
    m_has_accent3 = true;
    if (!m_accent3)
    {
        m_accent3 = new CT_Color();
    }
    return m_accent3;
}

const CT_Color& CT_ColorScheme::get_accent3() const
{
    if (m_accent3)
    {
        return *m_accent3;
    }
    return CT_Color::default_instance();
}

bool CT_ColorScheme::has_accent4() const
{
    return m_has_accent4;
}

CT_Color* CT_ColorScheme::mutable_accent4()
{
    m_has_accent4 = true;
    if (!m_accent4)
    {
        m_accent4 = new CT_Color();
    }
    return m_accent4;
}

const CT_Color& CT_ColorScheme::get_accent4() const
{
    if (m_accent4)
    {
        return *m_accent4;
    }
    return CT_Color::default_instance();
}

bool CT_ColorScheme::has_accent5() const
{
    return m_has_accent5;
}

CT_Color* CT_ColorScheme::mutable_accent5()
{
    m_has_accent5 = true;
    if (!m_accent5)
    {
        m_accent5 = new CT_Color();
    }
    return m_accent5;
}

const CT_Color& CT_ColorScheme::get_accent5() const
{
    if (m_accent5)
    {
        return *m_accent5;
    }
    return CT_Color::default_instance();
}

bool CT_ColorScheme::has_accent6() const
{
    return m_has_accent6;
}

CT_Color* CT_ColorScheme::mutable_accent6()
{
    m_has_accent6 = true;
    if (!m_accent6)
    {
        m_accent6 = new CT_Color();
    }
    return m_accent6;
}

const CT_Color& CT_ColorScheme::get_accent6() const
{
    if (m_accent6)
    {
        return *m_accent6;
    }
    return CT_Color::default_instance();
}

bool CT_ColorScheme::has_hlink() const
{
    return m_has_hlink;
}

CT_Color* CT_ColorScheme::mutable_hlink()
{
    m_has_hlink = true;
    if (!m_hlink)
    {
        m_hlink = new CT_Color();
    }
    return m_hlink;
}

const CT_Color& CT_ColorScheme::get_hlink() const
{
    if (m_hlink)
    {
        return *m_hlink;
    }
    return CT_Color::default_instance();
}

bool CT_ColorScheme::has_folHlink() const
{
    return m_has_folHlink;
}

CT_Color* CT_ColorScheme::mutable_folHlink()
{
    m_has_folHlink = true;
    if (!m_folHlink)
    {
        m_folHlink = new CT_Color();
    }
    return m_folHlink;
}

const CT_Color& CT_ColorScheme::get_folHlink() const
{
    if (m_folHlink)
    {
        return *m_folHlink;
    }
    return CT_Color::default_instance();
}

bool CT_ColorScheme::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_ColorScheme::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_ColorScheme::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_ColorScheme::clear()
{
    m_has_name_attr = false;
    m_name_attr.clear();

    m_has_dk1 = false;

    if (m_dk1)
    {
        delete m_dk1;
        m_dk1 = NULL;
    }


    m_has_lt1 = false;

    if (m_lt1)
    {
        delete m_lt1;
        m_lt1 = NULL;
    }


    m_has_dk2 = false;

    if (m_dk2)
    {
        delete m_dk2;
        m_dk2 = NULL;
    }


    m_has_lt2 = false;

    if (m_lt2)
    {
        delete m_lt2;
        m_lt2 = NULL;
    }


    m_has_accent1 = false;

    if (m_accent1)
    {
        delete m_accent1;
        m_accent1 = NULL;
    }


    m_has_accent2 = false;

    if (m_accent2)
    {
        delete m_accent2;
        m_accent2 = NULL;
    }


    m_has_accent3 = false;

    if (m_accent3)
    {
        delete m_accent3;
        m_accent3 = NULL;
    }


    m_has_accent4 = false;

    if (m_accent4)
    {
        delete m_accent4;
        m_accent4 = NULL;
    }


    m_has_accent5 = false;

    if (m_accent5)
    {
        delete m_accent5;
        m_accent5 = NULL;
    }


    m_has_accent6 = false;

    if (m_accent6)
    {
        delete m_accent6;
        m_accent6 = NULL;
    }


    m_has_hlink = false;

    if (m_hlink)
    {
        delete m_hlink;
        m_hlink = NULL;
    }


    m_has_folHlink = false;

    if (m_folHlink)
    {
        delete m_folHlink;
        m_folHlink = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_ColorScheme::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_name_attr);
    if (m_has_name_attr)
    {
        _outStream << " " << "name" << "=\"" << m_name_attr << "\"";
    }

    _outStream << ">";

    assert(m_has_dk1);


    assert(m_has_lt1);


    assert(m_has_dk2);


    assert(m_has_lt2);


    assert(m_has_accent1);


    assert(m_has_accent2);


    assert(m_has_accent3);


    assert(m_has_accent4);


    assert(m_has_accent5);


    assert(m_has_accent6);


    assert(m_has_hlink);


    assert(m_has_folHlink);


    if (m_has_dk1)
    {
        m_dk1->toXmlElem("a:dk1", "", _outStream);
    }


    if (m_has_lt1)
    {
        m_lt1->toXmlElem("a:lt1", "", _outStream);
    }


    if (m_has_dk2)
    {
        m_dk2->toXmlElem("a:dk2", "", _outStream);
    }


    if (m_has_lt2)
    {
        m_lt2->toXmlElem("a:lt2", "", _outStream);
    }


    if (m_has_accent1)
    {
        m_accent1->toXmlElem("a:accent1", "", _outStream);
    }


    if (m_has_accent2)
    {
        m_accent2->toXmlElem("a:accent2", "", _outStream);
    }


    if (m_has_accent3)
    {
        m_accent3->toXmlElem("a:accent3", "", _outStream);
    }


    if (m_has_accent4)
    {
        m_accent4->toXmlElem("a:accent4", "", _outStream);
    }


    if (m_has_accent5)
    {
        m_accent5->toXmlElem("a:accent5", "", _outStream);
    }


    if (m_has_accent6)
    {
        m_accent6->toXmlElem("a:accent6", "", _outStream);
    }


    if (m_has_hlink)
    {
        m_hlink->toXmlElem("a:hlink", "", _outStream);
    }


    if (m_has_folHlink)
    {
        m_folHlink->toXmlElem("a:folHlink", "", _outStream);
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_ColorScheme& CT_ColorScheme::default_instance()
{
    if (!CT_ColorScheme::default_instance_)
    {
        CT_ColorScheme::default_instance_ = new CT_ColorScheme();
    }
    return *CT_ColorScheme::default_instance_;
}

bool CT_ColorScheme::has_name_attr() const
{
    return m_has_name_attr;
}

void CT_ColorScheme::set_name_attr(const XSD::string_& _name_attr)
{
    m_has_name_attr = true;
    m_name_attr = _name_attr;
}

const XSD::string_& CT_ColorScheme::get_name_attr() const
{
    return m_name_attr;
}

CT_ColorScheme* CT_ColorScheme::default_instance_ = NULL;

// CT_CustomColor
CT_CustomColor::CT_CustomColor()
    :m_has_scrgbClr(false),
     m_scrgbClr(NULL),
     m_has_srgbClr(false),
     m_srgbClr(NULL),
     m_has_hslClr(false),
     m_hslClr(NULL),
     m_has_sysClr(false),
     m_sysClr(NULL),
     m_has_schemeClr(false),
     m_schemeClr(NULL),
     m_has_prstClr(false),
     m_prstClr(NULL),
     m_has_name_attr(false),
     m_name_attr("")
{
}
CT_CustomColor::~CT_CustomColor()
{
    clear();
}
bool CT_CustomColor::has_scrgbClr() const
{
    return m_has_scrgbClr;
}

CT_ScRgbColor* CT_CustomColor::mutable_scrgbClr()
{

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_scrgbClr = true;
    if (!m_scrgbClr)
    {
        m_scrgbClr = new CT_ScRgbColor();
    }
    return m_scrgbClr;
}

const CT_ScRgbColor& CT_CustomColor::get_scrgbClr() const
{
    if (m_scrgbClr)
    {
        return *m_scrgbClr;
    }
    return CT_ScRgbColor::default_instance();
}

bool CT_CustomColor::has_srgbClr() const
{
    return m_has_srgbClr;
}

CT_SRgbColor* CT_CustomColor::mutable_srgbClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_srgbClr = true;
    if (!m_srgbClr)
    {
        m_srgbClr = new CT_SRgbColor();
    }
    return m_srgbClr;
}

const CT_SRgbColor& CT_CustomColor::get_srgbClr() const
{
    if (m_srgbClr)
    {
        return *m_srgbClr;
    }
    return CT_SRgbColor::default_instance();
}

bool CT_CustomColor::has_hslClr() const
{
    return m_has_hslClr;
}

CT_HslColor* CT_CustomColor::mutable_hslClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_hslClr = true;
    if (!m_hslClr)
    {
        m_hslClr = new CT_HslColor();
    }
    return m_hslClr;
}

const CT_HslColor& CT_CustomColor::get_hslClr() const
{
    if (m_hslClr)
    {
        return *m_hslClr;
    }
    return CT_HslColor::default_instance();
}

bool CT_CustomColor::has_sysClr() const
{
    return m_has_sysClr;
}

CT_SystemColor* CT_CustomColor::mutable_sysClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_sysClr = true;
    if (!m_sysClr)
    {
        m_sysClr = new CT_SystemColor();
    }
    return m_sysClr;
}

const CT_SystemColor& CT_CustomColor::get_sysClr() const
{
    if (m_sysClr)
    {
        return *m_sysClr;
    }
    return CT_SystemColor::default_instance();
}

bool CT_CustomColor::has_schemeClr() const
{
    return m_has_schemeClr;
}

CT_SchemeColor* CT_CustomColor::mutable_schemeClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_schemeClr = true;
    if (!m_schemeClr)
    {
        m_schemeClr = new CT_SchemeColor();
    }
    return m_schemeClr;
}

const CT_SchemeColor& CT_CustomColor::get_schemeClr() const
{
    if (m_schemeClr)
    {
        return *m_schemeClr;
    }
    return CT_SchemeColor::default_instance();
}

bool CT_CustomColor::has_prstClr() const
{
    return m_has_prstClr;
}

CT_PresetColor* CT_CustomColor::mutable_prstClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = true;
    if (!m_prstClr)
    {
        m_prstClr = new CT_PresetColor();
    }
    return m_prstClr;
}

const CT_PresetColor& CT_CustomColor::get_prstClr() const
{
    if (m_prstClr)
    {
        return *m_prstClr;
    }
    return CT_PresetColor::default_instance();
}

void CT_CustomColor::clear()
{
    m_has_name_attr = false;
    m_name_attr.clear();

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }


    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }


    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }


    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }


    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }


    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }

}

void CT_CustomColor::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_name_attr)
    {
        _outStream << " " << "name" << "=\"" << m_name_attr << "\"";
    }

    _outStream << ">";

    {
        bool elemHasValueList[6] = {m_has_scrgbClr, m_has_srgbClr, m_has_hslClr, m_has_sysClr, m_has_schemeClr, m_has_prstClr};
        int cnt = count(elemHasValueList, elemHasValueList + 6, true);
        assert(cnt == 1);
    }


    if (m_has_scrgbClr)
    {
        m_scrgbClr->toXmlElem("a:scrgbClr", "", _outStream);
    }


    if (m_has_srgbClr)
    {
        m_srgbClr->toXmlElem("a:srgbClr", "", _outStream);
    }


    if (m_has_hslClr)
    {
        m_hslClr->toXmlElem("a:hslClr", "", _outStream);
    }


    if (m_has_sysClr)
    {
        m_sysClr->toXmlElem("a:sysClr", "", _outStream);
    }


    if (m_has_schemeClr)
    {
        m_schemeClr->toXmlElem("a:schemeClr", "", _outStream);
    }


    if (m_has_prstClr)
    {
        m_prstClr->toXmlElem("a:prstClr", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_CustomColor& CT_CustomColor::default_instance()
{
    if (!CT_CustomColor::default_instance_)
    {
        CT_CustomColor::default_instance_ = new CT_CustomColor();
    }
    return *CT_CustomColor::default_instance_;
}

bool CT_CustomColor::has_name_attr() const
{
    return m_has_name_attr;
}

void CT_CustomColor::set_name_attr(const XSD::string_& _name_attr)
{
    m_has_name_attr = true;
    m_name_attr = _name_attr;
}

const XSD::string_& CT_CustomColor::get_name_attr() const
{
    return m_name_attr;
}

CT_CustomColor* CT_CustomColor::default_instance_ = NULL;

// CT_SupplementalFont
CT_SupplementalFont::CT_SupplementalFont()
    :m_has_script_attr(false),
     m_script_attr(""),
     m_has_typeface_attr(false),
     m_typeface_attr(NULL)
{
}
CT_SupplementalFont::~CT_SupplementalFont()
{
    clear();
}
void CT_SupplementalFont::clear()
{
    m_has_script_attr = false;
    m_script_attr.clear();

    m_has_typeface_attr = false;

    if (m_typeface_attr)
    {
        delete m_typeface_attr;
        m_typeface_attr = NULL;
    }

}

void CT_SupplementalFont::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_script_attr);
    if (m_has_script_attr)
    {
        _outStream << " " << "script" << "=\"" << m_script_attr << "\"";
    }


    assert(m_has_typeface_attr);
    if (m_has_typeface_attr)
    {
        m_typeface_attr->toXmlAttr("typeface", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_SupplementalFont& CT_SupplementalFont::default_instance()
{
    if (!CT_SupplementalFont::default_instance_)
    {
        CT_SupplementalFont::default_instance_ = new CT_SupplementalFont();
    }
    return *CT_SupplementalFont::default_instance_;
}

bool CT_SupplementalFont::has_script_attr() const
{
    return m_has_script_attr;
}

void CT_SupplementalFont::set_script_attr(const XSD::string_& _script_attr)
{
    m_has_script_attr = true;
    m_script_attr = _script_attr;
}

const XSD::string_& CT_SupplementalFont::get_script_attr() const
{
    return m_script_attr;
}

bool CT_SupplementalFont::has_typeface_attr() const
{
    return m_has_typeface_attr;
}

void CT_SupplementalFont::set_typeface_attr(const ST_TextTypeface& _typeface_attr)
{
    m_has_typeface_attr = true;
    m_typeface_attr = new ST_TextTypeface(_typeface_attr);
}

const ST_TextTypeface& CT_SupplementalFont::get_typeface_attr() const
{
    if (m_typeface_attr)
    {
        return *m_typeface_attr;
    }
    return ST_TextTypeface::default_instance();
}

CT_SupplementalFont* CT_SupplementalFont::default_instance_ = NULL;

// CT_CustomColorList
CT_CustomColorList::CT_CustomColorList()

{
}
CT_CustomColorList::~CT_CustomColorList()
{
    clear();
}
CT_CustomColor* CT_CustomColorList::add_custClr()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_CustomColor* pNewChild = pChildGroup->mutable_custClr();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

void CT_CustomColorList::clear()
{
    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }
}

void CT_CustomColorList::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_custClr())
            {
                (*iter)->get_custClr().toXmlElem("a:custClr", "", _outStream);
            }


        }
    }

    _outStream << "</" << _elemName << ">";
}

const CT_CustomColorList& CT_CustomColorList::default_instance()
{
    if (!CT_CustomColorList::default_instance_)
    {
        CT_CustomColorList::default_instance_ = new CT_CustomColorList();
    }
    return *CT_CustomColorList::default_instance_;
}


// CT_CustomColorList::ChildGroup_1
CT_CustomColorList::ChildGroup_1::ChildGroup_1()
    :m_has_custClr(false),
     m_custClr(NULL)
{
}
bool CT_CustomColorList::ChildGroup_1::has_custClr() const
{
    return m_has_custClr;
}

CT_CustomColor* CT_CustomColorList::ChildGroup_1::mutable_custClr()
{

    m_has_custClr = true;
    if (!m_custClr)
    {
        m_custClr = new CT_CustomColor();
    }
    return m_custClr;
}

const CT_CustomColor& CT_CustomColorList::ChildGroup_1::get_custClr() const
{
    if (m_custClr)
    {
        return *m_custClr;
    }
    return CT_CustomColor::default_instance();
}

CT_CustomColorList* CT_CustomColorList::default_instance_ = NULL;

// CT_FontCollection
CT_FontCollection::CT_FontCollection()
    :m_has_latin(false),
     m_latin(NULL),
     m_has_ea(false),
     m_ea(NULL),
     m_has_cs(false),
     m_cs(NULL),
     m_has_extLst(false),
     m_extLst(NULL)
{
}
CT_FontCollection::~CT_FontCollection()
{
    clear();
}
bool CT_FontCollection::has_latin() const
{
    return m_has_latin;
}

CT_TextFont* CT_FontCollection::mutable_latin()
{
    m_has_latin = true;
    if (!m_latin)
    {
        m_latin = new CT_TextFont();
    }
    return m_latin;
}

const CT_TextFont& CT_FontCollection::get_latin() const
{
    if (m_latin)
    {
        return *m_latin;
    }
    return CT_TextFont::default_instance();
}

bool CT_FontCollection::has_ea() const
{
    return m_has_ea;
}

CT_TextFont* CT_FontCollection::mutable_ea()
{
    m_has_ea = true;
    if (!m_ea)
    {
        m_ea = new CT_TextFont();
    }
    return m_ea;
}

const CT_TextFont& CT_FontCollection::get_ea() const
{
    if (m_ea)
    {
        return *m_ea;
    }
    return CT_TextFont::default_instance();
}

bool CT_FontCollection::has_cs() const
{
    return m_has_cs;
}

CT_TextFont* CT_FontCollection::mutable_cs()
{
    m_has_cs = true;
    if (!m_cs)
    {
        m_cs = new CT_TextFont();
    }
    return m_cs;
}

const CT_TextFont& CT_FontCollection::get_cs() const
{
    if (m_cs)
    {
        return *m_cs;
    }
    return CT_TextFont::default_instance();
}

CT_SupplementalFont* CT_FontCollection::add_font()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_SupplementalFont* pNewChild = pChildGroup->mutable_font();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

bool CT_FontCollection::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_FontCollection::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_FontCollection::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_FontCollection::clear()
{
    m_has_latin = false;

    if (m_latin)
    {
        delete m_latin;
        m_latin = NULL;
    }


    m_has_ea = false;

    if (m_ea)
    {
        delete m_ea;
        m_ea = NULL;
    }


    m_has_cs = false;

    if (m_cs)
    {
        delete m_cs;
        m_cs = NULL;
    }


    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }

    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_FontCollection::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    assert(m_has_latin);


    assert(m_has_ea);


    assert(m_has_cs);


    if (m_has_latin)
    {
        m_latin->toXmlElem("a:latin", "", _outStream);
    }


    if (m_has_ea)
    {
        m_ea->toXmlElem("a:ea", "", _outStream);
    }


    if (m_has_cs)
    {
        m_cs->toXmlElem("a:cs", "", _outStream);
    }

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_font())
            {
                (*iter)->get_font().toXmlElem("a:font", "", _outStream);
            }


        }
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_FontCollection& CT_FontCollection::default_instance()
{
    if (!CT_FontCollection::default_instance_)
    {
        CT_FontCollection::default_instance_ = new CT_FontCollection();
    }
    return *CT_FontCollection::default_instance_;
}


// CT_FontCollection::ChildGroup_1
CT_FontCollection::ChildGroup_1::ChildGroup_1()
    :m_has_font(false),
     m_font(NULL)
{
}
bool CT_FontCollection::ChildGroup_1::has_font() const
{
    return m_has_font;
}

CT_SupplementalFont* CT_FontCollection::ChildGroup_1::mutable_font()
{

    m_has_font = true;
    if (!m_font)
    {
        m_font = new CT_SupplementalFont();
    }
    return m_font;
}

const CT_SupplementalFont& CT_FontCollection::ChildGroup_1::get_font() const
{
    if (m_font)
    {
        return *m_font;
    }
    return CT_SupplementalFont::default_instance();
}

CT_FontCollection* CT_FontCollection::default_instance_ = NULL;

// CT_EffectStyleItem
CT_EffectStyleItem::CT_EffectStyleItem()
    :m_has_effectLst(false),
     m_effectLst(NULL),
     m_has_effectDag(false),
     m_effectDag(NULL),
     m_has_scene3d(false),
     m_scene3d(NULL),
     m_has_sp3d(false),
     m_sp3d(NULL)
{
}
CT_EffectStyleItem::~CT_EffectStyleItem()
{
    clear();
}
bool CT_EffectStyleItem::has_effectLst() const
{
    return m_has_effectLst;
}

CT_EffectList* CT_EffectStyleItem::mutable_effectLst()
{

    m_has_effectDag = false;

    if (m_effectDag)
    {
        delete m_effectDag;
        m_effectDag = NULL;
    }
    ;

    m_has_effectLst = true;
    if (!m_effectLst)
    {
        m_effectLst = new CT_EffectList();
    }
    return m_effectLst;
}

const CT_EffectList& CT_EffectStyleItem::get_effectLst() const
{
    if (m_effectLst)
    {
        return *m_effectLst;
    }
    return CT_EffectList::default_instance();
}

bool CT_EffectStyleItem::has_effectDag() const
{
    return m_has_effectDag;
}

CT_EffectContainer* CT_EffectStyleItem::mutable_effectDag()
{

    m_has_effectLst = false;

    if (m_effectLst)
    {
        delete m_effectLst;
        m_effectLst = NULL;
    }
    ;

    m_has_effectDag = true;
    if (!m_effectDag)
    {
        m_effectDag = new CT_EffectContainer();
    }
    return m_effectDag;
}

const CT_EffectContainer& CT_EffectStyleItem::get_effectDag() const
{
    if (m_effectDag)
    {
        return *m_effectDag;
    }
    return CT_EffectContainer::default_instance();
}

bool CT_EffectStyleItem::has_scene3d() const
{
    return m_has_scene3d;
}

CT_Scene3D* CT_EffectStyleItem::mutable_scene3d()
{
    m_has_scene3d = true;
    if (!m_scene3d)
    {
        m_scene3d = new CT_Scene3D();
    }
    return m_scene3d;
}

const CT_Scene3D& CT_EffectStyleItem::get_scene3d() const
{
    if (m_scene3d)
    {
        return *m_scene3d;
    }
    return CT_Scene3D::default_instance();
}

bool CT_EffectStyleItem::has_sp3d() const
{
    return m_has_sp3d;
}

CT_Shape3D* CT_EffectStyleItem::mutable_sp3d()
{
    m_has_sp3d = true;
    if (!m_sp3d)
    {
        m_sp3d = new CT_Shape3D();
    }
    return m_sp3d;
}

const CT_Shape3D& CT_EffectStyleItem::get_sp3d() const
{
    if (m_sp3d)
    {
        return *m_sp3d;
    }
    return CT_Shape3D::default_instance();
}

void CT_EffectStyleItem::clear()
{
    m_has_effectLst = false;

    if (m_effectLst)
    {
        delete m_effectLst;
        m_effectLst = NULL;
    }


    m_has_effectDag = false;

    if (m_effectDag)
    {
        delete m_effectDag;
        m_effectDag = NULL;
    }


    m_has_scene3d = false;

    if (m_scene3d)
    {
        delete m_scene3d;
        m_scene3d = NULL;
    }


    m_has_sp3d = false;

    if (m_sp3d)
    {
        delete m_sp3d;
        m_sp3d = NULL;
    }

}

void CT_EffectStyleItem::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    {
        bool elemHasValueList[2] = {m_has_effectLst, m_has_effectDag};
        int cnt = count(elemHasValueList, elemHasValueList + 2, true);
        assert(cnt == 1);
    }


    if (m_has_effectLst)
    {
        m_effectLst->toXmlElem("a:effectLst", "", _outStream);
    }


    if (m_has_effectDag)
    {
        m_effectDag->toXmlElem("a:effectDag", "", _outStream);
    }


    if (m_has_scene3d)
    {
        m_scene3d->toXmlElem("a:scene3d", "", _outStream);
    }


    if (m_has_sp3d)
    {
        m_sp3d->toXmlElem("a:sp3d", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_EffectStyleItem& CT_EffectStyleItem::default_instance()
{
    if (!CT_EffectStyleItem::default_instance_)
    {
        CT_EffectStyleItem::default_instance_ = new CT_EffectStyleItem();
    }
    return *CT_EffectStyleItem::default_instance_;
}

CT_EffectStyleItem* CT_EffectStyleItem::default_instance_ = NULL;

// CT_FontScheme
CT_FontScheme::CT_FontScheme()
    :m_has_majorFont(false),
     m_majorFont(NULL),
     m_has_minorFont(false),
     m_minorFont(NULL),
     m_has_extLst(false),
     m_extLst(NULL),
     m_has_name_attr(false),
     m_name_attr("")
{
}
CT_FontScheme::~CT_FontScheme()
{
    clear();
}
bool CT_FontScheme::has_majorFont() const
{
    return m_has_majorFont;
}

CT_FontCollection* CT_FontScheme::mutable_majorFont()
{
    m_has_majorFont = true;
    if (!m_majorFont)
    {
        m_majorFont = new CT_FontCollection();
    }
    return m_majorFont;
}

const CT_FontCollection& CT_FontScheme::get_majorFont() const
{
    if (m_majorFont)
    {
        return *m_majorFont;
    }
    return CT_FontCollection::default_instance();
}

bool CT_FontScheme::has_minorFont() const
{
    return m_has_minorFont;
}

CT_FontCollection* CT_FontScheme::mutable_minorFont()
{
    m_has_minorFont = true;
    if (!m_minorFont)
    {
        m_minorFont = new CT_FontCollection();
    }
    return m_minorFont;
}

const CT_FontCollection& CT_FontScheme::get_minorFont() const
{
    if (m_minorFont)
    {
        return *m_minorFont;
    }
    return CT_FontCollection::default_instance();
}

bool CT_FontScheme::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_FontScheme::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_FontScheme::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_FontScheme::clear()
{
    m_has_name_attr = false;
    m_name_attr.clear();

    m_has_majorFont = false;

    if (m_majorFont)
    {
        delete m_majorFont;
        m_majorFont = NULL;
    }


    m_has_minorFont = false;

    if (m_minorFont)
    {
        delete m_minorFont;
        m_minorFont = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_FontScheme::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_name_attr);
    if (m_has_name_attr)
    {
        _outStream << " " << "name" << "=\"" << m_name_attr << "\"";
    }

    _outStream << ">";

    assert(m_has_majorFont);


    assert(m_has_minorFont);


    if (m_has_majorFont)
    {
        m_majorFont->toXmlElem("a:majorFont", "", _outStream);
    }


    if (m_has_minorFont)
    {
        m_minorFont->toXmlElem("a:minorFont", "", _outStream);
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_FontScheme& CT_FontScheme::default_instance()
{
    if (!CT_FontScheme::default_instance_)
    {
        CT_FontScheme::default_instance_ = new CT_FontScheme();
    }
    return *CT_FontScheme::default_instance_;
}

bool CT_FontScheme::has_name_attr() const
{
    return m_has_name_attr;
}

void CT_FontScheme::set_name_attr(const XSD::string_& _name_attr)
{
    m_has_name_attr = true;
    m_name_attr = _name_attr;
}

const XSD::string_& CT_FontScheme::get_name_attr() const
{
    return m_name_attr;
}

CT_FontScheme* CT_FontScheme::default_instance_ = NULL;

// CT_FillStyleList
CT_FillStyleList::CT_FillStyleList()

{
}
CT_FillStyleList::~CT_FillStyleList()
{
    clear();
}
CT_NoFillProperties* CT_FillStyleList::add_noFill()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_NoFillProperties* pNewChild = pChildGroup->mutable_noFill();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_SolidColorFillProperties* CT_FillStyleList::add_solidFill()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_SolidColorFillProperties* pNewChild = pChildGroup->mutable_solidFill();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_GradientFillProperties* CT_FillStyleList::add_gradFill()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_GradientFillProperties* pNewChild = pChildGroup->mutable_gradFill();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_BlipFillProperties* CT_FillStyleList::add_blipFill()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_BlipFillProperties* pNewChild = pChildGroup->mutable_blipFill();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_PatternFillProperties* CT_FillStyleList::add_pattFill()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PatternFillProperties* pNewChild = pChildGroup->mutable_pattFill();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_GroupFillProperties* CT_FillStyleList::add_grpFill()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_GroupFillProperties* pNewChild = pChildGroup->mutable_grpFill();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

void CT_FillStyleList::clear()
{
    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }
}

void CT_FillStyleList::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_noFill())
            {
                (*iter)->get_noFill().toXmlElem("a:noFill", "", _outStream);
            }


            else if ((*iter)->has_solidFill())
            {
                (*iter)->get_solidFill().toXmlElem("a:solidFill", "", _outStream);
            }


            else if ((*iter)->has_gradFill())
            {
                (*iter)->get_gradFill().toXmlElem("a:gradFill", "", _outStream);
            }


            else if ((*iter)->has_blipFill())
            {
                (*iter)->get_blipFill().toXmlElem("a:blipFill", "", _outStream);
            }


            else if ((*iter)->has_pattFill())
            {
                (*iter)->get_pattFill().toXmlElem("a:pattFill", "", _outStream);
            }


            else if ((*iter)->has_grpFill())
            {
                (*iter)->get_grpFill().toXmlElem("a:grpFill", "", _outStream);
            }


        }
    }

    _outStream << "</" << _elemName << ">";
}

const CT_FillStyleList& CT_FillStyleList::default_instance()
{
    if (!CT_FillStyleList::default_instance_)
    {
        CT_FillStyleList::default_instance_ = new CT_FillStyleList();
    }
    return *CT_FillStyleList::default_instance_;
}


// CT_FillStyleList::ChildGroup_1
CT_FillStyleList::ChildGroup_1::ChildGroup_1()
    :m_has_noFill(false),
     m_noFill(NULL),
     m_has_solidFill(false),
     m_solidFill(NULL),
     m_has_gradFill(false),
     m_gradFill(NULL),
     m_has_blipFill(false),
     m_blipFill(NULL),
     m_has_pattFill(false),
     m_pattFill(NULL),
     m_has_grpFill(false),
     m_grpFill(NULL)
{
}
bool CT_FillStyleList::ChildGroup_1::has_noFill() const
{
    return m_has_noFill;
}

CT_NoFillProperties* CT_FillStyleList::ChildGroup_1::mutable_noFill()
{

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_noFill = true;
    if (!m_noFill)
    {
        m_noFill = new CT_NoFillProperties();
    }
    return m_noFill;
}

const CT_NoFillProperties& CT_FillStyleList::ChildGroup_1::get_noFill() const
{
    if (m_noFill)
    {
        return *m_noFill;
    }
    return CT_NoFillProperties::default_instance();
}

bool CT_FillStyleList::ChildGroup_1::has_solidFill() const
{
    return m_has_solidFill;
}

CT_SolidColorFillProperties* CT_FillStyleList::ChildGroup_1::mutable_solidFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_solidFill = true;
    if (!m_solidFill)
    {
        m_solidFill = new CT_SolidColorFillProperties();
    }
    return m_solidFill;
}

const CT_SolidColorFillProperties& CT_FillStyleList::ChildGroup_1::get_solidFill() const
{
    if (m_solidFill)
    {
        return *m_solidFill;
    }
    return CT_SolidColorFillProperties::default_instance();
}

bool CT_FillStyleList::ChildGroup_1::has_gradFill() const
{
    return m_has_gradFill;
}

CT_GradientFillProperties* CT_FillStyleList::ChildGroup_1::mutable_gradFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_gradFill = true;
    if (!m_gradFill)
    {
        m_gradFill = new CT_GradientFillProperties();
    }
    return m_gradFill;
}

const CT_GradientFillProperties& CT_FillStyleList::ChildGroup_1::get_gradFill() const
{
    if (m_gradFill)
    {
        return *m_gradFill;
    }
    return CT_GradientFillProperties::default_instance();
}

bool CT_FillStyleList::ChildGroup_1::has_blipFill() const
{
    return m_has_blipFill;
}

CT_BlipFillProperties* CT_FillStyleList::ChildGroup_1::mutable_blipFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_blipFill = true;
    if (!m_blipFill)
    {
        m_blipFill = new CT_BlipFillProperties();
    }
    return m_blipFill;
}

const CT_BlipFillProperties& CT_FillStyleList::ChildGroup_1::get_blipFill() const
{
    if (m_blipFill)
    {
        return *m_blipFill;
    }
    return CT_BlipFillProperties::default_instance();
}

bool CT_FillStyleList::ChildGroup_1::has_pattFill() const
{
    return m_has_pattFill;
}

CT_PatternFillProperties* CT_FillStyleList::ChildGroup_1::mutable_pattFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_pattFill = true;
    if (!m_pattFill)
    {
        m_pattFill = new CT_PatternFillProperties();
    }
    return m_pattFill;
}

const CT_PatternFillProperties& CT_FillStyleList::ChildGroup_1::get_pattFill() const
{
    if (m_pattFill)
    {
        return *m_pattFill;
    }
    return CT_PatternFillProperties::default_instance();
}

bool CT_FillStyleList::ChildGroup_1::has_grpFill() const
{
    return m_has_grpFill;
}

CT_GroupFillProperties* CT_FillStyleList::ChildGroup_1::mutable_grpFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = true;
    if (!m_grpFill)
    {
        m_grpFill = new CT_GroupFillProperties();
    }
    return m_grpFill;
}

const CT_GroupFillProperties& CT_FillStyleList::ChildGroup_1::get_grpFill() const
{
    if (m_grpFill)
    {
        return *m_grpFill;
    }
    return CT_GroupFillProperties::default_instance();
}

CT_FillStyleList* CT_FillStyleList::default_instance_ = NULL;

// CT_LineStyleList
CT_LineStyleList::CT_LineStyleList()

{
}
CT_LineStyleList::~CT_LineStyleList()
{
    clear();
}
CT_LineProperties* CT_LineStyleList::add_ln()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_LineProperties* pNewChild = pChildGroup->mutable_ln();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

void CT_LineStyleList::clear()
{
    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }
}

void CT_LineStyleList::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    {
        int elemCnt = count_if(m_childGroupList_1.begin(), m_childGroupList_1.end(), mem_fun(&ChildGroup_1::has_ln));
        assert(3 <= elemCnt);
    }

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_ln())
            {
                (*iter)->get_ln().toXmlElem("a:ln", "", _outStream);
            }


        }
    }

    _outStream << "</" << _elemName << ">";
}

const CT_LineStyleList& CT_LineStyleList::default_instance()
{
    if (!CT_LineStyleList::default_instance_)
    {
        CT_LineStyleList::default_instance_ = new CT_LineStyleList();
    }
    return *CT_LineStyleList::default_instance_;
}


// CT_LineStyleList::ChildGroup_1
CT_LineStyleList::ChildGroup_1::ChildGroup_1()
    :m_has_ln(false),
     m_ln(NULL)
{
}
bool CT_LineStyleList::ChildGroup_1::has_ln() const
{
    return m_has_ln;
}

CT_LineProperties* CT_LineStyleList::ChildGroup_1::mutable_ln()
{

    m_has_ln = true;
    if (!m_ln)
    {
        m_ln = new CT_LineProperties();
    }
    return m_ln;
}

const CT_LineProperties& CT_LineStyleList::ChildGroup_1::get_ln() const
{
    if (m_ln)
    {
        return *m_ln;
    }
    return CT_LineProperties::default_instance();
}

CT_LineStyleList* CT_LineStyleList::default_instance_ = NULL;

// CT_EffectStyleList
CT_EffectStyleList::CT_EffectStyleList()

{
}
CT_EffectStyleList::~CT_EffectStyleList()
{
    clear();
}
CT_EffectStyleItem* CT_EffectStyleList::add_effectStyle()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_EffectStyleItem* pNewChild = pChildGroup->mutable_effectStyle();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

void CT_EffectStyleList::clear()
{
    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }
}

void CT_EffectStyleList::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    {
        int elemCnt = count_if(m_childGroupList_1.begin(), m_childGroupList_1.end(), mem_fun(&ChildGroup_1::has_effectStyle));
        assert(3 <= elemCnt);
    }

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_effectStyle())
            {
                (*iter)->get_effectStyle().toXmlElem("a:effectStyle", "", _outStream);
            }


        }
    }

    _outStream << "</" << _elemName << ">";
}

const CT_EffectStyleList& CT_EffectStyleList::default_instance()
{
    if (!CT_EffectStyleList::default_instance_)
    {
        CT_EffectStyleList::default_instance_ = new CT_EffectStyleList();
    }
    return *CT_EffectStyleList::default_instance_;
}


// CT_EffectStyleList::ChildGroup_1
CT_EffectStyleList::ChildGroup_1::ChildGroup_1()
    :m_has_effectStyle(false),
     m_effectStyle(NULL)
{
}
bool CT_EffectStyleList::ChildGroup_1::has_effectStyle() const
{
    return m_has_effectStyle;
}

CT_EffectStyleItem* CT_EffectStyleList::ChildGroup_1::mutable_effectStyle()
{

    m_has_effectStyle = true;
    if (!m_effectStyle)
    {
        m_effectStyle = new CT_EffectStyleItem();
    }
    return m_effectStyle;
}

const CT_EffectStyleItem& CT_EffectStyleList::ChildGroup_1::get_effectStyle() const
{
    if (m_effectStyle)
    {
        return *m_effectStyle;
    }
    return CT_EffectStyleItem::default_instance();
}

CT_EffectStyleList* CT_EffectStyleList::default_instance_ = NULL;

// CT_BackgroundFillStyleList
CT_BackgroundFillStyleList::CT_BackgroundFillStyleList()

{
}
CT_BackgroundFillStyleList::~CT_BackgroundFillStyleList()
{
    clear();
}
CT_NoFillProperties* CT_BackgroundFillStyleList::add_noFill()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_NoFillProperties* pNewChild = pChildGroup->mutable_noFill();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_SolidColorFillProperties* CT_BackgroundFillStyleList::add_solidFill()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_SolidColorFillProperties* pNewChild = pChildGroup->mutable_solidFill();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_GradientFillProperties* CT_BackgroundFillStyleList::add_gradFill()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_GradientFillProperties* pNewChild = pChildGroup->mutable_gradFill();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_BlipFillProperties* CT_BackgroundFillStyleList::add_blipFill()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_BlipFillProperties* pNewChild = pChildGroup->mutable_blipFill();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_PatternFillProperties* CT_BackgroundFillStyleList::add_pattFill()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PatternFillProperties* pNewChild = pChildGroup->mutable_pattFill();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_GroupFillProperties* CT_BackgroundFillStyleList::add_grpFill()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_GroupFillProperties* pNewChild = pChildGroup->mutable_grpFill();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

void CT_BackgroundFillStyleList::clear()
{
    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }
}

void CT_BackgroundFillStyleList::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_noFill())
            {
                (*iter)->get_noFill().toXmlElem("a:noFill", "", _outStream);
            }


            else if ((*iter)->has_solidFill())
            {
                (*iter)->get_solidFill().toXmlElem("a:solidFill", "", _outStream);
            }


            else if ((*iter)->has_gradFill())
            {
                (*iter)->get_gradFill().toXmlElem("a:gradFill", "", _outStream);
            }


            else if ((*iter)->has_blipFill())
            {
                (*iter)->get_blipFill().toXmlElem("a:blipFill", "", _outStream);
            }


            else if ((*iter)->has_pattFill())
            {
                (*iter)->get_pattFill().toXmlElem("a:pattFill", "", _outStream);
            }


            else if ((*iter)->has_grpFill())
            {
                (*iter)->get_grpFill().toXmlElem("a:grpFill", "", _outStream);
            }


        }
    }

    _outStream << "</" << _elemName << ">";
}

const CT_BackgroundFillStyleList& CT_BackgroundFillStyleList::default_instance()
{
    if (!CT_BackgroundFillStyleList::default_instance_)
    {
        CT_BackgroundFillStyleList::default_instance_ = new CT_BackgroundFillStyleList();
    }
    return *CT_BackgroundFillStyleList::default_instance_;
}


// CT_BackgroundFillStyleList::ChildGroup_1
CT_BackgroundFillStyleList::ChildGroup_1::ChildGroup_1()
    :m_has_noFill(false),
     m_noFill(NULL),
     m_has_solidFill(false),
     m_solidFill(NULL),
     m_has_gradFill(false),
     m_gradFill(NULL),
     m_has_blipFill(false),
     m_blipFill(NULL),
     m_has_pattFill(false),
     m_pattFill(NULL),
     m_has_grpFill(false),
     m_grpFill(NULL)
{
}
bool CT_BackgroundFillStyleList::ChildGroup_1::has_noFill() const
{
    return m_has_noFill;
}

CT_NoFillProperties* CT_BackgroundFillStyleList::ChildGroup_1::mutable_noFill()
{

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_noFill = true;
    if (!m_noFill)
    {
        m_noFill = new CT_NoFillProperties();
    }
    return m_noFill;
}

const CT_NoFillProperties& CT_BackgroundFillStyleList::ChildGroup_1::get_noFill() const
{
    if (m_noFill)
    {
        return *m_noFill;
    }
    return CT_NoFillProperties::default_instance();
}

bool CT_BackgroundFillStyleList::ChildGroup_1::has_solidFill() const
{
    return m_has_solidFill;
}

CT_SolidColorFillProperties* CT_BackgroundFillStyleList::ChildGroup_1::mutable_solidFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_solidFill = true;
    if (!m_solidFill)
    {
        m_solidFill = new CT_SolidColorFillProperties();
    }
    return m_solidFill;
}

const CT_SolidColorFillProperties& CT_BackgroundFillStyleList::ChildGroup_1::get_solidFill() const
{
    if (m_solidFill)
    {
        return *m_solidFill;
    }
    return CT_SolidColorFillProperties::default_instance();
}

bool CT_BackgroundFillStyleList::ChildGroup_1::has_gradFill() const
{
    return m_has_gradFill;
}

CT_GradientFillProperties* CT_BackgroundFillStyleList::ChildGroup_1::mutable_gradFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_gradFill = true;
    if (!m_gradFill)
    {
        m_gradFill = new CT_GradientFillProperties();
    }
    return m_gradFill;
}

const CT_GradientFillProperties& CT_BackgroundFillStyleList::ChildGroup_1::get_gradFill() const
{
    if (m_gradFill)
    {
        return *m_gradFill;
    }
    return CT_GradientFillProperties::default_instance();
}

bool CT_BackgroundFillStyleList::ChildGroup_1::has_blipFill() const
{
    return m_has_blipFill;
}

CT_BlipFillProperties* CT_BackgroundFillStyleList::ChildGroup_1::mutable_blipFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_blipFill = true;
    if (!m_blipFill)
    {
        m_blipFill = new CT_BlipFillProperties();
    }
    return m_blipFill;
}

const CT_BlipFillProperties& CT_BackgroundFillStyleList::ChildGroup_1::get_blipFill() const
{
    if (m_blipFill)
    {
        return *m_blipFill;
    }
    return CT_BlipFillProperties::default_instance();
}

bool CT_BackgroundFillStyleList::ChildGroup_1::has_pattFill() const
{
    return m_has_pattFill;
}

CT_PatternFillProperties* CT_BackgroundFillStyleList::ChildGroup_1::mutable_pattFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_pattFill = true;
    if (!m_pattFill)
    {
        m_pattFill = new CT_PatternFillProperties();
    }
    return m_pattFill;
}

const CT_PatternFillProperties& CT_BackgroundFillStyleList::ChildGroup_1::get_pattFill() const
{
    if (m_pattFill)
    {
        return *m_pattFill;
    }
    return CT_PatternFillProperties::default_instance();
}

bool CT_BackgroundFillStyleList::ChildGroup_1::has_grpFill() const
{
    return m_has_grpFill;
}

CT_GroupFillProperties* CT_BackgroundFillStyleList::ChildGroup_1::mutable_grpFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = true;
    if (!m_grpFill)
    {
        m_grpFill = new CT_GroupFillProperties();
    }
    return m_grpFill;
}

const CT_GroupFillProperties& CT_BackgroundFillStyleList::ChildGroup_1::get_grpFill() const
{
    if (m_grpFill)
    {
        return *m_grpFill;
    }
    return CT_GroupFillProperties::default_instance();
}

CT_BackgroundFillStyleList* CT_BackgroundFillStyleList::default_instance_ = NULL;

// CT_StyleMatrix
CT_StyleMatrix::CT_StyleMatrix()
    :m_has_fillStyleLst(false),
     m_fillStyleLst(NULL),
     m_has_lnStyleLst(false),
     m_lnStyleLst(NULL),
     m_has_effectStyleLst(false),
     m_effectStyleLst(NULL),
     m_has_bgFillStyleLst(false),
     m_bgFillStyleLst(NULL),
     m_has_name_attr(false),
     m_name_attr("")
{
}
CT_StyleMatrix::~CT_StyleMatrix()
{
    clear();
}
bool CT_StyleMatrix::has_fillStyleLst() const
{
    return m_has_fillStyleLst;
}

CT_FillStyleList* CT_StyleMatrix::mutable_fillStyleLst()
{
    m_has_fillStyleLst = true;
    if (!m_fillStyleLst)
    {
        m_fillStyleLst = new CT_FillStyleList();
    }
    return m_fillStyleLst;
}

const CT_FillStyleList& CT_StyleMatrix::get_fillStyleLst() const
{
    if (m_fillStyleLst)
    {
        return *m_fillStyleLst;
    }
    return CT_FillStyleList::default_instance();
}

bool CT_StyleMatrix::has_lnStyleLst() const
{
    return m_has_lnStyleLst;
}

CT_LineStyleList* CT_StyleMatrix::mutable_lnStyleLst()
{
    m_has_lnStyleLst = true;
    if (!m_lnStyleLst)
    {
        m_lnStyleLst = new CT_LineStyleList();
    }
    return m_lnStyleLst;
}

const CT_LineStyleList& CT_StyleMatrix::get_lnStyleLst() const
{
    if (m_lnStyleLst)
    {
        return *m_lnStyleLst;
    }
    return CT_LineStyleList::default_instance();
}

bool CT_StyleMatrix::has_effectStyleLst() const
{
    return m_has_effectStyleLst;
}

CT_EffectStyleList* CT_StyleMatrix::mutable_effectStyleLst()
{
    m_has_effectStyleLst = true;
    if (!m_effectStyleLst)
    {
        m_effectStyleLst = new CT_EffectStyleList();
    }
    return m_effectStyleLst;
}

const CT_EffectStyleList& CT_StyleMatrix::get_effectStyleLst() const
{
    if (m_effectStyleLst)
    {
        return *m_effectStyleLst;
    }
    return CT_EffectStyleList::default_instance();
}

bool CT_StyleMatrix::has_bgFillStyleLst() const
{
    return m_has_bgFillStyleLst;
}

CT_BackgroundFillStyleList* CT_StyleMatrix::mutable_bgFillStyleLst()
{
    m_has_bgFillStyleLst = true;
    if (!m_bgFillStyleLst)
    {
        m_bgFillStyleLst = new CT_BackgroundFillStyleList();
    }
    return m_bgFillStyleLst;
}

const CT_BackgroundFillStyleList& CT_StyleMatrix::get_bgFillStyleLst() const
{
    if (m_bgFillStyleLst)
    {
        return *m_bgFillStyleLst;
    }
    return CT_BackgroundFillStyleList::default_instance();
}

void CT_StyleMatrix::clear()
{
    m_has_name_attr = false;
    m_name_attr.clear();

    m_has_fillStyleLst = false;

    if (m_fillStyleLst)
    {
        delete m_fillStyleLst;
        m_fillStyleLst = NULL;
    }


    m_has_lnStyleLst = false;

    if (m_lnStyleLst)
    {
        delete m_lnStyleLst;
        m_lnStyleLst = NULL;
    }


    m_has_effectStyleLst = false;

    if (m_effectStyleLst)
    {
        delete m_effectStyleLst;
        m_effectStyleLst = NULL;
    }


    m_has_bgFillStyleLst = false;

    if (m_bgFillStyleLst)
    {
        delete m_bgFillStyleLst;
        m_bgFillStyleLst = NULL;
    }

}

void CT_StyleMatrix::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_name_attr)
    {
        _outStream << " " << "name" << "=\"" << m_name_attr << "\"";
    }

    _outStream << ">";

    assert(m_has_fillStyleLst);


    assert(m_has_lnStyleLst);


    assert(m_has_effectStyleLst);


    assert(m_has_bgFillStyleLst);


    if (m_has_fillStyleLst)
    {
        m_fillStyleLst->toXmlElem("a:fillStyleLst", "", _outStream);
    }


    if (m_has_lnStyleLst)
    {
        m_lnStyleLst->toXmlElem("a:lnStyleLst", "", _outStream);
    }


    if (m_has_effectStyleLst)
    {
        m_effectStyleLst->toXmlElem("a:effectStyleLst", "", _outStream);
    }


    if (m_has_bgFillStyleLst)
    {
        m_bgFillStyleLst->toXmlElem("a:bgFillStyleLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_StyleMatrix& CT_StyleMatrix::default_instance()
{
    if (!CT_StyleMatrix::default_instance_)
    {
        CT_StyleMatrix::default_instance_ = new CT_StyleMatrix();
    }
    return *CT_StyleMatrix::default_instance_;
}

bool CT_StyleMatrix::has_name_attr() const
{
    return m_has_name_attr;
}

void CT_StyleMatrix::set_name_attr(const XSD::string_& _name_attr)
{
    m_has_name_attr = true;
    m_name_attr = _name_attr;
}

const XSD::string_& CT_StyleMatrix::get_name_attr() const
{
    return m_name_attr;
}

CT_StyleMatrix* CT_StyleMatrix::default_instance_ = NULL;

// CT_BaseStyles
CT_BaseStyles::CT_BaseStyles()
    :m_has_clrScheme(false),
     m_clrScheme(NULL),
     m_has_fontScheme(false),
     m_fontScheme(NULL),
     m_has_fmtScheme(false),
     m_fmtScheme(NULL),
     m_has_extLst(false),
     m_extLst(NULL)
{
}
CT_BaseStyles::~CT_BaseStyles()
{
    clear();
}
bool CT_BaseStyles::has_clrScheme() const
{
    return m_has_clrScheme;
}

CT_ColorScheme* CT_BaseStyles::mutable_clrScheme()
{
    m_has_clrScheme = true;
    if (!m_clrScheme)
    {
        m_clrScheme = new CT_ColorScheme();
    }
    return m_clrScheme;
}

const CT_ColorScheme& CT_BaseStyles::get_clrScheme() const
{
    if (m_clrScheme)
    {
        return *m_clrScheme;
    }
    return CT_ColorScheme::default_instance();
}

bool CT_BaseStyles::has_fontScheme() const
{
    return m_has_fontScheme;
}

CT_FontScheme* CT_BaseStyles::mutable_fontScheme()
{
    m_has_fontScheme = true;
    if (!m_fontScheme)
    {
        m_fontScheme = new CT_FontScheme();
    }
    return m_fontScheme;
}

const CT_FontScheme& CT_BaseStyles::get_fontScheme() const
{
    if (m_fontScheme)
    {
        return *m_fontScheme;
    }
    return CT_FontScheme::default_instance();
}

bool CT_BaseStyles::has_fmtScheme() const
{
    return m_has_fmtScheme;
}

CT_StyleMatrix* CT_BaseStyles::mutable_fmtScheme()
{
    m_has_fmtScheme = true;
    if (!m_fmtScheme)
    {
        m_fmtScheme = new CT_StyleMatrix();
    }
    return m_fmtScheme;
}

const CT_StyleMatrix& CT_BaseStyles::get_fmtScheme() const
{
    if (m_fmtScheme)
    {
        return *m_fmtScheme;
    }
    return CT_StyleMatrix::default_instance();
}

bool CT_BaseStyles::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_BaseStyles::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_BaseStyles::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_BaseStyles::clear()
{
    m_has_clrScheme = false;

    if (m_clrScheme)
    {
        delete m_clrScheme;
        m_clrScheme = NULL;
    }


    m_has_fontScheme = false;

    if (m_fontScheme)
    {
        delete m_fontScheme;
        m_fontScheme = NULL;
    }


    m_has_fmtScheme = false;

    if (m_fmtScheme)
    {
        delete m_fmtScheme;
        m_fmtScheme = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_BaseStyles::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    assert(m_has_clrScheme);


    assert(m_has_fontScheme);


    assert(m_has_fmtScheme);


    if (m_has_clrScheme)
    {
        m_clrScheme->toXmlElem("a:clrScheme", "", _outStream);
    }


    if (m_has_fontScheme)
    {
        m_fontScheme->toXmlElem("a:fontScheme", "", _outStream);
    }


    if (m_has_fmtScheme)
    {
        m_fmtScheme->toXmlElem("a:fmtScheme", "", _outStream);
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_BaseStyles& CT_BaseStyles::default_instance()
{
    if (!CT_BaseStyles::default_instance_)
    {
        CT_BaseStyles::default_instance_ = new CT_BaseStyles();
    }
    return *CT_BaseStyles::default_instance_;
}

CT_BaseStyles* CT_BaseStyles::default_instance_ = NULL;

// CT_OfficeArtExtension
CT_OfficeArtExtension::CT_OfficeArtExtension()
    :m_has__any(false),
     m__any(NULL),
     m_has_uri_attr(false),
     m_uri_attr("")
{
}
CT_OfficeArtExtension::~CT_OfficeArtExtension()
{
    clear();
}
void CT_OfficeArtExtension::clear()
{
    m_has_uri_attr = false;
    m_uri_attr.clear();
}

void CT_OfficeArtExtension::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_uri_attr);
    if (m_has_uri_attr)
    {
        _outStream << " " << "uri" << "=\"" << m_uri_attr << "\"";
    }

    _outStream << ">";


    if (m_has__any)
    {
        m__any->toXml(_outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_OfficeArtExtension& CT_OfficeArtExtension::default_instance()
{
    if (!CT_OfficeArtExtension::default_instance_)
    {
        CT_OfficeArtExtension::default_instance_ = new CT_OfficeArtExtension();
    }
    return *CT_OfficeArtExtension::default_instance_;
}

bool CT_OfficeArtExtension::has_uri_attr() const
{
    return m_has_uri_attr;
}

void CT_OfficeArtExtension::set_uri_attr(const XSD::token_& _uri_attr)
{
    m_has_uri_attr = true;
    m_uri_attr = _uri_attr;
}

const XSD::token_& CT_OfficeArtExtension::get_uri_attr() const
{
    return m_uri_attr;
}

CT_OfficeArtExtension* CT_OfficeArtExtension::default_instance_ = NULL;

// CT_Angle
CT_Angle::CT_Angle()
    :m_has_val_attr(false),
     m_val_attr(NULL)
{
}
CT_Angle::~CT_Angle()
{
    clear();
}
void CT_Angle::clear()
{
    m_has_val_attr = false;

    if (m_val_attr)
    {
        delete m_val_attr;
        m_val_attr = NULL;
    }

}

void CT_Angle::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_val_attr);
    if (m_has_val_attr)
    {
        m_val_attr->toXmlAttr("val", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_Angle& CT_Angle::default_instance()
{
    if (!CT_Angle::default_instance_)
    {
        CT_Angle::default_instance_ = new CT_Angle();
    }
    return *CT_Angle::default_instance_;
}

bool CT_Angle::has_val_attr() const
{
    return m_has_val_attr;
}

void CT_Angle::set_val_attr(const ST_Angle& _val_attr)
{
    m_has_val_attr = true;
    m_val_attr = new ST_Angle(_val_attr);
}

const ST_Angle& CT_Angle::get_val_attr() const
{
    if (m_val_attr)
    {
        return *m_val_attr;
    }
    return ST_Angle::default_instance();
}

CT_Angle* CT_Angle::default_instance_ = NULL;

// CT_PositiveFixedAngle
CT_PositiveFixedAngle::CT_PositiveFixedAngle()
    :m_has_val_attr(false),
     m_val_attr(NULL)
{
}
CT_PositiveFixedAngle::~CT_PositiveFixedAngle()
{
    clear();
}
void CT_PositiveFixedAngle::clear()
{
    m_has_val_attr = false;

    if (m_val_attr)
    {
        delete m_val_attr;
        m_val_attr = NULL;
    }

}

void CT_PositiveFixedAngle::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_val_attr);
    if (m_has_val_attr)
    {
        m_val_attr->toXmlAttr("val", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_PositiveFixedAngle& CT_PositiveFixedAngle::default_instance()
{
    if (!CT_PositiveFixedAngle::default_instance_)
    {
        CT_PositiveFixedAngle::default_instance_ = new CT_PositiveFixedAngle();
    }
    return *CT_PositiveFixedAngle::default_instance_;
}

bool CT_PositiveFixedAngle::has_val_attr() const
{
    return m_has_val_attr;
}

void CT_PositiveFixedAngle::set_val_attr(const ST_PositiveFixedAngle& _val_attr)
{
    m_has_val_attr = true;
    m_val_attr = new ST_PositiveFixedAngle(_val_attr);
}

const ST_PositiveFixedAngle& CT_PositiveFixedAngle::get_val_attr() const
{
    if (m_val_attr)
    {
        return *m_val_attr;
    }
    return ST_PositiveFixedAngle::default_instance();
}

CT_PositiveFixedAngle* CT_PositiveFixedAngle::default_instance_ = NULL;

// CT_Percentage
CT_Percentage::CT_Percentage()
    :m_has_val_attr(false),
     m_val_attr(NULL)
{
}
CT_Percentage::~CT_Percentage()
{
    clear();
}
void CT_Percentage::clear()
{
    m_has_val_attr = false;

    if (m_val_attr)
    {
        delete m_val_attr;
        m_val_attr = NULL;
    }

}

void CT_Percentage::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_val_attr);
    if (m_has_val_attr)
    {
        m_val_attr->toXmlAttr("val", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_Percentage& CT_Percentage::default_instance()
{
    if (!CT_Percentage::default_instance_)
    {
        CT_Percentage::default_instance_ = new CT_Percentage();
    }
    return *CT_Percentage::default_instance_;
}

bool CT_Percentage::has_val_attr() const
{
    return m_has_val_attr;
}

void CT_Percentage::set_val_attr(const ST_Percentage& _val_attr)
{
    m_has_val_attr = true;
    m_val_attr = new ST_Percentage(_val_attr);
}

const ST_Percentage& CT_Percentage::get_val_attr() const
{
    if (m_val_attr)
    {
        return *m_val_attr;
    }
    return ST_Percentage::default_instance();
}

CT_Percentage* CT_Percentage::default_instance_ = NULL;

// CT_PositivePercentage
CT_PositivePercentage::CT_PositivePercentage()
    :m_has_val_attr(false),
     m_val_attr(NULL)
{
}
CT_PositivePercentage::~CT_PositivePercentage()
{
    clear();
}
void CT_PositivePercentage::clear()
{
    m_has_val_attr = false;

    if (m_val_attr)
    {
        delete m_val_attr;
        m_val_attr = NULL;
    }

}

void CT_PositivePercentage::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_val_attr);
    if (m_has_val_attr)
    {
        m_val_attr->toXmlAttr("val", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_PositivePercentage& CT_PositivePercentage::default_instance()
{
    if (!CT_PositivePercentage::default_instance_)
    {
        CT_PositivePercentage::default_instance_ = new CT_PositivePercentage();
    }
    return *CT_PositivePercentage::default_instance_;
}

bool CT_PositivePercentage::has_val_attr() const
{
    return m_has_val_attr;
}

void CT_PositivePercentage::set_val_attr(const ST_PositivePercentage& _val_attr)
{
    m_has_val_attr = true;
    m_val_attr = new ST_PositivePercentage(_val_attr);
}

const ST_PositivePercentage& CT_PositivePercentage::get_val_attr() const
{
    if (m_val_attr)
    {
        return *m_val_attr;
    }
    return ST_PositivePercentage::default_instance();
}

CT_PositivePercentage* CT_PositivePercentage::default_instance_ = NULL;

// CT_FixedPercentage
CT_FixedPercentage::CT_FixedPercentage()
    :m_has_val_attr(false),
     m_val_attr(NULL)
{
}
CT_FixedPercentage::~CT_FixedPercentage()
{
    clear();
}
void CT_FixedPercentage::clear()
{
    m_has_val_attr = false;

    if (m_val_attr)
    {
        delete m_val_attr;
        m_val_attr = NULL;
    }

}

void CT_FixedPercentage::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_val_attr);
    if (m_has_val_attr)
    {
        m_val_attr->toXmlAttr("val", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_FixedPercentage& CT_FixedPercentage::default_instance()
{
    if (!CT_FixedPercentage::default_instance_)
    {
        CT_FixedPercentage::default_instance_ = new CT_FixedPercentage();
    }
    return *CT_FixedPercentage::default_instance_;
}

bool CT_FixedPercentage::has_val_attr() const
{
    return m_has_val_attr;
}

void CT_FixedPercentage::set_val_attr(const ST_FixedPercentage& _val_attr)
{
    m_has_val_attr = true;
    m_val_attr = new ST_FixedPercentage(_val_attr);
}

const ST_FixedPercentage& CT_FixedPercentage::get_val_attr() const
{
    if (m_val_attr)
    {
        return *m_val_attr;
    }
    return ST_FixedPercentage::default_instance();
}

CT_FixedPercentage* CT_FixedPercentage::default_instance_ = NULL;

// CT_PositiveFixedPercentage
CT_PositiveFixedPercentage::CT_PositiveFixedPercentage()
    :m_has_val_attr(false),
     m_val_attr(NULL)
{
}
CT_PositiveFixedPercentage::~CT_PositiveFixedPercentage()
{
    clear();
}
void CT_PositiveFixedPercentage::clear()
{
    m_has_val_attr = false;

    if (m_val_attr)
    {
        delete m_val_attr;
        m_val_attr = NULL;
    }

}

void CT_PositiveFixedPercentage::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_val_attr);
    if (m_has_val_attr)
    {
        m_val_attr->toXmlAttr("val", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_PositiveFixedPercentage& CT_PositiveFixedPercentage::default_instance()
{
    if (!CT_PositiveFixedPercentage::default_instance_)
    {
        CT_PositiveFixedPercentage::default_instance_ = new CT_PositiveFixedPercentage();
    }
    return *CT_PositiveFixedPercentage::default_instance_;
}

bool CT_PositiveFixedPercentage::has_val_attr() const
{
    return m_has_val_attr;
}

void CT_PositiveFixedPercentage::set_val_attr(const ST_PositiveFixedPercentage& _val_attr)
{
    m_has_val_attr = true;
    m_val_attr = new ST_PositiveFixedPercentage(_val_attr);
}

const ST_PositiveFixedPercentage& CT_PositiveFixedPercentage::get_val_attr() const
{
    if (m_val_attr)
    {
        return *m_val_attr;
    }
    return ST_PositiveFixedPercentage::default_instance();
}

CT_PositiveFixedPercentage* CT_PositiveFixedPercentage::default_instance_ = NULL;

// CT_Ratio
CT_Ratio::CT_Ratio()
    :m_has_n_attr(false),
     m_n_attr(0),
     m_has_d_attr(false),
     m_d_attr(0)
{
}
CT_Ratio::~CT_Ratio()
{
    clear();
}
void CT_Ratio::clear()
{
    m_has_n_attr = false;
    m_n_attr = 0;

    m_has_d_attr = false;
    m_d_attr = 0;
}

void CT_Ratio::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_n_attr);
    if (m_has_n_attr)
    {
        _outStream << " " << "n" << "=\"" << m_n_attr << "\"";
    }


    assert(m_has_d_attr);
    if (m_has_d_attr)
    {
        _outStream << " " << "d" << "=\"" << m_d_attr << "\"";
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_Ratio& CT_Ratio::default_instance()
{
    if (!CT_Ratio::default_instance_)
    {
        CT_Ratio::default_instance_ = new CT_Ratio();
    }
    return *CT_Ratio::default_instance_;
}

bool CT_Ratio::has_n_attr() const
{
    return m_has_n_attr;
}

void CT_Ratio::set_n_attr(const XSD::long_& _n_attr)
{
    m_has_n_attr = true;
    m_n_attr = _n_attr;
}

const XSD::long_& CT_Ratio::get_n_attr() const
{
    return m_n_attr;
}

bool CT_Ratio::has_d_attr() const
{
    return m_has_d_attr;
}

void CT_Ratio::set_d_attr(const XSD::long_& _d_attr)
{
    m_has_d_attr = true;
    m_d_attr = _d_attr;
}

const XSD::long_& CT_Ratio::get_d_attr() const
{
    return m_d_attr;
}

CT_Ratio* CT_Ratio::default_instance_ = NULL;

// CT_Point2D
CT_Point2D::CT_Point2D()
    :m_has_x_attr(false),
     m_x_attr(NULL),
     m_has_y_attr(false),
     m_y_attr(NULL)
{
}
CT_Point2D::~CT_Point2D()
{
    clear();
}
void CT_Point2D::clear()
{
    m_has_x_attr = false;

    if (m_x_attr)
    {
        delete m_x_attr;
        m_x_attr = NULL;
    }


    m_has_y_attr = false;

    if (m_y_attr)
    {
        delete m_y_attr;
        m_y_attr = NULL;
    }

}

void CT_Point2D::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_x_attr);
    if (m_has_x_attr)
    {
        m_x_attr->toXmlAttr("x", _outStream);
    }


    assert(m_has_y_attr);
    if (m_has_y_attr)
    {
        m_y_attr->toXmlAttr("y", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_Point2D& CT_Point2D::default_instance()
{
    if (!CT_Point2D::default_instance_)
    {
        CT_Point2D::default_instance_ = new CT_Point2D();
    }
    return *CT_Point2D::default_instance_;
}

bool CT_Point2D::has_x_attr() const
{
    return m_has_x_attr;
}

void CT_Point2D::set_x_attr(const ST_Coordinate& _x_attr)
{
    m_has_x_attr = true;
    m_x_attr = new ST_Coordinate(_x_attr);
}

const ST_Coordinate& CT_Point2D::get_x_attr() const
{
    if (m_x_attr)
    {
        return *m_x_attr;
    }
    return ST_Coordinate::default_instance();
}

bool CT_Point2D::has_y_attr() const
{
    return m_has_y_attr;
}

void CT_Point2D::set_y_attr(const ST_Coordinate& _y_attr)
{
    m_has_y_attr = true;
    m_y_attr = new ST_Coordinate(_y_attr);
}

const ST_Coordinate& CT_Point2D::get_y_attr() const
{
    if (m_y_attr)
    {
        return *m_y_attr;
    }
    return ST_Coordinate::default_instance();
}

CT_Point2D* CT_Point2D::default_instance_ = NULL;

// CT_PositiveSize2D
CT_PositiveSize2D::CT_PositiveSize2D()
    :m_has_cx_attr(false),
     m_cx_attr(NULL),
     m_has_cy_attr(false),
     m_cy_attr(NULL)
{
}
CT_PositiveSize2D::~CT_PositiveSize2D()
{
    clear();
}
void CT_PositiveSize2D::clear()
{
    m_has_cx_attr = false;

    if (m_cx_attr)
    {
        delete m_cx_attr;
        m_cx_attr = NULL;
    }


    m_has_cy_attr = false;

    if (m_cy_attr)
    {
        delete m_cy_attr;
        m_cy_attr = NULL;
    }

}

void CT_PositiveSize2D::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_cx_attr);
    if (m_has_cx_attr)
    {
        m_cx_attr->toXmlAttr("cx", _outStream);
    }


    assert(m_has_cy_attr);
    if (m_has_cy_attr)
    {
        m_cy_attr->toXmlAttr("cy", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_PositiveSize2D& CT_PositiveSize2D::default_instance()
{
    if (!CT_PositiveSize2D::default_instance_)
    {
        CT_PositiveSize2D::default_instance_ = new CT_PositiveSize2D();
    }
    return *CT_PositiveSize2D::default_instance_;
}

bool CT_PositiveSize2D::has_cx_attr() const
{
    return m_has_cx_attr;
}

void CT_PositiveSize2D::set_cx_attr(const ST_PositiveCoordinate& _cx_attr)
{
    m_has_cx_attr = true;
    m_cx_attr = new ST_PositiveCoordinate(_cx_attr);
}

const ST_PositiveCoordinate& CT_PositiveSize2D::get_cx_attr() const
{
    if (m_cx_attr)
    {
        return *m_cx_attr;
    }
    return ST_PositiveCoordinate::default_instance();
}

bool CT_PositiveSize2D::has_cy_attr() const
{
    return m_has_cy_attr;
}

void CT_PositiveSize2D::set_cy_attr(const ST_PositiveCoordinate& _cy_attr)
{
    m_has_cy_attr = true;
    m_cy_attr = new ST_PositiveCoordinate(_cy_attr);
}

const ST_PositiveCoordinate& CT_PositiveSize2D::get_cy_attr() const
{
    if (m_cy_attr)
    {
        return *m_cy_attr;
    }
    return ST_PositiveCoordinate::default_instance();
}

CT_PositiveSize2D* CT_PositiveSize2D::default_instance_ = NULL;

// CT_ComplementTransform
CT_ComplementTransform::CT_ComplementTransform()

{
}
CT_ComplementTransform::~CT_ComplementTransform()
{
    clear();
}
void CT_ComplementTransform::clear()
{    }

void CT_ComplementTransform::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_ComplementTransform& CT_ComplementTransform::default_instance()
{
    if (!CT_ComplementTransform::default_instance_)
    {
        CT_ComplementTransform::default_instance_ = new CT_ComplementTransform();
    }
    return *CT_ComplementTransform::default_instance_;
}

CT_ComplementTransform* CT_ComplementTransform::default_instance_ = NULL;

// CT_InverseTransform
CT_InverseTransform::CT_InverseTransform()

{
}
CT_InverseTransform::~CT_InverseTransform()
{
    clear();
}
void CT_InverseTransform::clear()
{    }

void CT_InverseTransform::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_InverseTransform& CT_InverseTransform::default_instance()
{
    if (!CT_InverseTransform::default_instance_)
    {
        CT_InverseTransform::default_instance_ = new CT_InverseTransform();
    }
    return *CT_InverseTransform::default_instance_;
}

CT_InverseTransform* CT_InverseTransform::default_instance_ = NULL;

// CT_GrayscaleTransform
CT_GrayscaleTransform::CT_GrayscaleTransform()

{
}
CT_GrayscaleTransform::~CT_GrayscaleTransform()
{
    clear();
}
void CT_GrayscaleTransform::clear()
{    }

void CT_GrayscaleTransform::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_GrayscaleTransform& CT_GrayscaleTransform::default_instance()
{
    if (!CT_GrayscaleTransform::default_instance_)
    {
        CT_GrayscaleTransform::default_instance_ = new CT_GrayscaleTransform();
    }
    return *CT_GrayscaleTransform::default_instance_;
}

CT_GrayscaleTransform* CT_GrayscaleTransform::default_instance_ = NULL;

// CT_GammaTransform
CT_GammaTransform::CT_GammaTransform()

{
}
CT_GammaTransform::~CT_GammaTransform()
{
    clear();
}
void CT_GammaTransform::clear()
{    }

void CT_GammaTransform::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_GammaTransform& CT_GammaTransform::default_instance()
{
    if (!CT_GammaTransform::default_instance_)
    {
        CT_GammaTransform::default_instance_ = new CT_GammaTransform();
    }
    return *CT_GammaTransform::default_instance_;
}

CT_GammaTransform* CT_GammaTransform::default_instance_ = NULL;

// CT_InverseGammaTransform
CT_InverseGammaTransform::CT_InverseGammaTransform()

{
}
CT_InverseGammaTransform::~CT_InverseGammaTransform()
{
    clear();
}
void CT_InverseGammaTransform::clear()
{    }

void CT_InverseGammaTransform::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_InverseGammaTransform& CT_InverseGammaTransform::default_instance()
{
    if (!CT_InverseGammaTransform::default_instance_)
    {
        CT_InverseGammaTransform::default_instance_ = new CT_InverseGammaTransform();
    }
    return *CT_InverseGammaTransform::default_instance_;
}

CT_InverseGammaTransform* CT_InverseGammaTransform::default_instance_ = NULL;

// CT_ScRgbColor
CT_ScRgbColor::CT_ScRgbColor()
    :m_has_r_attr(false),
     m_r_attr(NULL),
     m_has_g_attr(false),
     m_g_attr(NULL),
     m_has_b_attr(false),
     m_b_attr(NULL)
{
}
CT_ScRgbColor::~CT_ScRgbColor()
{
    clear();
}
CT_PositiveFixedPercentage* CT_ScRgbColor::add_tint()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PositiveFixedPercentage* pNewChild = pChildGroup->mutable_tint();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_PositiveFixedPercentage* CT_ScRgbColor::add_shade()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PositiveFixedPercentage* pNewChild = pChildGroup->mutable_shade();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_ComplementTransform* CT_ScRgbColor::add_comp()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_ComplementTransform* pNewChild = pChildGroup->mutable_comp();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_InverseTransform* CT_ScRgbColor::add_inv()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_InverseTransform* pNewChild = pChildGroup->mutable_inv();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_GrayscaleTransform* CT_ScRgbColor::add_gray()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_GrayscaleTransform* pNewChild = pChildGroup->mutable_gray();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_PositiveFixedPercentage* CT_ScRgbColor::add_alpha()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PositiveFixedPercentage* pNewChild = pChildGroup->mutable_alpha();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_FixedPercentage* CT_ScRgbColor::add_alphaOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_FixedPercentage* pNewChild = pChildGroup->mutable_alphaOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_PositivePercentage* CT_ScRgbColor::add_alphaMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PositivePercentage* pNewChild = pChildGroup->mutable_alphaMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_PositiveFixedAngle* CT_ScRgbColor::add_hue()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PositiveFixedAngle* pNewChild = pChildGroup->mutable_hue();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Angle* CT_ScRgbColor::add_hueOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Angle* pNewChild = pChildGroup->mutable_hueOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_PositivePercentage* CT_ScRgbColor::add_hueMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PositivePercentage* pNewChild = pChildGroup->mutable_hueMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_ScRgbColor::add_sat()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_sat();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_ScRgbColor::add_satOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_satOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_ScRgbColor::add_satMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_satMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_ScRgbColor::add_lum()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_lum();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_ScRgbColor::add_lumOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_lumOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_ScRgbColor::add_lumMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_lumMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_ScRgbColor::add_red()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_red();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_ScRgbColor::add_redOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_redOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_ScRgbColor::add_redMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_redMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_ScRgbColor::add_green()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_green();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_ScRgbColor::add_greenOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_greenOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_ScRgbColor::add_greenMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_greenMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_ScRgbColor::add_blue()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_blue();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_ScRgbColor::add_blueOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_blueOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_ScRgbColor::add_blueMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_blueMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_GammaTransform* CT_ScRgbColor::add_gamma()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_GammaTransform* pNewChild = pChildGroup->mutable_gamma();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_InverseGammaTransform* CT_ScRgbColor::add_invGamma()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_InverseGammaTransform* pNewChild = pChildGroup->mutable_invGamma();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

void CT_ScRgbColor::clear()
{
    m_has_r_attr = false;

    if (m_r_attr)
    {
        delete m_r_attr;
        m_r_attr = NULL;
    }


    m_has_g_attr = false;

    if (m_g_attr)
    {
        delete m_g_attr;
        m_g_attr = NULL;
    }


    m_has_b_attr = false;

    if (m_b_attr)
    {
        delete m_b_attr;
        m_b_attr = NULL;
    }


    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }
}

void CT_ScRgbColor::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_r_attr);
    if (m_has_r_attr)
    {
        m_r_attr->toXmlAttr("r", _outStream);
    }


    assert(m_has_g_attr);
    if (m_has_g_attr)
    {
        m_g_attr->toXmlAttr("g", _outStream);
    }


    assert(m_has_b_attr);
    if (m_has_b_attr)
    {
        m_b_attr->toXmlAttr("b", _outStream);
    }

    _outStream << ">";

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_tint())
            {
                (*iter)->get_tint().toXmlElem("a:tint", "", _outStream);
            }


            else if ((*iter)->has_shade())
            {
                (*iter)->get_shade().toXmlElem("a:shade", "", _outStream);
            }


            else if ((*iter)->has_comp())
            {
                (*iter)->get_comp().toXmlElem("a:comp", "", _outStream);
            }


            else if ((*iter)->has_inv())
            {
                (*iter)->get_inv().toXmlElem("a:inv", "", _outStream);
            }


            else if ((*iter)->has_gray())
            {
                (*iter)->get_gray().toXmlElem("a:gray", "", _outStream);
            }


            else if ((*iter)->has_alpha())
            {
                (*iter)->get_alpha().toXmlElem("a:alpha", "", _outStream);
            }


            else if ((*iter)->has_alphaOff())
            {
                (*iter)->get_alphaOff().toXmlElem("a:alphaOff", "", _outStream);
            }


            else if ((*iter)->has_alphaMod())
            {
                (*iter)->get_alphaMod().toXmlElem("a:alphaMod", "", _outStream);
            }


            else if ((*iter)->has_hue())
            {
                (*iter)->get_hue().toXmlElem("a:hue", "", _outStream);
            }


            else if ((*iter)->has_hueOff())
            {
                (*iter)->get_hueOff().toXmlElem("a:hueOff", "", _outStream);
            }


            else if ((*iter)->has_hueMod())
            {
                (*iter)->get_hueMod().toXmlElem("a:hueMod", "", _outStream);
            }


            else if ((*iter)->has_sat())
            {
                (*iter)->get_sat().toXmlElem("a:sat", "", _outStream);
            }


            else if ((*iter)->has_satOff())
            {
                (*iter)->get_satOff().toXmlElem("a:satOff", "", _outStream);
            }


            else if ((*iter)->has_satMod())
            {
                (*iter)->get_satMod().toXmlElem("a:satMod", "", _outStream);
            }


            else if ((*iter)->has_lum())
            {
                (*iter)->get_lum().toXmlElem("a:lum", "", _outStream);
            }


            else if ((*iter)->has_lumOff())
            {
                (*iter)->get_lumOff().toXmlElem("a:lumOff", "", _outStream);
            }


            else if ((*iter)->has_lumMod())
            {
                (*iter)->get_lumMod().toXmlElem("a:lumMod", "", _outStream);
            }


            else if ((*iter)->has_red())
            {
                (*iter)->get_red().toXmlElem("a:red", "", _outStream);
            }


            else if ((*iter)->has_redOff())
            {
                (*iter)->get_redOff().toXmlElem("a:redOff", "", _outStream);
            }


            else if ((*iter)->has_redMod())
            {
                (*iter)->get_redMod().toXmlElem("a:redMod", "", _outStream);
            }


            else if ((*iter)->has_green())
            {
                (*iter)->get_green().toXmlElem("a:green", "", _outStream);
            }


            else if ((*iter)->has_greenOff())
            {
                (*iter)->get_greenOff().toXmlElem("a:greenOff", "", _outStream);
            }


            else if ((*iter)->has_greenMod())
            {
                (*iter)->get_greenMod().toXmlElem("a:greenMod", "", _outStream);
            }


            else if ((*iter)->has_blue())
            {
                (*iter)->get_blue().toXmlElem("a:blue", "", _outStream);
            }


            else if ((*iter)->has_blueOff())
            {
                (*iter)->get_blueOff().toXmlElem("a:blueOff", "", _outStream);
            }


            else if ((*iter)->has_blueMod())
            {
                (*iter)->get_blueMod().toXmlElem("a:blueMod", "", _outStream);
            }


            else if ((*iter)->has_gamma())
            {
                (*iter)->get_gamma().toXmlElem("a:gamma", "", _outStream);
            }


            else if ((*iter)->has_invGamma())
            {
                (*iter)->get_invGamma().toXmlElem("a:invGamma", "", _outStream);
            }


        }
    }

    _outStream << "</" << _elemName << ">";
}

const CT_ScRgbColor& CT_ScRgbColor::default_instance()
{
    if (!CT_ScRgbColor::default_instance_)
    {
        CT_ScRgbColor::default_instance_ = new CT_ScRgbColor();
    }
    return *CT_ScRgbColor::default_instance_;
}

bool CT_ScRgbColor::has_r_attr() const
{
    return m_has_r_attr;
}

void CT_ScRgbColor::set_r_attr(const ST_Percentage& _r_attr)
{
    m_has_r_attr = true;
    m_r_attr = new ST_Percentage(_r_attr);
}

const ST_Percentage& CT_ScRgbColor::get_r_attr() const
{
    if (m_r_attr)
    {
        return *m_r_attr;
    }
    return ST_Percentage::default_instance();
}

bool CT_ScRgbColor::has_g_attr() const
{
    return m_has_g_attr;
}

void CT_ScRgbColor::set_g_attr(const ST_Percentage& _g_attr)
{
    m_has_g_attr = true;
    m_g_attr = new ST_Percentage(_g_attr);
}

const ST_Percentage& CT_ScRgbColor::get_g_attr() const
{
    if (m_g_attr)
    {
        return *m_g_attr;
    }
    return ST_Percentage::default_instance();
}

bool CT_ScRgbColor::has_b_attr() const
{
    return m_has_b_attr;
}

void CT_ScRgbColor::set_b_attr(const ST_Percentage& _b_attr)
{
    m_has_b_attr = true;
    m_b_attr = new ST_Percentage(_b_attr);
}

const ST_Percentage& CT_ScRgbColor::get_b_attr() const
{
    if (m_b_attr)
    {
        return *m_b_attr;
    }
    return ST_Percentage::default_instance();
}


// CT_ScRgbColor::ChildGroup_1
CT_ScRgbColor::ChildGroup_1::ChildGroup_1()
    :m_has_tint(false),
     m_tint(NULL),
     m_has_shade(false),
     m_shade(NULL),
     m_has_comp(false),
     m_comp(NULL),
     m_has_inv(false),
     m_inv(NULL),
     m_has_gray(false),
     m_gray(NULL),
     m_has_alpha(false),
     m_alpha(NULL),
     m_has_alphaOff(false),
     m_alphaOff(NULL),
     m_has_alphaMod(false),
     m_alphaMod(NULL),
     m_has_hue(false),
     m_hue(NULL),
     m_has_hueOff(false),
     m_hueOff(NULL),
     m_has_hueMod(false),
     m_hueMod(NULL),
     m_has_sat(false),
     m_sat(NULL),
     m_has_satOff(false),
     m_satOff(NULL),
     m_has_satMod(false),
     m_satMod(NULL),
     m_has_lum(false),
     m_lum(NULL),
     m_has_lumOff(false),
     m_lumOff(NULL),
     m_has_lumMod(false),
     m_lumMod(NULL),
     m_has_red(false),
     m_red(NULL),
     m_has_redOff(false),
     m_redOff(NULL),
     m_has_redMod(false),
     m_redMod(NULL),
     m_has_green(false),
     m_green(NULL),
     m_has_greenOff(false),
     m_greenOff(NULL),
     m_has_greenMod(false),
     m_greenMod(NULL),
     m_has_blue(false),
     m_blue(NULL),
     m_has_blueOff(false),
     m_blueOff(NULL),
     m_has_blueMod(false),
     m_blueMod(NULL),
     m_has_gamma(false),
     m_gamma(NULL),
     m_has_invGamma(false),
     m_invGamma(NULL)
{
}
bool CT_ScRgbColor::ChildGroup_1::has_tint() const
{
    return m_has_tint;
}

CT_PositiveFixedPercentage* CT_ScRgbColor::ChildGroup_1::mutable_tint()
{

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_tint = true;
    if (!m_tint)
    {
        m_tint = new CT_PositiveFixedPercentage();
    }
    return m_tint;
}

const CT_PositiveFixedPercentage& CT_ScRgbColor::ChildGroup_1::get_tint() const
{
    if (m_tint)
    {
        return *m_tint;
    }
    return CT_PositiveFixedPercentage::default_instance();
}

bool CT_ScRgbColor::ChildGroup_1::has_shade() const
{
    return m_has_shade;
}

CT_PositiveFixedPercentage* CT_ScRgbColor::ChildGroup_1::mutable_shade()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_shade = true;
    if (!m_shade)
    {
        m_shade = new CT_PositiveFixedPercentage();
    }
    return m_shade;
}

const CT_PositiveFixedPercentage& CT_ScRgbColor::ChildGroup_1::get_shade() const
{
    if (m_shade)
    {
        return *m_shade;
    }
    return CT_PositiveFixedPercentage::default_instance();
}

bool CT_ScRgbColor::ChildGroup_1::has_comp() const
{
    return m_has_comp;
}

CT_ComplementTransform* CT_ScRgbColor::ChildGroup_1::mutable_comp()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_comp = true;
    if (!m_comp)
    {
        m_comp = new CT_ComplementTransform();
    }
    return m_comp;
}

const CT_ComplementTransform& CT_ScRgbColor::ChildGroup_1::get_comp() const
{
    if (m_comp)
    {
        return *m_comp;
    }
    return CT_ComplementTransform::default_instance();
}

bool CT_ScRgbColor::ChildGroup_1::has_inv() const
{
    return m_has_inv;
}

CT_InverseTransform* CT_ScRgbColor::ChildGroup_1::mutable_inv()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_inv = true;
    if (!m_inv)
    {
        m_inv = new CT_InverseTransform();
    }
    return m_inv;
}

const CT_InverseTransform& CT_ScRgbColor::ChildGroup_1::get_inv() const
{
    if (m_inv)
    {
        return *m_inv;
    }
    return CT_InverseTransform::default_instance();
}

bool CT_ScRgbColor::ChildGroup_1::has_gray() const
{
    return m_has_gray;
}

CT_GrayscaleTransform* CT_ScRgbColor::ChildGroup_1::mutable_gray()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_gray = true;
    if (!m_gray)
    {
        m_gray = new CT_GrayscaleTransform();
    }
    return m_gray;
}

const CT_GrayscaleTransform& CT_ScRgbColor::ChildGroup_1::get_gray() const
{
    if (m_gray)
    {
        return *m_gray;
    }
    return CT_GrayscaleTransform::default_instance();
}

bool CT_ScRgbColor::ChildGroup_1::has_alpha() const
{
    return m_has_alpha;
}

CT_PositiveFixedPercentage* CT_ScRgbColor::ChildGroup_1::mutable_alpha()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_alpha = true;
    if (!m_alpha)
    {
        m_alpha = new CT_PositiveFixedPercentage();
    }
    return m_alpha;
}

const CT_PositiveFixedPercentage& CT_ScRgbColor::ChildGroup_1::get_alpha() const
{
    if (m_alpha)
    {
        return *m_alpha;
    }
    return CT_PositiveFixedPercentage::default_instance();
}

bool CT_ScRgbColor::ChildGroup_1::has_alphaOff() const
{
    return m_has_alphaOff;
}

CT_FixedPercentage* CT_ScRgbColor::ChildGroup_1::mutable_alphaOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_alphaOff = true;
    if (!m_alphaOff)
    {
        m_alphaOff = new CT_FixedPercentage();
    }
    return m_alphaOff;
}

const CT_FixedPercentage& CT_ScRgbColor::ChildGroup_1::get_alphaOff() const
{
    if (m_alphaOff)
    {
        return *m_alphaOff;
    }
    return CT_FixedPercentage::default_instance();
}

bool CT_ScRgbColor::ChildGroup_1::has_alphaMod() const
{
    return m_has_alphaMod;
}

CT_PositivePercentage* CT_ScRgbColor::ChildGroup_1::mutable_alphaMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_alphaMod = true;
    if (!m_alphaMod)
    {
        m_alphaMod = new CT_PositivePercentage();
    }
    return m_alphaMod;
}

const CT_PositivePercentage& CT_ScRgbColor::ChildGroup_1::get_alphaMod() const
{
    if (m_alphaMod)
    {
        return *m_alphaMod;
    }
    return CT_PositivePercentage::default_instance();
}

bool CT_ScRgbColor::ChildGroup_1::has_hue() const
{
    return m_has_hue;
}

CT_PositiveFixedAngle* CT_ScRgbColor::ChildGroup_1::mutable_hue()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_hue = true;
    if (!m_hue)
    {
        m_hue = new CT_PositiveFixedAngle();
    }
    return m_hue;
}

const CT_PositiveFixedAngle& CT_ScRgbColor::ChildGroup_1::get_hue() const
{
    if (m_hue)
    {
        return *m_hue;
    }
    return CT_PositiveFixedAngle::default_instance();
}

bool CT_ScRgbColor::ChildGroup_1::has_hueOff() const
{
    return m_has_hueOff;
}

CT_Angle* CT_ScRgbColor::ChildGroup_1::mutable_hueOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_hueOff = true;
    if (!m_hueOff)
    {
        m_hueOff = new CT_Angle();
    }
    return m_hueOff;
}

const CT_Angle& CT_ScRgbColor::ChildGroup_1::get_hueOff() const
{
    if (m_hueOff)
    {
        return *m_hueOff;
    }
    return CT_Angle::default_instance();
}

bool CT_ScRgbColor::ChildGroup_1::has_hueMod() const
{
    return m_has_hueMod;
}

CT_PositivePercentage* CT_ScRgbColor::ChildGroup_1::mutable_hueMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_hueMod = true;
    if (!m_hueMod)
    {
        m_hueMod = new CT_PositivePercentage();
    }
    return m_hueMod;
}

const CT_PositivePercentage& CT_ScRgbColor::ChildGroup_1::get_hueMod() const
{
    if (m_hueMod)
    {
        return *m_hueMod;
    }
    return CT_PositivePercentage::default_instance();
}

bool CT_ScRgbColor::ChildGroup_1::has_sat() const
{
    return m_has_sat;
}

CT_Percentage* CT_ScRgbColor::ChildGroup_1::mutable_sat()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_sat = true;
    if (!m_sat)
    {
        m_sat = new CT_Percentage();
    }
    return m_sat;
}

const CT_Percentage& CT_ScRgbColor::ChildGroup_1::get_sat() const
{
    if (m_sat)
    {
        return *m_sat;
    }
    return CT_Percentage::default_instance();
}

bool CT_ScRgbColor::ChildGroup_1::has_satOff() const
{
    return m_has_satOff;
}

CT_Percentage* CT_ScRgbColor::ChildGroup_1::mutable_satOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_satOff = true;
    if (!m_satOff)
    {
        m_satOff = new CT_Percentage();
    }
    return m_satOff;
}

const CT_Percentage& CT_ScRgbColor::ChildGroup_1::get_satOff() const
{
    if (m_satOff)
    {
        return *m_satOff;
    }
    return CT_Percentage::default_instance();
}

bool CT_ScRgbColor::ChildGroup_1::has_satMod() const
{
    return m_has_satMod;
}

CT_Percentage* CT_ScRgbColor::ChildGroup_1::mutable_satMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_satMod = true;
    if (!m_satMod)
    {
        m_satMod = new CT_Percentage();
    }
    return m_satMod;
}

const CT_Percentage& CT_ScRgbColor::ChildGroup_1::get_satMod() const
{
    if (m_satMod)
    {
        return *m_satMod;
    }
    return CT_Percentage::default_instance();
}

bool CT_ScRgbColor::ChildGroup_1::has_lum() const
{
    return m_has_lum;
}

CT_Percentage* CT_ScRgbColor::ChildGroup_1::mutable_lum()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_lum = true;
    if (!m_lum)
    {
        m_lum = new CT_Percentage();
    }
    return m_lum;
}

const CT_Percentage& CT_ScRgbColor::ChildGroup_1::get_lum() const
{
    if (m_lum)
    {
        return *m_lum;
    }
    return CT_Percentage::default_instance();
}

bool CT_ScRgbColor::ChildGroup_1::has_lumOff() const
{
    return m_has_lumOff;
}

CT_Percentage* CT_ScRgbColor::ChildGroup_1::mutable_lumOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_lumOff = true;
    if (!m_lumOff)
    {
        m_lumOff = new CT_Percentage();
    }
    return m_lumOff;
}

const CT_Percentage& CT_ScRgbColor::ChildGroup_1::get_lumOff() const
{
    if (m_lumOff)
    {
        return *m_lumOff;
    }
    return CT_Percentage::default_instance();
}

bool CT_ScRgbColor::ChildGroup_1::has_lumMod() const
{
    return m_has_lumMod;
}

CT_Percentage* CT_ScRgbColor::ChildGroup_1::mutable_lumMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_lumMod = true;
    if (!m_lumMod)
    {
        m_lumMod = new CT_Percentage();
    }
    return m_lumMod;
}

const CT_Percentage& CT_ScRgbColor::ChildGroup_1::get_lumMod() const
{
    if (m_lumMod)
    {
        return *m_lumMod;
    }
    return CT_Percentage::default_instance();
}

bool CT_ScRgbColor::ChildGroup_1::has_red() const
{
    return m_has_red;
}

CT_Percentage* CT_ScRgbColor::ChildGroup_1::mutable_red()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_red = true;
    if (!m_red)
    {
        m_red = new CT_Percentage();
    }
    return m_red;
}

const CT_Percentage& CT_ScRgbColor::ChildGroup_1::get_red() const
{
    if (m_red)
    {
        return *m_red;
    }
    return CT_Percentage::default_instance();
}

bool CT_ScRgbColor::ChildGroup_1::has_redOff() const
{
    return m_has_redOff;
}

CT_Percentage* CT_ScRgbColor::ChildGroup_1::mutable_redOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_redOff = true;
    if (!m_redOff)
    {
        m_redOff = new CT_Percentage();
    }
    return m_redOff;
}

const CT_Percentage& CT_ScRgbColor::ChildGroup_1::get_redOff() const
{
    if (m_redOff)
    {
        return *m_redOff;
    }
    return CT_Percentage::default_instance();
}

bool CT_ScRgbColor::ChildGroup_1::has_redMod() const
{
    return m_has_redMod;
}

CT_Percentage* CT_ScRgbColor::ChildGroup_1::mutable_redMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_redMod = true;
    if (!m_redMod)
    {
        m_redMod = new CT_Percentage();
    }
    return m_redMod;
}

const CT_Percentage& CT_ScRgbColor::ChildGroup_1::get_redMod() const
{
    if (m_redMod)
    {
        return *m_redMod;
    }
    return CT_Percentage::default_instance();
}

bool CT_ScRgbColor::ChildGroup_1::has_green() const
{
    return m_has_green;
}

CT_Percentage* CT_ScRgbColor::ChildGroup_1::mutable_green()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_green = true;
    if (!m_green)
    {
        m_green = new CT_Percentage();
    }
    return m_green;
}

const CT_Percentage& CT_ScRgbColor::ChildGroup_1::get_green() const
{
    if (m_green)
    {
        return *m_green;
    }
    return CT_Percentage::default_instance();
}

bool CT_ScRgbColor::ChildGroup_1::has_greenOff() const
{
    return m_has_greenOff;
}

CT_Percentage* CT_ScRgbColor::ChildGroup_1::mutable_greenOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_greenOff = true;
    if (!m_greenOff)
    {
        m_greenOff = new CT_Percentage();
    }
    return m_greenOff;
}

const CT_Percentage& CT_ScRgbColor::ChildGroup_1::get_greenOff() const
{
    if (m_greenOff)
    {
        return *m_greenOff;
    }
    return CT_Percentage::default_instance();
}

bool CT_ScRgbColor::ChildGroup_1::has_greenMod() const
{
    return m_has_greenMod;
}

CT_Percentage* CT_ScRgbColor::ChildGroup_1::mutable_greenMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_greenMod = true;
    if (!m_greenMod)
    {
        m_greenMod = new CT_Percentage();
    }
    return m_greenMod;
}

const CT_Percentage& CT_ScRgbColor::ChildGroup_1::get_greenMod() const
{
    if (m_greenMod)
    {
        return *m_greenMod;
    }
    return CT_Percentage::default_instance();
}

bool CT_ScRgbColor::ChildGroup_1::has_blue() const
{
    return m_has_blue;
}

CT_Percentage* CT_ScRgbColor::ChildGroup_1::mutable_blue()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_blue = true;
    if (!m_blue)
    {
        m_blue = new CT_Percentage();
    }
    return m_blue;
}

const CT_Percentage& CT_ScRgbColor::ChildGroup_1::get_blue() const
{
    if (m_blue)
    {
        return *m_blue;
    }
    return CT_Percentage::default_instance();
}

bool CT_ScRgbColor::ChildGroup_1::has_blueOff() const
{
    return m_has_blueOff;
}

CT_Percentage* CT_ScRgbColor::ChildGroup_1::mutable_blueOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_blueOff = true;
    if (!m_blueOff)
    {
        m_blueOff = new CT_Percentage();
    }
    return m_blueOff;
}

const CT_Percentage& CT_ScRgbColor::ChildGroup_1::get_blueOff() const
{
    if (m_blueOff)
    {
        return *m_blueOff;
    }
    return CT_Percentage::default_instance();
}

bool CT_ScRgbColor::ChildGroup_1::has_blueMod() const
{
    return m_has_blueMod;
}

CT_Percentage* CT_ScRgbColor::ChildGroup_1::mutable_blueMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_blueMod = true;
    if (!m_blueMod)
    {
        m_blueMod = new CT_Percentage();
    }
    return m_blueMod;
}

const CT_Percentage& CT_ScRgbColor::ChildGroup_1::get_blueMod() const
{
    if (m_blueMod)
    {
        return *m_blueMod;
    }
    return CT_Percentage::default_instance();
}

bool CT_ScRgbColor::ChildGroup_1::has_gamma() const
{
    return m_has_gamma;
}

CT_GammaTransform* CT_ScRgbColor::ChildGroup_1::mutable_gamma()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_gamma = true;
    if (!m_gamma)
    {
        m_gamma = new CT_GammaTransform();
    }
    return m_gamma;
}

const CT_GammaTransform& CT_ScRgbColor::ChildGroup_1::get_gamma() const
{
    if (m_gamma)
    {
        return *m_gamma;
    }
    return CT_GammaTransform::default_instance();
}

bool CT_ScRgbColor::ChildGroup_1::has_invGamma() const
{
    return m_has_invGamma;
}

CT_InverseGammaTransform* CT_ScRgbColor::ChildGroup_1::mutable_invGamma()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = true;
    if (!m_invGamma)
    {
        m_invGamma = new CT_InverseGammaTransform();
    }
    return m_invGamma;
}

const CT_InverseGammaTransform& CT_ScRgbColor::ChildGroup_1::get_invGamma() const
{
    if (m_invGamma)
    {
        return *m_invGamma;
    }
    return CT_InverseGammaTransform::default_instance();
}

CT_ScRgbColor* CT_ScRgbColor::default_instance_ = NULL;

// CT_SRgbColor
CT_SRgbColor::CT_SRgbColor()
    :m_has_val_attr(false),
     m_val_attr(NULL)
{
}
CT_SRgbColor::~CT_SRgbColor()
{
    clear();
}
CT_PositiveFixedPercentage* CT_SRgbColor::add_tint()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PositiveFixedPercentage* pNewChild = pChildGroup->mutable_tint();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_PositiveFixedPercentage* CT_SRgbColor::add_shade()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PositiveFixedPercentage* pNewChild = pChildGroup->mutable_shade();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_ComplementTransform* CT_SRgbColor::add_comp()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_ComplementTransform* pNewChild = pChildGroup->mutable_comp();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_InverseTransform* CT_SRgbColor::add_inv()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_InverseTransform* pNewChild = pChildGroup->mutable_inv();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_GrayscaleTransform* CT_SRgbColor::add_gray()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_GrayscaleTransform* pNewChild = pChildGroup->mutable_gray();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_PositiveFixedPercentage* CT_SRgbColor::add_alpha()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PositiveFixedPercentage* pNewChild = pChildGroup->mutable_alpha();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_FixedPercentage* CT_SRgbColor::add_alphaOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_FixedPercentage* pNewChild = pChildGroup->mutable_alphaOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_PositivePercentage* CT_SRgbColor::add_alphaMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PositivePercentage* pNewChild = pChildGroup->mutable_alphaMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_PositiveFixedAngle* CT_SRgbColor::add_hue()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PositiveFixedAngle* pNewChild = pChildGroup->mutable_hue();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Angle* CT_SRgbColor::add_hueOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Angle* pNewChild = pChildGroup->mutable_hueOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_PositivePercentage* CT_SRgbColor::add_hueMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PositivePercentage* pNewChild = pChildGroup->mutable_hueMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SRgbColor::add_sat()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_sat();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SRgbColor::add_satOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_satOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SRgbColor::add_satMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_satMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SRgbColor::add_lum()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_lum();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SRgbColor::add_lumOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_lumOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SRgbColor::add_lumMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_lumMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SRgbColor::add_red()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_red();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SRgbColor::add_redOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_redOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SRgbColor::add_redMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_redMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SRgbColor::add_green()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_green();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SRgbColor::add_greenOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_greenOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SRgbColor::add_greenMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_greenMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SRgbColor::add_blue()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_blue();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SRgbColor::add_blueOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_blueOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SRgbColor::add_blueMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_blueMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_GammaTransform* CT_SRgbColor::add_gamma()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_GammaTransform* pNewChild = pChildGroup->mutable_gamma();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_InverseGammaTransform* CT_SRgbColor::add_invGamma()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_InverseGammaTransform* pNewChild = pChildGroup->mutable_invGamma();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

void CT_SRgbColor::clear()
{
    m_has_val_attr = false;

    if (m_val_attr)
    {
        delete m_val_attr;
        m_val_attr = NULL;
    }


    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }
}

void CT_SRgbColor::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_val_attr);
    if (m_has_val_attr)
    {
        m_val_attr->toXmlAttr("val", _outStream);
    }

    _outStream << ">";

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_tint())
            {
                (*iter)->get_tint().toXmlElem("a:tint", "", _outStream);
            }


            else if ((*iter)->has_shade())
            {
                (*iter)->get_shade().toXmlElem("a:shade", "", _outStream);
            }


            else if ((*iter)->has_comp())
            {
                (*iter)->get_comp().toXmlElem("a:comp", "", _outStream);
            }


            else if ((*iter)->has_inv())
            {
                (*iter)->get_inv().toXmlElem("a:inv", "", _outStream);
            }


            else if ((*iter)->has_gray())
            {
                (*iter)->get_gray().toXmlElem("a:gray", "", _outStream);
            }


            else if ((*iter)->has_alpha())
            {
                (*iter)->get_alpha().toXmlElem("a:alpha", "", _outStream);
            }


            else if ((*iter)->has_alphaOff())
            {
                (*iter)->get_alphaOff().toXmlElem("a:alphaOff", "", _outStream);
            }


            else if ((*iter)->has_alphaMod())
            {
                (*iter)->get_alphaMod().toXmlElem("a:alphaMod", "", _outStream);
            }


            else if ((*iter)->has_hue())
            {
                (*iter)->get_hue().toXmlElem("a:hue", "", _outStream);
            }


            else if ((*iter)->has_hueOff())
            {
                (*iter)->get_hueOff().toXmlElem("a:hueOff", "", _outStream);
            }


            else if ((*iter)->has_hueMod())
            {
                (*iter)->get_hueMod().toXmlElem("a:hueMod", "", _outStream);
            }


            else if ((*iter)->has_sat())
            {
                (*iter)->get_sat().toXmlElem("a:sat", "", _outStream);
            }


            else if ((*iter)->has_satOff())
            {
                (*iter)->get_satOff().toXmlElem("a:satOff", "", _outStream);
            }


            else if ((*iter)->has_satMod())
            {
                (*iter)->get_satMod().toXmlElem("a:satMod", "", _outStream);
            }


            else if ((*iter)->has_lum())
            {
                (*iter)->get_lum().toXmlElem("a:lum", "", _outStream);
            }


            else if ((*iter)->has_lumOff())
            {
                (*iter)->get_lumOff().toXmlElem("a:lumOff", "", _outStream);
            }


            else if ((*iter)->has_lumMod())
            {
                (*iter)->get_lumMod().toXmlElem("a:lumMod", "", _outStream);
            }


            else if ((*iter)->has_red())
            {
                (*iter)->get_red().toXmlElem("a:red", "", _outStream);
            }


            else if ((*iter)->has_redOff())
            {
                (*iter)->get_redOff().toXmlElem("a:redOff", "", _outStream);
            }


            else if ((*iter)->has_redMod())
            {
                (*iter)->get_redMod().toXmlElem("a:redMod", "", _outStream);
            }


            else if ((*iter)->has_green())
            {
                (*iter)->get_green().toXmlElem("a:green", "", _outStream);
            }


            else if ((*iter)->has_greenOff())
            {
                (*iter)->get_greenOff().toXmlElem("a:greenOff", "", _outStream);
            }


            else if ((*iter)->has_greenMod())
            {
                (*iter)->get_greenMod().toXmlElem("a:greenMod", "", _outStream);
            }


            else if ((*iter)->has_blue())
            {
                (*iter)->get_blue().toXmlElem("a:blue", "", _outStream);
            }


            else if ((*iter)->has_blueOff())
            {
                (*iter)->get_blueOff().toXmlElem("a:blueOff", "", _outStream);
            }


            else if ((*iter)->has_blueMod())
            {
                (*iter)->get_blueMod().toXmlElem("a:blueMod", "", _outStream);
            }


            else if ((*iter)->has_gamma())
            {
                (*iter)->get_gamma().toXmlElem("a:gamma", "", _outStream);
            }


            else if ((*iter)->has_invGamma())
            {
                (*iter)->get_invGamma().toXmlElem("a:invGamma", "", _outStream);
            }


        }
    }

    _outStream << "</" << _elemName << ">";
}

const CT_SRgbColor& CT_SRgbColor::default_instance()
{
    if (!CT_SRgbColor::default_instance_)
    {
        CT_SRgbColor::default_instance_ = new CT_SRgbColor();
    }
    return *CT_SRgbColor::default_instance_;
}

bool CT_SRgbColor::has_val_attr() const
{
    return m_has_val_attr;
}

void CT_SRgbColor::set_val_attr(const ns_s::ST_HexColorRGB& _val_attr)
{
    m_has_val_attr = true;
    m_val_attr = new ns_s::ST_HexColorRGB(_val_attr);
}

const ns_s::ST_HexColorRGB& CT_SRgbColor::get_val_attr() const
{
    if (m_val_attr)
    {
        return *m_val_attr;
    }
    return ns_s::ST_HexColorRGB::default_instance();
}


// CT_SRgbColor::ChildGroup_1
CT_SRgbColor::ChildGroup_1::ChildGroup_1()
    :m_has_tint(false),
     m_tint(NULL),
     m_has_shade(false),
     m_shade(NULL),
     m_has_comp(false),
     m_comp(NULL),
     m_has_inv(false),
     m_inv(NULL),
     m_has_gray(false),
     m_gray(NULL),
     m_has_alpha(false),
     m_alpha(NULL),
     m_has_alphaOff(false),
     m_alphaOff(NULL),
     m_has_alphaMod(false),
     m_alphaMod(NULL),
     m_has_hue(false),
     m_hue(NULL),
     m_has_hueOff(false),
     m_hueOff(NULL),
     m_has_hueMod(false),
     m_hueMod(NULL),
     m_has_sat(false),
     m_sat(NULL),
     m_has_satOff(false),
     m_satOff(NULL),
     m_has_satMod(false),
     m_satMod(NULL),
     m_has_lum(false),
     m_lum(NULL),
     m_has_lumOff(false),
     m_lumOff(NULL),
     m_has_lumMod(false),
     m_lumMod(NULL),
     m_has_red(false),
     m_red(NULL),
     m_has_redOff(false),
     m_redOff(NULL),
     m_has_redMod(false),
     m_redMod(NULL),
     m_has_green(false),
     m_green(NULL),
     m_has_greenOff(false),
     m_greenOff(NULL),
     m_has_greenMod(false),
     m_greenMod(NULL),
     m_has_blue(false),
     m_blue(NULL),
     m_has_blueOff(false),
     m_blueOff(NULL),
     m_has_blueMod(false),
     m_blueMod(NULL),
     m_has_gamma(false),
     m_gamma(NULL),
     m_has_invGamma(false),
     m_invGamma(NULL)
{
}
bool CT_SRgbColor::ChildGroup_1::has_tint() const
{
    return m_has_tint;
}

CT_PositiveFixedPercentage* CT_SRgbColor::ChildGroup_1::mutable_tint()
{

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_tint = true;
    if (!m_tint)
    {
        m_tint = new CT_PositiveFixedPercentage();
    }
    return m_tint;
}

const CT_PositiveFixedPercentage& CT_SRgbColor::ChildGroup_1::get_tint() const
{
    if (m_tint)
    {
        return *m_tint;
    }
    return CT_PositiveFixedPercentage::default_instance();
}

bool CT_SRgbColor::ChildGroup_1::has_shade() const
{
    return m_has_shade;
}

CT_PositiveFixedPercentage* CT_SRgbColor::ChildGroup_1::mutable_shade()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_shade = true;
    if (!m_shade)
    {
        m_shade = new CT_PositiveFixedPercentage();
    }
    return m_shade;
}

const CT_PositiveFixedPercentage& CT_SRgbColor::ChildGroup_1::get_shade() const
{
    if (m_shade)
    {
        return *m_shade;
    }
    return CT_PositiveFixedPercentage::default_instance();
}

bool CT_SRgbColor::ChildGroup_1::has_comp() const
{
    return m_has_comp;
}

CT_ComplementTransform* CT_SRgbColor::ChildGroup_1::mutable_comp()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_comp = true;
    if (!m_comp)
    {
        m_comp = new CT_ComplementTransform();
    }
    return m_comp;
}

const CT_ComplementTransform& CT_SRgbColor::ChildGroup_1::get_comp() const
{
    if (m_comp)
    {
        return *m_comp;
    }
    return CT_ComplementTransform::default_instance();
}

bool CT_SRgbColor::ChildGroup_1::has_inv() const
{
    return m_has_inv;
}

CT_InverseTransform* CT_SRgbColor::ChildGroup_1::mutable_inv()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_inv = true;
    if (!m_inv)
    {
        m_inv = new CT_InverseTransform();
    }
    return m_inv;
}

const CT_InverseTransform& CT_SRgbColor::ChildGroup_1::get_inv() const
{
    if (m_inv)
    {
        return *m_inv;
    }
    return CT_InverseTransform::default_instance();
}

bool CT_SRgbColor::ChildGroup_1::has_gray() const
{
    return m_has_gray;
}

CT_GrayscaleTransform* CT_SRgbColor::ChildGroup_1::mutable_gray()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_gray = true;
    if (!m_gray)
    {
        m_gray = new CT_GrayscaleTransform();
    }
    return m_gray;
}

const CT_GrayscaleTransform& CT_SRgbColor::ChildGroup_1::get_gray() const
{
    if (m_gray)
    {
        return *m_gray;
    }
    return CT_GrayscaleTransform::default_instance();
}

bool CT_SRgbColor::ChildGroup_1::has_alpha() const
{
    return m_has_alpha;
}

CT_PositiveFixedPercentage* CT_SRgbColor::ChildGroup_1::mutable_alpha()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_alpha = true;
    if (!m_alpha)
    {
        m_alpha = new CT_PositiveFixedPercentage();
    }
    return m_alpha;
}

const CT_PositiveFixedPercentage& CT_SRgbColor::ChildGroup_1::get_alpha() const
{
    if (m_alpha)
    {
        return *m_alpha;
    }
    return CT_PositiveFixedPercentage::default_instance();
}

bool CT_SRgbColor::ChildGroup_1::has_alphaOff() const
{
    return m_has_alphaOff;
}

CT_FixedPercentage* CT_SRgbColor::ChildGroup_1::mutable_alphaOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_alphaOff = true;
    if (!m_alphaOff)
    {
        m_alphaOff = new CT_FixedPercentage();
    }
    return m_alphaOff;
}

const CT_FixedPercentage& CT_SRgbColor::ChildGroup_1::get_alphaOff() const
{
    if (m_alphaOff)
    {
        return *m_alphaOff;
    }
    return CT_FixedPercentage::default_instance();
}

bool CT_SRgbColor::ChildGroup_1::has_alphaMod() const
{
    return m_has_alphaMod;
}

CT_PositivePercentage* CT_SRgbColor::ChildGroup_1::mutable_alphaMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_alphaMod = true;
    if (!m_alphaMod)
    {
        m_alphaMod = new CT_PositivePercentage();
    }
    return m_alphaMod;
}

const CT_PositivePercentage& CT_SRgbColor::ChildGroup_1::get_alphaMod() const
{
    if (m_alphaMod)
    {
        return *m_alphaMod;
    }
    return CT_PositivePercentage::default_instance();
}

bool CT_SRgbColor::ChildGroup_1::has_hue() const
{
    return m_has_hue;
}

CT_PositiveFixedAngle* CT_SRgbColor::ChildGroup_1::mutable_hue()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_hue = true;
    if (!m_hue)
    {
        m_hue = new CT_PositiveFixedAngle();
    }
    return m_hue;
}

const CT_PositiveFixedAngle& CT_SRgbColor::ChildGroup_1::get_hue() const
{
    if (m_hue)
    {
        return *m_hue;
    }
    return CT_PositiveFixedAngle::default_instance();
}

bool CT_SRgbColor::ChildGroup_1::has_hueOff() const
{
    return m_has_hueOff;
}

CT_Angle* CT_SRgbColor::ChildGroup_1::mutable_hueOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_hueOff = true;
    if (!m_hueOff)
    {
        m_hueOff = new CT_Angle();
    }
    return m_hueOff;
}

const CT_Angle& CT_SRgbColor::ChildGroup_1::get_hueOff() const
{
    if (m_hueOff)
    {
        return *m_hueOff;
    }
    return CT_Angle::default_instance();
}

bool CT_SRgbColor::ChildGroup_1::has_hueMod() const
{
    return m_has_hueMod;
}

CT_PositivePercentage* CT_SRgbColor::ChildGroup_1::mutable_hueMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_hueMod = true;
    if (!m_hueMod)
    {
        m_hueMod = new CT_PositivePercentage();
    }
    return m_hueMod;
}

const CT_PositivePercentage& CT_SRgbColor::ChildGroup_1::get_hueMod() const
{
    if (m_hueMod)
    {
        return *m_hueMod;
    }
    return CT_PositivePercentage::default_instance();
}

bool CT_SRgbColor::ChildGroup_1::has_sat() const
{
    return m_has_sat;
}

CT_Percentage* CT_SRgbColor::ChildGroup_1::mutable_sat()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_sat = true;
    if (!m_sat)
    {
        m_sat = new CT_Percentage();
    }
    return m_sat;
}

const CT_Percentage& CT_SRgbColor::ChildGroup_1::get_sat() const
{
    if (m_sat)
    {
        return *m_sat;
    }
    return CT_Percentage::default_instance();
}

bool CT_SRgbColor::ChildGroup_1::has_satOff() const
{
    return m_has_satOff;
}

CT_Percentage* CT_SRgbColor::ChildGroup_1::mutable_satOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_satOff = true;
    if (!m_satOff)
    {
        m_satOff = new CT_Percentage();
    }
    return m_satOff;
}

const CT_Percentage& CT_SRgbColor::ChildGroup_1::get_satOff() const
{
    if (m_satOff)
    {
        return *m_satOff;
    }
    return CT_Percentage::default_instance();
}

bool CT_SRgbColor::ChildGroup_1::has_satMod() const
{
    return m_has_satMod;
}

CT_Percentage* CT_SRgbColor::ChildGroup_1::mutable_satMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_satMod = true;
    if (!m_satMod)
    {
        m_satMod = new CT_Percentage();
    }
    return m_satMod;
}

const CT_Percentage& CT_SRgbColor::ChildGroup_1::get_satMod() const
{
    if (m_satMod)
    {
        return *m_satMod;
    }
    return CT_Percentage::default_instance();
}

bool CT_SRgbColor::ChildGroup_1::has_lum() const
{
    return m_has_lum;
}

CT_Percentage* CT_SRgbColor::ChildGroup_1::mutable_lum()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_lum = true;
    if (!m_lum)
    {
        m_lum = new CT_Percentage();
    }
    return m_lum;
}

const CT_Percentage& CT_SRgbColor::ChildGroup_1::get_lum() const
{
    if (m_lum)
    {
        return *m_lum;
    }
    return CT_Percentage::default_instance();
}

bool CT_SRgbColor::ChildGroup_1::has_lumOff() const
{
    return m_has_lumOff;
}

CT_Percentage* CT_SRgbColor::ChildGroup_1::mutable_lumOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_lumOff = true;
    if (!m_lumOff)
    {
        m_lumOff = new CT_Percentage();
    }
    return m_lumOff;
}

const CT_Percentage& CT_SRgbColor::ChildGroup_1::get_lumOff() const
{
    if (m_lumOff)
    {
        return *m_lumOff;
    }
    return CT_Percentage::default_instance();
}

bool CT_SRgbColor::ChildGroup_1::has_lumMod() const
{
    return m_has_lumMod;
}

CT_Percentage* CT_SRgbColor::ChildGroup_1::mutable_lumMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_lumMod = true;
    if (!m_lumMod)
    {
        m_lumMod = new CT_Percentage();
    }
    return m_lumMod;
}

const CT_Percentage& CT_SRgbColor::ChildGroup_1::get_lumMod() const
{
    if (m_lumMod)
    {
        return *m_lumMod;
    }
    return CT_Percentage::default_instance();
}

bool CT_SRgbColor::ChildGroup_1::has_red() const
{
    return m_has_red;
}

CT_Percentage* CT_SRgbColor::ChildGroup_1::mutable_red()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_red = true;
    if (!m_red)
    {
        m_red = new CT_Percentage();
    }
    return m_red;
}

const CT_Percentage& CT_SRgbColor::ChildGroup_1::get_red() const
{
    if (m_red)
    {
        return *m_red;
    }
    return CT_Percentage::default_instance();
}

bool CT_SRgbColor::ChildGroup_1::has_redOff() const
{
    return m_has_redOff;
}

CT_Percentage* CT_SRgbColor::ChildGroup_1::mutable_redOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_redOff = true;
    if (!m_redOff)
    {
        m_redOff = new CT_Percentage();
    }
    return m_redOff;
}

const CT_Percentage& CT_SRgbColor::ChildGroup_1::get_redOff() const
{
    if (m_redOff)
    {
        return *m_redOff;
    }
    return CT_Percentage::default_instance();
}

bool CT_SRgbColor::ChildGroup_1::has_redMod() const
{
    return m_has_redMod;
}

CT_Percentage* CT_SRgbColor::ChildGroup_1::mutable_redMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_redMod = true;
    if (!m_redMod)
    {
        m_redMod = new CT_Percentage();
    }
    return m_redMod;
}

const CT_Percentage& CT_SRgbColor::ChildGroup_1::get_redMod() const
{
    if (m_redMod)
    {
        return *m_redMod;
    }
    return CT_Percentage::default_instance();
}

bool CT_SRgbColor::ChildGroup_1::has_green() const
{
    return m_has_green;
}

CT_Percentage* CT_SRgbColor::ChildGroup_1::mutable_green()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_green = true;
    if (!m_green)
    {
        m_green = new CT_Percentage();
    }
    return m_green;
}

const CT_Percentage& CT_SRgbColor::ChildGroup_1::get_green() const
{
    if (m_green)
    {
        return *m_green;
    }
    return CT_Percentage::default_instance();
}

bool CT_SRgbColor::ChildGroup_1::has_greenOff() const
{
    return m_has_greenOff;
}

CT_Percentage* CT_SRgbColor::ChildGroup_1::mutable_greenOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_greenOff = true;
    if (!m_greenOff)
    {
        m_greenOff = new CT_Percentage();
    }
    return m_greenOff;
}

const CT_Percentage& CT_SRgbColor::ChildGroup_1::get_greenOff() const
{
    if (m_greenOff)
    {
        return *m_greenOff;
    }
    return CT_Percentage::default_instance();
}

bool CT_SRgbColor::ChildGroup_1::has_greenMod() const
{
    return m_has_greenMod;
}

CT_Percentage* CT_SRgbColor::ChildGroup_1::mutable_greenMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_greenMod = true;
    if (!m_greenMod)
    {
        m_greenMod = new CT_Percentage();
    }
    return m_greenMod;
}

const CT_Percentage& CT_SRgbColor::ChildGroup_1::get_greenMod() const
{
    if (m_greenMod)
    {
        return *m_greenMod;
    }
    return CT_Percentage::default_instance();
}

bool CT_SRgbColor::ChildGroup_1::has_blue() const
{
    return m_has_blue;
}

CT_Percentage* CT_SRgbColor::ChildGroup_1::mutable_blue()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_blue = true;
    if (!m_blue)
    {
        m_blue = new CT_Percentage();
    }
    return m_blue;
}

const CT_Percentage& CT_SRgbColor::ChildGroup_1::get_blue() const
{
    if (m_blue)
    {
        return *m_blue;
    }
    return CT_Percentage::default_instance();
}

bool CT_SRgbColor::ChildGroup_1::has_blueOff() const
{
    return m_has_blueOff;
}

CT_Percentage* CT_SRgbColor::ChildGroup_1::mutable_blueOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_blueOff = true;
    if (!m_blueOff)
    {
        m_blueOff = new CT_Percentage();
    }
    return m_blueOff;
}

const CT_Percentage& CT_SRgbColor::ChildGroup_1::get_blueOff() const
{
    if (m_blueOff)
    {
        return *m_blueOff;
    }
    return CT_Percentage::default_instance();
}

bool CT_SRgbColor::ChildGroup_1::has_blueMod() const
{
    return m_has_blueMod;
}

CT_Percentage* CT_SRgbColor::ChildGroup_1::mutable_blueMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_blueMod = true;
    if (!m_blueMod)
    {
        m_blueMod = new CT_Percentage();
    }
    return m_blueMod;
}

const CT_Percentage& CT_SRgbColor::ChildGroup_1::get_blueMod() const
{
    if (m_blueMod)
    {
        return *m_blueMod;
    }
    return CT_Percentage::default_instance();
}

bool CT_SRgbColor::ChildGroup_1::has_gamma() const
{
    return m_has_gamma;
}

CT_GammaTransform* CT_SRgbColor::ChildGroup_1::mutable_gamma()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_gamma = true;
    if (!m_gamma)
    {
        m_gamma = new CT_GammaTransform();
    }
    return m_gamma;
}

const CT_GammaTransform& CT_SRgbColor::ChildGroup_1::get_gamma() const
{
    if (m_gamma)
    {
        return *m_gamma;
    }
    return CT_GammaTransform::default_instance();
}

bool CT_SRgbColor::ChildGroup_1::has_invGamma() const
{
    return m_has_invGamma;
}

CT_InverseGammaTransform* CT_SRgbColor::ChildGroup_1::mutable_invGamma()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = true;
    if (!m_invGamma)
    {
        m_invGamma = new CT_InverseGammaTransform();
    }
    return m_invGamma;
}

const CT_InverseGammaTransform& CT_SRgbColor::ChildGroup_1::get_invGamma() const
{
    if (m_invGamma)
    {
        return *m_invGamma;
    }
    return CT_InverseGammaTransform::default_instance();
}

CT_SRgbColor* CT_SRgbColor::default_instance_ = NULL;

// CT_HslColor
CT_HslColor::CT_HslColor()
    :m_has_hue_attr(false),
     m_hue_attr(NULL),
     m_has_sat_attr(false),
     m_sat_attr(NULL),
     m_has_lum_attr(false),
     m_lum_attr(NULL)
{
}
CT_HslColor::~CT_HslColor()
{
    clear();
}
CT_PositiveFixedPercentage* CT_HslColor::add_tint()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PositiveFixedPercentage* pNewChild = pChildGroup->mutable_tint();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_PositiveFixedPercentage* CT_HslColor::add_shade()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PositiveFixedPercentage* pNewChild = pChildGroup->mutable_shade();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_ComplementTransform* CT_HslColor::add_comp()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_ComplementTransform* pNewChild = pChildGroup->mutable_comp();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_InverseTransform* CT_HslColor::add_inv()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_InverseTransform* pNewChild = pChildGroup->mutable_inv();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_GrayscaleTransform* CT_HslColor::add_gray()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_GrayscaleTransform* pNewChild = pChildGroup->mutable_gray();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_PositiveFixedPercentage* CT_HslColor::add_alpha()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PositiveFixedPercentage* pNewChild = pChildGroup->mutable_alpha();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_FixedPercentage* CT_HslColor::add_alphaOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_FixedPercentage* pNewChild = pChildGroup->mutable_alphaOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_PositivePercentage* CT_HslColor::add_alphaMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PositivePercentage* pNewChild = pChildGroup->mutable_alphaMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_PositiveFixedAngle* CT_HslColor::add_hue()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PositiveFixedAngle* pNewChild = pChildGroup->mutable_hue();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Angle* CT_HslColor::add_hueOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Angle* pNewChild = pChildGroup->mutable_hueOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_PositivePercentage* CT_HslColor::add_hueMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PositivePercentage* pNewChild = pChildGroup->mutable_hueMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_HslColor::add_sat()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_sat();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_HslColor::add_satOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_satOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_HslColor::add_satMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_satMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_HslColor::add_lum()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_lum();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_HslColor::add_lumOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_lumOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_HslColor::add_lumMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_lumMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_HslColor::add_red()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_red();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_HslColor::add_redOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_redOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_HslColor::add_redMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_redMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_HslColor::add_green()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_green();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_HslColor::add_greenOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_greenOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_HslColor::add_greenMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_greenMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_HslColor::add_blue()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_blue();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_HslColor::add_blueOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_blueOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_HslColor::add_blueMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_blueMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_GammaTransform* CT_HslColor::add_gamma()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_GammaTransform* pNewChild = pChildGroup->mutable_gamma();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_InverseGammaTransform* CT_HslColor::add_invGamma()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_InverseGammaTransform* pNewChild = pChildGroup->mutable_invGamma();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

void CT_HslColor::clear()
{
    m_has_hue_attr = false;

    if (m_hue_attr)
    {
        delete m_hue_attr;
        m_hue_attr = NULL;
    }


    m_has_sat_attr = false;

    if (m_sat_attr)
    {
        delete m_sat_attr;
        m_sat_attr = NULL;
    }


    m_has_lum_attr = false;

    if (m_lum_attr)
    {
        delete m_lum_attr;
        m_lum_attr = NULL;
    }


    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }
}

void CT_HslColor::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_hue_attr);
    if (m_has_hue_attr)
    {
        m_hue_attr->toXmlAttr("hue", _outStream);
    }


    assert(m_has_sat_attr);
    if (m_has_sat_attr)
    {
        m_sat_attr->toXmlAttr("sat", _outStream);
    }


    assert(m_has_lum_attr);
    if (m_has_lum_attr)
    {
        m_lum_attr->toXmlAttr("lum", _outStream);
    }

    _outStream << ">";

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_tint())
            {
                (*iter)->get_tint().toXmlElem("a:tint", "", _outStream);
            }


            else if ((*iter)->has_shade())
            {
                (*iter)->get_shade().toXmlElem("a:shade", "", _outStream);
            }


            else if ((*iter)->has_comp())
            {
                (*iter)->get_comp().toXmlElem("a:comp", "", _outStream);
            }


            else if ((*iter)->has_inv())
            {
                (*iter)->get_inv().toXmlElem("a:inv", "", _outStream);
            }


            else if ((*iter)->has_gray())
            {
                (*iter)->get_gray().toXmlElem("a:gray", "", _outStream);
            }


            else if ((*iter)->has_alpha())
            {
                (*iter)->get_alpha().toXmlElem("a:alpha", "", _outStream);
            }


            else if ((*iter)->has_alphaOff())
            {
                (*iter)->get_alphaOff().toXmlElem("a:alphaOff", "", _outStream);
            }


            else if ((*iter)->has_alphaMod())
            {
                (*iter)->get_alphaMod().toXmlElem("a:alphaMod", "", _outStream);
            }


            else if ((*iter)->has_hue())
            {
                (*iter)->get_hue().toXmlElem("a:hue", "", _outStream);
            }


            else if ((*iter)->has_hueOff())
            {
                (*iter)->get_hueOff().toXmlElem("a:hueOff", "", _outStream);
            }


            else if ((*iter)->has_hueMod())
            {
                (*iter)->get_hueMod().toXmlElem("a:hueMod", "", _outStream);
            }


            else if ((*iter)->has_sat())
            {
                (*iter)->get_sat().toXmlElem("a:sat", "", _outStream);
            }


            else if ((*iter)->has_satOff())
            {
                (*iter)->get_satOff().toXmlElem("a:satOff", "", _outStream);
            }


            else if ((*iter)->has_satMod())
            {
                (*iter)->get_satMod().toXmlElem("a:satMod", "", _outStream);
            }


            else if ((*iter)->has_lum())
            {
                (*iter)->get_lum().toXmlElem("a:lum", "", _outStream);
            }


            else if ((*iter)->has_lumOff())
            {
                (*iter)->get_lumOff().toXmlElem("a:lumOff", "", _outStream);
            }


            else if ((*iter)->has_lumMod())
            {
                (*iter)->get_lumMod().toXmlElem("a:lumMod", "", _outStream);
            }


            else if ((*iter)->has_red())
            {
                (*iter)->get_red().toXmlElem("a:red", "", _outStream);
            }


            else if ((*iter)->has_redOff())
            {
                (*iter)->get_redOff().toXmlElem("a:redOff", "", _outStream);
            }


            else if ((*iter)->has_redMod())
            {
                (*iter)->get_redMod().toXmlElem("a:redMod", "", _outStream);
            }


            else if ((*iter)->has_green())
            {
                (*iter)->get_green().toXmlElem("a:green", "", _outStream);
            }


            else if ((*iter)->has_greenOff())
            {
                (*iter)->get_greenOff().toXmlElem("a:greenOff", "", _outStream);
            }


            else if ((*iter)->has_greenMod())
            {
                (*iter)->get_greenMod().toXmlElem("a:greenMod", "", _outStream);
            }


            else if ((*iter)->has_blue())
            {
                (*iter)->get_blue().toXmlElem("a:blue", "", _outStream);
            }


            else if ((*iter)->has_blueOff())
            {
                (*iter)->get_blueOff().toXmlElem("a:blueOff", "", _outStream);
            }


            else if ((*iter)->has_blueMod())
            {
                (*iter)->get_blueMod().toXmlElem("a:blueMod", "", _outStream);
            }


            else if ((*iter)->has_gamma())
            {
                (*iter)->get_gamma().toXmlElem("a:gamma", "", _outStream);
            }


            else if ((*iter)->has_invGamma())
            {
                (*iter)->get_invGamma().toXmlElem("a:invGamma", "", _outStream);
            }


        }
    }

    _outStream << "</" << _elemName << ">";
}

const CT_HslColor& CT_HslColor::default_instance()
{
    if (!CT_HslColor::default_instance_)
    {
        CT_HslColor::default_instance_ = new CT_HslColor();
    }
    return *CT_HslColor::default_instance_;
}

bool CT_HslColor::has_hue_attr() const
{
    return m_has_hue_attr;
}

void CT_HslColor::set_hue_attr(const ST_PositiveFixedAngle& _hue_attr)
{
    m_has_hue_attr = true;
    m_hue_attr = new ST_PositiveFixedAngle(_hue_attr);
}

const ST_PositiveFixedAngle& CT_HslColor::get_hue_attr() const
{
    if (m_hue_attr)
    {
        return *m_hue_attr;
    }
    return ST_PositiveFixedAngle::default_instance();
}

bool CT_HslColor::has_sat_attr() const
{
    return m_has_sat_attr;
}

void CT_HslColor::set_sat_attr(const ST_Percentage& _sat_attr)
{
    m_has_sat_attr = true;
    m_sat_attr = new ST_Percentage(_sat_attr);
}

const ST_Percentage& CT_HslColor::get_sat_attr() const
{
    if (m_sat_attr)
    {
        return *m_sat_attr;
    }
    return ST_Percentage::default_instance();
}

bool CT_HslColor::has_lum_attr() const
{
    return m_has_lum_attr;
}

void CT_HslColor::set_lum_attr(const ST_Percentage& _lum_attr)
{
    m_has_lum_attr = true;
    m_lum_attr = new ST_Percentage(_lum_attr);
}

const ST_Percentage& CT_HslColor::get_lum_attr() const
{
    if (m_lum_attr)
    {
        return *m_lum_attr;
    }
    return ST_Percentage::default_instance();
}


// CT_HslColor::ChildGroup_1
CT_HslColor::ChildGroup_1::ChildGroup_1()
    :m_has_tint(false),
     m_tint(NULL),
     m_has_shade(false),
     m_shade(NULL),
     m_has_comp(false),
     m_comp(NULL),
     m_has_inv(false),
     m_inv(NULL),
     m_has_gray(false),
     m_gray(NULL),
     m_has_alpha(false),
     m_alpha(NULL),
     m_has_alphaOff(false),
     m_alphaOff(NULL),
     m_has_alphaMod(false),
     m_alphaMod(NULL),
     m_has_hue(false),
     m_hue(NULL),
     m_has_hueOff(false),
     m_hueOff(NULL),
     m_has_hueMod(false),
     m_hueMod(NULL),
     m_has_sat(false),
     m_sat(NULL),
     m_has_satOff(false),
     m_satOff(NULL),
     m_has_satMod(false),
     m_satMod(NULL),
     m_has_lum(false),
     m_lum(NULL),
     m_has_lumOff(false),
     m_lumOff(NULL),
     m_has_lumMod(false),
     m_lumMod(NULL),
     m_has_red(false),
     m_red(NULL),
     m_has_redOff(false),
     m_redOff(NULL),
     m_has_redMod(false),
     m_redMod(NULL),
     m_has_green(false),
     m_green(NULL),
     m_has_greenOff(false),
     m_greenOff(NULL),
     m_has_greenMod(false),
     m_greenMod(NULL),
     m_has_blue(false),
     m_blue(NULL),
     m_has_blueOff(false),
     m_blueOff(NULL),
     m_has_blueMod(false),
     m_blueMod(NULL),
     m_has_gamma(false),
     m_gamma(NULL),
     m_has_invGamma(false),
     m_invGamma(NULL)
{
}
bool CT_HslColor::ChildGroup_1::has_tint() const
{
    return m_has_tint;
}

CT_PositiveFixedPercentage* CT_HslColor::ChildGroup_1::mutable_tint()
{

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_tint = true;
    if (!m_tint)
    {
        m_tint = new CT_PositiveFixedPercentage();
    }
    return m_tint;
}

const CT_PositiveFixedPercentage& CT_HslColor::ChildGroup_1::get_tint() const
{
    if (m_tint)
    {
        return *m_tint;
    }
    return CT_PositiveFixedPercentage::default_instance();
}

bool CT_HslColor::ChildGroup_1::has_shade() const
{
    return m_has_shade;
}

CT_PositiveFixedPercentage* CT_HslColor::ChildGroup_1::mutable_shade()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_shade = true;
    if (!m_shade)
    {
        m_shade = new CT_PositiveFixedPercentage();
    }
    return m_shade;
}

const CT_PositiveFixedPercentage& CT_HslColor::ChildGroup_1::get_shade() const
{
    if (m_shade)
    {
        return *m_shade;
    }
    return CT_PositiveFixedPercentage::default_instance();
}

bool CT_HslColor::ChildGroup_1::has_comp() const
{
    return m_has_comp;
}

CT_ComplementTransform* CT_HslColor::ChildGroup_1::mutable_comp()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_comp = true;
    if (!m_comp)
    {
        m_comp = new CT_ComplementTransform();
    }
    return m_comp;
}

const CT_ComplementTransform& CT_HslColor::ChildGroup_1::get_comp() const
{
    if (m_comp)
    {
        return *m_comp;
    }
    return CT_ComplementTransform::default_instance();
}

bool CT_HslColor::ChildGroup_1::has_inv() const
{
    return m_has_inv;
}

CT_InverseTransform* CT_HslColor::ChildGroup_1::mutable_inv()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_inv = true;
    if (!m_inv)
    {
        m_inv = new CT_InverseTransform();
    }
    return m_inv;
}

const CT_InverseTransform& CT_HslColor::ChildGroup_1::get_inv() const
{
    if (m_inv)
    {
        return *m_inv;
    }
    return CT_InverseTransform::default_instance();
}

bool CT_HslColor::ChildGroup_1::has_gray() const
{
    return m_has_gray;
}

CT_GrayscaleTransform* CT_HslColor::ChildGroup_1::mutable_gray()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_gray = true;
    if (!m_gray)
    {
        m_gray = new CT_GrayscaleTransform();
    }
    return m_gray;
}

const CT_GrayscaleTransform& CT_HslColor::ChildGroup_1::get_gray() const
{
    if (m_gray)
    {
        return *m_gray;
    }
    return CT_GrayscaleTransform::default_instance();
}

bool CT_HslColor::ChildGroup_1::has_alpha() const
{
    return m_has_alpha;
}

CT_PositiveFixedPercentage* CT_HslColor::ChildGroup_1::mutable_alpha()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_alpha = true;
    if (!m_alpha)
    {
        m_alpha = new CT_PositiveFixedPercentage();
    }
    return m_alpha;
}

const CT_PositiveFixedPercentage& CT_HslColor::ChildGroup_1::get_alpha() const
{
    if (m_alpha)
    {
        return *m_alpha;
    }
    return CT_PositiveFixedPercentage::default_instance();
}

bool CT_HslColor::ChildGroup_1::has_alphaOff() const
{
    return m_has_alphaOff;
}

CT_FixedPercentage* CT_HslColor::ChildGroup_1::mutable_alphaOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_alphaOff = true;
    if (!m_alphaOff)
    {
        m_alphaOff = new CT_FixedPercentage();
    }
    return m_alphaOff;
}

const CT_FixedPercentage& CT_HslColor::ChildGroup_1::get_alphaOff() const
{
    if (m_alphaOff)
    {
        return *m_alphaOff;
    }
    return CT_FixedPercentage::default_instance();
}

bool CT_HslColor::ChildGroup_1::has_alphaMod() const
{
    return m_has_alphaMod;
}

CT_PositivePercentage* CT_HslColor::ChildGroup_1::mutable_alphaMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_alphaMod = true;
    if (!m_alphaMod)
    {
        m_alphaMod = new CT_PositivePercentage();
    }
    return m_alphaMod;
}

const CT_PositivePercentage& CT_HslColor::ChildGroup_1::get_alphaMod() const
{
    if (m_alphaMod)
    {
        return *m_alphaMod;
    }
    return CT_PositivePercentage::default_instance();
}

bool CT_HslColor::ChildGroup_1::has_hue() const
{
    return m_has_hue;
}

CT_PositiveFixedAngle* CT_HslColor::ChildGroup_1::mutable_hue()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_hue = true;
    if (!m_hue)
    {
        m_hue = new CT_PositiveFixedAngle();
    }
    return m_hue;
}

const CT_PositiveFixedAngle& CT_HslColor::ChildGroup_1::get_hue() const
{
    if (m_hue)
    {
        return *m_hue;
    }
    return CT_PositiveFixedAngle::default_instance();
}

bool CT_HslColor::ChildGroup_1::has_hueOff() const
{
    return m_has_hueOff;
}

CT_Angle* CT_HslColor::ChildGroup_1::mutable_hueOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_hueOff = true;
    if (!m_hueOff)
    {
        m_hueOff = new CT_Angle();
    }
    return m_hueOff;
}

const CT_Angle& CT_HslColor::ChildGroup_1::get_hueOff() const
{
    if (m_hueOff)
    {
        return *m_hueOff;
    }
    return CT_Angle::default_instance();
}

bool CT_HslColor::ChildGroup_1::has_hueMod() const
{
    return m_has_hueMod;
}

CT_PositivePercentage* CT_HslColor::ChildGroup_1::mutable_hueMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_hueMod = true;
    if (!m_hueMod)
    {
        m_hueMod = new CT_PositivePercentage();
    }
    return m_hueMod;
}

const CT_PositivePercentage& CT_HslColor::ChildGroup_1::get_hueMod() const
{
    if (m_hueMod)
    {
        return *m_hueMod;
    }
    return CT_PositivePercentage::default_instance();
}

bool CT_HslColor::ChildGroup_1::has_sat() const
{
    return m_has_sat;
}

CT_Percentage* CT_HslColor::ChildGroup_1::mutable_sat()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_sat = true;
    if (!m_sat)
    {
        m_sat = new CT_Percentage();
    }
    return m_sat;
}

const CT_Percentage& CT_HslColor::ChildGroup_1::get_sat() const
{
    if (m_sat)
    {
        return *m_sat;
    }
    return CT_Percentage::default_instance();
}

bool CT_HslColor::ChildGroup_1::has_satOff() const
{
    return m_has_satOff;
}

CT_Percentage* CT_HslColor::ChildGroup_1::mutable_satOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_satOff = true;
    if (!m_satOff)
    {
        m_satOff = new CT_Percentage();
    }
    return m_satOff;
}

const CT_Percentage& CT_HslColor::ChildGroup_1::get_satOff() const
{
    if (m_satOff)
    {
        return *m_satOff;
    }
    return CT_Percentage::default_instance();
}

bool CT_HslColor::ChildGroup_1::has_satMod() const
{
    return m_has_satMod;
}

CT_Percentage* CT_HslColor::ChildGroup_1::mutable_satMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_satMod = true;
    if (!m_satMod)
    {
        m_satMod = new CT_Percentage();
    }
    return m_satMod;
}

const CT_Percentage& CT_HslColor::ChildGroup_1::get_satMod() const
{
    if (m_satMod)
    {
        return *m_satMod;
    }
    return CT_Percentage::default_instance();
}

bool CT_HslColor::ChildGroup_1::has_lum() const
{
    return m_has_lum;
}

CT_Percentage* CT_HslColor::ChildGroup_1::mutable_lum()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_lum = true;
    if (!m_lum)
    {
        m_lum = new CT_Percentage();
    }
    return m_lum;
}

const CT_Percentage& CT_HslColor::ChildGroup_1::get_lum() const
{
    if (m_lum)
    {
        return *m_lum;
    }
    return CT_Percentage::default_instance();
}

bool CT_HslColor::ChildGroup_1::has_lumOff() const
{
    return m_has_lumOff;
}

CT_Percentage* CT_HslColor::ChildGroup_1::mutable_lumOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_lumOff = true;
    if (!m_lumOff)
    {
        m_lumOff = new CT_Percentage();
    }
    return m_lumOff;
}

const CT_Percentage& CT_HslColor::ChildGroup_1::get_lumOff() const
{
    if (m_lumOff)
    {
        return *m_lumOff;
    }
    return CT_Percentage::default_instance();
}

bool CT_HslColor::ChildGroup_1::has_lumMod() const
{
    return m_has_lumMod;
}

CT_Percentage* CT_HslColor::ChildGroup_1::mutable_lumMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_lumMod = true;
    if (!m_lumMod)
    {
        m_lumMod = new CT_Percentage();
    }
    return m_lumMod;
}

const CT_Percentage& CT_HslColor::ChildGroup_1::get_lumMod() const
{
    if (m_lumMod)
    {
        return *m_lumMod;
    }
    return CT_Percentage::default_instance();
}

bool CT_HslColor::ChildGroup_1::has_red() const
{
    return m_has_red;
}

CT_Percentage* CT_HslColor::ChildGroup_1::mutable_red()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_red = true;
    if (!m_red)
    {
        m_red = new CT_Percentage();
    }
    return m_red;
}

const CT_Percentage& CT_HslColor::ChildGroup_1::get_red() const
{
    if (m_red)
    {
        return *m_red;
    }
    return CT_Percentage::default_instance();
}

bool CT_HslColor::ChildGroup_1::has_redOff() const
{
    return m_has_redOff;
}

CT_Percentage* CT_HslColor::ChildGroup_1::mutable_redOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_redOff = true;
    if (!m_redOff)
    {
        m_redOff = new CT_Percentage();
    }
    return m_redOff;
}

const CT_Percentage& CT_HslColor::ChildGroup_1::get_redOff() const
{
    if (m_redOff)
    {
        return *m_redOff;
    }
    return CT_Percentage::default_instance();
}

bool CT_HslColor::ChildGroup_1::has_redMod() const
{
    return m_has_redMod;
}

CT_Percentage* CT_HslColor::ChildGroup_1::mutable_redMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_redMod = true;
    if (!m_redMod)
    {
        m_redMod = new CT_Percentage();
    }
    return m_redMod;
}

const CT_Percentage& CT_HslColor::ChildGroup_1::get_redMod() const
{
    if (m_redMod)
    {
        return *m_redMod;
    }
    return CT_Percentage::default_instance();
}

bool CT_HslColor::ChildGroup_1::has_green() const
{
    return m_has_green;
}

CT_Percentage* CT_HslColor::ChildGroup_1::mutable_green()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_green = true;
    if (!m_green)
    {
        m_green = new CT_Percentage();
    }
    return m_green;
}

const CT_Percentage& CT_HslColor::ChildGroup_1::get_green() const
{
    if (m_green)
    {
        return *m_green;
    }
    return CT_Percentage::default_instance();
}

bool CT_HslColor::ChildGroup_1::has_greenOff() const
{
    return m_has_greenOff;
}

CT_Percentage* CT_HslColor::ChildGroup_1::mutable_greenOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_greenOff = true;
    if (!m_greenOff)
    {
        m_greenOff = new CT_Percentage();
    }
    return m_greenOff;
}

const CT_Percentage& CT_HslColor::ChildGroup_1::get_greenOff() const
{
    if (m_greenOff)
    {
        return *m_greenOff;
    }
    return CT_Percentage::default_instance();
}

bool CT_HslColor::ChildGroup_1::has_greenMod() const
{
    return m_has_greenMod;
}

CT_Percentage* CT_HslColor::ChildGroup_1::mutable_greenMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_greenMod = true;
    if (!m_greenMod)
    {
        m_greenMod = new CT_Percentage();
    }
    return m_greenMod;
}

const CT_Percentage& CT_HslColor::ChildGroup_1::get_greenMod() const
{
    if (m_greenMod)
    {
        return *m_greenMod;
    }
    return CT_Percentage::default_instance();
}

bool CT_HslColor::ChildGroup_1::has_blue() const
{
    return m_has_blue;
}

CT_Percentage* CT_HslColor::ChildGroup_1::mutable_blue()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_blue = true;
    if (!m_blue)
    {
        m_blue = new CT_Percentage();
    }
    return m_blue;
}

const CT_Percentage& CT_HslColor::ChildGroup_1::get_blue() const
{
    if (m_blue)
    {
        return *m_blue;
    }
    return CT_Percentage::default_instance();
}

bool CT_HslColor::ChildGroup_1::has_blueOff() const
{
    return m_has_blueOff;
}

CT_Percentage* CT_HslColor::ChildGroup_1::mutable_blueOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_blueOff = true;
    if (!m_blueOff)
    {
        m_blueOff = new CT_Percentage();
    }
    return m_blueOff;
}

const CT_Percentage& CT_HslColor::ChildGroup_1::get_blueOff() const
{
    if (m_blueOff)
    {
        return *m_blueOff;
    }
    return CT_Percentage::default_instance();
}

bool CT_HslColor::ChildGroup_1::has_blueMod() const
{
    return m_has_blueMod;
}

CT_Percentage* CT_HslColor::ChildGroup_1::mutable_blueMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_blueMod = true;
    if (!m_blueMod)
    {
        m_blueMod = new CT_Percentage();
    }
    return m_blueMod;
}

const CT_Percentage& CT_HslColor::ChildGroup_1::get_blueMod() const
{
    if (m_blueMod)
    {
        return *m_blueMod;
    }
    return CT_Percentage::default_instance();
}

bool CT_HslColor::ChildGroup_1::has_gamma() const
{
    return m_has_gamma;
}

CT_GammaTransform* CT_HslColor::ChildGroup_1::mutable_gamma()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_gamma = true;
    if (!m_gamma)
    {
        m_gamma = new CT_GammaTransform();
    }
    return m_gamma;
}

const CT_GammaTransform& CT_HslColor::ChildGroup_1::get_gamma() const
{
    if (m_gamma)
    {
        return *m_gamma;
    }
    return CT_GammaTransform::default_instance();
}

bool CT_HslColor::ChildGroup_1::has_invGamma() const
{
    return m_has_invGamma;
}

CT_InverseGammaTransform* CT_HslColor::ChildGroup_1::mutable_invGamma()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = true;
    if (!m_invGamma)
    {
        m_invGamma = new CT_InverseGammaTransform();
    }
    return m_invGamma;
}

const CT_InverseGammaTransform& CT_HslColor::ChildGroup_1::get_invGamma() const
{
    if (m_invGamma)
    {
        return *m_invGamma;
    }
    return CT_InverseGammaTransform::default_instance();
}

CT_HslColor* CT_HslColor::default_instance_ = NULL;

// CT_SystemColor
CT_SystemColor::CT_SystemColor()
    :m_has_val_attr(false),
     m_val_attr(NULL),
     m_has_lastClr_attr(false),
     m_lastClr_attr(NULL)
{
}
CT_SystemColor::~CT_SystemColor()
{
    clear();
}
CT_PositiveFixedPercentage* CT_SystemColor::add_tint()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PositiveFixedPercentage* pNewChild = pChildGroup->mutable_tint();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_PositiveFixedPercentage* CT_SystemColor::add_shade()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PositiveFixedPercentage* pNewChild = pChildGroup->mutable_shade();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_ComplementTransform* CT_SystemColor::add_comp()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_ComplementTransform* pNewChild = pChildGroup->mutable_comp();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_InverseTransform* CT_SystemColor::add_inv()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_InverseTransform* pNewChild = pChildGroup->mutable_inv();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_GrayscaleTransform* CT_SystemColor::add_gray()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_GrayscaleTransform* pNewChild = pChildGroup->mutable_gray();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_PositiveFixedPercentage* CT_SystemColor::add_alpha()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PositiveFixedPercentage* pNewChild = pChildGroup->mutable_alpha();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_FixedPercentage* CT_SystemColor::add_alphaOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_FixedPercentage* pNewChild = pChildGroup->mutable_alphaOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_PositivePercentage* CT_SystemColor::add_alphaMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PositivePercentage* pNewChild = pChildGroup->mutable_alphaMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_PositiveFixedAngle* CT_SystemColor::add_hue()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PositiveFixedAngle* pNewChild = pChildGroup->mutable_hue();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Angle* CT_SystemColor::add_hueOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Angle* pNewChild = pChildGroup->mutable_hueOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_PositivePercentage* CT_SystemColor::add_hueMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PositivePercentage* pNewChild = pChildGroup->mutable_hueMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SystemColor::add_sat()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_sat();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SystemColor::add_satOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_satOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SystemColor::add_satMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_satMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SystemColor::add_lum()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_lum();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SystemColor::add_lumOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_lumOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SystemColor::add_lumMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_lumMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SystemColor::add_red()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_red();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SystemColor::add_redOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_redOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SystemColor::add_redMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_redMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SystemColor::add_green()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_green();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SystemColor::add_greenOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_greenOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SystemColor::add_greenMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_greenMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SystemColor::add_blue()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_blue();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SystemColor::add_blueOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_blueOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SystemColor::add_blueMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_blueMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_GammaTransform* CT_SystemColor::add_gamma()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_GammaTransform* pNewChild = pChildGroup->mutable_gamma();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_InverseGammaTransform* CT_SystemColor::add_invGamma()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_InverseGammaTransform* pNewChild = pChildGroup->mutable_invGamma();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

void CT_SystemColor::clear()
{
    m_has_val_attr = false;

    if (m_val_attr)
    {
        delete m_val_attr;
        m_val_attr = NULL;
    }


    m_has_lastClr_attr = false;

    if (m_lastClr_attr)
    {
        delete m_lastClr_attr;
        m_lastClr_attr = NULL;
    }


    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }
}

void CT_SystemColor::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_val_attr);
    if (m_has_val_attr)
    {
        m_val_attr->toXmlAttr("val", _outStream);
    }



    if (m_has_lastClr_attr)
    {
        m_lastClr_attr->toXmlAttr("lastClr", _outStream);
    }

    _outStream << ">";

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_tint())
            {
                (*iter)->get_tint().toXmlElem("a:tint", "", _outStream);
            }


            else if ((*iter)->has_shade())
            {
                (*iter)->get_shade().toXmlElem("a:shade", "", _outStream);
            }


            else if ((*iter)->has_comp())
            {
                (*iter)->get_comp().toXmlElem("a:comp", "", _outStream);
            }


            else if ((*iter)->has_inv())
            {
                (*iter)->get_inv().toXmlElem("a:inv", "", _outStream);
            }


            else if ((*iter)->has_gray())
            {
                (*iter)->get_gray().toXmlElem("a:gray", "", _outStream);
            }


            else if ((*iter)->has_alpha())
            {
                (*iter)->get_alpha().toXmlElem("a:alpha", "", _outStream);
            }


            else if ((*iter)->has_alphaOff())
            {
                (*iter)->get_alphaOff().toXmlElem("a:alphaOff", "", _outStream);
            }


            else if ((*iter)->has_alphaMod())
            {
                (*iter)->get_alphaMod().toXmlElem("a:alphaMod", "", _outStream);
            }


            else if ((*iter)->has_hue())
            {
                (*iter)->get_hue().toXmlElem("a:hue", "", _outStream);
            }


            else if ((*iter)->has_hueOff())
            {
                (*iter)->get_hueOff().toXmlElem("a:hueOff", "", _outStream);
            }


            else if ((*iter)->has_hueMod())
            {
                (*iter)->get_hueMod().toXmlElem("a:hueMod", "", _outStream);
            }


            else if ((*iter)->has_sat())
            {
                (*iter)->get_sat().toXmlElem("a:sat", "", _outStream);
            }


            else if ((*iter)->has_satOff())
            {
                (*iter)->get_satOff().toXmlElem("a:satOff", "", _outStream);
            }


            else if ((*iter)->has_satMod())
            {
                (*iter)->get_satMod().toXmlElem("a:satMod", "", _outStream);
            }


            else if ((*iter)->has_lum())
            {
                (*iter)->get_lum().toXmlElem("a:lum", "", _outStream);
            }


            else if ((*iter)->has_lumOff())
            {
                (*iter)->get_lumOff().toXmlElem("a:lumOff", "", _outStream);
            }


            else if ((*iter)->has_lumMod())
            {
                (*iter)->get_lumMod().toXmlElem("a:lumMod", "", _outStream);
            }


            else if ((*iter)->has_red())
            {
                (*iter)->get_red().toXmlElem("a:red", "", _outStream);
            }


            else if ((*iter)->has_redOff())
            {
                (*iter)->get_redOff().toXmlElem("a:redOff", "", _outStream);
            }


            else if ((*iter)->has_redMod())
            {
                (*iter)->get_redMod().toXmlElem("a:redMod", "", _outStream);
            }


            else if ((*iter)->has_green())
            {
                (*iter)->get_green().toXmlElem("a:green", "", _outStream);
            }


            else if ((*iter)->has_greenOff())
            {
                (*iter)->get_greenOff().toXmlElem("a:greenOff", "", _outStream);
            }


            else if ((*iter)->has_greenMod())
            {
                (*iter)->get_greenMod().toXmlElem("a:greenMod", "", _outStream);
            }


            else if ((*iter)->has_blue())
            {
                (*iter)->get_blue().toXmlElem("a:blue", "", _outStream);
            }


            else if ((*iter)->has_blueOff())
            {
                (*iter)->get_blueOff().toXmlElem("a:blueOff", "", _outStream);
            }


            else if ((*iter)->has_blueMod())
            {
                (*iter)->get_blueMod().toXmlElem("a:blueMod", "", _outStream);
            }


            else if ((*iter)->has_gamma())
            {
                (*iter)->get_gamma().toXmlElem("a:gamma", "", _outStream);
            }


            else if ((*iter)->has_invGamma())
            {
                (*iter)->get_invGamma().toXmlElem("a:invGamma", "", _outStream);
            }


        }
    }

    _outStream << "</" << _elemName << ">";
}

const CT_SystemColor& CT_SystemColor::default_instance()
{
    if (!CT_SystemColor::default_instance_)
    {
        CT_SystemColor::default_instance_ = new CT_SystemColor();
    }
    return *CT_SystemColor::default_instance_;
}

bool CT_SystemColor::has_val_attr() const
{
    return m_has_val_attr;
}

void CT_SystemColor::set_val_attr(const ST_SystemColorVal& _val_attr)
{
    m_has_val_attr = true;
    m_val_attr = new ST_SystemColorVal(_val_attr);
}

const ST_SystemColorVal& CT_SystemColor::get_val_attr() const
{
    if (m_val_attr)
    {
        return *m_val_attr;
    }
    return ST_SystemColorVal::default_instance();
}

bool CT_SystemColor::has_lastClr_attr() const
{
    return m_has_lastClr_attr;
}

void CT_SystemColor::set_lastClr_attr(const ns_s::ST_HexColorRGB& _lastClr_attr)
{
    m_has_lastClr_attr = true;
    m_lastClr_attr = new ns_s::ST_HexColorRGB(_lastClr_attr);
}

const ns_s::ST_HexColorRGB& CT_SystemColor::get_lastClr_attr() const
{
    if (m_lastClr_attr)
    {
        return *m_lastClr_attr;
    }
    return ns_s::ST_HexColorRGB::default_instance();
}


// CT_SystemColor::ChildGroup_1
CT_SystemColor::ChildGroup_1::ChildGroup_1()
    :m_has_tint(false),
     m_tint(NULL),
     m_has_shade(false),
     m_shade(NULL),
     m_has_comp(false),
     m_comp(NULL),
     m_has_inv(false),
     m_inv(NULL),
     m_has_gray(false),
     m_gray(NULL),
     m_has_alpha(false),
     m_alpha(NULL),
     m_has_alphaOff(false),
     m_alphaOff(NULL),
     m_has_alphaMod(false),
     m_alphaMod(NULL),
     m_has_hue(false),
     m_hue(NULL),
     m_has_hueOff(false),
     m_hueOff(NULL),
     m_has_hueMod(false),
     m_hueMod(NULL),
     m_has_sat(false),
     m_sat(NULL),
     m_has_satOff(false),
     m_satOff(NULL),
     m_has_satMod(false),
     m_satMod(NULL),
     m_has_lum(false),
     m_lum(NULL),
     m_has_lumOff(false),
     m_lumOff(NULL),
     m_has_lumMod(false),
     m_lumMod(NULL),
     m_has_red(false),
     m_red(NULL),
     m_has_redOff(false),
     m_redOff(NULL),
     m_has_redMod(false),
     m_redMod(NULL),
     m_has_green(false),
     m_green(NULL),
     m_has_greenOff(false),
     m_greenOff(NULL),
     m_has_greenMod(false),
     m_greenMod(NULL),
     m_has_blue(false),
     m_blue(NULL),
     m_has_blueOff(false),
     m_blueOff(NULL),
     m_has_blueMod(false),
     m_blueMod(NULL),
     m_has_gamma(false),
     m_gamma(NULL),
     m_has_invGamma(false),
     m_invGamma(NULL)
{
}
bool CT_SystemColor::ChildGroup_1::has_tint() const
{
    return m_has_tint;
}

CT_PositiveFixedPercentage* CT_SystemColor::ChildGroup_1::mutable_tint()
{

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_tint = true;
    if (!m_tint)
    {
        m_tint = new CT_PositiveFixedPercentage();
    }
    return m_tint;
}

const CT_PositiveFixedPercentage& CT_SystemColor::ChildGroup_1::get_tint() const
{
    if (m_tint)
    {
        return *m_tint;
    }
    return CT_PositiveFixedPercentage::default_instance();
}

bool CT_SystemColor::ChildGroup_1::has_shade() const
{
    return m_has_shade;
}

CT_PositiveFixedPercentage* CT_SystemColor::ChildGroup_1::mutable_shade()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_shade = true;
    if (!m_shade)
    {
        m_shade = new CT_PositiveFixedPercentage();
    }
    return m_shade;
}

const CT_PositiveFixedPercentage& CT_SystemColor::ChildGroup_1::get_shade() const
{
    if (m_shade)
    {
        return *m_shade;
    }
    return CT_PositiveFixedPercentage::default_instance();
}

bool CT_SystemColor::ChildGroup_1::has_comp() const
{
    return m_has_comp;
}

CT_ComplementTransform* CT_SystemColor::ChildGroup_1::mutable_comp()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_comp = true;
    if (!m_comp)
    {
        m_comp = new CT_ComplementTransform();
    }
    return m_comp;
}

const CT_ComplementTransform& CT_SystemColor::ChildGroup_1::get_comp() const
{
    if (m_comp)
    {
        return *m_comp;
    }
    return CT_ComplementTransform::default_instance();
}

bool CT_SystemColor::ChildGroup_1::has_inv() const
{
    return m_has_inv;
}

CT_InverseTransform* CT_SystemColor::ChildGroup_1::mutable_inv()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_inv = true;
    if (!m_inv)
    {
        m_inv = new CT_InverseTransform();
    }
    return m_inv;
}

const CT_InverseTransform& CT_SystemColor::ChildGroup_1::get_inv() const
{
    if (m_inv)
    {
        return *m_inv;
    }
    return CT_InverseTransform::default_instance();
}

bool CT_SystemColor::ChildGroup_1::has_gray() const
{
    return m_has_gray;
}

CT_GrayscaleTransform* CT_SystemColor::ChildGroup_1::mutable_gray()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_gray = true;
    if (!m_gray)
    {
        m_gray = new CT_GrayscaleTransform();
    }
    return m_gray;
}

const CT_GrayscaleTransform& CT_SystemColor::ChildGroup_1::get_gray() const
{
    if (m_gray)
    {
        return *m_gray;
    }
    return CT_GrayscaleTransform::default_instance();
}

bool CT_SystemColor::ChildGroup_1::has_alpha() const
{
    return m_has_alpha;
}

CT_PositiveFixedPercentage* CT_SystemColor::ChildGroup_1::mutable_alpha()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_alpha = true;
    if (!m_alpha)
    {
        m_alpha = new CT_PositiveFixedPercentage();
    }
    return m_alpha;
}

const CT_PositiveFixedPercentage& CT_SystemColor::ChildGroup_1::get_alpha() const
{
    if (m_alpha)
    {
        return *m_alpha;
    }
    return CT_PositiveFixedPercentage::default_instance();
}

bool CT_SystemColor::ChildGroup_1::has_alphaOff() const
{
    return m_has_alphaOff;
}

CT_FixedPercentage* CT_SystemColor::ChildGroup_1::mutable_alphaOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_alphaOff = true;
    if (!m_alphaOff)
    {
        m_alphaOff = new CT_FixedPercentage();
    }
    return m_alphaOff;
}

const CT_FixedPercentage& CT_SystemColor::ChildGroup_1::get_alphaOff() const
{
    if (m_alphaOff)
    {
        return *m_alphaOff;
    }
    return CT_FixedPercentage::default_instance();
}

bool CT_SystemColor::ChildGroup_1::has_alphaMod() const
{
    return m_has_alphaMod;
}

CT_PositivePercentage* CT_SystemColor::ChildGroup_1::mutable_alphaMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_alphaMod = true;
    if (!m_alphaMod)
    {
        m_alphaMod = new CT_PositivePercentage();
    }
    return m_alphaMod;
}

const CT_PositivePercentage& CT_SystemColor::ChildGroup_1::get_alphaMod() const
{
    if (m_alphaMod)
    {
        return *m_alphaMod;
    }
    return CT_PositivePercentage::default_instance();
}

bool CT_SystemColor::ChildGroup_1::has_hue() const
{
    return m_has_hue;
}

CT_PositiveFixedAngle* CT_SystemColor::ChildGroup_1::mutable_hue()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_hue = true;
    if (!m_hue)
    {
        m_hue = new CT_PositiveFixedAngle();
    }
    return m_hue;
}

const CT_PositiveFixedAngle& CT_SystemColor::ChildGroup_1::get_hue() const
{
    if (m_hue)
    {
        return *m_hue;
    }
    return CT_PositiveFixedAngle::default_instance();
}

bool CT_SystemColor::ChildGroup_1::has_hueOff() const
{
    return m_has_hueOff;
}

CT_Angle* CT_SystemColor::ChildGroup_1::mutable_hueOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_hueOff = true;
    if (!m_hueOff)
    {
        m_hueOff = new CT_Angle();
    }
    return m_hueOff;
}

const CT_Angle& CT_SystemColor::ChildGroup_1::get_hueOff() const
{
    if (m_hueOff)
    {
        return *m_hueOff;
    }
    return CT_Angle::default_instance();
}

bool CT_SystemColor::ChildGroup_1::has_hueMod() const
{
    return m_has_hueMod;
}

CT_PositivePercentage* CT_SystemColor::ChildGroup_1::mutable_hueMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_hueMod = true;
    if (!m_hueMod)
    {
        m_hueMod = new CT_PositivePercentage();
    }
    return m_hueMod;
}

const CT_PositivePercentage& CT_SystemColor::ChildGroup_1::get_hueMod() const
{
    if (m_hueMod)
    {
        return *m_hueMod;
    }
    return CT_PositivePercentage::default_instance();
}

bool CT_SystemColor::ChildGroup_1::has_sat() const
{
    return m_has_sat;
}

CT_Percentage* CT_SystemColor::ChildGroup_1::mutable_sat()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_sat = true;
    if (!m_sat)
    {
        m_sat = new CT_Percentage();
    }
    return m_sat;
}

const CT_Percentage& CT_SystemColor::ChildGroup_1::get_sat() const
{
    if (m_sat)
    {
        return *m_sat;
    }
    return CT_Percentage::default_instance();
}

bool CT_SystemColor::ChildGroup_1::has_satOff() const
{
    return m_has_satOff;
}

CT_Percentage* CT_SystemColor::ChildGroup_1::mutable_satOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_satOff = true;
    if (!m_satOff)
    {
        m_satOff = new CT_Percentage();
    }
    return m_satOff;
}

const CT_Percentage& CT_SystemColor::ChildGroup_1::get_satOff() const
{
    if (m_satOff)
    {
        return *m_satOff;
    }
    return CT_Percentage::default_instance();
}

bool CT_SystemColor::ChildGroup_1::has_satMod() const
{
    return m_has_satMod;
}

CT_Percentage* CT_SystemColor::ChildGroup_1::mutable_satMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_satMod = true;
    if (!m_satMod)
    {
        m_satMod = new CT_Percentage();
    }
    return m_satMod;
}

const CT_Percentage& CT_SystemColor::ChildGroup_1::get_satMod() const
{
    if (m_satMod)
    {
        return *m_satMod;
    }
    return CT_Percentage::default_instance();
}

bool CT_SystemColor::ChildGroup_1::has_lum() const
{
    return m_has_lum;
}

CT_Percentage* CT_SystemColor::ChildGroup_1::mutable_lum()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_lum = true;
    if (!m_lum)
    {
        m_lum = new CT_Percentage();
    }
    return m_lum;
}

const CT_Percentage& CT_SystemColor::ChildGroup_1::get_lum() const
{
    if (m_lum)
    {
        return *m_lum;
    }
    return CT_Percentage::default_instance();
}

bool CT_SystemColor::ChildGroup_1::has_lumOff() const
{
    return m_has_lumOff;
}

CT_Percentage* CT_SystemColor::ChildGroup_1::mutable_lumOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_lumOff = true;
    if (!m_lumOff)
    {
        m_lumOff = new CT_Percentage();
    }
    return m_lumOff;
}

const CT_Percentage& CT_SystemColor::ChildGroup_1::get_lumOff() const
{
    if (m_lumOff)
    {
        return *m_lumOff;
    }
    return CT_Percentage::default_instance();
}

bool CT_SystemColor::ChildGroup_1::has_lumMod() const
{
    return m_has_lumMod;
}

CT_Percentage* CT_SystemColor::ChildGroup_1::mutable_lumMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_lumMod = true;
    if (!m_lumMod)
    {
        m_lumMod = new CT_Percentage();
    }
    return m_lumMod;
}

const CT_Percentage& CT_SystemColor::ChildGroup_1::get_lumMod() const
{
    if (m_lumMod)
    {
        return *m_lumMod;
    }
    return CT_Percentage::default_instance();
}

bool CT_SystemColor::ChildGroup_1::has_red() const
{
    return m_has_red;
}

CT_Percentage* CT_SystemColor::ChildGroup_1::mutable_red()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_red = true;
    if (!m_red)
    {
        m_red = new CT_Percentage();
    }
    return m_red;
}

const CT_Percentage& CT_SystemColor::ChildGroup_1::get_red() const
{
    if (m_red)
    {
        return *m_red;
    }
    return CT_Percentage::default_instance();
}

bool CT_SystemColor::ChildGroup_1::has_redOff() const
{
    return m_has_redOff;
}

CT_Percentage* CT_SystemColor::ChildGroup_1::mutable_redOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_redOff = true;
    if (!m_redOff)
    {
        m_redOff = new CT_Percentage();
    }
    return m_redOff;
}

const CT_Percentage& CT_SystemColor::ChildGroup_1::get_redOff() const
{
    if (m_redOff)
    {
        return *m_redOff;
    }
    return CT_Percentage::default_instance();
}

bool CT_SystemColor::ChildGroup_1::has_redMod() const
{
    return m_has_redMod;
}

CT_Percentage* CT_SystemColor::ChildGroup_1::mutable_redMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_redMod = true;
    if (!m_redMod)
    {
        m_redMod = new CT_Percentage();
    }
    return m_redMod;
}

const CT_Percentage& CT_SystemColor::ChildGroup_1::get_redMod() const
{
    if (m_redMod)
    {
        return *m_redMod;
    }
    return CT_Percentage::default_instance();
}

bool CT_SystemColor::ChildGroup_1::has_green() const
{
    return m_has_green;
}

CT_Percentage* CT_SystemColor::ChildGroup_1::mutable_green()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_green = true;
    if (!m_green)
    {
        m_green = new CT_Percentage();
    }
    return m_green;
}

const CT_Percentage& CT_SystemColor::ChildGroup_1::get_green() const
{
    if (m_green)
    {
        return *m_green;
    }
    return CT_Percentage::default_instance();
}

bool CT_SystemColor::ChildGroup_1::has_greenOff() const
{
    return m_has_greenOff;
}

CT_Percentage* CT_SystemColor::ChildGroup_1::mutable_greenOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_greenOff = true;
    if (!m_greenOff)
    {
        m_greenOff = new CT_Percentage();
    }
    return m_greenOff;
}

const CT_Percentage& CT_SystemColor::ChildGroup_1::get_greenOff() const
{
    if (m_greenOff)
    {
        return *m_greenOff;
    }
    return CT_Percentage::default_instance();
}

bool CT_SystemColor::ChildGroup_1::has_greenMod() const
{
    return m_has_greenMod;
}

CT_Percentage* CT_SystemColor::ChildGroup_1::mutable_greenMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_greenMod = true;
    if (!m_greenMod)
    {
        m_greenMod = new CT_Percentage();
    }
    return m_greenMod;
}

const CT_Percentage& CT_SystemColor::ChildGroup_1::get_greenMod() const
{
    if (m_greenMod)
    {
        return *m_greenMod;
    }
    return CT_Percentage::default_instance();
}

bool CT_SystemColor::ChildGroup_1::has_blue() const
{
    return m_has_blue;
}

CT_Percentage* CT_SystemColor::ChildGroup_1::mutable_blue()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_blue = true;
    if (!m_blue)
    {
        m_blue = new CT_Percentage();
    }
    return m_blue;
}

const CT_Percentage& CT_SystemColor::ChildGroup_1::get_blue() const
{
    if (m_blue)
    {
        return *m_blue;
    }
    return CT_Percentage::default_instance();
}

bool CT_SystemColor::ChildGroup_1::has_blueOff() const
{
    return m_has_blueOff;
}

CT_Percentage* CT_SystemColor::ChildGroup_1::mutable_blueOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_blueOff = true;
    if (!m_blueOff)
    {
        m_blueOff = new CT_Percentage();
    }
    return m_blueOff;
}

const CT_Percentage& CT_SystemColor::ChildGroup_1::get_blueOff() const
{
    if (m_blueOff)
    {
        return *m_blueOff;
    }
    return CT_Percentage::default_instance();
}

bool CT_SystemColor::ChildGroup_1::has_blueMod() const
{
    return m_has_blueMod;
}

CT_Percentage* CT_SystemColor::ChildGroup_1::mutable_blueMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_blueMod = true;
    if (!m_blueMod)
    {
        m_blueMod = new CT_Percentage();
    }
    return m_blueMod;
}

const CT_Percentage& CT_SystemColor::ChildGroup_1::get_blueMod() const
{
    if (m_blueMod)
    {
        return *m_blueMod;
    }
    return CT_Percentage::default_instance();
}

bool CT_SystemColor::ChildGroup_1::has_gamma() const
{
    return m_has_gamma;
}

CT_GammaTransform* CT_SystemColor::ChildGroup_1::mutable_gamma()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_gamma = true;
    if (!m_gamma)
    {
        m_gamma = new CT_GammaTransform();
    }
    return m_gamma;
}

const CT_GammaTransform& CT_SystemColor::ChildGroup_1::get_gamma() const
{
    if (m_gamma)
    {
        return *m_gamma;
    }
    return CT_GammaTransform::default_instance();
}

bool CT_SystemColor::ChildGroup_1::has_invGamma() const
{
    return m_has_invGamma;
}

CT_InverseGammaTransform* CT_SystemColor::ChildGroup_1::mutable_invGamma()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = true;
    if (!m_invGamma)
    {
        m_invGamma = new CT_InverseGammaTransform();
    }
    return m_invGamma;
}

const CT_InverseGammaTransform& CT_SystemColor::ChildGroup_1::get_invGamma() const
{
    if (m_invGamma)
    {
        return *m_invGamma;
    }
    return CT_InverseGammaTransform::default_instance();
}

CT_SystemColor* CT_SystemColor::default_instance_ = NULL;

// CT_SchemeColor
CT_SchemeColor::CT_SchemeColor()
    :m_has_val_attr(false),
     m_val_attr(NULL)
{
}
CT_SchemeColor::~CT_SchemeColor()
{
    clear();
}
CT_PositiveFixedPercentage* CT_SchemeColor::add_tint()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PositiveFixedPercentage* pNewChild = pChildGroup->mutable_tint();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_PositiveFixedPercentage* CT_SchemeColor::add_shade()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PositiveFixedPercentage* pNewChild = pChildGroup->mutable_shade();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_ComplementTransform* CT_SchemeColor::add_comp()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_ComplementTransform* pNewChild = pChildGroup->mutable_comp();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_InverseTransform* CT_SchemeColor::add_inv()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_InverseTransform* pNewChild = pChildGroup->mutable_inv();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_GrayscaleTransform* CT_SchemeColor::add_gray()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_GrayscaleTransform* pNewChild = pChildGroup->mutable_gray();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_PositiveFixedPercentage* CT_SchemeColor::add_alpha()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PositiveFixedPercentage* pNewChild = pChildGroup->mutable_alpha();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_FixedPercentage* CT_SchemeColor::add_alphaOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_FixedPercentage* pNewChild = pChildGroup->mutable_alphaOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_PositivePercentage* CT_SchemeColor::add_alphaMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PositivePercentage* pNewChild = pChildGroup->mutable_alphaMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_PositiveFixedAngle* CT_SchemeColor::add_hue()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PositiveFixedAngle* pNewChild = pChildGroup->mutable_hue();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Angle* CT_SchemeColor::add_hueOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Angle* pNewChild = pChildGroup->mutable_hueOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_PositivePercentage* CT_SchemeColor::add_hueMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PositivePercentage* pNewChild = pChildGroup->mutable_hueMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SchemeColor::add_sat()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_sat();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SchemeColor::add_satOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_satOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SchemeColor::add_satMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_satMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SchemeColor::add_lum()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_lum();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SchemeColor::add_lumOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_lumOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SchemeColor::add_lumMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_lumMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SchemeColor::add_red()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_red();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SchemeColor::add_redOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_redOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SchemeColor::add_redMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_redMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SchemeColor::add_green()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_green();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SchemeColor::add_greenOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_greenOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SchemeColor::add_greenMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_greenMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SchemeColor::add_blue()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_blue();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SchemeColor::add_blueOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_blueOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_SchemeColor::add_blueMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_blueMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_GammaTransform* CT_SchemeColor::add_gamma()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_GammaTransform* pNewChild = pChildGroup->mutable_gamma();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_InverseGammaTransform* CT_SchemeColor::add_invGamma()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_InverseGammaTransform* pNewChild = pChildGroup->mutable_invGamma();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

void CT_SchemeColor::clear()
{
    m_has_val_attr = false;

    if (m_val_attr)
    {
        delete m_val_attr;
        m_val_attr = NULL;
    }


    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }
}

void CT_SchemeColor::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_val_attr);
    if (m_has_val_attr)
    {
        m_val_attr->toXmlAttr("val", _outStream);
    }

    _outStream << ">";

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_tint())
            {
                (*iter)->get_tint().toXmlElem("a:tint", "", _outStream);
            }


            else if ((*iter)->has_shade())
            {
                (*iter)->get_shade().toXmlElem("a:shade", "", _outStream);
            }


            else if ((*iter)->has_comp())
            {
                (*iter)->get_comp().toXmlElem("a:comp", "", _outStream);
            }


            else if ((*iter)->has_inv())
            {
                (*iter)->get_inv().toXmlElem("a:inv", "", _outStream);
            }


            else if ((*iter)->has_gray())
            {
                (*iter)->get_gray().toXmlElem("a:gray", "", _outStream);
            }


            else if ((*iter)->has_alpha())
            {
                (*iter)->get_alpha().toXmlElem("a:alpha", "", _outStream);
            }


            else if ((*iter)->has_alphaOff())
            {
                (*iter)->get_alphaOff().toXmlElem("a:alphaOff", "", _outStream);
            }


            else if ((*iter)->has_alphaMod())
            {
                (*iter)->get_alphaMod().toXmlElem("a:alphaMod", "", _outStream);
            }


            else if ((*iter)->has_hue())
            {
                (*iter)->get_hue().toXmlElem("a:hue", "", _outStream);
            }


            else if ((*iter)->has_hueOff())
            {
                (*iter)->get_hueOff().toXmlElem("a:hueOff", "", _outStream);
            }


            else if ((*iter)->has_hueMod())
            {
                (*iter)->get_hueMod().toXmlElem("a:hueMod", "", _outStream);
            }


            else if ((*iter)->has_sat())
            {
                (*iter)->get_sat().toXmlElem("a:sat", "", _outStream);
            }


            else if ((*iter)->has_satOff())
            {
                (*iter)->get_satOff().toXmlElem("a:satOff", "", _outStream);
            }


            else if ((*iter)->has_satMod())
            {
                (*iter)->get_satMod().toXmlElem("a:satMod", "", _outStream);
            }


            else if ((*iter)->has_lum())
            {
                (*iter)->get_lum().toXmlElem("a:lum", "", _outStream);
            }


            else if ((*iter)->has_lumOff())
            {
                (*iter)->get_lumOff().toXmlElem("a:lumOff", "", _outStream);
            }


            else if ((*iter)->has_lumMod())
            {
                (*iter)->get_lumMod().toXmlElem("a:lumMod", "", _outStream);
            }


            else if ((*iter)->has_red())
            {
                (*iter)->get_red().toXmlElem("a:red", "", _outStream);
            }


            else if ((*iter)->has_redOff())
            {
                (*iter)->get_redOff().toXmlElem("a:redOff", "", _outStream);
            }


            else if ((*iter)->has_redMod())
            {
                (*iter)->get_redMod().toXmlElem("a:redMod", "", _outStream);
            }


            else if ((*iter)->has_green())
            {
                (*iter)->get_green().toXmlElem("a:green", "", _outStream);
            }


            else if ((*iter)->has_greenOff())
            {
                (*iter)->get_greenOff().toXmlElem("a:greenOff", "", _outStream);
            }


            else if ((*iter)->has_greenMod())
            {
                (*iter)->get_greenMod().toXmlElem("a:greenMod", "", _outStream);
            }


            else if ((*iter)->has_blue())
            {
                (*iter)->get_blue().toXmlElem("a:blue", "", _outStream);
            }


            else if ((*iter)->has_blueOff())
            {
                (*iter)->get_blueOff().toXmlElem("a:blueOff", "", _outStream);
            }


            else if ((*iter)->has_blueMod())
            {
                (*iter)->get_blueMod().toXmlElem("a:blueMod", "", _outStream);
            }


            else if ((*iter)->has_gamma())
            {
                (*iter)->get_gamma().toXmlElem("a:gamma", "", _outStream);
            }


            else if ((*iter)->has_invGamma())
            {
                (*iter)->get_invGamma().toXmlElem("a:invGamma", "", _outStream);
            }


        }
    }

    _outStream << "</" << _elemName << ">";
}

const CT_SchemeColor& CT_SchemeColor::default_instance()
{
    if (!CT_SchemeColor::default_instance_)
    {
        CT_SchemeColor::default_instance_ = new CT_SchemeColor();
    }
    return *CT_SchemeColor::default_instance_;
}

bool CT_SchemeColor::has_val_attr() const
{
    return m_has_val_attr;
}

void CT_SchemeColor::set_val_attr(const ST_SchemeColorVal& _val_attr)
{
    m_has_val_attr = true;
    m_val_attr = new ST_SchemeColorVal(_val_attr);
}

const ST_SchemeColorVal& CT_SchemeColor::get_val_attr() const
{
    if (m_val_attr)
    {
        return *m_val_attr;
    }
    return ST_SchemeColorVal::default_instance();
}


// CT_SchemeColor::ChildGroup_1
CT_SchemeColor::ChildGroup_1::ChildGroup_1()
    :m_has_tint(false),
     m_tint(NULL),
     m_has_shade(false),
     m_shade(NULL),
     m_has_comp(false),
     m_comp(NULL),
     m_has_inv(false),
     m_inv(NULL),
     m_has_gray(false),
     m_gray(NULL),
     m_has_alpha(false),
     m_alpha(NULL),
     m_has_alphaOff(false),
     m_alphaOff(NULL),
     m_has_alphaMod(false),
     m_alphaMod(NULL),
     m_has_hue(false),
     m_hue(NULL),
     m_has_hueOff(false),
     m_hueOff(NULL),
     m_has_hueMod(false),
     m_hueMod(NULL),
     m_has_sat(false),
     m_sat(NULL),
     m_has_satOff(false),
     m_satOff(NULL),
     m_has_satMod(false),
     m_satMod(NULL),
     m_has_lum(false),
     m_lum(NULL),
     m_has_lumOff(false),
     m_lumOff(NULL),
     m_has_lumMod(false),
     m_lumMod(NULL),
     m_has_red(false),
     m_red(NULL),
     m_has_redOff(false),
     m_redOff(NULL),
     m_has_redMod(false),
     m_redMod(NULL),
     m_has_green(false),
     m_green(NULL),
     m_has_greenOff(false),
     m_greenOff(NULL),
     m_has_greenMod(false),
     m_greenMod(NULL),
     m_has_blue(false),
     m_blue(NULL),
     m_has_blueOff(false),
     m_blueOff(NULL),
     m_has_blueMod(false),
     m_blueMod(NULL),
     m_has_gamma(false),
     m_gamma(NULL),
     m_has_invGamma(false),
     m_invGamma(NULL)
{
}
bool CT_SchemeColor::ChildGroup_1::has_tint() const
{
    return m_has_tint;
}

CT_PositiveFixedPercentage* CT_SchemeColor::ChildGroup_1::mutable_tint()
{

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_tint = true;
    if (!m_tint)
    {
        m_tint = new CT_PositiveFixedPercentage();
    }
    return m_tint;
}

const CT_PositiveFixedPercentage& CT_SchemeColor::ChildGroup_1::get_tint() const
{
    if (m_tint)
    {
        return *m_tint;
    }
    return CT_PositiveFixedPercentage::default_instance();
}

bool CT_SchemeColor::ChildGroup_1::has_shade() const
{
    return m_has_shade;
}

CT_PositiveFixedPercentage* CT_SchemeColor::ChildGroup_1::mutable_shade()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_shade = true;
    if (!m_shade)
    {
        m_shade = new CT_PositiveFixedPercentage();
    }
    return m_shade;
}

const CT_PositiveFixedPercentage& CT_SchemeColor::ChildGroup_1::get_shade() const
{
    if (m_shade)
    {
        return *m_shade;
    }
    return CT_PositiveFixedPercentage::default_instance();
}

bool CT_SchemeColor::ChildGroup_1::has_comp() const
{
    return m_has_comp;
}

CT_ComplementTransform* CT_SchemeColor::ChildGroup_1::mutable_comp()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_comp = true;
    if (!m_comp)
    {
        m_comp = new CT_ComplementTransform();
    }
    return m_comp;
}

const CT_ComplementTransform& CT_SchemeColor::ChildGroup_1::get_comp() const
{
    if (m_comp)
    {
        return *m_comp;
    }
    return CT_ComplementTransform::default_instance();
}

bool CT_SchemeColor::ChildGroup_1::has_inv() const
{
    return m_has_inv;
}

CT_InverseTransform* CT_SchemeColor::ChildGroup_1::mutable_inv()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_inv = true;
    if (!m_inv)
    {
        m_inv = new CT_InverseTransform();
    }
    return m_inv;
}

const CT_InverseTransform& CT_SchemeColor::ChildGroup_1::get_inv() const
{
    if (m_inv)
    {
        return *m_inv;
    }
    return CT_InverseTransform::default_instance();
}

bool CT_SchemeColor::ChildGroup_1::has_gray() const
{
    return m_has_gray;
}

CT_GrayscaleTransform* CT_SchemeColor::ChildGroup_1::mutable_gray()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_gray = true;
    if (!m_gray)
    {
        m_gray = new CT_GrayscaleTransform();
    }
    return m_gray;
}

const CT_GrayscaleTransform& CT_SchemeColor::ChildGroup_1::get_gray() const
{
    if (m_gray)
    {
        return *m_gray;
    }
    return CT_GrayscaleTransform::default_instance();
}

bool CT_SchemeColor::ChildGroup_1::has_alpha() const
{
    return m_has_alpha;
}

CT_PositiveFixedPercentage* CT_SchemeColor::ChildGroup_1::mutable_alpha()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_alpha = true;
    if (!m_alpha)
    {
        m_alpha = new CT_PositiveFixedPercentage();
    }
    return m_alpha;
}

const CT_PositiveFixedPercentage& CT_SchemeColor::ChildGroup_1::get_alpha() const
{
    if (m_alpha)
    {
        return *m_alpha;
    }
    return CT_PositiveFixedPercentage::default_instance();
}

bool CT_SchemeColor::ChildGroup_1::has_alphaOff() const
{
    return m_has_alphaOff;
}

CT_FixedPercentage* CT_SchemeColor::ChildGroup_1::mutable_alphaOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_alphaOff = true;
    if (!m_alphaOff)
    {
        m_alphaOff = new CT_FixedPercentage();
    }
    return m_alphaOff;
}

const CT_FixedPercentage& CT_SchemeColor::ChildGroup_1::get_alphaOff() const
{
    if (m_alphaOff)
    {
        return *m_alphaOff;
    }
    return CT_FixedPercentage::default_instance();
}

bool CT_SchemeColor::ChildGroup_1::has_alphaMod() const
{
    return m_has_alphaMod;
}

CT_PositivePercentage* CT_SchemeColor::ChildGroup_1::mutable_alphaMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_alphaMod = true;
    if (!m_alphaMod)
    {
        m_alphaMod = new CT_PositivePercentage();
    }
    return m_alphaMod;
}

const CT_PositivePercentage& CT_SchemeColor::ChildGroup_1::get_alphaMod() const
{
    if (m_alphaMod)
    {
        return *m_alphaMod;
    }
    return CT_PositivePercentage::default_instance();
}

bool CT_SchemeColor::ChildGroup_1::has_hue() const
{
    return m_has_hue;
}

CT_PositiveFixedAngle* CT_SchemeColor::ChildGroup_1::mutable_hue()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_hue = true;
    if (!m_hue)
    {
        m_hue = new CT_PositiveFixedAngle();
    }
    return m_hue;
}

const CT_PositiveFixedAngle& CT_SchemeColor::ChildGroup_1::get_hue() const
{
    if (m_hue)
    {
        return *m_hue;
    }
    return CT_PositiveFixedAngle::default_instance();
}

bool CT_SchemeColor::ChildGroup_1::has_hueOff() const
{
    return m_has_hueOff;
}

CT_Angle* CT_SchemeColor::ChildGroup_1::mutable_hueOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_hueOff = true;
    if (!m_hueOff)
    {
        m_hueOff = new CT_Angle();
    }
    return m_hueOff;
}

const CT_Angle& CT_SchemeColor::ChildGroup_1::get_hueOff() const
{
    if (m_hueOff)
    {
        return *m_hueOff;
    }
    return CT_Angle::default_instance();
}

bool CT_SchemeColor::ChildGroup_1::has_hueMod() const
{
    return m_has_hueMod;
}

CT_PositivePercentage* CT_SchemeColor::ChildGroup_1::mutable_hueMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_hueMod = true;
    if (!m_hueMod)
    {
        m_hueMod = new CT_PositivePercentage();
    }
    return m_hueMod;
}

const CT_PositivePercentage& CT_SchemeColor::ChildGroup_1::get_hueMod() const
{
    if (m_hueMod)
    {
        return *m_hueMod;
    }
    return CT_PositivePercentage::default_instance();
}

bool CT_SchemeColor::ChildGroup_1::has_sat() const
{
    return m_has_sat;
}

CT_Percentage* CT_SchemeColor::ChildGroup_1::mutable_sat()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_sat = true;
    if (!m_sat)
    {
        m_sat = new CT_Percentage();
    }
    return m_sat;
}

const CT_Percentage& CT_SchemeColor::ChildGroup_1::get_sat() const
{
    if (m_sat)
    {
        return *m_sat;
    }
    return CT_Percentage::default_instance();
}

bool CT_SchemeColor::ChildGroup_1::has_satOff() const
{
    return m_has_satOff;
}

CT_Percentage* CT_SchemeColor::ChildGroup_1::mutable_satOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_satOff = true;
    if (!m_satOff)
    {
        m_satOff = new CT_Percentage();
    }
    return m_satOff;
}

const CT_Percentage& CT_SchemeColor::ChildGroup_1::get_satOff() const
{
    if (m_satOff)
    {
        return *m_satOff;
    }
    return CT_Percentage::default_instance();
}

bool CT_SchemeColor::ChildGroup_1::has_satMod() const
{
    return m_has_satMod;
}

CT_Percentage* CT_SchemeColor::ChildGroup_1::mutable_satMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_satMod = true;
    if (!m_satMod)
    {
        m_satMod = new CT_Percentage();
    }
    return m_satMod;
}

const CT_Percentage& CT_SchemeColor::ChildGroup_1::get_satMod() const
{
    if (m_satMod)
    {
        return *m_satMod;
    }
    return CT_Percentage::default_instance();
}

bool CT_SchemeColor::ChildGroup_1::has_lum() const
{
    return m_has_lum;
}

CT_Percentage* CT_SchemeColor::ChildGroup_1::mutable_lum()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_lum = true;
    if (!m_lum)
    {
        m_lum = new CT_Percentage();
    }
    return m_lum;
}

const CT_Percentage& CT_SchemeColor::ChildGroup_1::get_lum() const
{
    if (m_lum)
    {
        return *m_lum;
    }
    return CT_Percentage::default_instance();
}

bool CT_SchemeColor::ChildGroup_1::has_lumOff() const
{
    return m_has_lumOff;
}

CT_Percentage* CT_SchemeColor::ChildGroup_1::mutable_lumOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_lumOff = true;
    if (!m_lumOff)
    {
        m_lumOff = new CT_Percentage();
    }
    return m_lumOff;
}

const CT_Percentage& CT_SchemeColor::ChildGroup_1::get_lumOff() const
{
    if (m_lumOff)
    {
        return *m_lumOff;
    }
    return CT_Percentage::default_instance();
}

bool CT_SchemeColor::ChildGroup_1::has_lumMod() const
{
    return m_has_lumMod;
}

CT_Percentage* CT_SchemeColor::ChildGroup_1::mutable_lumMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_lumMod = true;
    if (!m_lumMod)
    {
        m_lumMod = new CT_Percentage();
    }
    return m_lumMod;
}

const CT_Percentage& CT_SchemeColor::ChildGroup_1::get_lumMod() const
{
    if (m_lumMod)
    {
        return *m_lumMod;
    }
    return CT_Percentage::default_instance();
}

bool CT_SchemeColor::ChildGroup_1::has_red() const
{
    return m_has_red;
}

CT_Percentage* CT_SchemeColor::ChildGroup_1::mutable_red()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_red = true;
    if (!m_red)
    {
        m_red = new CT_Percentage();
    }
    return m_red;
}

const CT_Percentage& CT_SchemeColor::ChildGroup_1::get_red() const
{
    if (m_red)
    {
        return *m_red;
    }
    return CT_Percentage::default_instance();
}

bool CT_SchemeColor::ChildGroup_1::has_redOff() const
{
    return m_has_redOff;
}

CT_Percentage* CT_SchemeColor::ChildGroup_1::mutable_redOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_redOff = true;
    if (!m_redOff)
    {
        m_redOff = new CT_Percentage();
    }
    return m_redOff;
}

const CT_Percentage& CT_SchemeColor::ChildGroup_1::get_redOff() const
{
    if (m_redOff)
    {
        return *m_redOff;
    }
    return CT_Percentage::default_instance();
}

bool CT_SchemeColor::ChildGroup_1::has_redMod() const
{
    return m_has_redMod;
}

CT_Percentage* CT_SchemeColor::ChildGroup_1::mutable_redMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_redMod = true;
    if (!m_redMod)
    {
        m_redMod = new CT_Percentage();
    }
    return m_redMod;
}

const CT_Percentage& CT_SchemeColor::ChildGroup_1::get_redMod() const
{
    if (m_redMod)
    {
        return *m_redMod;
    }
    return CT_Percentage::default_instance();
}

bool CT_SchemeColor::ChildGroup_1::has_green() const
{
    return m_has_green;
}

CT_Percentage* CT_SchemeColor::ChildGroup_1::mutable_green()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_green = true;
    if (!m_green)
    {
        m_green = new CT_Percentage();
    }
    return m_green;
}

const CT_Percentage& CT_SchemeColor::ChildGroup_1::get_green() const
{
    if (m_green)
    {
        return *m_green;
    }
    return CT_Percentage::default_instance();
}

bool CT_SchemeColor::ChildGroup_1::has_greenOff() const
{
    return m_has_greenOff;
}

CT_Percentage* CT_SchemeColor::ChildGroup_1::mutable_greenOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_greenOff = true;
    if (!m_greenOff)
    {
        m_greenOff = new CT_Percentage();
    }
    return m_greenOff;
}

const CT_Percentage& CT_SchemeColor::ChildGroup_1::get_greenOff() const
{
    if (m_greenOff)
    {
        return *m_greenOff;
    }
    return CT_Percentage::default_instance();
}

bool CT_SchemeColor::ChildGroup_1::has_greenMod() const
{
    return m_has_greenMod;
}

CT_Percentage* CT_SchemeColor::ChildGroup_1::mutable_greenMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_greenMod = true;
    if (!m_greenMod)
    {
        m_greenMod = new CT_Percentage();
    }
    return m_greenMod;
}

const CT_Percentage& CT_SchemeColor::ChildGroup_1::get_greenMod() const
{
    if (m_greenMod)
    {
        return *m_greenMod;
    }
    return CT_Percentage::default_instance();
}

bool CT_SchemeColor::ChildGroup_1::has_blue() const
{
    return m_has_blue;
}

CT_Percentage* CT_SchemeColor::ChildGroup_1::mutable_blue()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_blue = true;
    if (!m_blue)
    {
        m_blue = new CT_Percentage();
    }
    return m_blue;
}

const CT_Percentage& CT_SchemeColor::ChildGroup_1::get_blue() const
{
    if (m_blue)
    {
        return *m_blue;
    }
    return CT_Percentage::default_instance();
}

bool CT_SchemeColor::ChildGroup_1::has_blueOff() const
{
    return m_has_blueOff;
}

CT_Percentage* CT_SchemeColor::ChildGroup_1::mutable_blueOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_blueOff = true;
    if (!m_blueOff)
    {
        m_blueOff = new CT_Percentage();
    }
    return m_blueOff;
}

const CT_Percentage& CT_SchemeColor::ChildGroup_1::get_blueOff() const
{
    if (m_blueOff)
    {
        return *m_blueOff;
    }
    return CT_Percentage::default_instance();
}

bool CT_SchemeColor::ChildGroup_1::has_blueMod() const
{
    return m_has_blueMod;
}

CT_Percentage* CT_SchemeColor::ChildGroup_1::mutable_blueMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_blueMod = true;
    if (!m_blueMod)
    {
        m_blueMod = new CT_Percentage();
    }
    return m_blueMod;
}

const CT_Percentage& CT_SchemeColor::ChildGroup_1::get_blueMod() const
{
    if (m_blueMod)
    {
        return *m_blueMod;
    }
    return CT_Percentage::default_instance();
}

bool CT_SchemeColor::ChildGroup_1::has_gamma() const
{
    return m_has_gamma;
}

CT_GammaTransform* CT_SchemeColor::ChildGroup_1::mutable_gamma()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_gamma = true;
    if (!m_gamma)
    {
        m_gamma = new CT_GammaTransform();
    }
    return m_gamma;
}

const CT_GammaTransform& CT_SchemeColor::ChildGroup_1::get_gamma() const
{
    if (m_gamma)
    {
        return *m_gamma;
    }
    return CT_GammaTransform::default_instance();
}

bool CT_SchemeColor::ChildGroup_1::has_invGamma() const
{
    return m_has_invGamma;
}

CT_InverseGammaTransform* CT_SchemeColor::ChildGroup_1::mutable_invGamma()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = true;
    if (!m_invGamma)
    {
        m_invGamma = new CT_InverseGammaTransform();
    }
    return m_invGamma;
}

const CT_InverseGammaTransform& CT_SchemeColor::ChildGroup_1::get_invGamma() const
{
    if (m_invGamma)
    {
        return *m_invGamma;
    }
    return CT_InverseGammaTransform::default_instance();
}

CT_SchemeColor* CT_SchemeColor::default_instance_ = NULL;

// CT_PresetColor
CT_PresetColor::CT_PresetColor()
    :m_has_val_attr(false),
     m_val_attr(NULL)
{
}
CT_PresetColor::~CT_PresetColor()
{
    clear();
}
CT_PositiveFixedPercentage* CT_PresetColor::add_tint()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PositiveFixedPercentage* pNewChild = pChildGroup->mutable_tint();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_PositiveFixedPercentage* CT_PresetColor::add_shade()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PositiveFixedPercentage* pNewChild = pChildGroup->mutable_shade();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_ComplementTransform* CT_PresetColor::add_comp()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_ComplementTransform* pNewChild = pChildGroup->mutable_comp();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_InverseTransform* CT_PresetColor::add_inv()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_InverseTransform* pNewChild = pChildGroup->mutable_inv();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_GrayscaleTransform* CT_PresetColor::add_gray()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_GrayscaleTransform* pNewChild = pChildGroup->mutable_gray();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_PositiveFixedPercentage* CT_PresetColor::add_alpha()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PositiveFixedPercentage* pNewChild = pChildGroup->mutable_alpha();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_FixedPercentage* CT_PresetColor::add_alphaOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_FixedPercentage* pNewChild = pChildGroup->mutable_alphaOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_PositivePercentage* CT_PresetColor::add_alphaMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PositivePercentage* pNewChild = pChildGroup->mutable_alphaMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_PositiveFixedAngle* CT_PresetColor::add_hue()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PositiveFixedAngle* pNewChild = pChildGroup->mutable_hue();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Angle* CT_PresetColor::add_hueOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Angle* pNewChild = pChildGroup->mutable_hueOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_PositivePercentage* CT_PresetColor::add_hueMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PositivePercentage* pNewChild = pChildGroup->mutable_hueMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_PresetColor::add_sat()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_sat();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_PresetColor::add_satOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_satOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_PresetColor::add_satMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_satMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_PresetColor::add_lum()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_lum();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_PresetColor::add_lumOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_lumOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_PresetColor::add_lumMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_lumMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_PresetColor::add_red()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_red();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_PresetColor::add_redOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_redOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_PresetColor::add_redMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_redMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_PresetColor::add_green()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_green();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_PresetColor::add_greenOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_greenOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_PresetColor::add_greenMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_greenMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_PresetColor::add_blue()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_blue();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_PresetColor::add_blueOff()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_blueOff();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Percentage* CT_PresetColor::add_blueMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Percentage* pNewChild = pChildGroup->mutable_blueMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_GammaTransform* CT_PresetColor::add_gamma()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_GammaTransform* pNewChild = pChildGroup->mutable_gamma();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_InverseGammaTransform* CT_PresetColor::add_invGamma()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_InverseGammaTransform* pNewChild = pChildGroup->mutable_invGamma();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

void CT_PresetColor::clear()
{
    m_has_val_attr = false;

    if (m_val_attr)
    {
        delete m_val_attr;
        m_val_attr = NULL;
    }


    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }
}

void CT_PresetColor::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_val_attr);
    if (m_has_val_attr)
    {
        m_val_attr->toXmlAttr("val", _outStream);
    }

    _outStream << ">";

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_tint())
            {
                (*iter)->get_tint().toXmlElem("a:tint", "", _outStream);
            }


            else if ((*iter)->has_shade())
            {
                (*iter)->get_shade().toXmlElem("a:shade", "", _outStream);
            }


            else if ((*iter)->has_comp())
            {
                (*iter)->get_comp().toXmlElem("a:comp", "", _outStream);
            }


            else if ((*iter)->has_inv())
            {
                (*iter)->get_inv().toXmlElem("a:inv", "", _outStream);
            }


            else if ((*iter)->has_gray())
            {
                (*iter)->get_gray().toXmlElem("a:gray", "", _outStream);
            }


            else if ((*iter)->has_alpha())
            {
                (*iter)->get_alpha().toXmlElem("a:alpha", "", _outStream);
            }


            else if ((*iter)->has_alphaOff())
            {
                (*iter)->get_alphaOff().toXmlElem("a:alphaOff", "", _outStream);
            }


            else if ((*iter)->has_alphaMod())
            {
                (*iter)->get_alphaMod().toXmlElem("a:alphaMod", "", _outStream);
            }


            else if ((*iter)->has_hue())
            {
                (*iter)->get_hue().toXmlElem("a:hue", "", _outStream);
            }


            else if ((*iter)->has_hueOff())
            {
                (*iter)->get_hueOff().toXmlElem("a:hueOff", "", _outStream);
            }


            else if ((*iter)->has_hueMod())
            {
                (*iter)->get_hueMod().toXmlElem("a:hueMod", "", _outStream);
            }


            else if ((*iter)->has_sat())
            {
                (*iter)->get_sat().toXmlElem("a:sat", "", _outStream);
            }


            else if ((*iter)->has_satOff())
            {
                (*iter)->get_satOff().toXmlElem("a:satOff", "", _outStream);
            }


            else if ((*iter)->has_satMod())
            {
                (*iter)->get_satMod().toXmlElem("a:satMod", "", _outStream);
            }


            else if ((*iter)->has_lum())
            {
                (*iter)->get_lum().toXmlElem("a:lum", "", _outStream);
            }


            else if ((*iter)->has_lumOff())
            {
                (*iter)->get_lumOff().toXmlElem("a:lumOff", "", _outStream);
            }


            else if ((*iter)->has_lumMod())
            {
                (*iter)->get_lumMod().toXmlElem("a:lumMod", "", _outStream);
            }


            else if ((*iter)->has_red())
            {
                (*iter)->get_red().toXmlElem("a:red", "", _outStream);
            }


            else if ((*iter)->has_redOff())
            {
                (*iter)->get_redOff().toXmlElem("a:redOff", "", _outStream);
            }


            else if ((*iter)->has_redMod())
            {
                (*iter)->get_redMod().toXmlElem("a:redMod", "", _outStream);
            }


            else if ((*iter)->has_green())
            {
                (*iter)->get_green().toXmlElem("a:green", "", _outStream);
            }


            else if ((*iter)->has_greenOff())
            {
                (*iter)->get_greenOff().toXmlElem("a:greenOff", "", _outStream);
            }


            else if ((*iter)->has_greenMod())
            {
                (*iter)->get_greenMod().toXmlElem("a:greenMod", "", _outStream);
            }


            else if ((*iter)->has_blue())
            {
                (*iter)->get_blue().toXmlElem("a:blue", "", _outStream);
            }


            else if ((*iter)->has_blueOff())
            {
                (*iter)->get_blueOff().toXmlElem("a:blueOff", "", _outStream);
            }


            else if ((*iter)->has_blueMod())
            {
                (*iter)->get_blueMod().toXmlElem("a:blueMod", "", _outStream);
            }


            else if ((*iter)->has_gamma())
            {
                (*iter)->get_gamma().toXmlElem("a:gamma", "", _outStream);
            }


            else if ((*iter)->has_invGamma())
            {
                (*iter)->get_invGamma().toXmlElem("a:invGamma", "", _outStream);
            }


        }
    }

    _outStream << "</" << _elemName << ">";
}

const CT_PresetColor& CT_PresetColor::default_instance()
{
    if (!CT_PresetColor::default_instance_)
    {
        CT_PresetColor::default_instance_ = new CT_PresetColor();
    }
    return *CT_PresetColor::default_instance_;
}

bool CT_PresetColor::has_val_attr() const
{
    return m_has_val_attr;
}

void CT_PresetColor::set_val_attr(const ST_PresetColorVal& _val_attr)
{
    m_has_val_attr = true;
    m_val_attr = new ST_PresetColorVal(_val_attr);
}

const ST_PresetColorVal& CT_PresetColor::get_val_attr() const
{
    if (m_val_attr)
    {
        return *m_val_attr;
    }
    return ST_PresetColorVal::default_instance();
}


// CT_PresetColor::ChildGroup_1
CT_PresetColor::ChildGroup_1::ChildGroup_1()
    :m_has_tint(false),
     m_tint(NULL),
     m_has_shade(false),
     m_shade(NULL),
     m_has_comp(false),
     m_comp(NULL),
     m_has_inv(false),
     m_inv(NULL),
     m_has_gray(false),
     m_gray(NULL),
     m_has_alpha(false),
     m_alpha(NULL),
     m_has_alphaOff(false),
     m_alphaOff(NULL),
     m_has_alphaMod(false),
     m_alphaMod(NULL),
     m_has_hue(false),
     m_hue(NULL),
     m_has_hueOff(false),
     m_hueOff(NULL),
     m_has_hueMod(false),
     m_hueMod(NULL),
     m_has_sat(false),
     m_sat(NULL),
     m_has_satOff(false),
     m_satOff(NULL),
     m_has_satMod(false),
     m_satMod(NULL),
     m_has_lum(false),
     m_lum(NULL),
     m_has_lumOff(false),
     m_lumOff(NULL),
     m_has_lumMod(false),
     m_lumMod(NULL),
     m_has_red(false),
     m_red(NULL),
     m_has_redOff(false),
     m_redOff(NULL),
     m_has_redMod(false),
     m_redMod(NULL),
     m_has_green(false),
     m_green(NULL),
     m_has_greenOff(false),
     m_greenOff(NULL),
     m_has_greenMod(false),
     m_greenMod(NULL),
     m_has_blue(false),
     m_blue(NULL),
     m_has_blueOff(false),
     m_blueOff(NULL),
     m_has_blueMod(false),
     m_blueMod(NULL),
     m_has_gamma(false),
     m_gamma(NULL),
     m_has_invGamma(false),
     m_invGamma(NULL)
{
}
bool CT_PresetColor::ChildGroup_1::has_tint() const
{
    return m_has_tint;
}

CT_PositiveFixedPercentage* CT_PresetColor::ChildGroup_1::mutable_tint()
{

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_tint = true;
    if (!m_tint)
    {
        m_tint = new CT_PositiveFixedPercentage();
    }
    return m_tint;
}

const CT_PositiveFixedPercentage& CT_PresetColor::ChildGroup_1::get_tint() const
{
    if (m_tint)
    {
        return *m_tint;
    }
    return CT_PositiveFixedPercentage::default_instance();
}

bool CT_PresetColor::ChildGroup_1::has_shade() const
{
    return m_has_shade;
}

CT_PositiveFixedPercentage* CT_PresetColor::ChildGroup_1::mutable_shade()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_shade = true;
    if (!m_shade)
    {
        m_shade = new CT_PositiveFixedPercentage();
    }
    return m_shade;
}

const CT_PositiveFixedPercentage& CT_PresetColor::ChildGroup_1::get_shade() const
{
    if (m_shade)
    {
        return *m_shade;
    }
    return CT_PositiveFixedPercentage::default_instance();
}

bool CT_PresetColor::ChildGroup_1::has_comp() const
{
    return m_has_comp;
}

CT_ComplementTransform* CT_PresetColor::ChildGroup_1::mutable_comp()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_comp = true;
    if (!m_comp)
    {
        m_comp = new CT_ComplementTransform();
    }
    return m_comp;
}

const CT_ComplementTransform& CT_PresetColor::ChildGroup_1::get_comp() const
{
    if (m_comp)
    {
        return *m_comp;
    }
    return CT_ComplementTransform::default_instance();
}

bool CT_PresetColor::ChildGroup_1::has_inv() const
{
    return m_has_inv;
}

CT_InverseTransform* CT_PresetColor::ChildGroup_1::mutable_inv()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_inv = true;
    if (!m_inv)
    {
        m_inv = new CT_InverseTransform();
    }
    return m_inv;
}

const CT_InverseTransform& CT_PresetColor::ChildGroup_1::get_inv() const
{
    if (m_inv)
    {
        return *m_inv;
    }
    return CT_InverseTransform::default_instance();
}

bool CT_PresetColor::ChildGroup_1::has_gray() const
{
    return m_has_gray;
}

CT_GrayscaleTransform* CT_PresetColor::ChildGroup_1::mutable_gray()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_gray = true;
    if (!m_gray)
    {
        m_gray = new CT_GrayscaleTransform();
    }
    return m_gray;
}

const CT_GrayscaleTransform& CT_PresetColor::ChildGroup_1::get_gray() const
{
    if (m_gray)
    {
        return *m_gray;
    }
    return CT_GrayscaleTransform::default_instance();
}

bool CT_PresetColor::ChildGroup_1::has_alpha() const
{
    return m_has_alpha;
}

CT_PositiveFixedPercentage* CT_PresetColor::ChildGroup_1::mutable_alpha()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_alpha = true;
    if (!m_alpha)
    {
        m_alpha = new CT_PositiveFixedPercentage();
    }
    return m_alpha;
}

const CT_PositiveFixedPercentage& CT_PresetColor::ChildGroup_1::get_alpha() const
{
    if (m_alpha)
    {
        return *m_alpha;
    }
    return CT_PositiveFixedPercentage::default_instance();
}

bool CT_PresetColor::ChildGroup_1::has_alphaOff() const
{
    return m_has_alphaOff;
}

CT_FixedPercentage* CT_PresetColor::ChildGroup_1::mutable_alphaOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_alphaOff = true;
    if (!m_alphaOff)
    {
        m_alphaOff = new CT_FixedPercentage();
    }
    return m_alphaOff;
}

const CT_FixedPercentage& CT_PresetColor::ChildGroup_1::get_alphaOff() const
{
    if (m_alphaOff)
    {
        return *m_alphaOff;
    }
    return CT_FixedPercentage::default_instance();
}

bool CT_PresetColor::ChildGroup_1::has_alphaMod() const
{
    return m_has_alphaMod;
}

CT_PositivePercentage* CT_PresetColor::ChildGroup_1::mutable_alphaMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_alphaMod = true;
    if (!m_alphaMod)
    {
        m_alphaMod = new CT_PositivePercentage();
    }
    return m_alphaMod;
}

const CT_PositivePercentage& CT_PresetColor::ChildGroup_1::get_alphaMod() const
{
    if (m_alphaMod)
    {
        return *m_alphaMod;
    }
    return CT_PositivePercentage::default_instance();
}

bool CT_PresetColor::ChildGroup_1::has_hue() const
{
    return m_has_hue;
}

CT_PositiveFixedAngle* CT_PresetColor::ChildGroup_1::mutable_hue()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_hue = true;
    if (!m_hue)
    {
        m_hue = new CT_PositiveFixedAngle();
    }
    return m_hue;
}

const CT_PositiveFixedAngle& CT_PresetColor::ChildGroup_1::get_hue() const
{
    if (m_hue)
    {
        return *m_hue;
    }
    return CT_PositiveFixedAngle::default_instance();
}

bool CT_PresetColor::ChildGroup_1::has_hueOff() const
{
    return m_has_hueOff;
}

CT_Angle* CT_PresetColor::ChildGroup_1::mutable_hueOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_hueOff = true;
    if (!m_hueOff)
    {
        m_hueOff = new CT_Angle();
    }
    return m_hueOff;
}

const CT_Angle& CT_PresetColor::ChildGroup_1::get_hueOff() const
{
    if (m_hueOff)
    {
        return *m_hueOff;
    }
    return CT_Angle::default_instance();
}

bool CT_PresetColor::ChildGroup_1::has_hueMod() const
{
    return m_has_hueMod;
}

CT_PositivePercentage* CT_PresetColor::ChildGroup_1::mutable_hueMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_hueMod = true;
    if (!m_hueMod)
    {
        m_hueMod = new CT_PositivePercentage();
    }
    return m_hueMod;
}

const CT_PositivePercentage& CT_PresetColor::ChildGroup_1::get_hueMod() const
{
    if (m_hueMod)
    {
        return *m_hueMod;
    }
    return CT_PositivePercentage::default_instance();
}

bool CT_PresetColor::ChildGroup_1::has_sat() const
{
    return m_has_sat;
}

CT_Percentage* CT_PresetColor::ChildGroup_1::mutable_sat()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_sat = true;
    if (!m_sat)
    {
        m_sat = new CT_Percentage();
    }
    return m_sat;
}

const CT_Percentage& CT_PresetColor::ChildGroup_1::get_sat() const
{
    if (m_sat)
    {
        return *m_sat;
    }
    return CT_Percentage::default_instance();
}

bool CT_PresetColor::ChildGroup_1::has_satOff() const
{
    return m_has_satOff;
}

CT_Percentage* CT_PresetColor::ChildGroup_1::mutable_satOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_satOff = true;
    if (!m_satOff)
    {
        m_satOff = new CT_Percentage();
    }
    return m_satOff;
}

const CT_Percentage& CT_PresetColor::ChildGroup_1::get_satOff() const
{
    if (m_satOff)
    {
        return *m_satOff;
    }
    return CT_Percentage::default_instance();
}

bool CT_PresetColor::ChildGroup_1::has_satMod() const
{
    return m_has_satMod;
}

CT_Percentage* CT_PresetColor::ChildGroup_1::mutable_satMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_satMod = true;
    if (!m_satMod)
    {
        m_satMod = new CT_Percentage();
    }
    return m_satMod;
}

const CT_Percentage& CT_PresetColor::ChildGroup_1::get_satMod() const
{
    if (m_satMod)
    {
        return *m_satMod;
    }
    return CT_Percentage::default_instance();
}

bool CT_PresetColor::ChildGroup_1::has_lum() const
{
    return m_has_lum;
}

CT_Percentage* CT_PresetColor::ChildGroup_1::mutable_lum()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_lum = true;
    if (!m_lum)
    {
        m_lum = new CT_Percentage();
    }
    return m_lum;
}

const CT_Percentage& CT_PresetColor::ChildGroup_1::get_lum() const
{
    if (m_lum)
    {
        return *m_lum;
    }
    return CT_Percentage::default_instance();
}

bool CT_PresetColor::ChildGroup_1::has_lumOff() const
{
    return m_has_lumOff;
}

CT_Percentage* CT_PresetColor::ChildGroup_1::mutable_lumOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_lumOff = true;
    if (!m_lumOff)
    {
        m_lumOff = new CT_Percentage();
    }
    return m_lumOff;
}

const CT_Percentage& CT_PresetColor::ChildGroup_1::get_lumOff() const
{
    if (m_lumOff)
    {
        return *m_lumOff;
    }
    return CT_Percentage::default_instance();
}

bool CT_PresetColor::ChildGroup_1::has_lumMod() const
{
    return m_has_lumMod;
}

CT_Percentage* CT_PresetColor::ChildGroup_1::mutable_lumMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_lumMod = true;
    if (!m_lumMod)
    {
        m_lumMod = new CT_Percentage();
    }
    return m_lumMod;
}

const CT_Percentage& CT_PresetColor::ChildGroup_1::get_lumMod() const
{
    if (m_lumMod)
    {
        return *m_lumMod;
    }
    return CT_Percentage::default_instance();
}

bool CT_PresetColor::ChildGroup_1::has_red() const
{
    return m_has_red;
}

CT_Percentage* CT_PresetColor::ChildGroup_1::mutable_red()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_red = true;
    if (!m_red)
    {
        m_red = new CT_Percentage();
    }
    return m_red;
}

const CT_Percentage& CT_PresetColor::ChildGroup_1::get_red() const
{
    if (m_red)
    {
        return *m_red;
    }
    return CT_Percentage::default_instance();
}

bool CT_PresetColor::ChildGroup_1::has_redOff() const
{
    return m_has_redOff;
}

CT_Percentage* CT_PresetColor::ChildGroup_1::mutable_redOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_redOff = true;
    if (!m_redOff)
    {
        m_redOff = new CT_Percentage();
    }
    return m_redOff;
}

const CT_Percentage& CT_PresetColor::ChildGroup_1::get_redOff() const
{
    if (m_redOff)
    {
        return *m_redOff;
    }
    return CT_Percentage::default_instance();
}

bool CT_PresetColor::ChildGroup_1::has_redMod() const
{
    return m_has_redMod;
}

CT_Percentage* CT_PresetColor::ChildGroup_1::mutable_redMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_redMod = true;
    if (!m_redMod)
    {
        m_redMod = new CT_Percentage();
    }
    return m_redMod;
}

const CT_Percentage& CT_PresetColor::ChildGroup_1::get_redMod() const
{
    if (m_redMod)
    {
        return *m_redMod;
    }
    return CT_Percentage::default_instance();
}

bool CT_PresetColor::ChildGroup_1::has_green() const
{
    return m_has_green;
}

CT_Percentage* CT_PresetColor::ChildGroup_1::mutable_green()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_green = true;
    if (!m_green)
    {
        m_green = new CT_Percentage();
    }
    return m_green;
}

const CT_Percentage& CT_PresetColor::ChildGroup_1::get_green() const
{
    if (m_green)
    {
        return *m_green;
    }
    return CT_Percentage::default_instance();
}

bool CT_PresetColor::ChildGroup_1::has_greenOff() const
{
    return m_has_greenOff;
}

CT_Percentage* CT_PresetColor::ChildGroup_1::mutable_greenOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_greenOff = true;
    if (!m_greenOff)
    {
        m_greenOff = new CT_Percentage();
    }
    return m_greenOff;
}

const CT_Percentage& CT_PresetColor::ChildGroup_1::get_greenOff() const
{
    if (m_greenOff)
    {
        return *m_greenOff;
    }
    return CT_Percentage::default_instance();
}

bool CT_PresetColor::ChildGroup_1::has_greenMod() const
{
    return m_has_greenMod;
}

CT_Percentage* CT_PresetColor::ChildGroup_1::mutable_greenMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_greenMod = true;
    if (!m_greenMod)
    {
        m_greenMod = new CT_Percentage();
    }
    return m_greenMod;
}

const CT_Percentage& CT_PresetColor::ChildGroup_1::get_greenMod() const
{
    if (m_greenMod)
    {
        return *m_greenMod;
    }
    return CT_Percentage::default_instance();
}

bool CT_PresetColor::ChildGroup_1::has_blue() const
{
    return m_has_blue;
}

CT_Percentage* CT_PresetColor::ChildGroup_1::mutable_blue()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_blue = true;
    if (!m_blue)
    {
        m_blue = new CT_Percentage();
    }
    return m_blue;
}

const CT_Percentage& CT_PresetColor::ChildGroup_1::get_blue() const
{
    if (m_blue)
    {
        return *m_blue;
    }
    return CT_Percentage::default_instance();
}

bool CT_PresetColor::ChildGroup_1::has_blueOff() const
{
    return m_has_blueOff;
}

CT_Percentage* CT_PresetColor::ChildGroup_1::mutable_blueOff()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_blueOff = true;
    if (!m_blueOff)
    {
        m_blueOff = new CT_Percentage();
    }
    return m_blueOff;
}

const CT_Percentage& CT_PresetColor::ChildGroup_1::get_blueOff() const
{
    if (m_blueOff)
    {
        return *m_blueOff;
    }
    return CT_Percentage::default_instance();
}

bool CT_PresetColor::ChildGroup_1::has_blueMod() const
{
    return m_has_blueMod;
}

CT_Percentage* CT_PresetColor::ChildGroup_1::mutable_blueMod()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_blueMod = true;
    if (!m_blueMod)
    {
        m_blueMod = new CT_Percentage();
    }
    return m_blueMod;
}

const CT_Percentage& CT_PresetColor::ChildGroup_1::get_blueMod() const
{
    if (m_blueMod)
    {
        return *m_blueMod;
    }
    return CT_Percentage::default_instance();
}

bool CT_PresetColor::ChildGroup_1::has_gamma() const
{
    return m_has_gamma;
}

CT_GammaTransform* CT_PresetColor::ChildGroup_1::mutable_gamma()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_invGamma = false;

    if (m_invGamma)
    {
        delete m_invGamma;
        m_invGamma = NULL;
    }
    ;

    m_has_gamma = true;
    if (!m_gamma)
    {
        m_gamma = new CT_GammaTransform();
    }
    return m_gamma;
}

const CT_GammaTransform& CT_PresetColor::ChildGroup_1::get_gamma() const
{
    if (m_gamma)
    {
        return *m_gamma;
    }
    return CT_GammaTransform::default_instance();
}

bool CT_PresetColor::ChildGroup_1::has_invGamma() const
{
    return m_has_invGamma;
}

CT_InverseGammaTransform* CT_PresetColor::ChildGroup_1::mutable_invGamma()
{

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_shade = false;

    if (m_shade)
    {
        delete m_shade;
        m_shade = NULL;
    }
    ;

    m_has_comp = false;

    if (m_comp)
    {
        delete m_comp;
        m_comp = NULL;
    }
    ;

    m_has_inv = false;

    if (m_inv)
    {
        delete m_inv;
        m_inv = NULL;
    }
    ;

    m_has_gray = false;

    if (m_gray)
    {
        delete m_gray;
        m_gray = NULL;
    }
    ;

    m_has_alpha = false;

    if (m_alpha)
    {
        delete m_alpha;
        m_alpha = NULL;
    }
    ;

    m_has_alphaOff = false;

    if (m_alphaOff)
    {
        delete m_alphaOff;
        m_alphaOff = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_hue = false;

    if (m_hue)
    {
        delete m_hue;
        m_hue = NULL;
    }
    ;

    m_has_hueOff = false;

    if (m_hueOff)
    {
        delete m_hueOff;
        m_hueOff = NULL;
    }
    ;

    m_has_hueMod = false;

    if (m_hueMod)
    {
        delete m_hueMod;
        m_hueMod = NULL;
    }
    ;

    m_has_sat = false;

    if (m_sat)
    {
        delete m_sat;
        m_sat = NULL;
    }
    ;

    m_has_satOff = false;

    if (m_satOff)
    {
        delete m_satOff;
        m_satOff = NULL;
    }
    ;

    m_has_satMod = false;

    if (m_satMod)
    {
        delete m_satMod;
        m_satMod = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_lumOff = false;

    if (m_lumOff)
    {
        delete m_lumOff;
        m_lumOff = NULL;
    }
    ;

    m_has_lumMod = false;

    if (m_lumMod)
    {
        delete m_lumMod;
        m_lumMod = NULL;
    }
    ;

    m_has_red = false;

    if (m_red)
    {
        delete m_red;
        m_red = NULL;
    }
    ;

    m_has_redOff = false;

    if (m_redOff)
    {
        delete m_redOff;
        m_redOff = NULL;
    }
    ;

    m_has_redMod = false;

    if (m_redMod)
    {
        delete m_redMod;
        m_redMod = NULL;
    }
    ;

    m_has_green = false;

    if (m_green)
    {
        delete m_green;
        m_green = NULL;
    }
    ;

    m_has_greenOff = false;

    if (m_greenOff)
    {
        delete m_greenOff;
        m_greenOff = NULL;
    }
    ;

    m_has_greenMod = false;

    if (m_greenMod)
    {
        delete m_greenMod;
        m_greenMod = NULL;
    }
    ;

    m_has_blue = false;

    if (m_blue)
    {
        delete m_blue;
        m_blue = NULL;
    }
    ;

    m_has_blueOff = false;

    if (m_blueOff)
    {
        delete m_blueOff;
        m_blueOff = NULL;
    }
    ;

    m_has_blueMod = false;

    if (m_blueMod)
    {
        delete m_blueMod;
        m_blueMod = NULL;
    }
    ;

    m_has_gamma = false;

    if (m_gamma)
    {
        delete m_gamma;
        m_gamma = NULL;
    }
    ;

    m_has_invGamma = true;
    if (!m_invGamma)
    {
        m_invGamma = new CT_InverseGammaTransform();
    }
    return m_invGamma;
}

const CT_InverseGammaTransform& CT_PresetColor::ChildGroup_1::get_invGamma() const
{
    if (m_invGamma)
    {
        return *m_invGamma;
    }
    return CT_InverseGammaTransform::default_instance();
}

CT_PresetColor* CT_PresetColor::default_instance_ = NULL;

// CT_OfficeArtExtensionList
CT_OfficeArtExtensionList::CT_OfficeArtExtensionList()

{
}
CT_OfficeArtExtensionList::~CT_OfficeArtExtensionList()
{
    clear();
}
CT_OfficeArtExtension* CT_OfficeArtExtensionList::add_ext()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_OfficeArtExtension* pNewChild = pChildGroup->mutable_ext();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

void CT_OfficeArtExtensionList::clear()
{
    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }
}

void CT_OfficeArtExtensionList::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_ext())
            {
                (*iter)->get_ext().toXmlElem("a:ext", "", _outStream);
            }


        }
    }

    _outStream << "</" << _elemName << ">";
}

const CT_OfficeArtExtensionList& CT_OfficeArtExtensionList::default_instance()
{
    if (!CT_OfficeArtExtensionList::default_instance_)
    {
        CT_OfficeArtExtensionList::default_instance_ = new CT_OfficeArtExtensionList();
    }
    return *CT_OfficeArtExtensionList::default_instance_;
}


// CT_OfficeArtExtensionList::ChildGroup_1
CT_OfficeArtExtensionList::ChildGroup_1::ChildGroup_1()
    :m_has_ext(false),
     m_ext(NULL)
{
}
bool CT_OfficeArtExtensionList::ChildGroup_1::has_ext() const
{
    return m_has_ext;
}

CT_OfficeArtExtension* CT_OfficeArtExtensionList::ChildGroup_1::mutable_ext()
{

    m_has_ext = true;
    if (!m_ext)
    {
        m_ext = new CT_OfficeArtExtension();
    }
    return m_ext;
}

const CT_OfficeArtExtension& CT_OfficeArtExtensionList::ChildGroup_1::get_ext() const
{
    if (m_ext)
    {
        return *m_ext;
    }
    return CT_OfficeArtExtension::default_instance();
}

CT_OfficeArtExtensionList* CT_OfficeArtExtensionList::default_instance_ = NULL;

// CT_Scale2D
CT_Scale2D::CT_Scale2D()
    :m_has_sx(false),
     m_sx(NULL),
     m_has_sy(false),
     m_sy(NULL)
{
}
CT_Scale2D::~CT_Scale2D()
{
    clear();
}
bool CT_Scale2D::has_sx() const
{
    return m_has_sx;
}

CT_Ratio* CT_Scale2D::mutable_sx()
{
    m_has_sx = true;
    if (!m_sx)
    {
        m_sx = new CT_Ratio();
    }
    return m_sx;
}

const CT_Ratio& CT_Scale2D::get_sx() const
{
    if (m_sx)
    {
        return *m_sx;
    }
    return CT_Ratio::default_instance();
}

bool CT_Scale2D::has_sy() const
{
    return m_has_sy;
}

CT_Ratio* CT_Scale2D::mutable_sy()
{
    m_has_sy = true;
    if (!m_sy)
    {
        m_sy = new CT_Ratio();
    }
    return m_sy;
}

const CT_Ratio& CT_Scale2D::get_sy() const
{
    if (m_sy)
    {
        return *m_sy;
    }
    return CT_Ratio::default_instance();
}

void CT_Scale2D::clear()
{
    m_has_sx = false;

    if (m_sx)
    {
        delete m_sx;
        m_sx = NULL;
    }


    m_has_sy = false;

    if (m_sy)
    {
        delete m_sy;
        m_sy = NULL;
    }

}

void CT_Scale2D::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    assert(m_has_sx);


    assert(m_has_sy);


    if (m_has_sx)
    {
        m_sx->toXmlElem("a:sx", "", _outStream);
    }


    if (m_has_sy)
    {
        m_sy->toXmlElem("a:sy", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_Scale2D& CT_Scale2D::default_instance()
{
    if (!CT_Scale2D::default_instance_)
    {
        CT_Scale2D::default_instance_ = new CT_Scale2D();
    }
    return *CT_Scale2D::default_instance_;
}

CT_Scale2D* CT_Scale2D::default_instance_ = NULL;

// CT_Transform2D
CT_Transform2D::CT_Transform2D()
    :m_has_off(false),
     m_off(NULL),
     m_has_ext(false),
     m_ext(NULL),
     m_has_rot_attr(false),
     m_rot_attr(NULL),
     m_has_flipH_attr(false),
     m_flipH_attr(false),
     m_has_flipV_attr(false),
     m_flipV_attr(false)
{
}
CT_Transform2D::~CT_Transform2D()
{
    clear();
}
bool CT_Transform2D::has_off() const
{
    return m_has_off;
}

CT_Point2D* CT_Transform2D::mutable_off()
{
    m_has_off = true;
    if (!m_off)
    {
        m_off = new CT_Point2D();
    }
    return m_off;
}

const CT_Point2D& CT_Transform2D::get_off() const
{
    if (m_off)
    {
        return *m_off;
    }
    return CT_Point2D::default_instance();
}

bool CT_Transform2D::has_ext() const
{
    return m_has_ext;
}

CT_PositiveSize2D* CT_Transform2D::mutable_ext()
{
    m_has_ext = true;
    if (!m_ext)
    {
        m_ext = new CT_PositiveSize2D();
    }
    return m_ext;
}

const CT_PositiveSize2D& CT_Transform2D::get_ext() const
{
    if (m_ext)
    {
        return *m_ext;
    }
    return CT_PositiveSize2D::default_instance();
}

void CT_Transform2D::clear()
{
    m_has_rot_attr = false;

    if (m_rot_attr)
    {
        delete m_rot_attr;
        m_rot_attr = NULL;
    }


    m_has_flipH_attr = false;
    m_flipH_attr = false;

    m_has_flipV_attr = false;
    m_flipV_attr = false;

    m_has_off = false;

    if (m_off)
    {
        delete m_off;
        m_off = NULL;
    }


    m_has_ext = false;

    if (m_ext)
    {
        delete m_ext;
        m_ext = NULL;
    }

}

void CT_Transform2D::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_rot_attr)
    {
        m_rot_attr->toXmlAttr("rot", _outStream);
    }



    if (m_has_flipH_attr)
    {
        _outStream << " " << "flipH" << "=\"" << XSD::XMLBooleanStr(m_flipH_attr) << "\"";
    }



    if (m_has_flipV_attr)
    {
        _outStream << " " << "flipV" << "=\"" << XSD::XMLBooleanStr(m_flipV_attr) << "\"";
    }

    _outStream << ">";


    if (m_has_off)
    {
        m_off->toXmlElem("a:off", "", _outStream);
    }


    if (m_has_ext)
    {
        m_ext->toXmlElem("a:ext", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_Transform2D& CT_Transform2D::default_instance()
{
    if (!CT_Transform2D::default_instance_)
    {
        CT_Transform2D::default_instance_ = new CT_Transform2D();
    }
    return *CT_Transform2D::default_instance_;
}

bool CT_Transform2D::has_rot_attr() const
{
    return m_has_rot_attr;
}

void CT_Transform2D::set_rot_attr(const ST_Angle& _rot_attr)
{
    m_has_rot_attr = true;
    m_rot_attr = new ST_Angle(_rot_attr);
}

const ST_Angle& CT_Transform2D::get_rot_attr() const
{
    if (m_rot_attr)
    {
        return *m_rot_attr;
    }
    return ST_Angle::default_instance();
}

bool CT_Transform2D::has_flipH_attr() const
{
    return m_has_flipH_attr;
}

void CT_Transform2D::set_flipH_attr(const XSD::boolean_& _flipH_attr)
{
    m_has_flipH_attr = true;
    m_flipH_attr = _flipH_attr;
}

const XSD::boolean_& CT_Transform2D::get_flipH_attr() const
{
    return m_flipH_attr;
}

bool CT_Transform2D::has_flipV_attr() const
{
    return m_has_flipV_attr;
}

void CT_Transform2D::set_flipV_attr(const XSD::boolean_& _flipV_attr)
{
    m_has_flipV_attr = true;
    m_flipV_attr = _flipV_attr;
}

const XSD::boolean_& CT_Transform2D::get_flipV_attr() const
{
    return m_flipV_attr;
}

CT_Transform2D* CT_Transform2D::default_instance_ = NULL;

// CT_GroupTransform2D
CT_GroupTransform2D::CT_GroupTransform2D()
    :m_has_off(false),
     m_off(NULL),
     m_has_ext(false),
     m_ext(NULL),
     m_has_chOff(false),
     m_chOff(NULL),
     m_has_chExt(false),
     m_chExt(NULL),
     m_has_rot_attr(false),
     m_rot_attr(NULL),
     m_has_flipH_attr(false),
     m_flipH_attr(false),
     m_has_flipV_attr(false),
     m_flipV_attr(false)
{
}
CT_GroupTransform2D::~CT_GroupTransform2D()
{
    clear();
}
bool CT_GroupTransform2D::has_off() const
{
    return m_has_off;
}

CT_Point2D* CT_GroupTransform2D::mutable_off()
{
    m_has_off = true;
    if (!m_off)
    {
        m_off = new CT_Point2D();
    }
    return m_off;
}

const CT_Point2D& CT_GroupTransform2D::get_off() const
{
    if (m_off)
    {
        return *m_off;
    }
    return CT_Point2D::default_instance();
}

bool CT_GroupTransform2D::has_ext() const
{
    return m_has_ext;
}

CT_PositiveSize2D* CT_GroupTransform2D::mutable_ext()
{
    m_has_ext = true;
    if (!m_ext)
    {
        m_ext = new CT_PositiveSize2D();
    }
    return m_ext;
}

const CT_PositiveSize2D& CT_GroupTransform2D::get_ext() const
{
    if (m_ext)
    {
        return *m_ext;
    }
    return CT_PositiveSize2D::default_instance();
}

bool CT_GroupTransform2D::has_chOff() const
{
    return m_has_chOff;
}

CT_Point2D* CT_GroupTransform2D::mutable_chOff()
{
    m_has_chOff = true;
    if (!m_chOff)
    {
        m_chOff = new CT_Point2D();
    }
    return m_chOff;
}

const CT_Point2D& CT_GroupTransform2D::get_chOff() const
{
    if (m_chOff)
    {
        return *m_chOff;
    }
    return CT_Point2D::default_instance();
}

bool CT_GroupTransform2D::has_chExt() const
{
    return m_has_chExt;
}

CT_PositiveSize2D* CT_GroupTransform2D::mutable_chExt()
{
    m_has_chExt = true;
    if (!m_chExt)
    {
        m_chExt = new CT_PositiveSize2D();
    }
    return m_chExt;
}

const CT_PositiveSize2D& CT_GroupTransform2D::get_chExt() const
{
    if (m_chExt)
    {
        return *m_chExt;
    }
    return CT_PositiveSize2D::default_instance();
}

void CT_GroupTransform2D::clear()
{
    m_has_rot_attr = false;

    if (m_rot_attr)
    {
        delete m_rot_attr;
        m_rot_attr = NULL;
    }


    m_has_flipH_attr = false;
    m_flipH_attr = false;

    m_has_flipV_attr = false;
    m_flipV_attr = false;

    m_has_off = false;

    if (m_off)
    {
        delete m_off;
        m_off = NULL;
    }


    m_has_ext = false;

    if (m_ext)
    {
        delete m_ext;
        m_ext = NULL;
    }


    m_has_chOff = false;

    if (m_chOff)
    {
        delete m_chOff;
        m_chOff = NULL;
    }


    m_has_chExt = false;

    if (m_chExt)
    {
        delete m_chExt;
        m_chExt = NULL;
    }

}

void CT_GroupTransform2D::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_rot_attr)
    {
        m_rot_attr->toXmlAttr("rot", _outStream);
    }



    if (m_has_flipH_attr)
    {
        _outStream << " " << "flipH" << "=\"" << XSD::XMLBooleanStr(m_flipH_attr) << "\"";
    }



    if (m_has_flipV_attr)
    {
        _outStream << " " << "flipV" << "=\"" << XSD::XMLBooleanStr(m_flipV_attr) << "\"";
    }

    _outStream << ">";


    if (m_has_off)
    {
        m_off->toXmlElem("a:off", "", _outStream);
    }


    if (m_has_ext)
    {
        m_ext->toXmlElem("a:ext", "", _outStream);
    }


    if (m_has_chOff)
    {
        m_chOff->toXmlElem("a:chOff", "", _outStream);
    }


    if (m_has_chExt)
    {
        m_chExt->toXmlElem("a:chExt", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_GroupTransform2D& CT_GroupTransform2D::default_instance()
{
    if (!CT_GroupTransform2D::default_instance_)
    {
        CT_GroupTransform2D::default_instance_ = new CT_GroupTransform2D();
    }
    return *CT_GroupTransform2D::default_instance_;
}

bool CT_GroupTransform2D::has_rot_attr() const
{
    return m_has_rot_attr;
}

void CT_GroupTransform2D::set_rot_attr(const ST_Angle& _rot_attr)
{
    m_has_rot_attr = true;
    m_rot_attr = new ST_Angle(_rot_attr);
}

const ST_Angle& CT_GroupTransform2D::get_rot_attr() const
{
    if (m_rot_attr)
    {
        return *m_rot_attr;
    }
    return ST_Angle::default_instance();
}

bool CT_GroupTransform2D::has_flipH_attr() const
{
    return m_has_flipH_attr;
}

void CT_GroupTransform2D::set_flipH_attr(const XSD::boolean_& _flipH_attr)
{
    m_has_flipH_attr = true;
    m_flipH_attr = _flipH_attr;
}

const XSD::boolean_& CT_GroupTransform2D::get_flipH_attr() const
{
    return m_flipH_attr;
}

bool CT_GroupTransform2D::has_flipV_attr() const
{
    return m_has_flipV_attr;
}

void CT_GroupTransform2D::set_flipV_attr(const XSD::boolean_& _flipV_attr)
{
    m_has_flipV_attr = true;
    m_flipV_attr = _flipV_attr;
}

const XSD::boolean_& CT_GroupTransform2D::get_flipV_attr() const
{
    return m_flipV_attr;
}

CT_GroupTransform2D* CT_GroupTransform2D::default_instance_ = NULL;

// CT_Point3D
CT_Point3D::CT_Point3D()
    :m_has_x_attr(false),
     m_x_attr(NULL),
     m_has_y_attr(false),
     m_y_attr(NULL),
     m_has_z_attr(false),
     m_z_attr(NULL)
{
}
CT_Point3D::~CT_Point3D()
{
    clear();
}
void CT_Point3D::clear()
{
    m_has_x_attr = false;

    if (m_x_attr)
    {
        delete m_x_attr;
        m_x_attr = NULL;
    }


    m_has_y_attr = false;

    if (m_y_attr)
    {
        delete m_y_attr;
        m_y_attr = NULL;
    }


    m_has_z_attr = false;

    if (m_z_attr)
    {
        delete m_z_attr;
        m_z_attr = NULL;
    }

}

void CT_Point3D::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_x_attr);
    if (m_has_x_attr)
    {
        m_x_attr->toXmlAttr("x", _outStream);
    }


    assert(m_has_y_attr);
    if (m_has_y_attr)
    {
        m_y_attr->toXmlAttr("y", _outStream);
    }


    assert(m_has_z_attr);
    if (m_has_z_attr)
    {
        m_z_attr->toXmlAttr("z", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_Point3D& CT_Point3D::default_instance()
{
    if (!CT_Point3D::default_instance_)
    {
        CT_Point3D::default_instance_ = new CT_Point3D();
    }
    return *CT_Point3D::default_instance_;
}

bool CT_Point3D::has_x_attr() const
{
    return m_has_x_attr;
}

void CT_Point3D::set_x_attr(const ST_Coordinate& _x_attr)
{
    m_has_x_attr = true;
    m_x_attr = new ST_Coordinate(_x_attr);
}

const ST_Coordinate& CT_Point3D::get_x_attr() const
{
    if (m_x_attr)
    {
        return *m_x_attr;
    }
    return ST_Coordinate::default_instance();
}

bool CT_Point3D::has_y_attr() const
{
    return m_has_y_attr;
}

void CT_Point3D::set_y_attr(const ST_Coordinate& _y_attr)
{
    m_has_y_attr = true;
    m_y_attr = new ST_Coordinate(_y_attr);
}

const ST_Coordinate& CT_Point3D::get_y_attr() const
{
    if (m_y_attr)
    {
        return *m_y_attr;
    }
    return ST_Coordinate::default_instance();
}

bool CT_Point3D::has_z_attr() const
{
    return m_has_z_attr;
}

void CT_Point3D::set_z_attr(const ST_Coordinate& _z_attr)
{
    m_has_z_attr = true;
    m_z_attr = new ST_Coordinate(_z_attr);
}

const ST_Coordinate& CT_Point3D::get_z_attr() const
{
    if (m_z_attr)
    {
        return *m_z_attr;
    }
    return ST_Coordinate::default_instance();
}

CT_Point3D* CT_Point3D::default_instance_ = NULL;

// CT_Vector3D
CT_Vector3D::CT_Vector3D()
    :m_has_dx_attr(false),
     m_dx_attr(NULL),
     m_has_dy_attr(false),
     m_dy_attr(NULL),
     m_has_dz_attr(false),
     m_dz_attr(NULL)
{
}
CT_Vector3D::~CT_Vector3D()
{
    clear();
}
void CT_Vector3D::clear()
{
    m_has_dx_attr = false;

    if (m_dx_attr)
    {
        delete m_dx_attr;
        m_dx_attr = NULL;
    }


    m_has_dy_attr = false;

    if (m_dy_attr)
    {
        delete m_dy_attr;
        m_dy_attr = NULL;
    }


    m_has_dz_attr = false;

    if (m_dz_attr)
    {
        delete m_dz_attr;
        m_dz_attr = NULL;
    }

}

void CT_Vector3D::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_dx_attr);
    if (m_has_dx_attr)
    {
        m_dx_attr->toXmlAttr("dx", _outStream);
    }


    assert(m_has_dy_attr);
    if (m_has_dy_attr)
    {
        m_dy_attr->toXmlAttr("dy", _outStream);
    }


    assert(m_has_dz_attr);
    if (m_has_dz_attr)
    {
        m_dz_attr->toXmlAttr("dz", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_Vector3D& CT_Vector3D::default_instance()
{
    if (!CT_Vector3D::default_instance_)
    {
        CT_Vector3D::default_instance_ = new CT_Vector3D();
    }
    return *CT_Vector3D::default_instance_;
}

bool CT_Vector3D::has_dx_attr() const
{
    return m_has_dx_attr;
}

void CT_Vector3D::set_dx_attr(const ST_Coordinate& _dx_attr)
{
    m_has_dx_attr = true;
    m_dx_attr = new ST_Coordinate(_dx_attr);
}

const ST_Coordinate& CT_Vector3D::get_dx_attr() const
{
    if (m_dx_attr)
    {
        return *m_dx_attr;
    }
    return ST_Coordinate::default_instance();
}

bool CT_Vector3D::has_dy_attr() const
{
    return m_has_dy_attr;
}

void CT_Vector3D::set_dy_attr(const ST_Coordinate& _dy_attr)
{
    m_has_dy_attr = true;
    m_dy_attr = new ST_Coordinate(_dy_attr);
}

const ST_Coordinate& CT_Vector3D::get_dy_attr() const
{
    if (m_dy_attr)
    {
        return *m_dy_attr;
    }
    return ST_Coordinate::default_instance();
}

bool CT_Vector3D::has_dz_attr() const
{
    return m_has_dz_attr;
}

void CT_Vector3D::set_dz_attr(const ST_Coordinate& _dz_attr)
{
    m_has_dz_attr = true;
    m_dz_attr = new ST_Coordinate(_dz_attr);
}

const ST_Coordinate& CT_Vector3D::get_dz_attr() const
{
    if (m_dz_attr)
    {
        return *m_dz_attr;
    }
    return ST_Coordinate::default_instance();
}

CT_Vector3D* CT_Vector3D::default_instance_ = NULL;

// CT_SphereCoords
CT_SphereCoords::CT_SphereCoords()
    :m_has_lat_attr(false),
     m_lat_attr(NULL),
     m_has_lon_attr(false),
     m_lon_attr(NULL),
     m_has_rev_attr(false),
     m_rev_attr(NULL)
{
}
CT_SphereCoords::~CT_SphereCoords()
{
    clear();
}
void CT_SphereCoords::clear()
{
    m_has_lat_attr = false;

    if (m_lat_attr)
    {
        delete m_lat_attr;
        m_lat_attr = NULL;
    }


    m_has_lon_attr = false;

    if (m_lon_attr)
    {
        delete m_lon_attr;
        m_lon_attr = NULL;
    }


    m_has_rev_attr = false;

    if (m_rev_attr)
    {
        delete m_rev_attr;
        m_rev_attr = NULL;
    }

}

void CT_SphereCoords::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_lat_attr);
    if (m_has_lat_attr)
    {
        m_lat_attr->toXmlAttr("lat", _outStream);
    }


    assert(m_has_lon_attr);
    if (m_has_lon_attr)
    {
        m_lon_attr->toXmlAttr("lon", _outStream);
    }


    assert(m_has_rev_attr);
    if (m_has_rev_attr)
    {
        m_rev_attr->toXmlAttr("rev", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_SphereCoords& CT_SphereCoords::default_instance()
{
    if (!CT_SphereCoords::default_instance_)
    {
        CT_SphereCoords::default_instance_ = new CT_SphereCoords();
    }
    return *CT_SphereCoords::default_instance_;
}

bool CT_SphereCoords::has_lat_attr() const
{
    return m_has_lat_attr;
}

void CT_SphereCoords::set_lat_attr(const ST_PositiveFixedAngle& _lat_attr)
{
    m_has_lat_attr = true;
    m_lat_attr = new ST_PositiveFixedAngle(_lat_attr);
}

const ST_PositiveFixedAngle& CT_SphereCoords::get_lat_attr() const
{
    if (m_lat_attr)
    {
        return *m_lat_attr;
    }
    return ST_PositiveFixedAngle::default_instance();
}

bool CT_SphereCoords::has_lon_attr() const
{
    return m_has_lon_attr;
}

void CT_SphereCoords::set_lon_attr(const ST_PositiveFixedAngle& _lon_attr)
{
    m_has_lon_attr = true;
    m_lon_attr = new ST_PositiveFixedAngle(_lon_attr);
}

const ST_PositiveFixedAngle& CT_SphereCoords::get_lon_attr() const
{
    if (m_lon_attr)
    {
        return *m_lon_attr;
    }
    return ST_PositiveFixedAngle::default_instance();
}

bool CT_SphereCoords::has_rev_attr() const
{
    return m_has_rev_attr;
}

void CT_SphereCoords::set_rev_attr(const ST_PositiveFixedAngle& _rev_attr)
{
    m_has_rev_attr = true;
    m_rev_attr = new ST_PositiveFixedAngle(_rev_attr);
}

const ST_PositiveFixedAngle& CT_SphereCoords::get_rev_attr() const
{
    if (m_rev_attr)
    {
        return *m_rev_attr;
    }
    return ST_PositiveFixedAngle::default_instance();
}

CT_SphereCoords* CT_SphereCoords::default_instance_ = NULL;

// CT_RelativeRect
CT_RelativeRect::CT_RelativeRect()
    :m_has_l_attr(false),
     m_l_attr(NULL),
     m_has_t_attr(false),
     m_t_attr(NULL),
     m_has_r_attr(false),
     m_r_attr(NULL),
     m_has_b_attr(false),
     m_b_attr(NULL)
{
}
CT_RelativeRect::~CT_RelativeRect()
{
    clear();
}
void CT_RelativeRect::clear()
{
    m_has_l_attr = false;

    if (m_l_attr)
    {
        delete m_l_attr;
        m_l_attr = NULL;
    }


    m_has_t_attr = false;

    if (m_t_attr)
    {
        delete m_t_attr;
        m_t_attr = NULL;
    }


    m_has_r_attr = false;

    if (m_r_attr)
    {
        delete m_r_attr;
        m_r_attr = NULL;
    }


    m_has_b_attr = false;

    if (m_b_attr)
    {
        delete m_b_attr;
        m_b_attr = NULL;
    }

}

void CT_RelativeRect::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_l_attr)
    {
        m_l_attr->toXmlAttr("l", _outStream);
    }



    if (m_has_t_attr)
    {
        m_t_attr->toXmlAttr("t", _outStream);
    }



    if (m_has_r_attr)
    {
        m_r_attr->toXmlAttr("r", _outStream);
    }



    if (m_has_b_attr)
    {
        m_b_attr->toXmlAttr("b", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_RelativeRect& CT_RelativeRect::default_instance()
{
    if (!CT_RelativeRect::default_instance_)
    {
        CT_RelativeRect::default_instance_ = new CT_RelativeRect();
    }
    return *CT_RelativeRect::default_instance_;
}

bool CT_RelativeRect::has_l_attr() const
{
    return m_has_l_attr;
}

void CT_RelativeRect::set_l_attr(const ST_Percentage& _l_attr)
{
    m_has_l_attr = true;
    m_l_attr = new ST_Percentage(_l_attr);
}

const ST_Percentage& CT_RelativeRect::get_l_attr() const
{
    if (m_l_attr)
    {
        return *m_l_attr;
    }
    return ST_Percentage::default_instance();
}

bool CT_RelativeRect::has_t_attr() const
{
    return m_has_t_attr;
}

void CT_RelativeRect::set_t_attr(const ST_Percentage& _t_attr)
{
    m_has_t_attr = true;
    m_t_attr = new ST_Percentage(_t_attr);
}

const ST_Percentage& CT_RelativeRect::get_t_attr() const
{
    if (m_t_attr)
    {
        return *m_t_attr;
    }
    return ST_Percentage::default_instance();
}

bool CT_RelativeRect::has_r_attr() const
{
    return m_has_r_attr;
}

void CT_RelativeRect::set_r_attr(const ST_Percentage& _r_attr)
{
    m_has_r_attr = true;
    m_r_attr = new ST_Percentage(_r_attr);
}

const ST_Percentage& CT_RelativeRect::get_r_attr() const
{
    if (m_r_attr)
    {
        return *m_r_attr;
    }
    return ST_Percentage::default_instance();
}

bool CT_RelativeRect::has_b_attr() const
{
    return m_has_b_attr;
}

void CT_RelativeRect::set_b_attr(const ST_Percentage& _b_attr)
{
    m_has_b_attr = true;
    m_b_attr = new ST_Percentage(_b_attr);
}

const ST_Percentage& CT_RelativeRect::get_b_attr() const
{
    if (m_b_attr)
    {
        return *m_b_attr;
    }
    return ST_Percentage::default_instance();
}

CT_RelativeRect* CT_RelativeRect::default_instance_ = NULL;

// CT_Color
CT_Color::CT_Color()
    :m_has_scrgbClr(false),
     m_scrgbClr(NULL),
     m_has_srgbClr(false),
     m_srgbClr(NULL),
     m_has_hslClr(false),
     m_hslClr(NULL),
     m_has_sysClr(false),
     m_sysClr(NULL),
     m_has_schemeClr(false),
     m_schemeClr(NULL),
     m_has_prstClr(false),
     m_prstClr(NULL)
{
}
CT_Color::~CT_Color()
{
    clear();
}
bool CT_Color::has_scrgbClr() const
{
    return m_has_scrgbClr;
}

CT_ScRgbColor* CT_Color::mutable_scrgbClr()
{

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_scrgbClr = true;
    if (!m_scrgbClr)
    {
        m_scrgbClr = new CT_ScRgbColor();
    }
    return m_scrgbClr;
}

const CT_ScRgbColor& CT_Color::get_scrgbClr() const
{
    if (m_scrgbClr)
    {
        return *m_scrgbClr;
    }
    return CT_ScRgbColor::default_instance();
}

bool CT_Color::has_srgbClr() const
{
    return m_has_srgbClr;
}

CT_SRgbColor* CT_Color::mutable_srgbClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_srgbClr = true;
    if (!m_srgbClr)
    {
        m_srgbClr = new CT_SRgbColor();
    }
    return m_srgbClr;
}

const CT_SRgbColor& CT_Color::get_srgbClr() const
{
    if (m_srgbClr)
    {
        return *m_srgbClr;
    }
    return CT_SRgbColor::default_instance();
}

bool CT_Color::has_hslClr() const
{
    return m_has_hslClr;
}

CT_HslColor* CT_Color::mutable_hslClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_hslClr = true;
    if (!m_hslClr)
    {
        m_hslClr = new CT_HslColor();
    }
    return m_hslClr;
}

const CT_HslColor& CT_Color::get_hslClr() const
{
    if (m_hslClr)
    {
        return *m_hslClr;
    }
    return CT_HslColor::default_instance();
}

bool CT_Color::has_sysClr() const
{
    return m_has_sysClr;
}

CT_SystemColor* CT_Color::mutable_sysClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_sysClr = true;
    if (!m_sysClr)
    {
        m_sysClr = new CT_SystemColor();
    }
    return m_sysClr;
}

const CT_SystemColor& CT_Color::get_sysClr() const
{
    if (m_sysClr)
    {
        return *m_sysClr;
    }
    return CT_SystemColor::default_instance();
}

bool CT_Color::has_schemeClr() const
{
    return m_has_schemeClr;
}

CT_SchemeColor* CT_Color::mutable_schemeClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_schemeClr = true;
    if (!m_schemeClr)
    {
        m_schemeClr = new CT_SchemeColor();
    }
    return m_schemeClr;
}

const CT_SchemeColor& CT_Color::get_schemeClr() const
{
    if (m_schemeClr)
    {
        return *m_schemeClr;
    }
    return CT_SchemeColor::default_instance();
}

bool CT_Color::has_prstClr() const
{
    return m_has_prstClr;
}

CT_PresetColor* CT_Color::mutable_prstClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = true;
    if (!m_prstClr)
    {
        m_prstClr = new CT_PresetColor();
    }
    return m_prstClr;
}

const CT_PresetColor& CT_Color::get_prstClr() const
{
    if (m_prstClr)
    {
        return *m_prstClr;
    }
    return CT_PresetColor::default_instance();
}

void CT_Color::clear()
{
    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }


    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }


    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }


    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }


    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }


    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }

}

void CT_Color::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    {
        bool elemHasValueList[6] = {m_has_scrgbClr, m_has_srgbClr, m_has_hslClr, m_has_sysClr, m_has_schemeClr, m_has_prstClr};
        int cnt = count(elemHasValueList, elemHasValueList + 6, true);
        assert(cnt == 1);
    }


    if (m_has_scrgbClr)
    {
        m_scrgbClr->toXmlElem("a:scrgbClr", "", _outStream);
    }


    if (m_has_srgbClr)
    {
        m_srgbClr->toXmlElem("a:srgbClr", "", _outStream);
    }


    if (m_has_hslClr)
    {
        m_hslClr->toXmlElem("a:hslClr", "", _outStream);
    }


    if (m_has_sysClr)
    {
        m_sysClr->toXmlElem("a:sysClr", "", _outStream);
    }


    if (m_has_schemeClr)
    {
        m_schemeClr->toXmlElem("a:schemeClr", "", _outStream);
    }


    if (m_has_prstClr)
    {
        m_prstClr->toXmlElem("a:prstClr", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_Color& CT_Color::default_instance()
{
    if (!CT_Color::default_instance_)
    {
        CT_Color::default_instance_ = new CT_Color();
    }
    return *CT_Color::default_instance_;
}

CT_Color* CT_Color::default_instance_ = NULL;

// CT_ColorMRU
CT_ColorMRU::CT_ColorMRU()

{
}
CT_ColorMRU::~CT_ColorMRU()
{
    clear();
}
CT_ScRgbColor* CT_ColorMRU::add_scrgbClr()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_ScRgbColor* pNewChild = pChildGroup->mutable_scrgbClr();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_SRgbColor* CT_ColorMRU::add_srgbClr()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_SRgbColor* pNewChild = pChildGroup->mutable_srgbClr();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_HslColor* CT_ColorMRU::add_hslClr()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_HslColor* pNewChild = pChildGroup->mutable_hslClr();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_SystemColor* CT_ColorMRU::add_sysClr()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_SystemColor* pNewChild = pChildGroup->mutable_sysClr();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_SchemeColor* CT_ColorMRU::add_schemeClr()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_SchemeColor* pNewChild = pChildGroup->mutable_schemeClr();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_PresetColor* CT_ColorMRU::add_prstClr()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PresetColor* pNewChild = pChildGroup->mutable_prstClr();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

void CT_ColorMRU::clear()
{
    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }
}

void CT_ColorMRU::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_scrgbClr())
            {
                (*iter)->get_scrgbClr().toXmlElem("a:scrgbClr", "", _outStream);
            }


            else if ((*iter)->has_srgbClr())
            {
                (*iter)->get_srgbClr().toXmlElem("a:srgbClr", "", _outStream);
            }


            else if ((*iter)->has_hslClr())
            {
                (*iter)->get_hslClr().toXmlElem("a:hslClr", "", _outStream);
            }


            else if ((*iter)->has_sysClr())
            {
                (*iter)->get_sysClr().toXmlElem("a:sysClr", "", _outStream);
            }


            else if ((*iter)->has_schemeClr())
            {
                (*iter)->get_schemeClr().toXmlElem("a:schemeClr", "", _outStream);
            }


            else if ((*iter)->has_prstClr())
            {
                (*iter)->get_prstClr().toXmlElem("a:prstClr", "", _outStream);
            }


        }
    }

    _outStream << "</" << _elemName << ">";
}

const CT_ColorMRU& CT_ColorMRU::default_instance()
{
    if (!CT_ColorMRU::default_instance_)
    {
        CT_ColorMRU::default_instance_ = new CT_ColorMRU();
    }
    return *CT_ColorMRU::default_instance_;
}


// CT_ColorMRU::ChildGroup_1
CT_ColorMRU::ChildGroup_1::ChildGroup_1()
    :m_has_scrgbClr(false),
     m_scrgbClr(NULL),
     m_has_srgbClr(false),
     m_srgbClr(NULL),
     m_has_hslClr(false),
     m_hslClr(NULL),
     m_has_sysClr(false),
     m_sysClr(NULL),
     m_has_schemeClr(false),
     m_schemeClr(NULL),
     m_has_prstClr(false),
     m_prstClr(NULL)
{
}
bool CT_ColorMRU::ChildGroup_1::has_scrgbClr() const
{
    return m_has_scrgbClr;
}

CT_ScRgbColor* CT_ColorMRU::ChildGroup_1::mutable_scrgbClr()
{

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_scrgbClr = true;
    if (!m_scrgbClr)
    {
        m_scrgbClr = new CT_ScRgbColor();
    }
    return m_scrgbClr;
}

const CT_ScRgbColor& CT_ColorMRU::ChildGroup_1::get_scrgbClr() const
{
    if (m_scrgbClr)
    {
        return *m_scrgbClr;
    }
    return CT_ScRgbColor::default_instance();
}

bool CT_ColorMRU::ChildGroup_1::has_srgbClr() const
{
    return m_has_srgbClr;
}

CT_SRgbColor* CT_ColorMRU::ChildGroup_1::mutable_srgbClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_srgbClr = true;
    if (!m_srgbClr)
    {
        m_srgbClr = new CT_SRgbColor();
    }
    return m_srgbClr;
}

const CT_SRgbColor& CT_ColorMRU::ChildGroup_1::get_srgbClr() const
{
    if (m_srgbClr)
    {
        return *m_srgbClr;
    }
    return CT_SRgbColor::default_instance();
}

bool CT_ColorMRU::ChildGroup_1::has_hslClr() const
{
    return m_has_hslClr;
}

CT_HslColor* CT_ColorMRU::ChildGroup_1::mutable_hslClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_hslClr = true;
    if (!m_hslClr)
    {
        m_hslClr = new CT_HslColor();
    }
    return m_hslClr;
}

const CT_HslColor& CT_ColorMRU::ChildGroup_1::get_hslClr() const
{
    if (m_hslClr)
    {
        return *m_hslClr;
    }
    return CT_HslColor::default_instance();
}

bool CT_ColorMRU::ChildGroup_1::has_sysClr() const
{
    return m_has_sysClr;
}

CT_SystemColor* CT_ColorMRU::ChildGroup_1::mutable_sysClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_sysClr = true;
    if (!m_sysClr)
    {
        m_sysClr = new CT_SystemColor();
    }
    return m_sysClr;
}

const CT_SystemColor& CT_ColorMRU::ChildGroup_1::get_sysClr() const
{
    if (m_sysClr)
    {
        return *m_sysClr;
    }
    return CT_SystemColor::default_instance();
}

bool CT_ColorMRU::ChildGroup_1::has_schemeClr() const
{
    return m_has_schemeClr;
}

CT_SchemeColor* CT_ColorMRU::ChildGroup_1::mutable_schemeClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_schemeClr = true;
    if (!m_schemeClr)
    {
        m_schemeClr = new CT_SchemeColor();
    }
    return m_schemeClr;
}

const CT_SchemeColor& CT_ColorMRU::ChildGroup_1::get_schemeClr() const
{
    if (m_schemeClr)
    {
        return *m_schemeClr;
    }
    return CT_SchemeColor::default_instance();
}

bool CT_ColorMRU::ChildGroup_1::has_prstClr() const
{
    return m_has_prstClr;
}

CT_PresetColor* CT_ColorMRU::ChildGroup_1::mutable_prstClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = true;
    if (!m_prstClr)
    {
        m_prstClr = new CT_PresetColor();
    }
    return m_prstClr;
}

const CT_PresetColor& CT_ColorMRU::ChildGroup_1::get_prstClr() const
{
    if (m_prstClr)
    {
        return *m_prstClr;
    }
    return CT_PresetColor::default_instance();
}

CT_ColorMRU* CT_ColorMRU::default_instance_ = NULL;

// CT_EmbeddedWAVAudioFile
CT_EmbeddedWAVAudioFile::CT_EmbeddedWAVAudioFile()
    :m_has_r_embed_attr(false),
     m_r_embed_attr(NULL),
     m_has_name_attr(false),
     m_name_attr("")
{
}
CT_EmbeddedWAVAudioFile::~CT_EmbeddedWAVAudioFile()
{
    clear();
}
void CT_EmbeddedWAVAudioFile::clear()
{
    m_has_r_embed_attr = false;

    if (m_r_embed_attr)
    {
        delete m_r_embed_attr;
        m_r_embed_attr = NULL;
    }


    m_has_name_attr = false;
    m_name_attr.clear();
}

void CT_EmbeddedWAVAudioFile::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_r_embed_attr);
    if (m_has_r_embed_attr)
    {
        m_r_embed_attr->toXmlAttr("r:embed", _outStream);
    }



    if (m_has_name_attr)
    {
        _outStream << " " << "name" << "=\"" << m_name_attr << "\"";
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_EmbeddedWAVAudioFile& CT_EmbeddedWAVAudioFile::default_instance()
{
    if (!CT_EmbeddedWAVAudioFile::default_instance_)
    {
        CT_EmbeddedWAVAudioFile::default_instance_ = new CT_EmbeddedWAVAudioFile();
    }
    return *CT_EmbeddedWAVAudioFile::default_instance_;
}

bool CT_EmbeddedWAVAudioFile::has_r_embed_attr() const
{
    return m_has_r_embed_attr;
}

void CT_EmbeddedWAVAudioFile::set_r_embed_attr(const ns_r::ST_RelationshipId& _r_embed_attr)
{
    m_has_r_embed_attr = true;
    m_r_embed_attr = new ns_r::ST_RelationshipId(_r_embed_attr);
}

const ns_r::ST_RelationshipId& CT_EmbeddedWAVAudioFile::get_r_embed_attr() const
{
    if (m_r_embed_attr)
    {
        return *m_r_embed_attr;
    }
    return ns_r::ST_RelationshipId::default_instance();
}

bool CT_EmbeddedWAVAudioFile::has_name_attr() const
{
    return m_has_name_attr;
}

void CT_EmbeddedWAVAudioFile::set_name_attr(const XSD::string_& _name_attr)
{
    m_has_name_attr = true;
    m_name_attr = _name_attr;
}

const XSD::string_& CT_EmbeddedWAVAudioFile::get_name_attr() const
{
    return m_name_attr;
}

CT_EmbeddedWAVAudioFile* CT_EmbeddedWAVAudioFile::default_instance_ = NULL;

// CT_Hyperlink
CT_Hyperlink::CT_Hyperlink()
    :m_has_snd(false),
     m_snd(NULL),
     m_has_extLst(false),
     m_extLst(NULL),
     m_has_r_id_attr(false),
     m_r_id_attr(NULL),
     m_has_invalidUrl_attr(false),
     m_invalidUrl_attr(""),
     m_has_action_attr(false),
     m_action_attr(""),
     m_has_tgtFrame_attr(false),
     m_tgtFrame_attr(""),
     m_has_tooltip_attr(false),
     m_tooltip_attr(""),
     m_has_history_attr(false),
     m_history_attr(false),
     m_has_highlightClick_attr(false),
     m_highlightClick_attr(false),
     m_has_endSnd_attr(false),
     m_endSnd_attr(false)
{
}
CT_Hyperlink::~CT_Hyperlink()
{
    clear();
}
bool CT_Hyperlink::has_snd() const
{
    return m_has_snd;
}

CT_EmbeddedWAVAudioFile* CT_Hyperlink::mutable_snd()
{
    m_has_snd = true;
    if (!m_snd)
    {
        m_snd = new CT_EmbeddedWAVAudioFile();
    }
    return m_snd;
}

const CT_EmbeddedWAVAudioFile& CT_Hyperlink::get_snd() const
{
    if (m_snd)
    {
        return *m_snd;
    }
    return CT_EmbeddedWAVAudioFile::default_instance();
}

bool CT_Hyperlink::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_Hyperlink::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_Hyperlink::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_Hyperlink::clear()
{
    m_has_r_id_attr = false;

    if (m_r_id_attr)
    {
        delete m_r_id_attr;
        m_r_id_attr = NULL;
    }


    m_has_invalidUrl_attr = false;
    m_invalidUrl_attr.clear();

    m_has_action_attr = false;
    m_action_attr.clear();

    m_has_tgtFrame_attr = false;
    m_tgtFrame_attr.clear();

    m_has_tooltip_attr = false;
    m_tooltip_attr.clear();

    m_has_history_attr = false;
    m_history_attr = false;

    m_has_highlightClick_attr = false;
    m_highlightClick_attr = false;

    m_has_endSnd_attr = false;
    m_endSnd_attr = false;

    m_has_snd = false;

    if (m_snd)
    {
        delete m_snd;
        m_snd = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_Hyperlink::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_r_id_attr)
    {
        m_r_id_attr->toXmlAttr("r:id", _outStream);
    }



    if (m_has_invalidUrl_attr)
    {
        _outStream << " " << "invalidUrl" << "=\"" << m_invalidUrl_attr << "\"";
    }



    if (m_has_action_attr)
    {
        _outStream << " " << "action" << "=\"" << m_action_attr << "\"";
    }



    if (m_has_tgtFrame_attr)
    {
        _outStream << " " << "tgtFrame" << "=\"" << m_tgtFrame_attr << "\"";
    }



    if (m_has_tooltip_attr)
    {
        _outStream << " " << "tooltip" << "=\"" << m_tooltip_attr << "\"";
    }



    if (m_has_history_attr)
    {
        _outStream << " " << "history" << "=\"" << XSD::XMLBooleanStr(m_history_attr) << "\"";
    }



    if (m_has_highlightClick_attr)
    {
        _outStream << " " << "highlightClick" << "=\"" << XSD::XMLBooleanStr(m_highlightClick_attr) << "\"";
    }



    if (m_has_endSnd_attr)
    {
        _outStream << " " << "endSnd" << "=\"" << XSD::XMLBooleanStr(m_endSnd_attr) << "\"";
    }

    _outStream << ">";


    if (m_has_snd)
    {
        m_snd->toXmlElem("a:snd", "", _outStream);
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_Hyperlink& CT_Hyperlink::default_instance()
{
    if (!CT_Hyperlink::default_instance_)
    {
        CT_Hyperlink::default_instance_ = new CT_Hyperlink();
    }
    return *CT_Hyperlink::default_instance_;
}

bool CT_Hyperlink::has_r_id_attr() const
{
    return m_has_r_id_attr;
}

void CT_Hyperlink::set_r_id_attr(const ns_r::ST_RelationshipId& _r_id_attr)
{
    m_has_r_id_attr = true;
    m_r_id_attr = new ns_r::ST_RelationshipId(_r_id_attr);
}

const ns_r::ST_RelationshipId& CT_Hyperlink::get_r_id_attr() const
{
    if (m_r_id_attr)
    {
        return *m_r_id_attr;
    }
    return ns_r::ST_RelationshipId::default_instance();
}

bool CT_Hyperlink::has_invalidUrl_attr() const
{
    return m_has_invalidUrl_attr;
}

void CT_Hyperlink::set_invalidUrl_attr(const XSD::string_& _invalidUrl_attr)
{
    m_has_invalidUrl_attr = true;
    m_invalidUrl_attr = _invalidUrl_attr;
}

const XSD::string_& CT_Hyperlink::get_invalidUrl_attr() const
{
    return m_invalidUrl_attr;
}

bool CT_Hyperlink::has_action_attr() const
{
    return m_has_action_attr;
}

void CT_Hyperlink::set_action_attr(const XSD::string_& _action_attr)
{
    m_has_action_attr = true;
    m_action_attr = _action_attr;
}

const XSD::string_& CT_Hyperlink::get_action_attr() const
{
    return m_action_attr;
}

bool CT_Hyperlink::has_tgtFrame_attr() const
{
    return m_has_tgtFrame_attr;
}

void CT_Hyperlink::set_tgtFrame_attr(const XSD::string_& _tgtFrame_attr)
{
    m_has_tgtFrame_attr = true;
    m_tgtFrame_attr = _tgtFrame_attr;
}

const XSD::string_& CT_Hyperlink::get_tgtFrame_attr() const
{
    return m_tgtFrame_attr;
}

bool CT_Hyperlink::has_tooltip_attr() const
{
    return m_has_tooltip_attr;
}

void CT_Hyperlink::set_tooltip_attr(const XSD::string_& _tooltip_attr)
{
    m_has_tooltip_attr = true;
    m_tooltip_attr = _tooltip_attr;
}

const XSD::string_& CT_Hyperlink::get_tooltip_attr() const
{
    return m_tooltip_attr;
}

bool CT_Hyperlink::has_history_attr() const
{
    return m_has_history_attr;
}

void CT_Hyperlink::set_history_attr(const XSD::boolean_& _history_attr)
{
    m_has_history_attr = true;
    m_history_attr = _history_attr;
}

const XSD::boolean_& CT_Hyperlink::get_history_attr() const
{
    return m_history_attr;
}

bool CT_Hyperlink::has_highlightClick_attr() const
{
    return m_has_highlightClick_attr;
}

void CT_Hyperlink::set_highlightClick_attr(const XSD::boolean_& _highlightClick_attr)
{
    m_has_highlightClick_attr = true;
    m_highlightClick_attr = _highlightClick_attr;
}

const XSD::boolean_& CT_Hyperlink::get_highlightClick_attr() const
{
    return m_highlightClick_attr;
}

bool CT_Hyperlink::has_endSnd_attr() const
{
    return m_has_endSnd_attr;
}

void CT_Hyperlink::set_endSnd_attr(const XSD::boolean_& _endSnd_attr)
{
    m_has_endSnd_attr = true;
    m_endSnd_attr = _endSnd_attr;
}

const XSD::boolean_& CT_Hyperlink::get_endSnd_attr() const
{
    return m_endSnd_attr;
}

CT_Hyperlink* CT_Hyperlink::default_instance_ = NULL;

// CT_ConnectorLocking
CT_ConnectorLocking::CT_ConnectorLocking()
    :m_has_extLst(false),
     m_extLst(NULL),
     m_has_noGrp_attr(false),
     m_noGrp_attr(false),
     m_has_noSelect_attr(false),
     m_noSelect_attr(false),
     m_has_noRot_attr(false),
     m_noRot_attr(false),
     m_has_noChangeAspect_attr(false),
     m_noChangeAspect_attr(false),
     m_has_noMove_attr(false),
     m_noMove_attr(false),
     m_has_noResize_attr(false),
     m_noResize_attr(false),
     m_has_noEditPoints_attr(false),
     m_noEditPoints_attr(false),
     m_has_noAdjustHandles_attr(false),
     m_noAdjustHandles_attr(false),
     m_has_noChangeArrowheads_attr(false),
     m_noChangeArrowheads_attr(false),
     m_has_noChangeShapeType_attr(false),
     m_noChangeShapeType_attr(false)
{
}
CT_ConnectorLocking::~CT_ConnectorLocking()
{
    clear();
}
bool CT_ConnectorLocking::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_ConnectorLocking::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_ConnectorLocking::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_ConnectorLocking::clear()
{
    m_has_noGrp_attr = false;
    m_noGrp_attr = false;

    m_has_noSelect_attr = false;
    m_noSelect_attr = false;

    m_has_noRot_attr = false;
    m_noRot_attr = false;

    m_has_noChangeAspect_attr = false;
    m_noChangeAspect_attr = false;

    m_has_noMove_attr = false;
    m_noMove_attr = false;

    m_has_noResize_attr = false;
    m_noResize_attr = false;

    m_has_noEditPoints_attr = false;
    m_noEditPoints_attr = false;

    m_has_noAdjustHandles_attr = false;
    m_noAdjustHandles_attr = false;

    m_has_noChangeArrowheads_attr = false;
    m_noChangeArrowheads_attr = false;

    m_has_noChangeShapeType_attr = false;
    m_noChangeShapeType_attr = false;

    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_ConnectorLocking::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_noGrp_attr)
    {
        _outStream << " " << "noGrp" << "=\"" << XSD::XMLBooleanStr(m_noGrp_attr) << "\"";
    }



    if (m_has_noSelect_attr)
    {
        _outStream << " " << "noSelect" << "=\"" << XSD::XMLBooleanStr(m_noSelect_attr) << "\"";
    }



    if (m_has_noRot_attr)
    {
        _outStream << " " << "noRot" << "=\"" << XSD::XMLBooleanStr(m_noRot_attr) << "\"";
    }



    if (m_has_noChangeAspect_attr)
    {
        _outStream << " " << "noChangeAspect" << "=\"" << XSD::XMLBooleanStr(m_noChangeAspect_attr) << "\"";
    }



    if (m_has_noMove_attr)
    {
        _outStream << " " << "noMove" << "=\"" << XSD::XMLBooleanStr(m_noMove_attr) << "\"";
    }



    if (m_has_noResize_attr)
    {
        _outStream << " " << "noResize" << "=\"" << XSD::XMLBooleanStr(m_noResize_attr) << "\"";
    }



    if (m_has_noEditPoints_attr)
    {
        _outStream << " " << "noEditPoints" << "=\"" << XSD::XMLBooleanStr(m_noEditPoints_attr) << "\"";
    }



    if (m_has_noAdjustHandles_attr)
    {
        _outStream << " " << "noAdjustHandles" << "=\"" << XSD::XMLBooleanStr(m_noAdjustHandles_attr) << "\"";
    }



    if (m_has_noChangeArrowheads_attr)
    {
        _outStream << " " << "noChangeArrowheads" << "=\"" << XSD::XMLBooleanStr(m_noChangeArrowheads_attr) << "\"";
    }



    if (m_has_noChangeShapeType_attr)
    {
        _outStream << " " << "noChangeShapeType" << "=\"" << XSD::XMLBooleanStr(m_noChangeShapeType_attr) << "\"";
    }

    _outStream << ">";


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_ConnectorLocking& CT_ConnectorLocking::default_instance()
{
    if (!CT_ConnectorLocking::default_instance_)
    {
        CT_ConnectorLocking::default_instance_ = new CT_ConnectorLocking();
    }
    return *CT_ConnectorLocking::default_instance_;
}

bool CT_ConnectorLocking::has_noGrp_attr() const
{
    return m_has_noGrp_attr;
}

void CT_ConnectorLocking::set_noGrp_attr(const XSD::boolean_& _noGrp_attr)
{
    m_has_noGrp_attr = true;
    m_noGrp_attr = _noGrp_attr;
}

const XSD::boolean_& CT_ConnectorLocking::get_noGrp_attr() const
{
    return m_noGrp_attr;
}

bool CT_ConnectorLocking::has_noSelect_attr() const
{
    return m_has_noSelect_attr;
}

void CT_ConnectorLocking::set_noSelect_attr(const XSD::boolean_& _noSelect_attr)
{
    m_has_noSelect_attr = true;
    m_noSelect_attr = _noSelect_attr;
}

const XSD::boolean_& CT_ConnectorLocking::get_noSelect_attr() const
{
    return m_noSelect_attr;
}

bool CT_ConnectorLocking::has_noRot_attr() const
{
    return m_has_noRot_attr;
}

void CT_ConnectorLocking::set_noRot_attr(const XSD::boolean_& _noRot_attr)
{
    m_has_noRot_attr = true;
    m_noRot_attr = _noRot_attr;
}

const XSD::boolean_& CT_ConnectorLocking::get_noRot_attr() const
{
    return m_noRot_attr;
}

bool CT_ConnectorLocking::has_noChangeAspect_attr() const
{
    return m_has_noChangeAspect_attr;
}

void CT_ConnectorLocking::set_noChangeAspect_attr(const XSD::boolean_& _noChangeAspect_attr)
{
    m_has_noChangeAspect_attr = true;
    m_noChangeAspect_attr = _noChangeAspect_attr;
}

const XSD::boolean_& CT_ConnectorLocking::get_noChangeAspect_attr() const
{
    return m_noChangeAspect_attr;
}

bool CT_ConnectorLocking::has_noMove_attr() const
{
    return m_has_noMove_attr;
}

void CT_ConnectorLocking::set_noMove_attr(const XSD::boolean_& _noMove_attr)
{
    m_has_noMove_attr = true;
    m_noMove_attr = _noMove_attr;
}

const XSD::boolean_& CT_ConnectorLocking::get_noMove_attr() const
{
    return m_noMove_attr;
}

bool CT_ConnectorLocking::has_noResize_attr() const
{
    return m_has_noResize_attr;
}

void CT_ConnectorLocking::set_noResize_attr(const XSD::boolean_& _noResize_attr)
{
    m_has_noResize_attr = true;
    m_noResize_attr = _noResize_attr;
}

const XSD::boolean_& CT_ConnectorLocking::get_noResize_attr() const
{
    return m_noResize_attr;
}

bool CT_ConnectorLocking::has_noEditPoints_attr() const
{
    return m_has_noEditPoints_attr;
}

void CT_ConnectorLocking::set_noEditPoints_attr(const XSD::boolean_& _noEditPoints_attr)
{
    m_has_noEditPoints_attr = true;
    m_noEditPoints_attr = _noEditPoints_attr;
}

const XSD::boolean_& CT_ConnectorLocking::get_noEditPoints_attr() const
{
    return m_noEditPoints_attr;
}

bool CT_ConnectorLocking::has_noAdjustHandles_attr() const
{
    return m_has_noAdjustHandles_attr;
}

void CT_ConnectorLocking::set_noAdjustHandles_attr(const XSD::boolean_& _noAdjustHandles_attr)
{
    m_has_noAdjustHandles_attr = true;
    m_noAdjustHandles_attr = _noAdjustHandles_attr;
}

const XSD::boolean_& CT_ConnectorLocking::get_noAdjustHandles_attr() const
{
    return m_noAdjustHandles_attr;
}

bool CT_ConnectorLocking::has_noChangeArrowheads_attr() const
{
    return m_has_noChangeArrowheads_attr;
}

void CT_ConnectorLocking::set_noChangeArrowheads_attr(const XSD::boolean_& _noChangeArrowheads_attr)
{
    m_has_noChangeArrowheads_attr = true;
    m_noChangeArrowheads_attr = _noChangeArrowheads_attr;
}

const XSD::boolean_& CT_ConnectorLocking::get_noChangeArrowheads_attr() const
{
    return m_noChangeArrowheads_attr;
}

bool CT_ConnectorLocking::has_noChangeShapeType_attr() const
{
    return m_has_noChangeShapeType_attr;
}

void CT_ConnectorLocking::set_noChangeShapeType_attr(const XSD::boolean_& _noChangeShapeType_attr)
{
    m_has_noChangeShapeType_attr = true;
    m_noChangeShapeType_attr = _noChangeShapeType_attr;
}

const XSD::boolean_& CT_ConnectorLocking::get_noChangeShapeType_attr() const
{
    return m_noChangeShapeType_attr;
}

CT_ConnectorLocking* CT_ConnectorLocking::default_instance_ = NULL;

// CT_ShapeLocking
CT_ShapeLocking::CT_ShapeLocking()
    :m_has_extLst(false),
     m_extLst(NULL),
     m_has_noGrp_attr(false),
     m_noGrp_attr(false),
     m_has_noSelect_attr(false),
     m_noSelect_attr(false),
     m_has_noRot_attr(false),
     m_noRot_attr(false),
     m_has_noChangeAspect_attr(false),
     m_noChangeAspect_attr(false),
     m_has_noMove_attr(false),
     m_noMove_attr(false),
     m_has_noResize_attr(false),
     m_noResize_attr(false),
     m_has_noEditPoints_attr(false),
     m_noEditPoints_attr(false),
     m_has_noAdjustHandles_attr(false),
     m_noAdjustHandles_attr(false),
     m_has_noChangeArrowheads_attr(false),
     m_noChangeArrowheads_attr(false),
     m_has_noChangeShapeType_attr(false),
     m_noChangeShapeType_attr(false),
     m_has_noTextEdit_attr(false),
     m_noTextEdit_attr(false)
{
}
CT_ShapeLocking::~CT_ShapeLocking()
{
    clear();
}
bool CT_ShapeLocking::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_ShapeLocking::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_ShapeLocking::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_ShapeLocking::clear()
{
    m_has_noGrp_attr = false;
    m_noGrp_attr = false;

    m_has_noSelect_attr = false;
    m_noSelect_attr = false;

    m_has_noRot_attr = false;
    m_noRot_attr = false;

    m_has_noChangeAspect_attr = false;
    m_noChangeAspect_attr = false;

    m_has_noMove_attr = false;
    m_noMove_attr = false;

    m_has_noResize_attr = false;
    m_noResize_attr = false;

    m_has_noEditPoints_attr = false;
    m_noEditPoints_attr = false;

    m_has_noAdjustHandles_attr = false;
    m_noAdjustHandles_attr = false;

    m_has_noChangeArrowheads_attr = false;
    m_noChangeArrowheads_attr = false;

    m_has_noChangeShapeType_attr = false;
    m_noChangeShapeType_attr = false;

    m_has_noTextEdit_attr = false;
    m_noTextEdit_attr = false;

    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_ShapeLocking::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_noGrp_attr)
    {
        _outStream << " " << "noGrp" << "=\"" << XSD::XMLBooleanStr(m_noGrp_attr) << "\"";
    }



    if (m_has_noSelect_attr)
    {
        _outStream << " " << "noSelect" << "=\"" << XSD::XMLBooleanStr(m_noSelect_attr) << "\"";
    }



    if (m_has_noRot_attr)
    {
        _outStream << " " << "noRot" << "=\"" << XSD::XMLBooleanStr(m_noRot_attr) << "\"";
    }



    if (m_has_noChangeAspect_attr)
    {
        _outStream << " " << "noChangeAspect" << "=\"" << XSD::XMLBooleanStr(m_noChangeAspect_attr) << "\"";
    }



    if (m_has_noMove_attr)
    {
        _outStream << " " << "noMove" << "=\"" << XSD::XMLBooleanStr(m_noMove_attr) << "\"";
    }



    if (m_has_noResize_attr)
    {
        _outStream << " " << "noResize" << "=\"" << XSD::XMLBooleanStr(m_noResize_attr) << "\"";
    }



    if (m_has_noEditPoints_attr)
    {
        _outStream << " " << "noEditPoints" << "=\"" << XSD::XMLBooleanStr(m_noEditPoints_attr) << "\"";
    }



    if (m_has_noAdjustHandles_attr)
    {
        _outStream << " " << "noAdjustHandles" << "=\"" << XSD::XMLBooleanStr(m_noAdjustHandles_attr) << "\"";
    }



    if (m_has_noChangeArrowheads_attr)
    {
        _outStream << " " << "noChangeArrowheads" << "=\"" << XSD::XMLBooleanStr(m_noChangeArrowheads_attr) << "\"";
    }



    if (m_has_noChangeShapeType_attr)
    {
        _outStream << " " << "noChangeShapeType" << "=\"" << XSD::XMLBooleanStr(m_noChangeShapeType_attr) << "\"";
    }



    if (m_has_noTextEdit_attr)
    {
        _outStream << " " << "noTextEdit" << "=\"" << XSD::XMLBooleanStr(m_noTextEdit_attr) << "\"";
    }

    _outStream << ">";


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_ShapeLocking& CT_ShapeLocking::default_instance()
{
    if (!CT_ShapeLocking::default_instance_)
    {
        CT_ShapeLocking::default_instance_ = new CT_ShapeLocking();
    }
    return *CT_ShapeLocking::default_instance_;
}

bool CT_ShapeLocking::has_noGrp_attr() const
{
    return m_has_noGrp_attr;
}

void CT_ShapeLocking::set_noGrp_attr(const XSD::boolean_& _noGrp_attr)
{
    m_has_noGrp_attr = true;
    m_noGrp_attr = _noGrp_attr;
}

const XSD::boolean_& CT_ShapeLocking::get_noGrp_attr() const
{
    return m_noGrp_attr;
}

bool CT_ShapeLocking::has_noSelect_attr() const
{
    return m_has_noSelect_attr;
}

void CT_ShapeLocking::set_noSelect_attr(const XSD::boolean_& _noSelect_attr)
{
    m_has_noSelect_attr = true;
    m_noSelect_attr = _noSelect_attr;
}

const XSD::boolean_& CT_ShapeLocking::get_noSelect_attr() const
{
    return m_noSelect_attr;
}

bool CT_ShapeLocking::has_noRot_attr() const
{
    return m_has_noRot_attr;
}

void CT_ShapeLocking::set_noRot_attr(const XSD::boolean_& _noRot_attr)
{
    m_has_noRot_attr = true;
    m_noRot_attr = _noRot_attr;
}

const XSD::boolean_& CT_ShapeLocking::get_noRot_attr() const
{
    return m_noRot_attr;
}

bool CT_ShapeLocking::has_noChangeAspect_attr() const
{
    return m_has_noChangeAspect_attr;
}

void CT_ShapeLocking::set_noChangeAspect_attr(const XSD::boolean_& _noChangeAspect_attr)
{
    m_has_noChangeAspect_attr = true;
    m_noChangeAspect_attr = _noChangeAspect_attr;
}

const XSD::boolean_& CT_ShapeLocking::get_noChangeAspect_attr() const
{
    return m_noChangeAspect_attr;
}

bool CT_ShapeLocking::has_noMove_attr() const
{
    return m_has_noMove_attr;
}

void CT_ShapeLocking::set_noMove_attr(const XSD::boolean_& _noMove_attr)
{
    m_has_noMove_attr = true;
    m_noMove_attr = _noMove_attr;
}

const XSD::boolean_& CT_ShapeLocking::get_noMove_attr() const
{
    return m_noMove_attr;
}

bool CT_ShapeLocking::has_noResize_attr() const
{
    return m_has_noResize_attr;
}

void CT_ShapeLocking::set_noResize_attr(const XSD::boolean_& _noResize_attr)
{
    m_has_noResize_attr = true;
    m_noResize_attr = _noResize_attr;
}

const XSD::boolean_& CT_ShapeLocking::get_noResize_attr() const
{
    return m_noResize_attr;
}

bool CT_ShapeLocking::has_noEditPoints_attr() const
{
    return m_has_noEditPoints_attr;
}

void CT_ShapeLocking::set_noEditPoints_attr(const XSD::boolean_& _noEditPoints_attr)
{
    m_has_noEditPoints_attr = true;
    m_noEditPoints_attr = _noEditPoints_attr;
}

const XSD::boolean_& CT_ShapeLocking::get_noEditPoints_attr() const
{
    return m_noEditPoints_attr;
}

bool CT_ShapeLocking::has_noAdjustHandles_attr() const
{
    return m_has_noAdjustHandles_attr;
}

void CT_ShapeLocking::set_noAdjustHandles_attr(const XSD::boolean_& _noAdjustHandles_attr)
{
    m_has_noAdjustHandles_attr = true;
    m_noAdjustHandles_attr = _noAdjustHandles_attr;
}

const XSD::boolean_& CT_ShapeLocking::get_noAdjustHandles_attr() const
{
    return m_noAdjustHandles_attr;
}

bool CT_ShapeLocking::has_noChangeArrowheads_attr() const
{
    return m_has_noChangeArrowheads_attr;
}

void CT_ShapeLocking::set_noChangeArrowheads_attr(const XSD::boolean_& _noChangeArrowheads_attr)
{
    m_has_noChangeArrowheads_attr = true;
    m_noChangeArrowheads_attr = _noChangeArrowheads_attr;
}

const XSD::boolean_& CT_ShapeLocking::get_noChangeArrowheads_attr() const
{
    return m_noChangeArrowheads_attr;
}

bool CT_ShapeLocking::has_noChangeShapeType_attr() const
{
    return m_has_noChangeShapeType_attr;
}

void CT_ShapeLocking::set_noChangeShapeType_attr(const XSD::boolean_& _noChangeShapeType_attr)
{
    m_has_noChangeShapeType_attr = true;
    m_noChangeShapeType_attr = _noChangeShapeType_attr;
}

const XSD::boolean_& CT_ShapeLocking::get_noChangeShapeType_attr() const
{
    return m_noChangeShapeType_attr;
}

bool CT_ShapeLocking::has_noTextEdit_attr() const
{
    return m_has_noTextEdit_attr;
}

void CT_ShapeLocking::set_noTextEdit_attr(const XSD::boolean_& _noTextEdit_attr)
{
    m_has_noTextEdit_attr = true;
    m_noTextEdit_attr = _noTextEdit_attr;
}

const XSD::boolean_& CT_ShapeLocking::get_noTextEdit_attr() const
{
    return m_noTextEdit_attr;
}

CT_ShapeLocking* CT_ShapeLocking::default_instance_ = NULL;

// CT_PictureLocking
CT_PictureLocking::CT_PictureLocking()
    :m_has_extLst(false),
     m_extLst(NULL),
     m_has_noGrp_attr(false),
     m_noGrp_attr(false),
     m_has_noSelect_attr(false),
     m_noSelect_attr(false),
     m_has_noRot_attr(false),
     m_noRot_attr(false),
     m_has_noChangeAspect_attr(false),
     m_noChangeAspect_attr(false),
     m_has_noMove_attr(false),
     m_noMove_attr(false),
     m_has_noResize_attr(false),
     m_noResize_attr(false),
     m_has_noEditPoints_attr(false),
     m_noEditPoints_attr(false),
     m_has_noAdjustHandles_attr(false),
     m_noAdjustHandles_attr(false),
     m_has_noChangeArrowheads_attr(false),
     m_noChangeArrowheads_attr(false),
     m_has_noChangeShapeType_attr(false),
     m_noChangeShapeType_attr(false),
     m_has_noCrop_attr(false),
     m_noCrop_attr(false)
{
}
CT_PictureLocking::~CT_PictureLocking()
{
    clear();
}
bool CT_PictureLocking::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_PictureLocking::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_PictureLocking::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_PictureLocking::clear()
{
    m_has_noGrp_attr = false;
    m_noGrp_attr = false;

    m_has_noSelect_attr = false;
    m_noSelect_attr = false;

    m_has_noRot_attr = false;
    m_noRot_attr = false;

    m_has_noChangeAspect_attr = false;
    m_noChangeAspect_attr = false;

    m_has_noMove_attr = false;
    m_noMove_attr = false;

    m_has_noResize_attr = false;
    m_noResize_attr = false;

    m_has_noEditPoints_attr = false;
    m_noEditPoints_attr = false;

    m_has_noAdjustHandles_attr = false;
    m_noAdjustHandles_attr = false;

    m_has_noChangeArrowheads_attr = false;
    m_noChangeArrowheads_attr = false;

    m_has_noChangeShapeType_attr = false;
    m_noChangeShapeType_attr = false;

    m_has_noCrop_attr = false;
    m_noCrop_attr = false;

    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_PictureLocking::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_noGrp_attr)
    {
        _outStream << " " << "noGrp" << "=\"" << XSD::XMLBooleanStr(m_noGrp_attr) << "\"";
    }



    if (m_has_noSelect_attr)
    {
        _outStream << " " << "noSelect" << "=\"" << XSD::XMLBooleanStr(m_noSelect_attr) << "\"";
    }



    if (m_has_noRot_attr)
    {
        _outStream << " " << "noRot" << "=\"" << XSD::XMLBooleanStr(m_noRot_attr) << "\"";
    }



    if (m_has_noChangeAspect_attr)
    {
        _outStream << " " << "noChangeAspect" << "=\"" << XSD::XMLBooleanStr(m_noChangeAspect_attr) << "\"";
    }



    if (m_has_noMove_attr)
    {
        _outStream << " " << "noMove" << "=\"" << XSD::XMLBooleanStr(m_noMove_attr) << "\"";
    }



    if (m_has_noResize_attr)
    {
        _outStream << " " << "noResize" << "=\"" << XSD::XMLBooleanStr(m_noResize_attr) << "\"";
    }



    if (m_has_noEditPoints_attr)
    {
        _outStream << " " << "noEditPoints" << "=\"" << XSD::XMLBooleanStr(m_noEditPoints_attr) << "\"";
    }



    if (m_has_noAdjustHandles_attr)
    {
        _outStream << " " << "noAdjustHandles" << "=\"" << XSD::XMLBooleanStr(m_noAdjustHandles_attr) << "\"";
    }



    if (m_has_noChangeArrowheads_attr)
    {
        _outStream << " " << "noChangeArrowheads" << "=\"" << XSD::XMLBooleanStr(m_noChangeArrowheads_attr) << "\"";
    }



    if (m_has_noChangeShapeType_attr)
    {
        _outStream << " " << "noChangeShapeType" << "=\"" << XSD::XMLBooleanStr(m_noChangeShapeType_attr) << "\"";
    }



    if (m_has_noCrop_attr)
    {
        _outStream << " " << "noCrop" << "=\"" << XSD::XMLBooleanStr(m_noCrop_attr) << "\"";
    }

    _outStream << ">";


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_PictureLocking& CT_PictureLocking::default_instance()
{
    if (!CT_PictureLocking::default_instance_)
    {
        CT_PictureLocking::default_instance_ = new CT_PictureLocking();
    }
    return *CT_PictureLocking::default_instance_;
}

bool CT_PictureLocking::has_noGrp_attr() const
{
    return m_has_noGrp_attr;
}

void CT_PictureLocking::set_noGrp_attr(const XSD::boolean_& _noGrp_attr)
{
    m_has_noGrp_attr = true;
    m_noGrp_attr = _noGrp_attr;
}

const XSD::boolean_& CT_PictureLocking::get_noGrp_attr() const
{
    return m_noGrp_attr;
}

bool CT_PictureLocking::has_noSelect_attr() const
{
    return m_has_noSelect_attr;
}

void CT_PictureLocking::set_noSelect_attr(const XSD::boolean_& _noSelect_attr)
{
    m_has_noSelect_attr = true;
    m_noSelect_attr = _noSelect_attr;
}

const XSD::boolean_& CT_PictureLocking::get_noSelect_attr() const
{
    return m_noSelect_attr;
}

bool CT_PictureLocking::has_noRot_attr() const
{
    return m_has_noRot_attr;
}

void CT_PictureLocking::set_noRot_attr(const XSD::boolean_& _noRot_attr)
{
    m_has_noRot_attr = true;
    m_noRot_attr = _noRot_attr;
}

const XSD::boolean_& CT_PictureLocking::get_noRot_attr() const
{
    return m_noRot_attr;
}

bool CT_PictureLocking::has_noChangeAspect_attr() const
{
    return m_has_noChangeAspect_attr;
}

void CT_PictureLocking::set_noChangeAspect_attr(const XSD::boolean_& _noChangeAspect_attr)
{
    m_has_noChangeAspect_attr = true;
    m_noChangeAspect_attr = _noChangeAspect_attr;
}

const XSD::boolean_& CT_PictureLocking::get_noChangeAspect_attr() const
{
    return m_noChangeAspect_attr;
}

bool CT_PictureLocking::has_noMove_attr() const
{
    return m_has_noMove_attr;
}

void CT_PictureLocking::set_noMove_attr(const XSD::boolean_& _noMove_attr)
{
    m_has_noMove_attr = true;
    m_noMove_attr = _noMove_attr;
}

const XSD::boolean_& CT_PictureLocking::get_noMove_attr() const
{
    return m_noMove_attr;
}

bool CT_PictureLocking::has_noResize_attr() const
{
    return m_has_noResize_attr;
}

void CT_PictureLocking::set_noResize_attr(const XSD::boolean_& _noResize_attr)
{
    m_has_noResize_attr = true;
    m_noResize_attr = _noResize_attr;
}

const XSD::boolean_& CT_PictureLocking::get_noResize_attr() const
{
    return m_noResize_attr;
}

bool CT_PictureLocking::has_noEditPoints_attr() const
{
    return m_has_noEditPoints_attr;
}

void CT_PictureLocking::set_noEditPoints_attr(const XSD::boolean_& _noEditPoints_attr)
{
    m_has_noEditPoints_attr = true;
    m_noEditPoints_attr = _noEditPoints_attr;
}

const XSD::boolean_& CT_PictureLocking::get_noEditPoints_attr() const
{
    return m_noEditPoints_attr;
}

bool CT_PictureLocking::has_noAdjustHandles_attr() const
{
    return m_has_noAdjustHandles_attr;
}

void CT_PictureLocking::set_noAdjustHandles_attr(const XSD::boolean_& _noAdjustHandles_attr)
{
    m_has_noAdjustHandles_attr = true;
    m_noAdjustHandles_attr = _noAdjustHandles_attr;
}

const XSD::boolean_& CT_PictureLocking::get_noAdjustHandles_attr() const
{
    return m_noAdjustHandles_attr;
}

bool CT_PictureLocking::has_noChangeArrowheads_attr() const
{
    return m_has_noChangeArrowheads_attr;
}

void CT_PictureLocking::set_noChangeArrowheads_attr(const XSD::boolean_& _noChangeArrowheads_attr)
{
    m_has_noChangeArrowheads_attr = true;
    m_noChangeArrowheads_attr = _noChangeArrowheads_attr;
}

const XSD::boolean_& CT_PictureLocking::get_noChangeArrowheads_attr() const
{
    return m_noChangeArrowheads_attr;
}

bool CT_PictureLocking::has_noChangeShapeType_attr() const
{
    return m_has_noChangeShapeType_attr;
}

void CT_PictureLocking::set_noChangeShapeType_attr(const XSD::boolean_& _noChangeShapeType_attr)
{
    m_has_noChangeShapeType_attr = true;
    m_noChangeShapeType_attr = _noChangeShapeType_attr;
}

const XSD::boolean_& CT_PictureLocking::get_noChangeShapeType_attr() const
{
    return m_noChangeShapeType_attr;
}

bool CT_PictureLocking::has_noCrop_attr() const
{
    return m_has_noCrop_attr;
}

void CT_PictureLocking::set_noCrop_attr(const XSD::boolean_& _noCrop_attr)
{
    m_has_noCrop_attr = true;
    m_noCrop_attr = _noCrop_attr;
}

const XSD::boolean_& CT_PictureLocking::get_noCrop_attr() const
{
    return m_noCrop_attr;
}

CT_PictureLocking* CT_PictureLocking::default_instance_ = NULL;

// CT_GroupLocking
CT_GroupLocking::CT_GroupLocking()
    :m_has_extLst(false),
     m_extLst(NULL),
     m_has_noGrp_attr(false),
     m_noGrp_attr(false),
     m_has_noUngrp_attr(false),
     m_noUngrp_attr(false),
     m_has_noSelect_attr(false),
     m_noSelect_attr(false),
     m_has_noRot_attr(false),
     m_noRot_attr(false),
     m_has_noChangeAspect_attr(false),
     m_noChangeAspect_attr(false),
     m_has_noMove_attr(false),
     m_noMove_attr(false),
     m_has_noResize_attr(false),
     m_noResize_attr(false)
{
}
CT_GroupLocking::~CT_GroupLocking()
{
    clear();
}
bool CT_GroupLocking::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_GroupLocking::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_GroupLocking::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_GroupLocking::clear()
{
    m_has_noGrp_attr = false;
    m_noGrp_attr = false;

    m_has_noUngrp_attr = false;
    m_noUngrp_attr = false;

    m_has_noSelect_attr = false;
    m_noSelect_attr = false;

    m_has_noRot_attr = false;
    m_noRot_attr = false;

    m_has_noChangeAspect_attr = false;
    m_noChangeAspect_attr = false;

    m_has_noMove_attr = false;
    m_noMove_attr = false;

    m_has_noResize_attr = false;
    m_noResize_attr = false;

    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_GroupLocking::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_noGrp_attr)
    {
        _outStream << " " << "noGrp" << "=\"" << XSD::XMLBooleanStr(m_noGrp_attr) << "\"";
    }



    if (m_has_noUngrp_attr)
    {
        _outStream << " " << "noUngrp" << "=\"" << XSD::XMLBooleanStr(m_noUngrp_attr) << "\"";
    }



    if (m_has_noSelect_attr)
    {
        _outStream << " " << "noSelect" << "=\"" << XSD::XMLBooleanStr(m_noSelect_attr) << "\"";
    }



    if (m_has_noRot_attr)
    {
        _outStream << " " << "noRot" << "=\"" << XSD::XMLBooleanStr(m_noRot_attr) << "\"";
    }



    if (m_has_noChangeAspect_attr)
    {
        _outStream << " " << "noChangeAspect" << "=\"" << XSD::XMLBooleanStr(m_noChangeAspect_attr) << "\"";
    }



    if (m_has_noMove_attr)
    {
        _outStream << " " << "noMove" << "=\"" << XSD::XMLBooleanStr(m_noMove_attr) << "\"";
    }



    if (m_has_noResize_attr)
    {
        _outStream << " " << "noResize" << "=\"" << XSD::XMLBooleanStr(m_noResize_attr) << "\"";
    }

    _outStream << ">";


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_GroupLocking& CT_GroupLocking::default_instance()
{
    if (!CT_GroupLocking::default_instance_)
    {
        CT_GroupLocking::default_instance_ = new CT_GroupLocking();
    }
    return *CT_GroupLocking::default_instance_;
}

bool CT_GroupLocking::has_noGrp_attr() const
{
    return m_has_noGrp_attr;
}

void CT_GroupLocking::set_noGrp_attr(const XSD::boolean_& _noGrp_attr)
{
    m_has_noGrp_attr = true;
    m_noGrp_attr = _noGrp_attr;
}

const XSD::boolean_& CT_GroupLocking::get_noGrp_attr() const
{
    return m_noGrp_attr;
}

bool CT_GroupLocking::has_noUngrp_attr() const
{
    return m_has_noUngrp_attr;
}

void CT_GroupLocking::set_noUngrp_attr(const XSD::boolean_& _noUngrp_attr)
{
    m_has_noUngrp_attr = true;
    m_noUngrp_attr = _noUngrp_attr;
}

const XSD::boolean_& CT_GroupLocking::get_noUngrp_attr() const
{
    return m_noUngrp_attr;
}

bool CT_GroupLocking::has_noSelect_attr() const
{
    return m_has_noSelect_attr;
}

void CT_GroupLocking::set_noSelect_attr(const XSD::boolean_& _noSelect_attr)
{
    m_has_noSelect_attr = true;
    m_noSelect_attr = _noSelect_attr;
}

const XSD::boolean_& CT_GroupLocking::get_noSelect_attr() const
{
    return m_noSelect_attr;
}

bool CT_GroupLocking::has_noRot_attr() const
{
    return m_has_noRot_attr;
}

void CT_GroupLocking::set_noRot_attr(const XSD::boolean_& _noRot_attr)
{
    m_has_noRot_attr = true;
    m_noRot_attr = _noRot_attr;
}

const XSD::boolean_& CT_GroupLocking::get_noRot_attr() const
{
    return m_noRot_attr;
}

bool CT_GroupLocking::has_noChangeAspect_attr() const
{
    return m_has_noChangeAspect_attr;
}

void CT_GroupLocking::set_noChangeAspect_attr(const XSD::boolean_& _noChangeAspect_attr)
{
    m_has_noChangeAspect_attr = true;
    m_noChangeAspect_attr = _noChangeAspect_attr;
}

const XSD::boolean_& CT_GroupLocking::get_noChangeAspect_attr() const
{
    return m_noChangeAspect_attr;
}

bool CT_GroupLocking::has_noMove_attr() const
{
    return m_has_noMove_attr;
}

void CT_GroupLocking::set_noMove_attr(const XSD::boolean_& _noMove_attr)
{
    m_has_noMove_attr = true;
    m_noMove_attr = _noMove_attr;
}

const XSD::boolean_& CT_GroupLocking::get_noMove_attr() const
{
    return m_noMove_attr;
}

bool CT_GroupLocking::has_noResize_attr() const
{
    return m_has_noResize_attr;
}

void CT_GroupLocking::set_noResize_attr(const XSD::boolean_& _noResize_attr)
{
    m_has_noResize_attr = true;
    m_noResize_attr = _noResize_attr;
}

const XSD::boolean_& CT_GroupLocking::get_noResize_attr() const
{
    return m_noResize_attr;
}

CT_GroupLocking* CT_GroupLocking::default_instance_ = NULL;

// CT_GraphicalObjectFrameLocking
CT_GraphicalObjectFrameLocking::CT_GraphicalObjectFrameLocking()
    :m_has_extLst(false),
     m_extLst(NULL),
     m_has_noGrp_attr(false),
     m_noGrp_attr(false),
     m_has_noDrilldown_attr(false),
     m_noDrilldown_attr(false),
     m_has_noSelect_attr(false),
     m_noSelect_attr(false),
     m_has_noChangeAspect_attr(false),
     m_noChangeAspect_attr(false),
     m_has_noMove_attr(false),
     m_noMove_attr(false),
     m_has_noResize_attr(false),
     m_noResize_attr(false)
{
}
CT_GraphicalObjectFrameLocking::~CT_GraphicalObjectFrameLocking()
{
    clear();
}
bool CT_GraphicalObjectFrameLocking::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_GraphicalObjectFrameLocking::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_GraphicalObjectFrameLocking::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_GraphicalObjectFrameLocking::clear()
{
    m_has_noGrp_attr = false;
    m_noGrp_attr = false;

    m_has_noDrilldown_attr = false;
    m_noDrilldown_attr = false;

    m_has_noSelect_attr = false;
    m_noSelect_attr = false;

    m_has_noChangeAspect_attr = false;
    m_noChangeAspect_attr = false;

    m_has_noMove_attr = false;
    m_noMove_attr = false;

    m_has_noResize_attr = false;
    m_noResize_attr = false;

    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_GraphicalObjectFrameLocking::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_noGrp_attr)
    {
        _outStream << " " << "noGrp" << "=\"" << XSD::XMLBooleanStr(m_noGrp_attr) << "\"";
    }



    if (m_has_noDrilldown_attr)
    {
        _outStream << " " << "noDrilldown" << "=\"" << XSD::XMLBooleanStr(m_noDrilldown_attr) << "\"";
    }



    if (m_has_noSelect_attr)
    {
        _outStream << " " << "noSelect" << "=\"" << XSD::XMLBooleanStr(m_noSelect_attr) << "\"";
    }



    if (m_has_noChangeAspect_attr)
    {
        _outStream << " " << "noChangeAspect" << "=\"" << XSD::XMLBooleanStr(m_noChangeAspect_attr) << "\"";
    }



    if (m_has_noMove_attr)
    {
        _outStream << " " << "noMove" << "=\"" << XSD::XMLBooleanStr(m_noMove_attr) << "\"";
    }



    if (m_has_noResize_attr)
    {
        _outStream << " " << "noResize" << "=\"" << XSD::XMLBooleanStr(m_noResize_attr) << "\"";
    }

    _outStream << ">";


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_GraphicalObjectFrameLocking& CT_GraphicalObjectFrameLocking::default_instance()
{
    if (!CT_GraphicalObjectFrameLocking::default_instance_)
    {
        CT_GraphicalObjectFrameLocking::default_instance_ = new CT_GraphicalObjectFrameLocking();
    }
    return *CT_GraphicalObjectFrameLocking::default_instance_;
}

bool CT_GraphicalObjectFrameLocking::has_noGrp_attr() const
{
    return m_has_noGrp_attr;
}

void CT_GraphicalObjectFrameLocking::set_noGrp_attr(const XSD::boolean_& _noGrp_attr)
{
    m_has_noGrp_attr = true;
    m_noGrp_attr = _noGrp_attr;
}

const XSD::boolean_& CT_GraphicalObjectFrameLocking::get_noGrp_attr() const
{
    return m_noGrp_attr;
}

bool CT_GraphicalObjectFrameLocking::has_noDrilldown_attr() const
{
    return m_has_noDrilldown_attr;
}

void CT_GraphicalObjectFrameLocking::set_noDrilldown_attr(const XSD::boolean_& _noDrilldown_attr)
{
    m_has_noDrilldown_attr = true;
    m_noDrilldown_attr = _noDrilldown_attr;
}

const XSD::boolean_& CT_GraphicalObjectFrameLocking::get_noDrilldown_attr() const
{
    return m_noDrilldown_attr;
}

bool CT_GraphicalObjectFrameLocking::has_noSelect_attr() const
{
    return m_has_noSelect_attr;
}

void CT_GraphicalObjectFrameLocking::set_noSelect_attr(const XSD::boolean_& _noSelect_attr)
{
    m_has_noSelect_attr = true;
    m_noSelect_attr = _noSelect_attr;
}

const XSD::boolean_& CT_GraphicalObjectFrameLocking::get_noSelect_attr() const
{
    return m_noSelect_attr;
}

bool CT_GraphicalObjectFrameLocking::has_noChangeAspect_attr() const
{
    return m_has_noChangeAspect_attr;
}

void CT_GraphicalObjectFrameLocking::set_noChangeAspect_attr(const XSD::boolean_& _noChangeAspect_attr)
{
    m_has_noChangeAspect_attr = true;
    m_noChangeAspect_attr = _noChangeAspect_attr;
}

const XSD::boolean_& CT_GraphicalObjectFrameLocking::get_noChangeAspect_attr() const
{
    return m_noChangeAspect_attr;
}

bool CT_GraphicalObjectFrameLocking::has_noMove_attr() const
{
    return m_has_noMove_attr;
}

void CT_GraphicalObjectFrameLocking::set_noMove_attr(const XSD::boolean_& _noMove_attr)
{
    m_has_noMove_attr = true;
    m_noMove_attr = _noMove_attr;
}

const XSD::boolean_& CT_GraphicalObjectFrameLocking::get_noMove_attr() const
{
    return m_noMove_attr;
}

bool CT_GraphicalObjectFrameLocking::has_noResize_attr() const
{
    return m_has_noResize_attr;
}

void CT_GraphicalObjectFrameLocking::set_noResize_attr(const XSD::boolean_& _noResize_attr)
{
    m_has_noResize_attr = true;
    m_noResize_attr = _noResize_attr;
}

const XSD::boolean_& CT_GraphicalObjectFrameLocking::get_noResize_attr() const
{
    return m_noResize_attr;
}

CT_GraphicalObjectFrameLocking* CT_GraphicalObjectFrameLocking::default_instance_ = NULL;

// CT_ContentPartLocking
CT_ContentPartLocking::CT_ContentPartLocking()
    :m_has_extLst(false),
     m_extLst(NULL),
     m_has_noGrp_attr(false),
     m_noGrp_attr(false),
     m_has_noSelect_attr(false),
     m_noSelect_attr(false),
     m_has_noRot_attr(false),
     m_noRot_attr(false),
     m_has_noChangeAspect_attr(false),
     m_noChangeAspect_attr(false),
     m_has_noMove_attr(false),
     m_noMove_attr(false),
     m_has_noResize_attr(false),
     m_noResize_attr(false),
     m_has_noEditPoints_attr(false),
     m_noEditPoints_attr(false),
     m_has_noAdjustHandles_attr(false),
     m_noAdjustHandles_attr(false),
     m_has_noChangeArrowheads_attr(false),
     m_noChangeArrowheads_attr(false),
     m_has_noChangeShapeType_attr(false),
     m_noChangeShapeType_attr(false)
{
}
CT_ContentPartLocking::~CT_ContentPartLocking()
{
    clear();
}
bool CT_ContentPartLocking::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_ContentPartLocking::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_ContentPartLocking::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_ContentPartLocking::clear()
{
    m_has_noGrp_attr = false;
    m_noGrp_attr = false;

    m_has_noSelect_attr = false;
    m_noSelect_attr = false;

    m_has_noRot_attr = false;
    m_noRot_attr = false;

    m_has_noChangeAspect_attr = false;
    m_noChangeAspect_attr = false;

    m_has_noMove_attr = false;
    m_noMove_attr = false;

    m_has_noResize_attr = false;
    m_noResize_attr = false;

    m_has_noEditPoints_attr = false;
    m_noEditPoints_attr = false;

    m_has_noAdjustHandles_attr = false;
    m_noAdjustHandles_attr = false;

    m_has_noChangeArrowheads_attr = false;
    m_noChangeArrowheads_attr = false;

    m_has_noChangeShapeType_attr = false;
    m_noChangeShapeType_attr = false;

    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_ContentPartLocking::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_noGrp_attr)
    {
        _outStream << " " << "noGrp" << "=\"" << XSD::XMLBooleanStr(m_noGrp_attr) << "\"";
    }



    if (m_has_noSelect_attr)
    {
        _outStream << " " << "noSelect" << "=\"" << XSD::XMLBooleanStr(m_noSelect_attr) << "\"";
    }



    if (m_has_noRot_attr)
    {
        _outStream << " " << "noRot" << "=\"" << XSD::XMLBooleanStr(m_noRot_attr) << "\"";
    }



    if (m_has_noChangeAspect_attr)
    {
        _outStream << " " << "noChangeAspect" << "=\"" << XSD::XMLBooleanStr(m_noChangeAspect_attr) << "\"";
    }



    if (m_has_noMove_attr)
    {
        _outStream << " " << "noMove" << "=\"" << XSD::XMLBooleanStr(m_noMove_attr) << "\"";
    }



    if (m_has_noResize_attr)
    {
        _outStream << " " << "noResize" << "=\"" << XSD::XMLBooleanStr(m_noResize_attr) << "\"";
    }



    if (m_has_noEditPoints_attr)
    {
        _outStream << " " << "noEditPoints" << "=\"" << XSD::XMLBooleanStr(m_noEditPoints_attr) << "\"";
    }



    if (m_has_noAdjustHandles_attr)
    {
        _outStream << " " << "noAdjustHandles" << "=\"" << XSD::XMLBooleanStr(m_noAdjustHandles_attr) << "\"";
    }



    if (m_has_noChangeArrowheads_attr)
    {
        _outStream << " " << "noChangeArrowheads" << "=\"" << XSD::XMLBooleanStr(m_noChangeArrowheads_attr) << "\"";
    }



    if (m_has_noChangeShapeType_attr)
    {
        _outStream << " " << "noChangeShapeType" << "=\"" << XSD::XMLBooleanStr(m_noChangeShapeType_attr) << "\"";
    }

    _outStream << ">";


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_ContentPartLocking& CT_ContentPartLocking::default_instance()
{
    if (!CT_ContentPartLocking::default_instance_)
    {
        CT_ContentPartLocking::default_instance_ = new CT_ContentPartLocking();
    }
    return *CT_ContentPartLocking::default_instance_;
}

bool CT_ContentPartLocking::has_noGrp_attr() const
{
    return m_has_noGrp_attr;
}

void CT_ContentPartLocking::set_noGrp_attr(const XSD::boolean_& _noGrp_attr)
{
    m_has_noGrp_attr = true;
    m_noGrp_attr = _noGrp_attr;
}

const XSD::boolean_& CT_ContentPartLocking::get_noGrp_attr() const
{
    return m_noGrp_attr;
}

bool CT_ContentPartLocking::has_noSelect_attr() const
{
    return m_has_noSelect_attr;
}

void CT_ContentPartLocking::set_noSelect_attr(const XSD::boolean_& _noSelect_attr)
{
    m_has_noSelect_attr = true;
    m_noSelect_attr = _noSelect_attr;
}

const XSD::boolean_& CT_ContentPartLocking::get_noSelect_attr() const
{
    return m_noSelect_attr;
}

bool CT_ContentPartLocking::has_noRot_attr() const
{
    return m_has_noRot_attr;
}

void CT_ContentPartLocking::set_noRot_attr(const XSD::boolean_& _noRot_attr)
{
    m_has_noRot_attr = true;
    m_noRot_attr = _noRot_attr;
}

const XSD::boolean_& CT_ContentPartLocking::get_noRot_attr() const
{
    return m_noRot_attr;
}

bool CT_ContentPartLocking::has_noChangeAspect_attr() const
{
    return m_has_noChangeAspect_attr;
}

void CT_ContentPartLocking::set_noChangeAspect_attr(const XSD::boolean_& _noChangeAspect_attr)
{
    m_has_noChangeAspect_attr = true;
    m_noChangeAspect_attr = _noChangeAspect_attr;
}

const XSD::boolean_& CT_ContentPartLocking::get_noChangeAspect_attr() const
{
    return m_noChangeAspect_attr;
}

bool CT_ContentPartLocking::has_noMove_attr() const
{
    return m_has_noMove_attr;
}

void CT_ContentPartLocking::set_noMove_attr(const XSD::boolean_& _noMove_attr)
{
    m_has_noMove_attr = true;
    m_noMove_attr = _noMove_attr;
}

const XSD::boolean_& CT_ContentPartLocking::get_noMove_attr() const
{
    return m_noMove_attr;
}

bool CT_ContentPartLocking::has_noResize_attr() const
{
    return m_has_noResize_attr;
}

void CT_ContentPartLocking::set_noResize_attr(const XSD::boolean_& _noResize_attr)
{
    m_has_noResize_attr = true;
    m_noResize_attr = _noResize_attr;
}

const XSD::boolean_& CT_ContentPartLocking::get_noResize_attr() const
{
    return m_noResize_attr;
}

bool CT_ContentPartLocking::has_noEditPoints_attr() const
{
    return m_has_noEditPoints_attr;
}

void CT_ContentPartLocking::set_noEditPoints_attr(const XSD::boolean_& _noEditPoints_attr)
{
    m_has_noEditPoints_attr = true;
    m_noEditPoints_attr = _noEditPoints_attr;
}

const XSD::boolean_& CT_ContentPartLocking::get_noEditPoints_attr() const
{
    return m_noEditPoints_attr;
}

bool CT_ContentPartLocking::has_noAdjustHandles_attr() const
{
    return m_has_noAdjustHandles_attr;
}

void CT_ContentPartLocking::set_noAdjustHandles_attr(const XSD::boolean_& _noAdjustHandles_attr)
{
    m_has_noAdjustHandles_attr = true;
    m_noAdjustHandles_attr = _noAdjustHandles_attr;
}

const XSD::boolean_& CT_ContentPartLocking::get_noAdjustHandles_attr() const
{
    return m_noAdjustHandles_attr;
}

bool CT_ContentPartLocking::has_noChangeArrowheads_attr() const
{
    return m_has_noChangeArrowheads_attr;
}

void CT_ContentPartLocking::set_noChangeArrowheads_attr(const XSD::boolean_& _noChangeArrowheads_attr)
{
    m_has_noChangeArrowheads_attr = true;
    m_noChangeArrowheads_attr = _noChangeArrowheads_attr;
}

const XSD::boolean_& CT_ContentPartLocking::get_noChangeArrowheads_attr() const
{
    return m_noChangeArrowheads_attr;
}

bool CT_ContentPartLocking::has_noChangeShapeType_attr() const
{
    return m_has_noChangeShapeType_attr;
}

void CT_ContentPartLocking::set_noChangeShapeType_attr(const XSD::boolean_& _noChangeShapeType_attr)
{
    m_has_noChangeShapeType_attr = true;
    m_noChangeShapeType_attr = _noChangeShapeType_attr;
}

const XSD::boolean_& CT_ContentPartLocking::get_noChangeShapeType_attr() const
{
    return m_noChangeShapeType_attr;
}

CT_ContentPartLocking* CT_ContentPartLocking::default_instance_ = NULL;

// CT_NonVisualDrawingProps
CT_NonVisualDrawingProps::CT_NonVisualDrawingProps()
    :m_has_hlinkClick(false),
     m_hlinkClick(NULL),
     m_has_hlinkHover(false),
     m_hlinkHover(NULL),
     m_has_extLst(false),
     m_extLst(NULL),
     m_has_id_attr(false),
     m_id_attr(NULL),
     m_has_name_attr(false),
     m_name_attr(""),
     m_has_descr_attr(false),
     m_descr_attr(""),
     m_has_hidden_attr(false),
     m_hidden_attr(false),
     m_has_title_attr(false),
     m_title_attr("")
{
}
CT_NonVisualDrawingProps::~CT_NonVisualDrawingProps()
{
    clear();
}
bool CT_NonVisualDrawingProps::has_hlinkClick() const
{
    return m_has_hlinkClick;
}

CT_Hyperlink* CT_NonVisualDrawingProps::mutable_hlinkClick()
{
    m_has_hlinkClick = true;
    if (!m_hlinkClick)
    {
        m_hlinkClick = new CT_Hyperlink();
    }
    return m_hlinkClick;
}

const CT_Hyperlink& CT_NonVisualDrawingProps::get_hlinkClick() const
{
    if (m_hlinkClick)
    {
        return *m_hlinkClick;
    }
    return CT_Hyperlink::default_instance();
}

bool CT_NonVisualDrawingProps::has_hlinkHover() const
{
    return m_has_hlinkHover;
}

CT_Hyperlink* CT_NonVisualDrawingProps::mutable_hlinkHover()
{
    m_has_hlinkHover = true;
    if (!m_hlinkHover)
    {
        m_hlinkHover = new CT_Hyperlink();
    }
    return m_hlinkHover;
}

const CT_Hyperlink& CT_NonVisualDrawingProps::get_hlinkHover() const
{
    if (m_hlinkHover)
    {
        return *m_hlinkHover;
    }
    return CT_Hyperlink::default_instance();
}

bool CT_NonVisualDrawingProps::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_NonVisualDrawingProps::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_NonVisualDrawingProps::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_NonVisualDrawingProps::clear()
{
    m_has_id_attr = false;

    if (m_id_attr)
    {
        delete m_id_attr;
        m_id_attr = NULL;
    }


    m_has_name_attr = false;
    m_name_attr.clear();

    m_has_descr_attr = false;
    m_descr_attr.clear();

    m_has_hidden_attr = false;
    m_hidden_attr = false;

    m_has_title_attr = false;
    m_title_attr.clear();

    m_has_hlinkClick = false;

    if (m_hlinkClick)
    {
        delete m_hlinkClick;
        m_hlinkClick = NULL;
    }


    m_has_hlinkHover = false;

    if (m_hlinkHover)
    {
        delete m_hlinkHover;
        m_hlinkHover = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_NonVisualDrawingProps::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_id_attr);
    if (m_has_id_attr)
    {
        m_id_attr->toXmlAttr("id", _outStream);
    }


    assert(m_has_name_attr);
    if (m_has_name_attr)
    {
        _outStream << " " << "name" << "=\"" << m_name_attr << "\"";
    }



    if (m_has_descr_attr)
    {
        _outStream << " " << "descr" << "=\"" << m_descr_attr << "\"";
    }



    if (m_has_hidden_attr)
    {
        _outStream << " " << "hidden" << "=\"" << XSD::XMLBooleanStr(m_hidden_attr) << "\"";
    }



    if (m_has_title_attr)
    {
        _outStream << " " << "title" << "=\"" << m_title_attr << "\"";
    }

    _outStream << ">";


    if (m_has_hlinkClick)
    {
        m_hlinkClick->toXmlElem("a:hlinkClick", "", _outStream);
    }


    if (m_has_hlinkHover)
    {
        m_hlinkHover->toXmlElem("a:hlinkHover", "", _outStream);
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_NonVisualDrawingProps& CT_NonVisualDrawingProps::default_instance()
{
    if (!CT_NonVisualDrawingProps::default_instance_)
    {
        CT_NonVisualDrawingProps::default_instance_ = new CT_NonVisualDrawingProps();
    }
    return *CT_NonVisualDrawingProps::default_instance_;
}

bool CT_NonVisualDrawingProps::has_id_attr() const
{
    return m_has_id_attr;
}

void CT_NonVisualDrawingProps::set_id_attr(const ST_DrawingElementId& _id_attr)
{
    m_has_id_attr = true;
    m_id_attr = new ST_DrawingElementId(_id_attr);
}

const ST_DrawingElementId& CT_NonVisualDrawingProps::get_id_attr() const
{
    if (m_id_attr)
    {
        return *m_id_attr;
    }
    return ST_DrawingElementId::default_instance();
}

bool CT_NonVisualDrawingProps::has_name_attr() const
{
    return m_has_name_attr;
}

void CT_NonVisualDrawingProps::set_name_attr(const XSD::string_& _name_attr)
{
    m_has_name_attr = true;
    m_name_attr = _name_attr;
}

const XSD::string_& CT_NonVisualDrawingProps::get_name_attr() const
{
    return m_name_attr;
}

bool CT_NonVisualDrawingProps::has_descr_attr() const
{
    return m_has_descr_attr;
}

void CT_NonVisualDrawingProps::set_descr_attr(const XSD::string_& _descr_attr)
{
    m_has_descr_attr = true;
    m_descr_attr = _descr_attr;
}

const XSD::string_& CT_NonVisualDrawingProps::get_descr_attr() const
{
    return m_descr_attr;
}

bool CT_NonVisualDrawingProps::has_hidden_attr() const
{
    return m_has_hidden_attr;
}

void CT_NonVisualDrawingProps::set_hidden_attr(const XSD::boolean_& _hidden_attr)
{
    m_has_hidden_attr = true;
    m_hidden_attr = _hidden_attr;
}

const XSD::boolean_& CT_NonVisualDrawingProps::get_hidden_attr() const
{
    return m_hidden_attr;
}

bool CT_NonVisualDrawingProps::has_title_attr() const
{
    return m_has_title_attr;
}

void CT_NonVisualDrawingProps::set_title_attr(const XSD::string_& _title_attr)
{
    m_has_title_attr = true;
    m_title_attr = _title_attr;
}

const XSD::string_& CT_NonVisualDrawingProps::get_title_attr() const
{
    return m_title_attr;
}

CT_NonVisualDrawingProps* CT_NonVisualDrawingProps::default_instance_ = NULL;

// CT_NonVisualDrawingShapeProps
CT_NonVisualDrawingShapeProps::CT_NonVisualDrawingShapeProps()
    :m_has_spLocks(false),
     m_spLocks(NULL),
     m_has_extLst(false),
     m_extLst(NULL),
     m_has_txBox_attr(false),
     m_txBox_attr(false)
{
}
CT_NonVisualDrawingShapeProps::~CT_NonVisualDrawingShapeProps()
{
    clear();
}
bool CT_NonVisualDrawingShapeProps::has_spLocks() const
{
    return m_has_spLocks;
}

CT_ShapeLocking* CT_NonVisualDrawingShapeProps::mutable_spLocks()
{
    m_has_spLocks = true;
    if (!m_spLocks)
    {
        m_spLocks = new CT_ShapeLocking();
    }
    return m_spLocks;
}

const CT_ShapeLocking& CT_NonVisualDrawingShapeProps::get_spLocks() const
{
    if (m_spLocks)
    {
        return *m_spLocks;
    }
    return CT_ShapeLocking::default_instance();
}

bool CT_NonVisualDrawingShapeProps::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_NonVisualDrawingShapeProps::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_NonVisualDrawingShapeProps::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_NonVisualDrawingShapeProps::clear()
{
    m_has_txBox_attr = false;
    m_txBox_attr = false;

    m_has_spLocks = false;

    if (m_spLocks)
    {
        delete m_spLocks;
        m_spLocks = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_NonVisualDrawingShapeProps::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_txBox_attr)
    {
        _outStream << " " << "txBox" << "=\"" << XSD::XMLBooleanStr(m_txBox_attr) << "\"";
    }

    _outStream << ">";


    if (m_has_spLocks)
    {
        m_spLocks->toXmlElem("a:spLocks", "", _outStream);
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_NonVisualDrawingShapeProps& CT_NonVisualDrawingShapeProps::default_instance()
{
    if (!CT_NonVisualDrawingShapeProps::default_instance_)
    {
        CT_NonVisualDrawingShapeProps::default_instance_ = new CT_NonVisualDrawingShapeProps();
    }
    return *CT_NonVisualDrawingShapeProps::default_instance_;
}

bool CT_NonVisualDrawingShapeProps::has_txBox_attr() const
{
    return m_has_txBox_attr;
}

void CT_NonVisualDrawingShapeProps::set_txBox_attr(const XSD::boolean_& _txBox_attr)
{
    m_has_txBox_attr = true;
    m_txBox_attr = _txBox_attr;
}

const XSD::boolean_& CT_NonVisualDrawingShapeProps::get_txBox_attr() const
{
    return m_txBox_attr;
}

CT_NonVisualDrawingShapeProps* CT_NonVisualDrawingShapeProps::default_instance_ = NULL;

// CT_NonVisualConnectorProperties
CT_NonVisualConnectorProperties::CT_NonVisualConnectorProperties()
    :m_has_cxnSpLocks(false),
     m_cxnSpLocks(NULL),
     m_has_stCxn(false),
     m_stCxn(NULL),
     m_has_endCxn(false),
     m_endCxn(NULL),
     m_has_extLst(false),
     m_extLst(NULL)
{
}
CT_NonVisualConnectorProperties::~CT_NonVisualConnectorProperties()
{
    clear();
}
bool CT_NonVisualConnectorProperties::has_cxnSpLocks() const
{
    return m_has_cxnSpLocks;
}

CT_ConnectorLocking* CT_NonVisualConnectorProperties::mutable_cxnSpLocks()
{
    m_has_cxnSpLocks = true;
    if (!m_cxnSpLocks)
    {
        m_cxnSpLocks = new CT_ConnectorLocking();
    }
    return m_cxnSpLocks;
}

const CT_ConnectorLocking& CT_NonVisualConnectorProperties::get_cxnSpLocks() const
{
    if (m_cxnSpLocks)
    {
        return *m_cxnSpLocks;
    }
    return CT_ConnectorLocking::default_instance();
}

bool CT_NonVisualConnectorProperties::has_stCxn() const
{
    return m_has_stCxn;
}

CT_Connection* CT_NonVisualConnectorProperties::mutable_stCxn()
{
    m_has_stCxn = true;
    if (!m_stCxn)
    {
        m_stCxn = new CT_Connection();
    }
    return m_stCxn;
}

const CT_Connection& CT_NonVisualConnectorProperties::get_stCxn() const
{
    if (m_stCxn)
    {
        return *m_stCxn;
    }
    return CT_Connection::default_instance();
}

bool CT_NonVisualConnectorProperties::has_endCxn() const
{
    return m_has_endCxn;
}

CT_Connection* CT_NonVisualConnectorProperties::mutable_endCxn()
{
    m_has_endCxn = true;
    if (!m_endCxn)
    {
        m_endCxn = new CT_Connection();
    }
    return m_endCxn;
}

const CT_Connection& CT_NonVisualConnectorProperties::get_endCxn() const
{
    if (m_endCxn)
    {
        return *m_endCxn;
    }
    return CT_Connection::default_instance();
}

bool CT_NonVisualConnectorProperties::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_NonVisualConnectorProperties::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_NonVisualConnectorProperties::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_NonVisualConnectorProperties::clear()
{
    m_has_cxnSpLocks = false;

    if (m_cxnSpLocks)
    {
        delete m_cxnSpLocks;
        m_cxnSpLocks = NULL;
    }


    m_has_stCxn = false;

    if (m_stCxn)
    {
        delete m_stCxn;
        m_stCxn = NULL;
    }


    m_has_endCxn = false;

    if (m_endCxn)
    {
        delete m_endCxn;
        m_endCxn = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_NonVisualConnectorProperties::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";


    if (m_has_cxnSpLocks)
    {
        m_cxnSpLocks->toXmlElem("a:cxnSpLocks", "", _outStream);
    }


    if (m_has_stCxn)
    {
        m_stCxn->toXmlElem("a:stCxn", "", _outStream);
    }


    if (m_has_endCxn)
    {
        m_endCxn->toXmlElem("a:endCxn", "", _outStream);
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_NonVisualConnectorProperties& CT_NonVisualConnectorProperties::default_instance()
{
    if (!CT_NonVisualConnectorProperties::default_instance_)
    {
        CT_NonVisualConnectorProperties::default_instance_ = new CT_NonVisualConnectorProperties();
    }
    return *CT_NonVisualConnectorProperties::default_instance_;
}

CT_NonVisualConnectorProperties* CT_NonVisualConnectorProperties::default_instance_ = NULL;

// CT_NonVisualPictureProperties
CT_NonVisualPictureProperties::CT_NonVisualPictureProperties()
    :m_has_picLocks(false),
     m_picLocks(NULL),
     m_has_extLst(false),
     m_extLst(NULL),
     m_has_preferRelativeResize_attr(false),
     m_preferRelativeResize_attr(false)
{
}
CT_NonVisualPictureProperties::~CT_NonVisualPictureProperties()
{
    clear();
}
bool CT_NonVisualPictureProperties::has_picLocks() const
{
    return m_has_picLocks;
}

CT_PictureLocking* CT_NonVisualPictureProperties::mutable_picLocks()
{
    m_has_picLocks = true;
    if (!m_picLocks)
    {
        m_picLocks = new CT_PictureLocking();
    }
    return m_picLocks;
}

const CT_PictureLocking& CT_NonVisualPictureProperties::get_picLocks() const
{
    if (m_picLocks)
    {
        return *m_picLocks;
    }
    return CT_PictureLocking::default_instance();
}

bool CT_NonVisualPictureProperties::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_NonVisualPictureProperties::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_NonVisualPictureProperties::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_NonVisualPictureProperties::clear()
{
    m_has_preferRelativeResize_attr = false;
    m_preferRelativeResize_attr = false;

    m_has_picLocks = false;

    if (m_picLocks)
    {
        delete m_picLocks;
        m_picLocks = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_NonVisualPictureProperties::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_preferRelativeResize_attr)
    {
        _outStream << " " << "preferRelativeResize" << "=\"" << XSD::XMLBooleanStr(m_preferRelativeResize_attr) << "\"";
    }

    _outStream << ">";


    if (m_has_picLocks)
    {
        m_picLocks->toXmlElem("a:picLocks", "", _outStream);
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_NonVisualPictureProperties& CT_NonVisualPictureProperties::default_instance()
{
    if (!CT_NonVisualPictureProperties::default_instance_)
    {
        CT_NonVisualPictureProperties::default_instance_ = new CT_NonVisualPictureProperties();
    }
    return *CT_NonVisualPictureProperties::default_instance_;
}

bool CT_NonVisualPictureProperties::has_preferRelativeResize_attr() const
{
    return m_has_preferRelativeResize_attr;
}

void CT_NonVisualPictureProperties::set_preferRelativeResize_attr(const XSD::boolean_& _preferRelativeResize_attr)
{
    m_has_preferRelativeResize_attr = true;
    m_preferRelativeResize_attr = _preferRelativeResize_attr;
}

const XSD::boolean_& CT_NonVisualPictureProperties::get_preferRelativeResize_attr() const
{
    return m_preferRelativeResize_attr;
}

CT_NonVisualPictureProperties* CT_NonVisualPictureProperties::default_instance_ = NULL;

// CT_NonVisualGroupDrawingShapeProps
CT_NonVisualGroupDrawingShapeProps::CT_NonVisualGroupDrawingShapeProps()
    :m_has_grpSpLocks(false),
     m_grpSpLocks(NULL),
     m_has_extLst(false),
     m_extLst(NULL)
{
}
CT_NonVisualGroupDrawingShapeProps::~CT_NonVisualGroupDrawingShapeProps()
{
    clear();
}
bool CT_NonVisualGroupDrawingShapeProps::has_grpSpLocks() const
{
    return m_has_grpSpLocks;
}

CT_GroupLocking* CT_NonVisualGroupDrawingShapeProps::mutable_grpSpLocks()
{
    m_has_grpSpLocks = true;
    if (!m_grpSpLocks)
    {
        m_grpSpLocks = new CT_GroupLocking();
    }
    return m_grpSpLocks;
}

const CT_GroupLocking& CT_NonVisualGroupDrawingShapeProps::get_grpSpLocks() const
{
    if (m_grpSpLocks)
    {
        return *m_grpSpLocks;
    }
    return CT_GroupLocking::default_instance();
}

bool CT_NonVisualGroupDrawingShapeProps::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_NonVisualGroupDrawingShapeProps::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_NonVisualGroupDrawingShapeProps::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_NonVisualGroupDrawingShapeProps::clear()
{
    m_has_grpSpLocks = false;

    if (m_grpSpLocks)
    {
        delete m_grpSpLocks;
        m_grpSpLocks = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_NonVisualGroupDrawingShapeProps::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";


    if (m_has_grpSpLocks)
    {
        m_grpSpLocks->toXmlElem("a:grpSpLocks", "", _outStream);
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_NonVisualGroupDrawingShapeProps& CT_NonVisualGroupDrawingShapeProps::default_instance()
{
    if (!CT_NonVisualGroupDrawingShapeProps::default_instance_)
    {
        CT_NonVisualGroupDrawingShapeProps::default_instance_ = new CT_NonVisualGroupDrawingShapeProps();
    }
    return *CT_NonVisualGroupDrawingShapeProps::default_instance_;
}

CT_NonVisualGroupDrawingShapeProps* CT_NonVisualGroupDrawingShapeProps::default_instance_ = NULL;

// CT_NonVisualGraphicFrameProperties
CT_NonVisualGraphicFrameProperties::CT_NonVisualGraphicFrameProperties()
    :m_has_graphicFrameLocks(false),
     m_graphicFrameLocks(NULL),
     m_has_extLst(false),
     m_extLst(NULL)
{
}
CT_NonVisualGraphicFrameProperties::~CT_NonVisualGraphicFrameProperties()
{
    clear();
}
bool CT_NonVisualGraphicFrameProperties::has_graphicFrameLocks() const
{
    return m_has_graphicFrameLocks;
}

CT_GraphicalObjectFrameLocking* CT_NonVisualGraphicFrameProperties::mutable_graphicFrameLocks()
{
    m_has_graphicFrameLocks = true;
    if (!m_graphicFrameLocks)
    {
        m_graphicFrameLocks = new CT_GraphicalObjectFrameLocking();
    }
    return m_graphicFrameLocks;
}

const CT_GraphicalObjectFrameLocking& CT_NonVisualGraphicFrameProperties::get_graphicFrameLocks() const
{
    if (m_graphicFrameLocks)
    {
        return *m_graphicFrameLocks;
    }
    return CT_GraphicalObjectFrameLocking::default_instance();
}

bool CT_NonVisualGraphicFrameProperties::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_NonVisualGraphicFrameProperties::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_NonVisualGraphicFrameProperties::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_NonVisualGraphicFrameProperties::clear()
{
    m_has_graphicFrameLocks = false;

    if (m_graphicFrameLocks)
    {
        delete m_graphicFrameLocks;
        m_graphicFrameLocks = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_NonVisualGraphicFrameProperties::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";


    if (m_has_graphicFrameLocks)
    {
        m_graphicFrameLocks->toXmlElem("a:graphicFrameLocks", "", _outStream);
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_NonVisualGraphicFrameProperties& CT_NonVisualGraphicFrameProperties::default_instance()
{
    if (!CT_NonVisualGraphicFrameProperties::default_instance_)
    {
        CT_NonVisualGraphicFrameProperties::default_instance_ = new CT_NonVisualGraphicFrameProperties();
    }
    return *CT_NonVisualGraphicFrameProperties::default_instance_;
}

CT_NonVisualGraphicFrameProperties* CT_NonVisualGraphicFrameProperties::default_instance_ = NULL;

// CT_NonVisualContentPartProperties
CT_NonVisualContentPartProperties::CT_NonVisualContentPartProperties()
    :m_has_cpLocks(false),
     m_cpLocks(NULL),
     m_has_extLst(false),
     m_extLst(NULL),
     m_has_isComment_attr(false),
     m_isComment_attr(false)
{
}
CT_NonVisualContentPartProperties::~CT_NonVisualContentPartProperties()
{
    clear();
}
bool CT_NonVisualContentPartProperties::has_cpLocks() const
{
    return m_has_cpLocks;
}

CT_ContentPartLocking* CT_NonVisualContentPartProperties::mutable_cpLocks()
{
    m_has_cpLocks = true;
    if (!m_cpLocks)
    {
        m_cpLocks = new CT_ContentPartLocking();
    }
    return m_cpLocks;
}

const CT_ContentPartLocking& CT_NonVisualContentPartProperties::get_cpLocks() const
{
    if (m_cpLocks)
    {
        return *m_cpLocks;
    }
    return CT_ContentPartLocking::default_instance();
}

bool CT_NonVisualContentPartProperties::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_NonVisualContentPartProperties::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_NonVisualContentPartProperties::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_NonVisualContentPartProperties::clear()
{
    m_has_isComment_attr = false;
    m_isComment_attr = false;

    m_has_cpLocks = false;

    if (m_cpLocks)
    {
        delete m_cpLocks;
        m_cpLocks = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_NonVisualContentPartProperties::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_isComment_attr)
    {
        _outStream << " " << "isComment" << "=\"" << XSD::XMLBooleanStr(m_isComment_attr) << "\"";
    }

    _outStream << ">";


    if (m_has_cpLocks)
    {
        m_cpLocks->toXmlElem("a:cpLocks", "", _outStream);
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_NonVisualContentPartProperties& CT_NonVisualContentPartProperties::default_instance()
{
    if (!CT_NonVisualContentPartProperties::default_instance_)
    {
        CT_NonVisualContentPartProperties::default_instance_ = new CT_NonVisualContentPartProperties();
    }
    return *CT_NonVisualContentPartProperties::default_instance_;
}

bool CT_NonVisualContentPartProperties::has_isComment_attr() const
{
    return m_has_isComment_attr;
}

void CT_NonVisualContentPartProperties::set_isComment_attr(const XSD::boolean_& _isComment_attr)
{
    m_has_isComment_attr = true;
    m_isComment_attr = _isComment_attr;
}

const XSD::boolean_& CT_NonVisualContentPartProperties::get_isComment_attr() const
{
    return m_isComment_attr;
}

CT_NonVisualContentPartProperties* CT_NonVisualContentPartProperties::default_instance_ = NULL;

// CT_GraphicalObjectData
CT_GraphicalObjectData::CT_GraphicalObjectData()
    :m_has__any(false),
     m__any(NULL),
     m_has_uri_attr(false),
     m_uri_attr("")
{
}
CT_GraphicalObjectData::~CT_GraphicalObjectData()
{
    clear();
}
void CT_GraphicalObjectData::clear()
{
    m_has_uri_attr = false;
    m_uri_attr.clear();
}

void CT_GraphicalObjectData::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_uri_attr);
    if (m_has_uri_attr)
    {
        _outStream << " " << "uri" << "=\"" << m_uri_attr << "\"";
    }

    _outStream << ">";


    if (m_has__any)
    {
        m__any->toXml(_outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_GraphicalObjectData& CT_GraphicalObjectData::default_instance()
{
    if (!CT_GraphicalObjectData::default_instance_)
    {
        CT_GraphicalObjectData::default_instance_ = new CT_GraphicalObjectData();
    }
    return *CT_GraphicalObjectData::default_instance_;
}

bool CT_GraphicalObjectData::has_uri_attr() const
{
    return m_has_uri_attr;
}

void CT_GraphicalObjectData::set_uri_attr(const XSD::token_& _uri_attr)
{
    m_has_uri_attr = true;
    m_uri_attr = _uri_attr;
}

const XSD::token_& CT_GraphicalObjectData::get_uri_attr() const
{
    return m_uri_attr;
}

CT_GraphicalObjectData* CT_GraphicalObjectData::default_instance_ = NULL;

// CT_GraphicalObject
CT_GraphicalObject::CT_GraphicalObject()
    :m_has_graphicData(false),
     m_graphicData(NULL)
{
}
CT_GraphicalObject::~CT_GraphicalObject()
{
    clear();
}
bool CT_GraphicalObject::has_graphicData() const
{
    return m_has_graphicData;
}

CT_GraphicalObjectData* CT_GraphicalObject::mutable_graphicData()
{
    m_has_graphicData = true;
    if (!m_graphicData)
    {
        m_graphicData = new CT_GraphicalObjectData();
    }
    return m_graphicData;
}

const CT_GraphicalObjectData& CT_GraphicalObject::get_graphicData() const
{
    if (m_graphicData)
    {
        return *m_graphicData;
    }
    return CT_GraphicalObjectData::default_instance();
}

void CT_GraphicalObject::clear()
{
    m_has_graphicData = false;

    if (m_graphicData)
    {
        delete m_graphicData;
        m_graphicData = NULL;
    }

}

void CT_GraphicalObject::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    assert(m_has_graphicData);


    if (m_has_graphicData)
    {
        m_graphicData->toXmlElem("a:graphicData", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_GraphicalObject& CT_GraphicalObject::default_instance()
{
    if (!CT_GraphicalObject::default_instance_)
    {
        CT_GraphicalObject::default_instance_ = new CT_GraphicalObject();
    }
    return *CT_GraphicalObject::default_instance_;
}

CT_GraphicalObject* CT_GraphicalObject::default_instance_ = NULL;

// CT_AnimationDgmElement
CT_AnimationDgmElement::CT_AnimationDgmElement()
    :m_has_id_attr(false),
     m_id_attr(NULL),
     m_has_bldStep_attr(false),
     m_bldStep_attr(NULL)
{
}
CT_AnimationDgmElement::~CT_AnimationDgmElement()
{
    clear();
}
void CT_AnimationDgmElement::clear()
{
    m_has_id_attr = false;

    if (m_id_attr)
    {
        delete m_id_attr;
        m_id_attr = NULL;
    }


    m_has_bldStep_attr = false;

    if (m_bldStep_attr)
    {
        delete m_bldStep_attr;
        m_bldStep_attr = NULL;
    }

}

void CT_AnimationDgmElement::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_id_attr)
    {
        m_id_attr->toXmlAttr("id", _outStream);
    }



    if (m_has_bldStep_attr)
    {
        m_bldStep_attr->toXmlAttr("bldStep", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_AnimationDgmElement& CT_AnimationDgmElement::default_instance()
{
    if (!CT_AnimationDgmElement::default_instance_)
    {
        CT_AnimationDgmElement::default_instance_ = new CT_AnimationDgmElement();
    }
    return *CT_AnimationDgmElement::default_instance_;
}

bool CT_AnimationDgmElement::has_id_attr() const
{
    return m_has_id_attr;
}

void CT_AnimationDgmElement::set_id_attr(const ns_s::ST_Guid& _id_attr)
{
    m_has_id_attr = true;
    m_id_attr = new ns_s::ST_Guid(_id_attr);
}

const ns_s::ST_Guid& CT_AnimationDgmElement::get_id_attr() const
{
    if (m_id_attr)
    {
        return *m_id_attr;
    }
    return ns_s::ST_Guid::default_instance();
}

bool CT_AnimationDgmElement::has_bldStep_attr() const
{
    return m_has_bldStep_attr;
}

void CT_AnimationDgmElement::set_bldStep_attr(const ST_DgmBuildStep& _bldStep_attr)
{
    m_has_bldStep_attr = true;
    m_bldStep_attr = new ST_DgmBuildStep(_bldStep_attr);
}

const ST_DgmBuildStep& CT_AnimationDgmElement::get_bldStep_attr() const
{
    if (m_bldStep_attr)
    {
        return *m_bldStep_attr;
    }
    return ST_DgmBuildStep::default_instance();
}

CT_AnimationDgmElement* CT_AnimationDgmElement::default_instance_ = NULL;

// CT_AnimationChartElement
CT_AnimationChartElement::CT_AnimationChartElement()
    :m_has_seriesIdx_attr(false),
     m_seriesIdx_attr(0),
     m_has_categoryIdx_attr(false),
     m_categoryIdx_attr(0),
     m_has_bldStep_attr(false),
     m_bldStep_attr(NULL)
{
}
CT_AnimationChartElement::~CT_AnimationChartElement()
{
    clear();
}
void CT_AnimationChartElement::clear()
{
    m_has_seriesIdx_attr = false;
    m_seriesIdx_attr = 0;

    m_has_categoryIdx_attr = false;
    m_categoryIdx_attr = 0;

    m_has_bldStep_attr = false;

    if (m_bldStep_attr)
    {
        delete m_bldStep_attr;
        m_bldStep_attr = NULL;
    }

}

void CT_AnimationChartElement::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_seriesIdx_attr)
    {
        _outStream << " " << "seriesIdx" << "=\"" << m_seriesIdx_attr << "\"";
    }



    if (m_has_categoryIdx_attr)
    {
        _outStream << " " << "categoryIdx" << "=\"" << m_categoryIdx_attr << "\"";
    }


    assert(m_has_bldStep_attr);
    if (m_has_bldStep_attr)
    {
        m_bldStep_attr->toXmlAttr("bldStep", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_AnimationChartElement& CT_AnimationChartElement::default_instance()
{
    if (!CT_AnimationChartElement::default_instance_)
    {
        CT_AnimationChartElement::default_instance_ = new CT_AnimationChartElement();
    }
    return *CT_AnimationChartElement::default_instance_;
}

bool CT_AnimationChartElement::has_seriesIdx_attr() const
{
    return m_has_seriesIdx_attr;
}

void CT_AnimationChartElement::set_seriesIdx_attr(const XSD::int_& _seriesIdx_attr)
{
    m_has_seriesIdx_attr = true;
    m_seriesIdx_attr = _seriesIdx_attr;
}

const XSD::int_& CT_AnimationChartElement::get_seriesIdx_attr() const
{
    return m_seriesIdx_attr;
}

bool CT_AnimationChartElement::has_categoryIdx_attr() const
{
    return m_has_categoryIdx_attr;
}

void CT_AnimationChartElement::set_categoryIdx_attr(const XSD::int_& _categoryIdx_attr)
{
    m_has_categoryIdx_attr = true;
    m_categoryIdx_attr = _categoryIdx_attr;
}

const XSD::int_& CT_AnimationChartElement::get_categoryIdx_attr() const
{
    return m_categoryIdx_attr;
}

bool CT_AnimationChartElement::has_bldStep_attr() const
{
    return m_has_bldStep_attr;
}

void CT_AnimationChartElement::set_bldStep_attr(const ST_ChartBuildStep& _bldStep_attr)
{
    m_has_bldStep_attr = true;
    m_bldStep_attr = new ST_ChartBuildStep(_bldStep_attr);
}

const ST_ChartBuildStep& CT_AnimationChartElement::get_bldStep_attr() const
{
    if (m_bldStep_attr)
    {
        return *m_bldStep_attr;
    }
    return ST_ChartBuildStep::default_instance();
}

CT_AnimationChartElement* CT_AnimationChartElement::default_instance_ = NULL;

// CT_AnimationElementChoice
CT_AnimationElementChoice::CT_AnimationElementChoice()
    :m_has_dgm(false),
     m_dgm(NULL),
     m_has_chart(false),
     m_chart(NULL)
{
}
CT_AnimationElementChoice::~CT_AnimationElementChoice()
{
    clear();
}
bool CT_AnimationElementChoice::has_dgm() const
{
    return m_has_dgm;
}

CT_AnimationDgmElement* CT_AnimationElementChoice::mutable_dgm()
{

    m_has_chart = false;

    if (m_chart)
    {
        delete m_chart;
        m_chart = NULL;
    }
    ;

    m_has_dgm = true;
    if (!m_dgm)
    {
        m_dgm = new CT_AnimationDgmElement();
    }
    return m_dgm;
}

const CT_AnimationDgmElement& CT_AnimationElementChoice::get_dgm() const
{
    if (m_dgm)
    {
        return *m_dgm;
    }
    return CT_AnimationDgmElement::default_instance();
}

bool CT_AnimationElementChoice::has_chart() const
{
    return m_has_chart;
}

CT_AnimationChartElement* CT_AnimationElementChoice::mutable_chart()
{

    m_has_dgm = false;

    if (m_dgm)
    {
        delete m_dgm;
        m_dgm = NULL;
    }
    ;

    m_has_chart = true;
    if (!m_chart)
    {
        m_chart = new CT_AnimationChartElement();
    }
    return m_chart;
}

const CT_AnimationChartElement& CT_AnimationElementChoice::get_chart() const
{
    if (m_chart)
    {
        return *m_chart;
    }
    return CT_AnimationChartElement::default_instance();
}

void CT_AnimationElementChoice::clear()
{
    m_has_dgm = false;

    if (m_dgm)
    {
        delete m_dgm;
        m_dgm = NULL;
    }


    m_has_chart = false;

    if (m_chart)
    {
        delete m_chart;
        m_chart = NULL;
    }

}

void CT_AnimationElementChoice::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    {
        bool elemHasValueList[2] = {m_has_dgm, m_has_chart};
        int cnt = count(elemHasValueList, elemHasValueList + 2, true);
        assert(cnt == 1);
    }


    if (m_has_dgm)
    {
        m_dgm->toXmlElem("a:dgm", "", _outStream);
    }


    if (m_has_chart)
    {
        m_chart->toXmlElem("a:chart", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_AnimationElementChoice& CT_AnimationElementChoice::default_instance()
{
    if (!CT_AnimationElementChoice::default_instance_)
    {
        CT_AnimationElementChoice::default_instance_ = new CT_AnimationElementChoice();
    }
    return *CT_AnimationElementChoice::default_instance_;
}

CT_AnimationElementChoice* CT_AnimationElementChoice::default_instance_ = NULL;

// CT_AnimationDgmBuildProperties
CT_AnimationDgmBuildProperties::CT_AnimationDgmBuildProperties()
    :m_has_bld_attr(false),
     m_bld_attr(NULL),
     m_has_rev_attr(false),
     m_rev_attr(false)
{
}
CT_AnimationDgmBuildProperties::~CT_AnimationDgmBuildProperties()
{
    clear();
}
void CT_AnimationDgmBuildProperties::clear()
{
    m_has_bld_attr = false;

    if (m_bld_attr)
    {
        delete m_bld_attr;
        m_bld_attr = NULL;
    }


    m_has_rev_attr = false;
    m_rev_attr = false;
}

void CT_AnimationDgmBuildProperties::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_bld_attr)
    {
        m_bld_attr->toXmlAttr("bld", _outStream);
    }



    if (m_has_rev_attr)
    {
        _outStream << " " << "rev" << "=\"" << XSD::XMLBooleanStr(m_rev_attr) << "\"";
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_AnimationDgmBuildProperties& CT_AnimationDgmBuildProperties::default_instance()
{
    if (!CT_AnimationDgmBuildProperties::default_instance_)
    {
        CT_AnimationDgmBuildProperties::default_instance_ = new CT_AnimationDgmBuildProperties();
    }
    return *CT_AnimationDgmBuildProperties::default_instance_;
}

bool CT_AnimationDgmBuildProperties::has_bld_attr() const
{
    return m_has_bld_attr;
}

void CT_AnimationDgmBuildProperties::set_bld_attr(const ST_AnimationDgmBuildType& _bld_attr)
{
    m_has_bld_attr = true;
    m_bld_attr = new ST_AnimationDgmBuildType(_bld_attr);
}

const ST_AnimationDgmBuildType& CT_AnimationDgmBuildProperties::get_bld_attr() const
{
    if (m_bld_attr)
    {
        return *m_bld_attr;
    }
    return ST_AnimationDgmBuildType::default_instance();
}

bool CT_AnimationDgmBuildProperties::has_rev_attr() const
{
    return m_has_rev_attr;
}

void CT_AnimationDgmBuildProperties::set_rev_attr(const XSD::boolean_& _rev_attr)
{
    m_has_rev_attr = true;
    m_rev_attr = _rev_attr;
}

const XSD::boolean_& CT_AnimationDgmBuildProperties::get_rev_attr() const
{
    return m_rev_attr;
}

CT_AnimationDgmBuildProperties* CT_AnimationDgmBuildProperties::default_instance_ = NULL;

// CT_AnimationChartBuildProperties
CT_AnimationChartBuildProperties::CT_AnimationChartBuildProperties()
    :m_has_bld_attr(false),
     m_bld_attr(NULL),
     m_has_animBg_attr(false),
     m_animBg_attr(false)
{
}
CT_AnimationChartBuildProperties::~CT_AnimationChartBuildProperties()
{
    clear();
}
void CT_AnimationChartBuildProperties::clear()
{
    m_has_bld_attr = false;

    if (m_bld_attr)
    {
        delete m_bld_attr;
        m_bld_attr = NULL;
    }


    m_has_animBg_attr = false;
    m_animBg_attr = false;
}

void CT_AnimationChartBuildProperties::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_bld_attr)
    {
        m_bld_attr->toXmlAttr("bld", _outStream);
    }



    if (m_has_animBg_attr)
    {
        _outStream << " " << "animBg" << "=\"" << XSD::XMLBooleanStr(m_animBg_attr) << "\"";
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_AnimationChartBuildProperties& CT_AnimationChartBuildProperties::default_instance()
{
    if (!CT_AnimationChartBuildProperties::default_instance_)
    {
        CT_AnimationChartBuildProperties::default_instance_ = new CT_AnimationChartBuildProperties();
    }
    return *CT_AnimationChartBuildProperties::default_instance_;
}

bool CT_AnimationChartBuildProperties::has_bld_attr() const
{
    return m_has_bld_attr;
}

void CT_AnimationChartBuildProperties::set_bld_attr(const ST_AnimationChartBuildType& _bld_attr)
{
    m_has_bld_attr = true;
    m_bld_attr = new ST_AnimationChartBuildType(_bld_attr);
}

const ST_AnimationChartBuildType& CT_AnimationChartBuildProperties::get_bld_attr() const
{
    if (m_bld_attr)
    {
        return *m_bld_attr;
    }
    return ST_AnimationChartBuildType::default_instance();
}

bool CT_AnimationChartBuildProperties::has_animBg_attr() const
{
    return m_has_animBg_attr;
}

void CT_AnimationChartBuildProperties::set_animBg_attr(const XSD::boolean_& _animBg_attr)
{
    m_has_animBg_attr = true;
    m_animBg_attr = _animBg_attr;
}

const XSD::boolean_& CT_AnimationChartBuildProperties::get_animBg_attr() const
{
    return m_animBg_attr;
}

CT_AnimationChartBuildProperties* CT_AnimationChartBuildProperties::default_instance_ = NULL;

// CT_AnimationGraphicalObjectBuildProperties
CT_AnimationGraphicalObjectBuildProperties::CT_AnimationGraphicalObjectBuildProperties()
    :m_has_bldDgm(false),
     m_bldDgm(NULL),
     m_has_bldChart(false),
     m_bldChart(NULL)
{
}
CT_AnimationGraphicalObjectBuildProperties::~CT_AnimationGraphicalObjectBuildProperties()
{
    clear();
}
bool CT_AnimationGraphicalObjectBuildProperties::has_bldDgm() const
{
    return m_has_bldDgm;
}

CT_AnimationDgmBuildProperties* CT_AnimationGraphicalObjectBuildProperties::mutable_bldDgm()
{

    m_has_bldChart = false;

    if (m_bldChart)
    {
        delete m_bldChart;
        m_bldChart = NULL;
    }
    ;

    m_has_bldDgm = true;
    if (!m_bldDgm)
    {
        m_bldDgm = new CT_AnimationDgmBuildProperties();
    }
    return m_bldDgm;
}

const CT_AnimationDgmBuildProperties& CT_AnimationGraphicalObjectBuildProperties::get_bldDgm() const
{
    if (m_bldDgm)
    {
        return *m_bldDgm;
    }
    return CT_AnimationDgmBuildProperties::default_instance();
}

bool CT_AnimationGraphicalObjectBuildProperties::has_bldChart() const
{
    return m_has_bldChart;
}

CT_AnimationChartBuildProperties* CT_AnimationGraphicalObjectBuildProperties::mutable_bldChart()
{

    m_has_bldDgm = false;

    if (m_bldDgm)
    {
        delete m_bldDgm;
        m_bldDgm = NULL;
    }
    ;

    m_has_bldChart = true;
    if (!m_bldChart)
    {
        m_bldChart = new CT_AnimationChartBuildProperties();
    }
    return m_bldChart;
}

const CT_AnimationChartBuildProperties& CT_AnimationGraphicalObjectBuildProperties::get_bldChart() const
{
    if (m_bldChart)
    {
        return *m_bldChart;
    }
    return CT_AnimationChartBuildProperties::default_instance();
}

void CT_AnimationGraphicalObjectBuildProperties::clear()
{
    m_has_bldDgm = false;

    if (m_bldDgm)
    {
        delete m_bldDgm;
        m_bldDgm = NULL;
    }


    m_has_bldChart = false;

    if (m_bldChart)
    {
        delete m_bldChart;
        m_bldChart = NULL;
    }

}

void CT_AnimationGraphicalObjectBuildProperties::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    {
        bool elemHasValueList[2] = {m_has_bldDgm, m_has_bldChart};
        int cnt = count(elemHasValueList, elemHasValueList + 2, true);
        assert(cnt == 1);
    }


    if (m_has_bldDgm)
    {
        m_bldDgm->toXmlElem("a:bldDgm", "", _outStream);
    }


    if (m_has_bldChart)
    {
        m_bldChart->toXmlElem("a:bldChart", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_AnimationGraphicalObjectBuildProperties& CT_AnimationGraphicalObjectBuildProperties::default_instance()
{
    if (!CT_AnimationGraphicalObjectBuildProperties::default_instance_)
    {
        CT_AnimationGraphicalObjectBuildProperties::default_instance_ = new CT_AnimationGraphicalObjectBuildProperties();
    }
    return *CT_AnimationGraphicalObjectBuildProperties::default_instance_;
}

CT_AnimationGraphicalObjectBuildProperties* CT_AnimationGraphicalObjectBuildProperties::default_instance_ = NULL;

// CT_BackgrCT_TextEffectoundFormatting
CT_BackgrCT_TextEffectoundFormatting::CT_BackgrCT_TextEffectoundFormatting()
    :m_has_noFill(false),
     m_noFill(NULL),
     m_has_solidFill(false),
     m_solidFill(NULL),
     m_has_gradFill(false),
     m_gradFill(NULL),
     m_has_blipFill(false),
     m_blipFill(NULL),
     m_has_pattFill(false),
     m_pattFill(NULL),
     m_has_grpFill(false),
     m_grpFill(NULL),
     m_has_effectLst(false),
     m_effectLst(NULL),
     m_has_effectDag(false),
     m_effectDag(NULL)
{
}
CT_BackgrCT_TextEffectoundFormatting::~CT_BackgrCT_TextEffectoundFormatting()
{
    clear();
}
bool CT_BackgrCT_TextEffectoundFormatting::has_noFill() const
{
    return m_has_noFill;
}

CT_NoFillProperties* CT_BackgrCT_TextEffectoundFormatting::mutable_noFill()
{

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_noFill = true;
    if (!m_noFill)
    {
        m_noFill = new CT_NoFillProperties();
    }
    return m_noFill;
}

const CT_NoFillProperties& CT_BackgrCT_TextEffectoundFormatting::get_noFill() const
{
    if (m_noFill)
    {
        return *m_noFill;
    }
    return CT_NoFillProperties::default_instance();
}

bool CT_BackgrCT_TextEffectoundFormatting::has_solidFill() const
{
    return m_has_solidFill;
}

CT_SolidColorFillProperties* CT_BackgrCT_TextEffectoundFormatting::mutable_solidFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_solidFill = true;
    if (!m_solidFill)
    {
        m_solidFill = new CT_SolidColorFillProperties();
    }
    return m_solidFill;
}

const CT_SolidColorFillProperties& CT_BackgrCT_TextEffectoundFormatting::get_solidFill() const
{
    if (m_solidFill)
    {
        return *m_solidFill;
    }
    return CT_SolidColorFillProperties::default_instance();
}

bool CT_BackgrCT_TextEffectoundFormatting::has_gradFill() const
{
    return m_has_gradFill;
}

CT_GradientFillProperties* CT_BackgrCT_TextEffectoundFormatting::mutable_gradFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_gradFill = true;
    if (!m_gradFill)
    {
        m_gradFill = new CT_GradientFillProperties();
    }
    return m_gradFill;
}

const CT_GradientFillProperties& CT_BackgrCT_TextEffectoundFormatting::get_gradFill() const
{
    if (m_gradFill)
    {
        return *m_gradFill;
    }
    return CT_GradientFillProperties::default_instance();
}

bool CT_BackgrCT_TextEffectoundFormatting::has_blipFill() const
{
    return m_has_blipFill;
}

CT_BlipFillProperties* CT_BackgrCT_TextEffectoundFormatting::mutable_blipFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_blipFill = true;
    if (!m_blipFill)
    {
        m_blipFill = new CT_BlipFillProperties();
    }
    return m_blipFill;
}

const CT_BlipFillProperties& CT_BackgrCT_TextEffectoundFormatting::get_blipFill() const
{
    if (m_blipFill)
    {
        return *m_blipFill;
    }
    return CT_BlipFillProperties::default_instance();
}

bool CT_BackgrCT_TextEffectoundFormatting::has_pattFill() const
{
    return m_has_pattFill;
}

CT_PatternFillProperties* CT_BackgrCT_TextEffectoundFormatting::mutable_pattFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_pattFill = true;
    if (!m_pattFill)
    {
        m_pattFill = new CT_PatternFillProperties();
    }
    return m_pattFill;
}

const CT_PatternFillProperties& CT_BackgrCT_TextEffectoundFormatting::get_pattFill() const
{
    if (m_pattFill)
    {
        return *m_pattFill;
    }
    return CT_PatternFillProperties::default_instance();
}

bool CT_BackgrCT_TextEffectoundFormatting::has_grpFill() const
{
    return m_has_grpFill;
}

CT_GroupFillProperties* CT_BackgrCT_TextEffectoundFormatting::mutable_grpFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = true;
    if (!m_grpFill)
    {
        m_grpFill = new CT_GroupFillProperties();
    }
    return m_grpFill;
}

const CT_GroupFillProperties& CT_BackgrCT_TextEffectoundFormatting::get_grpFill() const
{
    if (m_grpFill)
    {
        return *m_grpFill;
    }
    return CT_GroupFillProperties::default_instance();
}

bool CT_BackgrCT_TextEffectoundFormatting::has_effectLst() const
{
    return m_has_effectLst;
}

CT_EffectList* CT_BackgrCT_TextEffectoundFormatting::mutable_effectLst()
{

    m_has_effectDag = false;

    if (m_effectDag)
    {
        delete m_effectDag;
        m_effectDag = NULL;
    }
    ;

    m_has_effectLst = true;
    if (!m_effectLst)
    {
        m_effectLst = new CT_EffectList();
    }
    return m_effectLst;
}

const CT_EffectList& CT_BackgrCT_TextEffectoundFormatting::get_effectLst() const
{
    if (m_effectLst)
    {
        return *m_effectLst;
    }
    return CT_EffectList::default_instance();
}

bool CT_BackgrCT_TextEffectoundFormatting::has_effectDag() const
{
    return m_has_effectDag;
}

CT_EffectContainer* CT_BackgrCT_TextEffectoundFormatting::mutable_effectDag()
{

    m_has_effectLst = false;

    if (m_effectLst)
    {
        delete m_effectLst;
        m_effectLst = NULL;
    }
    ;

    m_has_effectDag = true;
    if (!m_effectDag)
    {
        m_effectDag = new CT_EffectContainer();
    }
    return m_effectDag;
}

const CT_EffectContainer& CT_BackgrCT_TextEffectoundFormatting::get_effectDag() const
{
    if (m_effectDag)
    {
        return *m_effectDag;
    }
    return CT_EffectContainer::default_instance();
}

void CT_BackgrCT_TextEffectoundFormatting::clear()
{
    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }


    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }


    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }


    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }


    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }


    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }


    m_has_effectLst = false;

    if (m_effectLst)
    {
        delete m_effectLst;
        m_effectLst = NULL;
    }


    m_has_effectDag = false;

    if (m_effectDag)
    {
        delete m_effectDag;
        m_effectDag = NULL;
    }

}

void CT_BackgrCT_TextEffectoundFormatting::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    {
        bool elemHasValueList[6] = {m_has_noFill, m_has_solidFill, m_has_gradFill, m_has_blipFill, m_has_pattFill, m_has_grpFill};
        int cnt = count(elemHasValueList, elemHasValueList + 6, true);
        assert(cnt == 0 || cnt == 1);
    }


    if (m_has_noFill)
    {
        m_noFill->toXmlElem("a:noFill", "", _outStream);
    }


    if (m_has_solidFill)
    {
        m_solidFill->toXmlElem("a:solidFill", "", _outStream);
    }


    if (m_has_gradFill)
    {
        m_gradFill->toXmlElem("a:gradFill", "", _outStream);
    }


    if (m_has_blipFill)
    {
        m_blipFill->toXmlElem("a:blipFill", "", _outStream);
    }


    if (m_has_pattFill)
    {
        m_pattFill->toXmlElem("a:pattFill", "", _outStream);
    }


    if (m_has_grpFill)
    {
        m_grpFill->toXmlElem("a:grpFill", "", _outStream);
    }

    {
        bool elemHasValueList[2] = {m_has_effectLst, m_has_effectDag};
        int cnt = count(elemHasValueList, elemHasValueList + 2, true);
        assert(cnt == 0 || cnt == 1);
    }


    if (m_has_effectLst)
    {
        m_effectLst->toXmlElem("a:effectLst", "", _outStream);
    }


    if (m_has_effectDag)
    {
        m_effectDag->toXmlElem("a:effectDag", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_BackgrCT_TextEffectoundFormatting& CT_BackgrCT_TextEffectoundFormatting::default_instance()
{
    if (!CT_BackgrCT_TextEffectoundFormatting::default_instance_)
    {
        CT_BackgrCT_TextEffectoundFormatting::default_instance_ = new CT_BackgrCT_TextEffectoundFormatting();
    }
    return *CT_BackgrCT_TextEffectoundFormatting::default_instance_;
}

CT_BackgrCT_TextEffectoundFormatting* CT_BackgrCT_TextEffectoundFormatting::default_instance_ = NULL;

// CT_WholeE2oFormatting
CT_WholeE2oFormatting::CT_WholeE2oFormatting()
    :m_has_ln(false),
     m_ln(NULL),
     m_has_effectLst(false),
     m_effectLst(NULL),
     m_has_effectDag(false),
     m_effectDag(NULL)
{
}
CT_WholeE2oFormatting::~CT_WholeE2oFormatting()
{
    clear();
}
bool CT_WholeE2oFormatting::has_ln() const
{
    return m_has_ln;
}

CT_LineProperties* CT_WholeE2oFormatting::mutable_ln()
{
    m_has_ln = true;
    if (!m_ln)
    {
        m_ln = new CT_LineProperties();
    }
    return m_ln;
}

const CT_LineProperties& CT_WholeE2oFormatting::get_ln() const
{
    if (m_ln)
    {
        return *m_ln;
    }
    return CT_LineProperties::default_instance();
}

bool CT_WholeE2oFormatting::has_effectLst() const
{
    return m_has_effectLst;
}

CT_EffectList* CT_WholeE2oFormatting::mutable_effectLst()
{

    m_has_effectDag = false;

    if (m_effectDag)
    {
        delete m_effectDag;
        m_effectDag = NULL;
    }
    ;

    m_has_effectLst = true;
    if (!m_effectLst)
    {
        m_effectLst = new CT_EffectList();
    }
    return m_effectLst;
}

const CT_EffectList& CT_WholeE2oFormatting::get_effectLst() const
{
    if (m_effectLst)
    {
        return *m_effectLst;
    }
    return CT_EffectList::default_instance();
}

bool CT_WholeE2oFormatting::has_effectDag() const
{
    return m_has_effectDag;
}

CT_EffectContainer* CT_WholeE2oFormatting::mutable_effectDag()
{

    m_has_effectLst = false;

    if (m_effectLst)
    {
        delete m_effectLst;
        m_effectLst = NULL;
    }
    ;

    m_has_effectDag = true;
    if (!m_effectDag)
    {
        m_effectDag = new CT_EffectContainer();
    }
    return m_effectDag;
}

const CT_EffectContainer& CT_WholeE2oFormatting::get_effectDag() const
{
    if (m_effectDag)
    {
        return *m_effectDag;
    }
    return CT_EffectContainer::default_instance();
}

void CT_WholeE2oFormatting::clear()
{
    m_has_ln = false;

    if (m_ln)
    {
        delete m_ln;
        m_ln = NULL;
    }


    m_has_effectLst = false;

    if (m_effectLst)
    {
        delete m_effectLst;
        m_effectLst = NULL;
    }


    m_has_effectDag = false;

    if (m_effectDag)
    {
        delete m_effectDag;
        m_effectDag = NULL;
    }

}

void CT_WholeE2oFormatting::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";


    if (m_has_ln)
    {
        m_ln->toXmlElem("a:ln", "", _outStream);
    }

    {
        bool elemHasValueList[2] = {m_has_effectLst, m_has_effectDag};
        int cnt = count(elemHasValueList, elemHasValueList + 2, true);
        assert(cnt == 0 || cnt == 1);
    }


    if (m_has_effectLst)
    {
        m_effectLst->toXmlElem("a:effectLst", "", _outStream);
    }


    if (m_has_effectDag)
    {
        m_effectDag->toXmlElem("a:effectDag", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_WholeE2oFormatting& CT_WholeE2oFormatting::default_instance()
{
    if (!CT_WholeE2oFormatting::default_instance_)
    {
        CT_WholeE2oFormatting::default_instance_ = new CT_WholeE2oFormatting();
    }
    return *CT_WholeE2oFormatting::default_instance_;
}

CT_WholeE2oFormatting* CT_WholeE2oFormatting::default_instance_ = NULL;

// CT_GvmlUseShapeRectangle
CT_GvmlUseShapeRectangle::CT_GvmlUseShapeRectangle()

{
}
CT_GvmlUseShapeRectangle::~CT_GvmlUseShapeRectangle()
{
    clear();
}
void CT_GvmlUseShapeRectangle::clear()
{    }

void CT_GvmlUseShapeRectangle::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_GvmlUseShapeRectangle& CT_GvmlUseShapeRectangle::default_instance()
{
    if (!CT_GvmlUseShapeRectangle::default_instance_)
    {
        CT_GvmlUseShapeRectangle::default_instance_ = new CT_GvmlUseShapeRectangle();
    }
    return *CT_GvmlUseShapeRectangle::default_instance_;
}

CT_GvmlUseShapeRectangle* CT_GvmlUseShapeRectangle::default_instance_ = NULL;

// CT_GvmlTextShape
CT_GvmlTextShape::CT_GvmlTextShape()
    :m_has_txBody(false),
     m_txBody(NULL),
     m_has_useSpRect(false),
     m_useSpRect(NULL),
     m_has_xfrm(false),
     m_xfrm(NULL),
     m_has_extLst(false),
     m_extLst(NULL)
{
}
CT_GvmlTextShape::~CT_GvmlTextShape()
{
    clear();
}
bool CT_GvmlTextShape::has_txBody() const
{
    return m_has_txBody;
}

CT_TextBody* CT_GvmlTextShape::mutable_txBody()
{
    m_has_txBody = true;
    if (!m_txBody)
    {
        m_txBody = new CT_TextBody();
    }
    return m_txBody;
}

const CT_TextBody& CT_GvmlTextShape::get_txBody() const
{
    if (m_txBody)
    {
        return *m_txBody;
    }
    return CT_TextBody::default_instance();
}

bool CT_GvmlTextShape::has_useSpRect() const
{
    return m_has_useSpRect;
}

CT_GvmlUseShapeRectangle* CT_GvmlTextShape::mutable_useSpRect()
{

    m_has_xfrm = false;

    if (m_xfrm)
    {
        delete m_xfrm;
        m_xfrm = NULL;
    }
    ;

    m_has_useSpRect = true;
    if (!m_useSpRect)
    {
        m_useSpRect = new CT_GvmlUseShapeRectangle();
    }
    return m_useSpRect;
}

const CT_GvmlUseShapeRectangle& CT_GvmlTextShape::get_useSpRect() const
{
    if (m_useSpRect)
    {
        return *m_useSpRect;
    }
    return CT_GvmlUseShapeRectangle::default_instance();
}

bool CT_GvmlTextShape::has_xfrm() const
{
    return m_has_xfrm;
}

CT_Transform2D* CT_GvmlTextShape::mutable_xfrm()
{

    m_has_useSpRect = false;

    if (m_useSpRect)
    {
        delete m_useSpRect;
        m_useSpRect = NULL;
    }
    ;

    m_has_xfrm = true;
    if (!m_xfrm)
    {
        m_xfrm = new CT_Transform2D();
    }
    return m_xfrm;
}

const CT_Transform2D& CT_GvmlTextShape::get_xfrm() const
{
    if (m_xfrm)
    {
        return *m_xfrm;
    }
    return CT_Transform2D::default_instance();
}

bool CT_GvmlTextShape::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_GvmlTextShape::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_GvmlTextShape::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_GvmlTextShape::clear()
{
    m_has_txBody = false;

    if (m_txBody)
    {
        delete m_txBody;
        m_txBody = NULL;
    }


    m_has_useSpRect = false;

    if (m_useSpRect)
    {
        delete m_useSpRect;
        m_useSpRect = NULL;
    }


    m_has_xfrm = false;

    if (m_xfrm)
    {
        delete m_xfrm;
        m_xfrm = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_GvmlTextShape::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    assert(m_has_txBody);


    if (m_has_txBody)
    {
        m_txBody->toXmlElem("a:txBody", "", _outStream);
    }

    {
        bool elemHasValueList[2] = {m_has_useSpRect, m_has_xfrm};
        int cnt = count(elemHasValueList, elemHasValueList + 2, true);
        assert(cnt == 1);
    }


    if (m_has_useSpRect)
    {
        m_useSpRect->toXmlElem("a:useSpRect", "", _outStream);
    }


    if (m_has_xfrm)
    {
        m_xfrm->toXmlElem("a:xfrm", "", _outStream);
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_GvmlTextShape& CT_GvmlTextShape::default_instance()
{
    if (!CT_GvmlTextShape::default_instance_)
    {
        CT_GvmlTextShape::default_instance_ = new CT_GvmlTextShape();
    }
    return *CT_GvmlTextShape::default_instance_;
}

CT_GvmlTextShape* CT_GvmlTextShape::default_instance_ = NULL;

// CT_GvmlShapeNonVisual
CT_GvmlShapeNonVisual::CT_GvmlShapeNonVisual()
    :m_has_cNvPr(false),
     m_cNvPr(NULL),
     m_has_cNvSpPr(false),
     m_cNvSpPr(NULL)
{
}
CT_GvmlShapeNonVisual::~CT_GvmlShapeNonVisual()
{
    clear();
}
bool CT_GvmlShapeNonVisual::has_cNvPr() const
{
    return m_has_cNvPr;
}

CT_NonVisualDrawingProps* CT_GvmlShapeNonVisual::mutable_cNvPr()
{
    m_has_cNvPr = true;
    if (!m_cNvPr)
    {
        m_cNvPr = new CT_NonVisualDrawingProps();
    }
    return m_cNvPr;
}

const CT_NonVisualDrawingProps& CT_GvmlShapeNonVisual::get_cNvPr() const
{
    if (m_cNvPr)
    {
        return *m_cNvPr;
    }
    return CT_NonVisualDrawingProps::default_instance();
}

bool CT_GvmlShapeNonVisual::has_cNvSpPr() const
{
    return m_has_cNvSpPr;
}

CT_NonVisualDrawingShapeProps* CT_GvmlShapeNonVisual::mutable_cNvSpPr()
{
    m_has_cNvSpPr = true;
    if (!m_cNvSpPr)
    {
        m_cNvSpPr = new CT_NonVisualDrawingShapeProps();
    }
    return m_cNvSpPr;
}

const CT_NonVisualDrawingShapeProps& CT_GvmlShapeNonVisual::get_cNvSpPr() const
{
    if (m_cNvSpPr)
    {
        return *m_cNvSpPr;
    }
    return CT_NonVisualDrawingShapeProps::default_instance();
}

void CT_GvmlShapeNonVisual::clear()
{
    m_has_cNvPr = false;

    if (m_cNvPr)
    {
        delete m_cNvPr;
        m_cNvPr = NULL;
    }


    m_has_cNvSpPr = false;

    if (m_cNvSpPr)
    {
        delete m_cNvSpPr;
        m_cNvSpPr = NULL;
    }

}

void CT_GvmlShapeNonVisual::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    assert(m_has_cNvPr);


    assert(m_has_cNvSpPr);


    if (m_has_cNvPr)
    {
        m_cNvPr->toXmlElem("a:cNvPr", "", _outStream);
    }


    if (m_has_cNvSpPr)
    {
        m_cNvSpPr->toXmlElem("a:cNvSpPr", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_GvmlShapeNonVisual& CT_GvmlShapeNonVisual::default_instance()
{
    if (!CT_GvmlShapeNonVisual::default_instance_)
    {
        CT_GvmlShapeNonVisual::default_instance_ = new CT_GvmlShapeNonVisual();
    }
    return *CT_GvmlShapeNonVisual::default_instance_;
}

CT_GvmlShapeNonVisual* CT_GvmlShapeNonVisual::default_instance_ = NULL;

// CT_GvmlShape
CT_GvmlShape::CT_GvmlShape()
    :m_has_nvSpPr(false),
     m_nvSpPr(NULL),
     m_has_spPr(false),
     m_spPr(NULL),
     m_has_txSp(false),
     m_txSp(NULL),
     m_has_style(false),
     m_style(NULL),
     m_has_extLst(false),
     m_extLst(NULL)
{
}
CT_GvmlShape::~CT_GvmlShape()
{
    clear();
}
bool CT_GvmlShape::has_nvSpPr() const
{
    return m_has_nvSpPr;
}

CT_GvmlShapeNonVisual* CT_GvmlShape::mutable_nvSpPr()
{
    m_has_nvSpPr = true;
    if (!m_nvSpPr)
    {
        m_nvSpPr = new CT_GvmlShapeNonVisual();
    }
    return m_nvSpPr;
}

const CT_GvmlShapeNonVisual& CT_GvmlShape::get_nvSpPr() const
{
    if (m_nvSpPr)
    {
        return *m_nvSpPr;
    }
    return CT_GvmlShapeNonVisual::default_instance();
}

bool CT_GvmlShape::has_spPr() const
{
    return m_has_spPr;
}

CT_ShapeProperties* CT_GvmlShape::mutable_spPr()
{
    m_has_spPr = true;
    if (!m_spPr)
    {
        m_spPr = new CT_ShapeProperties();
    }
    return m_spPr;
}

const CT_ShapeProperties& CT_GvmlShape::get_spPr() const
{
    if (m_spPr)
    {
        return *m_spPr;
    }
    return CT_ShapeProperties::default_instance();
}

bool CT_GvmlShape::has_txSp() const
{
    return m_has_txSp;
}

CT_GvmlTextShape* CT_GvmlShape::mutable_txSp()
{
    m_has_txSp = true;
    if (!m_txSp)
    {
        m_txSp = new CT_GvmlTextShape();
    }
    return m_txSp;
}

const CT_GvmlTextShape& CT_GvmlShape::get_txSp() const
{
    if (m_txSp)
    {
        return *m_txSp;
    }
    return CT_GvmlTextShape::default_instance();
}

bool CT_GvmlShape::has_style() const
{
    return m_has_style;
}

CT_ShapeStyle* CT_GvmlShape::mutable_style()
{
    m_has_style = true;
    if (!m_style)
    {
        m_style = new CT_ShapeStyle();
    }
    return m_style;
}

const CT_ShapeStyle& CT_GvmlShape::get_style() const
{
    if (m_style)
    {
        return *m_style;
    }
    return CT_ShapeStyle::default_instance();
}

bool CT_GvmlShape::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_GvmlShape::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_GvmlShape::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_GvmlShape::clear()
{
    m_has_nvSpPr = false;

    if (m_nvSpPr)
    {
        delete m_nvSpPr;
        m_nvSpPr = NULL;
    }


    m_has_spPr = false;

    if (m_spPr)
    {
        delete m_spPr;
        m_spPr = NULL;
    }


    m_has_txSp = false;

    if (m_txSp)
    {
        delete m_txSp;
        m_txSp = NULL;
    }


    m_has_style = false;

    if (m_style)
    {
        delete m_style;
        m_style = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_GvmlShape::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    assert(m_has_nvSpPr);


    assert(m_has_spPr);


    if (m_has_nvSpPr)
    {
        m_nvSpPr->toXmlElem("a:nvSpPr", "", _outStream);
    }


    if (m_has_spPr)
    {
        m_spPr->toXmlElem("a:spPr", "", _outStream);
    }


    if (m_has_txSp)
    {
        m_txSp->toXmlElem("a:txSp", "", _outStream);
    }


    if (m_has_style)
    {
        m_style->toXmlElem("a:style", "", _outStream);
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_GvmlShape& CT_GvmlShape::default_instance()
{
    if (!CT_GvmlShape::default_instance_)
    {
        CT_GvmlShape::default_instance_ = new CT_GvmlShape();
    }
    return *CT_GvmlShape::default_instance_;
}

CT_GvmlShape* CT_GvmlShape::default_instance_ = NULL;

// CT_GvmlConnectorNonVisual
CT_GvmlConnectorNonVisual::CT_GvmlConnectorNonVisual()
    :m_has_cNvPr(false),
     m_cNvPr(NULL),
     m_has_cNvCxnSpPr(false),
     m_cNvCxnSpPr(NULL)
{
}
CT_GvmlConnectorNonVisual::~CT_GvmlConnectorNonVisual()
{
    clear();
}
bool CT_GvmlConnectorNonVisual::has_cNvPr() const
{
    return m_has_cNvPr;
}

CT_NonVisualDrawingProps* CT_GvmlConnectorNonVisual::mutable_cNvPr()
{
    m_has_cNvPr = true;
    if (!m_cNvPr)
    {
        m_cNvPr = new CT_NonVisualDrawingProps();
    }
    return m_cNvPr;
}

const CT_NonVisualDrawingProps& CT_GvmlConnectorNonVisual::get_cNvPr() const
{
    if (m_cNvPr)
    {
        return *m_cNvPr;
    }
    return CT_NonVisualDrawingProps::default_instance();
}

bool CT_GvmlConnectorNonVisual::has_cNvCxnSpPr() const
{
    return m_has_cNvCxnSpPr;
}

CT_NonVisualConnectorProperties* CT_GvmlConnectorNonVisual::mutable_cNvCxnSpPr()
{
    m_has_cNvCxnSpPr = true;
    if (!m_cNvCxnSpPr)
    {
        m_cNvCxnSpPr = new CT_NonVisualConnectorProperties();
    }
    return m_cNvCxnSpPr;
}

const CT_NonVisualConnectorProperties& CT_GvmlConnectorNonVisual::get_cNvCxnSpPr() const
{
    if (m_cNvCxnSpPr)
    {
        return *m_cNvCxnSpPr;
    }
    return CT_NonVisualConnectorProperties::default_instance();
}

void CT_GvmlConnectorNonVisual::clear()
{
    m_has_cNvPr = false;

    if (m_cNvPr)
    {
        delete m_cNvPr;
        m_cNvPr = NULL;
    }


    m_has_cNvCxnSpPr = false;

    if (m_cNvCxnSpPr)
    {
        delete m_cNvCxnSpPr;
        m_cNvCxnSpPr = NULL;
    }

}

void CT_GvmlConnectorNonVisual::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    assert(m_has_cNvPr);


    assert(m_has_cNvCxnSpPr);


    if (m_has_cNvPr)
    {
        m_cNvPr->toXmlElem("a:cNvPr", "", _outStream);
    }


    if (m_has_cNvCxnSpPr)
    {
        m_cNvCxnSpPr->toXmlElem("a:cNvCxnSpPr", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_GvmlConnectorNonVisual& CT_GvmlConnectorNonVisual::default_instance()
{
    if (!CT_GvmlConnectorNonVisual::default_instance_)
    {
        CT_GvmlConnectorNonVisual::default_instance_ = new CT_GvmlConnectorNonVisual();
    }
    return *CT_GvmlConnectorNonVisual::default_instance_;
}

CT_GvmlConnectorNonVisual* CT_GvmlConnectorNonVisual::default_instance_ = NULL;

// CT_GvmlConnector
CT_GvmlConnector::CT_GvmlConnector()
    :m_has_nvCxnSpPr(false),
     m_nvCxnSpPr(NULL),
     m_has_spPr(false),
     m_spPr(NULL),
     m_has_style(false),
     m_style(NULL),
     m_has_extLst(false),
     m_extLst(NULL)
{
}
CT_GvmlConnector::~CT_GvmlConnector()
{
    clear();
}
bool CT_GvmlConnector::has_nvCxnSpPr() const
{
    return m_has_nvCxnSpPr;
}

CT_GvmlConnectorNonVisual* CT_GvmlConnector::mutable_nvCxnSpPr()
{
    m_has_nvCxnSpPr = true;
    if (!m_nvCxnSpPr)
    {
        m_nvCxnSpPr = new CT_GvmlConnectorNonVisual();
    }
    return m_nvCxnSpPr;
}

const CT_GvmlConnectorNonVisual& CT_GvmlConnector::get_nvCxnSpPr() const
{
    if (m_nvCxnSpPr)
    {
        return *m_nvCxnSpPr;
    }
    return CT_GvmlConnectorNonVisual::default_instance();
}

bool CT_GvmlConnector::has_spPr() const
{
    return m_has_spPr;
}

CT_ShapeProperties* CT_GvmlConnector::mutable_spPr()
{
    m_has_spPr = true;
    if (!m_spPr)
    {
        m_spPr = new CT_ShapeProperties();
    }
    return m_spPr;
}

const CT_ShapeProperties& CT_GvmlConnector::get_spPr() const
{
    if (m_spPr)
    {
        return *m_spPr;
    }
    return CT_ShapeProperties::default_instance();
}

bool CT_GvmlConnector::has_style() const
{
    return m_has_style;
}

CT_ShapeStyle* CT_GvmlConnector::mutable_style()
{
    m_has_style = true;
    if (!m_style)
    {
        m_style = new CT_ShapeStyle();
    }
    return m_style;
}

const CT_ShapeStyle& CT_GvmlConnector::get_style() const
{
    if (m_style)
    {
        return *m_style;
    }
    return CT_ShapeStyle::default_instance();
}

bool CT_GvmlConnector::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_GvmlConnector::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_GvmlConnector::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_GvmlConnector::clear()
{
    m_has_nvCxnSpPr = false;

    if (m_nvCxnSpPr)
    {
        delete m_nvCxnSpPr;
        m_nvCxnSpPr = NULL;
    }


    m_has_spPr = false;

    if (m_spPr)
    {
        delete m_spPr;
        m_spPr = NULL;
    }


    m_has_style = false;

    if (m_style)
    {
        delete m_style;
        m_style = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_GvmlConnector::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    assert(m_has_nvCxnSpPr);


    assert(m_has_spPr);


    if (m_has_nvCxnSpPr)
    {
        m_nvCxnSpPr->toXmlElem("a:nvCxnSpPr", "", _outStream);
    }


    if (m_has_spPr)
    {
        m_spPr->toXmlElem("a:spPr", "", _outStream);
    }


    if (m_has_style)
    {
        m_style->toXmlElem("a:style", "", _outStream);
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_GvmlConnector& CT_GvmlConnector::default_instance()
{
    if (!CT_GvmlConnector::default_instance_)
    {
        CT_GvmlConnector::default_instance_ = new CT_GvmlConnector();
    }
    return *CT_GvmlConnector::default_instance_;
}

CT_GvmlConnector* CT_GvmlConnector::default_instance_ = NULL;

// CT_GvmlPictureNonVisual
CT_GvmlPictureNonVisual::CT_GvmlPictureNonVisual()
    :m_has_cNvPr(false),
     m_cNvPr(NULL),
     m_has_cNvPicPr(false),
     m_cNvPicPr(NULL)
{
}
CT_GvmlPictureNonVisual::~CT_GvmlPictureNonVisual()
{
    clear();
}
bool CT_GvmlPictureNonVisual::has_cNvPr() const
{
    return m_has_cNvPr;
}

CT_NonVisualDrawingProps* CT_GvmlPictureNonVisual::mutable_cNvPr()
{
    m_has_cNvPr = true;
    if (!m_cNvPr)
    {
        m_cNvPr = new CT_NonVisualDrawingProps();
    }
    return m_cNvPr;
}

const CT_NonVisualDrawingProps& CT_GvmlPictureNonVisual::get_cNvPr() const
{
    if (m_cNvPr)
    {
        return *m_cNvPr;
    }
    return CT_NonVisualDrawingProps::default_instance();
}

bool CT_GvmlPictureNonVisual::has_cNvPicPr() const
{
    return m_has_cNvPicPr;
}

CT_NonVisualPictureProperties* CT_GvmlPictureNonVisual::mutable_cNvPicPr()
{
    m_has_cNvPicPr = true;
    if (!m_cNvPicPr)
    {
        m_cNvPicPr = new CT_NonVisualPictureProperties();
    }
    return m_cNvPicPr;
}

const CT_NonVisualPictureProperties& CT_GvmlPictureNonVisual::get_cNvPicPr() const
{
    if (m_cNvPicPr)
    {
        return *m_cNvPicPr;
    }
    return CT_NonVisualPictureProperties::default_instance();
}

void CT_GvmlPictureNonVisual::clear()
{
    m_has_cNvPr = false;

    if (m_cNvPr)
    {
        delete m_cNvPr;
        m_cNvPr = NULL;
    }


    m_has_cNvPicPr = false;

    if (m_cNvPicPr)
    {
        delete m_cNvPicPr;
        m_cNvPicPr = NULL;
    }

}

void CT_GvmlPictureNonVisual::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    assert(m_has_cNvPr);


    assert(m_has_cNvPicPr);


    if (m_has_cNvPr)
    {
        m_cNvPr->toXmlElem("a:cNvPr", "", _outStream);
    }


    if (m_has_cNvPicPr)
    {
        m_cNvPicPr->toXmlElem("a:cNvPicPr", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_GvmlPictureNonVisual& CT_GvmlPictureNonVisual::default_instance()
{
    if (!CT_GvmlPictureNonVisual::default_instance_)
    {
        CT_GvmlPictureNonVisual::default_instance_ = new CT_GvmlPictureNonVisual();
    }
    return *CT_GvmlPictureNonVisual::default_instance_;
}

CT_GvmlPictureNonVisual* CT_GvmlPictureNonVisual::default_instance_ = NULL;

// CT_GvmlPicture
CT_GvmlPicture::CT_GvmlPicture()
    :m_has_nvPicPr(false),
     m_nvPicPr(NULL),
     m_has_blipFill(false),
     m_blipFill(NULL),
     m_has_spPr(false),
     m_spPr(NULL),
     m_has_style(false),
     m_style(NULL),
     m_has_extLst(false),
     m_extLst(NULL)
{
}
CT_GvmlPicture::~CT_GvmlPicture()
{
    clear();
}
bool CT_GvmlPicture::has_nvPicPr() const
{
    return m_has_nvPicPr;
}

CT_GvmlPictureNonVisual* CT_GvmlPicture::mutable_nvPicPr()
{
    m_has_nvPicPr = true;
    if (!m_nvPicPr)
    {
        m_nvPicPr = new CT_GvmlPictureNonVisual();
    }
    return m_nvPicPr;
}

const CT_GvmlPictureNonVisual& CT_GvmlPicture::get_nvPicPr() const
{
    if (m_nvPicPr)
    {
        return *m_nvPicPr;
    }
    return CT_GvmlPictureNonVisual::default_instance();
}

bool CT_GvmlPicture::has_blipFill() const
{
    return m_has_blipFill;
}

CT_BlipFillProperties* CT_GvmlPicture::mutable_blipFill()
{
    m_has_blipFill = true;
    if (!m_blipFill)
    {
        m_blipFill = new CT_BlipFillProperties();
    }
    return m_blipFill;
}

const CT_BlipFillProperties& CT_GvmlPicture::get_blipFill() const
{
    if (m_blipFill)
    {
        return *m_blipFill;
    }
    return CT_BlipFillProperties::default_instance();
}

bool CT_GvmlPicture::has_spPr() const
{
    return m_has_spPr;
}

CT_ShapeProperties* CT_GvmlPicture::mutable_spPr()
{
    m_has_spPr = true;
    if (!m_spPr)
    {
        m_spPr = new CT_ShapeProperties();
    }
    return m_spPr;
}

const CT_ShapeProperties& CT_GvmlPicture::get_spPr() const
{
    if (m_spPr)
    {
        return *m_spPr;
    }
    return CT_ShapeProperties::default_instance();
}

bool CT_GvmlPicture::has_style() const
{
    return m_has_style;
}

CT_ShapeStyle* CT_GvmlPicture::mutable_style()
{
    m_has_style = true;
    if (!m_style)
    {
        m_style = new CT_ShapeStyle();
    }
    return m_style;
}

const CT_ShapeStyle& CT_GvmlPicture::get_style() const
{
    if (m_style)
    {
        return *m_style;
    }
    return CT_ShapeStyle::default_instance();
}

bool CT_GvmlPicture::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_GvmlPicture::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_GvmlPicture::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_GvmlPicture::clear()
{
    m_has_nvPicPr = false;

    if (m_nvPicPr)
    {
        delete m_nvPicPr;
        m_nvPicPr = NULL;
    }


    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }


    m_has_spPr = false;

    if (m_spPr)
    {
        delete m_spPr;
        m_spPr = NULL;
    }


    m_has_style = false;

    if (m_style)
    {
        delete m_style;
        m_style = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_GvmlPicture::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    assert(m_has_nvPicPr);


    assert(m_has_blipFill);


    assert(m_has_spPr);


    if (m_has_nvPicPr)
    {
        m_nvPicPr->toXmlElem("a:nvPicPr", "", _outStream);
    }


    if (m_has_blipFill)
    {
        m_blipFill->toXmlElem("a:blipFill", "", _outStream);
    }


    if (m_has_spPr)
    {
        m_spPr->toXmlElem("a:spPr", "", _outStream);
    }


    if (m_has_style)
    {
        m_style->toXmlElem("a:style", "", _outStream);
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_GvmlPicture& CT_GvmlPicture::default_instance()
{
    if (!CT_GvmlPicture::default_instance_)
    {
        CT_GvmlPicture::default_instance_ = new CT_GvmlPicture();
    }
    return *CT_GvmlPicture::default_instance_;
}

CT_GvmlPicture* CT_GvmlPicture::default_instance_ = NULL;

// CT_GvmlGraphicFrameNonVisual
CT_GvmlGraphicFrameNonVisual::CT_GvmlGraphicFrameNonVisual()
    :m_has_cNvPr(false),
     m_cNvPr(NULL),
     m_has_cNvGraphicFramePr(false),
     m_cNvGraphicFramePr(NULL)
{
}
CT_GvmlGraphicFrameNonVisual::~CT_GvmlGraphicFrameNonVisual()
{
    clear();
}
bool CT_GvmlGraphicFrameNonVisual::has_cNvPr() const
{
    return m_has_cNvPr;
}

CT_NonVisualDrawingProps* CT_GvmlGraphicFrameNonVisual::mutable_cNvPr()
{
    m_has_cNvPr = true;
    if (!m_cNvPr)
    {
        m_cNvPr = new CT_NonVisualDrawingProps();
    }
    return m_cNvPr;
}

const CT_NonVisualDrawingProps& CT_GvmlGraphicFrameNonVisual::get_cNvPr() const
{
    if (m_cNvPr)
    {
        return *m_cNvPr;
    }
    return CT_NonVisualDrawingProps::default_instance();
}

bool CT_GvmlGraphicFrameNonVisual::has_cNvGraphicFramePr() const
{
    return m_has_cNvGraphicFramePr;
}

CT_NonVisualGraphicFrameProperties* CT_GvmlGraphicFrameNonVisual::mutable_cNvGraphicFramePr()
{
    m_has_cNvGraphicFramePr = true;
    if (!m_cNvGraphicFramePr)
    {
        m_cNvGraphicFramePr = new CT_NonVisualGraphicFrameProperties();
    }
    return m_cNvGraphicFramePr;
}

const CT_NonVisualGraphicFrameProperties& CT_GvmlGraphicFrameNonVisual::get_cNvGraphicFramePr() const
{
    if (m_cNvGraphicFramePr)
    {
        return *m_cNvGraphicFramePr;
    }
    return CT_NonVisualGraphicFrameProperties::default_instance();
}

void CT_GvmlGraphicFrameNonVisual::clear()
{
    m_has_cNvPr = false;

    if (m_cNvPr)
    {
        delete m_cNvPr;
        m_cNvPr = NULL;
    }


    m_has_cNvGraphicFramePr = false;

    if (m_cNvGraphicFramePr)
    {
        delete m_cNvGraphicFramePr;
        m_cNvGraphicFramePr = NULL;
    }

}

void CT_GvmlGraphicFrameNonVisual::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    assert(m_has_cNvPr);


    assert(m_has_cNvGraphicFramePr);


    if (m_has_cNvPr)
    {
        m_cNvPr->toXmlElem("a:cNvPr", "", _outStream);
    }


    if (m_has_cNvGraphicFramePr)
    {
        m_cNvGraphicFramePr->toXmlElem("a:cNvGraphicFramePr", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_GvmlGraphicFrameNonVisual& CT_GvmlGraphicFrameNonVisual::default_instance()
{
    if (!CT_GvmlGraphicFrameNonVisual::default_instance_)
    {
        CT_GvmlGraphicFrameNonVisual::default_instance_ = new CT_GvmlGraphicFrameNonVisual();
    }
    return *CT_GvmlGraphicFrameNonVisual::default_instance_;
}

CT_GvmlGraphicFrameNonVisual* CT_GvmlGraphicFrameNonVisual::default_instance_ = NULL;

// CT_GvmlGraphicalObjectFrame
CT_GvmlGraphicalObjectFrame::CT_GvmlGraphicalObjectFrame()
    :m_has_nvGraphicFramePr(false),
     m_nvGraphicFramePr(NULL),
     m_has_graphic(false),
     m_graphic(NULL),
     m_has_xfrm(false),
     m_xfrm(NULL),
     m_has_extLst(false),
     m_extLst(NULL)
{
}
CT_GvmlGraphicalObjectFrame::~CT_GvmlGraphicalObjectFrame()
{
    clear();
}
bool CT_GvmlGraphicalObjectFrame::has_nvGraphicFramePr() const
{
    return m_has_nvGraphicFramePr;
}

CT_GvmlGraphicFrameNonVisual* CT_GvmlGraphicalObjectFrame::mutable_nvGraphicFramePr()
{
    m_has_nvGraphicFramePr = true;
    if (!m_nvGraphicFramePr)
    {
        m_nvGraphicFramePr = new CT_GvmlGraphicFrameNonVisual();
    }
    return m_nvGraphicFramePr;
}

const CT_GvmlGraphicFrameNonVisual& CT_GvmlGraphicalObjectFrame::get_nvGraphicFramePr() const
{
    if (m_nvGraphicFramePr)
    {
        return *m_nvGraphicFramePr;
    }
    return CT_GvmlGraphicFrameNonVisual::default_instance();
}

bool CT_GvmlGraphicalObjectFrame::has_graphic() const
{
    return m_has_graphic;
}

CT_GraphicalObject* CT_GvmlGraphicalObjectFrame::mutable_graphic()
{
    m_has_graphic = true;
    if (!m_graphic)
    {
        m_graphic = new CT_GraphicalObject();
    }
    return m_graphic;
}

const CT_GraphicalObject& CT_GvmlGraphicalObjectFrame::get_graphic() const
{
    if (m_graphic)
    {
        return *m_graphic;
    }
    return CT_GraphicalObject::default_instance();
}

bool CT_GvmlGraphicalObjectFrame::has_xfrm() const
{
    return m_has_xfrm;
}

CT_Transform2D* CT_GvmlGraphicalObjectFrame::mutable_xfrm()
{
    m_has_xfrm = true;
    if (!m_xfrm)
    {
        m_xfrm = new CT_Transform2D();
    }
    return m_xfrm;
}

const CT_Transform2D& CT_GvmlGraphicalObjectFrame::get_xfrm() const
{
    if (m_xfrm)
    {
        return *m_xfrm;
    }
    return CT_Transform2D::default_instance();
}

bool CT_GvmlGraphicalObjectFrame::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_GvmlGraphicalObjectFrame::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_GvmlGraphicalObjectFrame::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_GvmlGraphicalObjectFrame::clear()
{
    m_has_nvGraphicFramePr = false;

    if (m_nvGraphicFramePr)
    {
        delete m_nvGraphicFramePr;
        m_nvGraphicFramePr = NULL;
    }


    m_has_graphic = false;

    if (m_graphic)
    {
        delete m_graphic;
        m_graphic = NULL;
    }


    m_has_xfrm = false;

    if (m_xfrm)
    {
        delete m_xfrm;
        m_xfrm = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_GvmlGraphicalObjectFrame::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    assert(m_has_nvGraphicFramePr);


    assert(m_has_graphic);


    assert(m_has_xfrm);


    if (m_has_nvGraphicFramePr)
    {
        m_nvGraphicFramePr->toXmlElem("a:nvGraphicFramePr", "", _outStream);
    }


    if (m_has_graphic)
    {
        m_graphic->toXmlElem("a:graphic", "", _outStream);
    }


    if (m_has_xfrm)
    {
        m_xfrm->toXmlElem("a:xfrm", "", _outStream);
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_GvmlGraphicalObjectFrame& CT_GvmlGraphicalObjectFrame::default_instance()
{
    if (!CT_GvmlGraphicalObjectFrame::default_instance_)
    {
        CT_GvmlGraphicalObjectFrame::default_instance_ = new CT_GvmlGraphicalObjectFrame();
    }
    return *CT_GvmlGraphicalObjectFrame::default_instance_;
}

CT_GvmlGraphicalObjectFrame* CT_GvmlGraphicalObjectFrame::default_instance_ = NULL;

// CT_GvmlGroupShapeNonVisual
CT_GvmlGroupShapeNonVisual::CT_GvmlGroupShapeNonVisual()
    :m_has_cNvPr(false),
     m_cNvPr(NULL),
     m_has_cNvGrpSpPr(false),
     m_cNvGrpSpPr(NULL)
{
}
CT_GvmlGroupShapeNonVisual::~CT_GvmlGroupShapeNonVisual()
{
    clear();
}
bool CT_GvmlGroupShapeNonVisual::has_cNvPr() const
{
    return m_has_cNvPr;
}

CT_NonVisualDrawingProps* CT_GvmlGroupShapeNonVisual::mutable_cNvPr()
{
    m_has_cNvPr = true;
    if (!m_cNvPr)
    {
        m_cNvPr = new CT_NonVisualDrawingProps();
    }
    return m_cNvPr;
}

const CT_NonVisualDrawingProps& CT_GvmlGroupShapeNonVisual::get_cNvPr() const
{
    if (m_cNvPr)
    {
        return *m_cNvPr;
    }
    return CT_NonVisualDrawingProps::default_instance();
}

bool CT_GvmlGroupShapeNonVisual::has_cNvGrpSpPr() const
{
    return m_has_cNvGrpSpPr;
}

CT_NonVisualGroupDrawingShapeProps* CT_GvmlGroupShapeNonVisual::mutable_cNvGrpSpPr()
{
    m_has_cNvGrpSpPr = true;
    if (!m_cNvGrpSpPr)
    {
        m_cNvGrpSpPr = new CT_NonVisualGroupDrawingShapeProps();
    }
    return m_cNvGrpSpPr;
}

const CT_NonVisualGroupDrawingShapeProps& CT_GvmlGroupShapeNonVisual::get_cNvGrpSpPr() const
{
    if (m_cNvGrpSpPr)
    {
        return *m_cNvGrpSpPr;
    }
    return CT_NonVisualGroupDrawingShapeProps::default_instance();
}

void CT_GvmlGroupShapeNonVisual::clear()
{
    m_has_cNvPr = false;

    if (m_cNvPr)
    {
        delete m_cNvPr;
        m_cNvPr = NULL;
    }


    m_has_cNvGrpSpPr = false;

    if (m_cNvGrpSpPr)
    {
        delete m_cNvGrpSpPr;
        m_cNvGrpSpPr = NULL;
    }

}

void CT_GvmlGroupShapeNonVisual::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    assert(m_has_cNvPr);


    assert(m_has_cNvGrpSpPr);


    if (m_has_cNvPr)
    {
        m_cNvPr->toXmlElem("a:cNvPr", "", _outStream);
    }


    if (m_has_cNvGrpSpPr)
    {
        m_cNvGrpSpPr->toXmlElem("a:cNvGrpSpPr", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_GvmlGroupShapeNonVisual& CT_GvmlGroupShapeNonVisual::default_instance()
{
    if (!CT_GvmlGroupShapeNonVisual::default_instance_)
    {
        CT_GvmlGroupShapeNonVisual::default_instance_ = new CT_GvmlGroupShapeNonVisual();
    }
    return *CT_GvmlGroupShapeNonVisual::default_instance_;
}

CT_GvmlGroupShapeNonVisual* CT_GvmlGroupShapeNonVisual::default_instance_ = NULL;

// CT_GvmlGroupShape
CT_GvmlGroupShape::CT_GvmlGroupShape()
    :m_has_nvGrpSpPr(false),
     m_nvGrpSpPr(NULL),
     m_has_grpSpPr(false),
     m_grpSpPr(NULL),
     m_has_extLst(false),
     m_extLst(NULL)
{
}
CT_GvmlGroupShape::~CT_GvmlGroupShape()
{
    clear();
}
bool CT_GvmlGroupShape::has_nvGrpSpPr() const
{
    return m_has_nvGrpSpPr;
}

CT_GvmlGroupShapeNonVisual* CT_GvmlGroupShape::mutable_nvGrpSpPr()
{
    m_has_nvGrpSpPr = true;
    if (!m_nvGrpSpPr)
    {
        m_nvGrpSpPr = new CT_GvmlGroupShapeNonVisual();
    }
    return m_nvGrpSpPr;
}

const CT_GvmlGroupShapeNonVisual& CT_GvmlGroupShape::get_nvGrpSpPr() const
{
    if (m_nvGrpSpPr)
    {
        return *m_nvGrpSpPr;
    }
    return CT_GvmlGroupShapeNonVisual::default_instance();
}

bool CT_GvmlGroupShape::has_grpSpPr() const
{
    return m_has_grpSpPr;
}

CT_GroupShapeProperties* CT_GvmlGroupShape::mutable_grpSpPr()
{
    m_has_grpSpPr = true;
    if (!m_grpSpPr)
    {
        m_grpSpPr = new CT_GroupShapeProperties();
    }
    return m_grpSpPr;
}

const CT_GroupShapeProperties& CT_GvmlGroupShape::get_grpSpPr() const
{
    if (m_grpSpPr)
    {
        return *m_grpSpPr;
    }
    return CT_GroupShapeProperties::default_instance();
}

CT_GvmlTextShape* CT_GvmlGroupShape::add_txSp()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_GvmlTextShape* pNewChild = pChildGroup->mutable_txSp();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_GvmlShape* CT_GvmlGroupShape::add_sp()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_GvmlShape* pNewChild = pChildGroup->mutable_sp();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_GvmlConnector* CT_GvmlGroupShape::add_cxnSp()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_GvmlConnector* pNewChild = pChildGroup->mutable_cxnSp();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_GvmlPicture* CT_GvmlGroupShape::add_pic()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_GvmlPicture* pNewChild = pChildGroup->mutable_pic();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_GvmlGraphicalObjectFrame* CT_GvmlGroupShape::add_graphicFrame()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_GvmlGraphicalObjectFrame* pNewChild = pChildGroup->mutable_graphicFrame();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_GvmlGroupShape* CT_GvmlGroupShape::add_grpSp()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_GvmlGroupShape* pNewChild = pChildGroup->mutable_grpSp();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

bool CT_GvmlGroupShape::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_GvmlGroupShape::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_GvmlGroupShape::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_GvmlGroupShape::clear()
{
    m_has_nvGrpSpPr = false;

    if (m_nvGrpSpPr)
    {
        delete m_nvGrpSpPr;
        m_nvGrpSpPr = NULL;
    }


    m_has_grpSpPr = false;

    if (m_grpSpPr)
    {
        delete m_grpSpPr;
        m_grpSpPr = NULL;
    }


    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }

    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_GvmlGroupShape::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    assert(m_has_nvGrpSpPr);


    assert(m_has_grpSpPr);


    if (m_has_nvGrpSpPr)
    {
        m_nvGrpSpPr->toXmlElem("a:nvGrpSpPr", "", _outStream);
    }


    if (m_has_grpSpPr)
    {
        m_grpSpPr->toXmlElem("a:grpSpPr", "", _outStream);
    }

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_txSp())
            {
                (*iter)->get_txSp().toXmlElem("a:txSp", "", _outStream);
            }


            else if ((*iter)->has_sp())
            {
                (*iter)->get_sp().toXmlElem("a:sp", "", _outStream);
            }


            else if ((*iter)->has_cxnSp())
            {
                (*iter)->get_cxnSp().toXmlElem("a:cxnSp", "", _outStream);
            }


            else if ((*iter)->has_pic())
            {
                (*iter)->get_pic().toXmlElem("a:pic", "", _outStream);
            }


            else if ((*iter)->has_graphicFrame())
            {
                (*iter)->get_graphicFrame().toXmlElem("a:graphicFrame", "", _outStream);
            }


            else if ((*iter)->has_grpSp())
            {
                (*iter)->get_grpSp().toXmlElem("a:grpSp", "", _outStream);
            }


        }
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_GvmlGroupShape& CT_GvmlGroupShape::default_instance()
{
    if (!CT_GvmlGroupShape::default_instance_)
    {
        CT_GvmlGroupShape::default_instance_ = new CT_GvmlGroupShape();
    }
    return *CT_GvmlGroupShape::default_instance_;
}


// CT_GvmlGroupShape::ChildGroup_1
CT_GvmlGroupShape::ChildGroup_1::ChildGroup_1()
    :m_has_txSp(false),
     m_txSp(NULL),
     m_has_sp(false),
     m_sp(NULL),
     m_has_cxnSp(false),
     m_cxnSp(NULL),
     m_has_pic(false),
     m_pic(NULL),
     m_has_graphicFrame(false),
     m_graphicFrame(NULL),
     m_has_grpSp(false),
     m_grpSp(NULL)
{
}
bool CT_GvmlGroupShape::ChildGroup_1::has_txSp() const
{
    return m_has_txSp;
}

CT_GvmlTextShape* CT_GvmlGroupShape::ChildGroup_1::mutable_txSp()
{

    m_has_sp = false;

    if (m_sp)
    {
        delete m_sp;
        m_sp = NULL;
    }
    ;

    m_has_cxnSp = false;

    if (m_cxnSp)
    {
        delete m_cxnSp;
        m_cxnSp = NULL;
    }
    ;

    m_has_pic = false;

    if (m_pic)
    {
        delete m_pic;
        m_pic = NULL;
    }
    ;

    m_has_graphicFrame = false;

    if (m_graphicFrame)
    {
        delete m_graphicFrame;
        m_graphicFrame = NULL;
    }
    ;

    m_has_grpSp = false;

    if (m_grpSp)
    {
        delete m_grpSp;
        m_grpSp = NULL;
    }
    ;

    m_has_txSp = true;
    if (!m_txSp)
    {
        m_txSp = new CT_GvmlTextShape();
    }
    return m_txSp;
}

const CT_GvmlTextShape& CT_GvmlGroupShape::ChildGroup_1::get_txSp() const
{
    if (m_txSp)
    {
        return *m_txSp;
    }
    return CT_GvmlTextShape::default_instance();
}

bool CT_GvmlGroupShape::ChildGroup_1::has_sp() const
{
    return m_has_sp;
}

CT_GvmlShape* CT_GvmlGroupShape::ChildGroup_1::mutable_sp()
{

    m_has_txSp = false;

    if (m_txSp)
    {
        delete m_txSp;
        m_txSp = NULL;
    }
    ;

    m_has_cxnSp = false;

    if (m_cxnSp)
    {
        delete m_cxnSp;
        m_cxnSp = NULL;
    }
    ;

    m_has_pic = false;

    if (m_pic)
    {
        delete m_pic;
        m_pic = NULL;
    }
    ;

    m_has_graphicFrame = false;

    if (m_graphicFrame)
    {
        delete m_graphicFrame;
        m_graphicFrame = NULL;
    }
    ;

    m_has_grpSp = false;

    if (m_grpSp)
    {
        delete m_grpSp;
        m_grpSp = NULL;
    }
    ;

    m_has_sp = true;
    if (!m_sp)
    {
        m_sp = new CT_GvmlShape();
    }
    return m_sp;
}

const CT_GvmlShape& CT_GvmlGroupShape::ChildGroup_1::get_sp() const
{
    if (m_sp)
    {
        return *m_sp;
    }
    return CT_GvmlShape::default_instance();
}

bool CT_GvmlGroupShape::ChildGroup_1::has_cxnSp() const
{
    return m_has_cxnSp;
}

CT_GvmlConnector* CT_GvmlGroupShape::ChildGroup_1::mutable_cxnSp()
{

    m_has_txSp = false;

    if (m_txSp)
    {
        delete m_txSp;
        m_txSp = NULL;
    }
    ;

    m_has_sp = false;

    if (m_sp)
    {
        delete m_sp;
        m_sp = NULL;
    }
    ;

    m_has_pic = false;

    if (m_pic)
    {
        delete m_pic;
        m_pic = NULL;
    }
    ;

    m_has_graphicFrame = false;

    if (m_graphicFrame)
    {
        delete m_graphicFrame;
        m_graphicFrame = NULL;
    }
    ;

    m_has_grpSp = false;

    if (m_grpSp)
    {
        delete m_grpSp;
        m_grpSp = NULL;
    }
    ;

    m_has_cxnSp = true;
    if (!m_cxnSp)
    {
        m_cxnSp = new CT_GvmlConnector();
    }
    return m_cxnSp;
}

const CT_GvmlConnector& CT_GvmlGroupShape::ChildGroup_1::get_cxnSp() const
{
    if (m_cxnSp)
    {
        return *m_cxnSp;
    }
    return CT_GvmlConnector::default_instance();
}

bool CT_GvmlGroupShape::ChildGroup_1::has_pic() const
{
    return m_has_pic;
}

CT_GvmlPicture* CT_GvmlGroupShape::ChildGroup_1::mutable_pic()
{

    m_has_txSp = false;

    if (m_txSp)
    {
        delete m_txSp;
        m_txSp = NULL;
    }
    ;

    m_has_sp = false;

    if (m_sp)
    {
        delete m_sp;
        m_sp = NULL;
    }
    ;

    m_has_cxnSp = false;

    if (m_cxnSp)
    {
        delete m_cxnSp;
        m_cxnSp = NULL;
    }
    ;

    m_has_graphicFrame = false;

    if (m_graphicFrame)
    {
        delete m_graphicFrame;
        m_graphicFrame = NULL;
    }
    ;

    m_has_grpSp = false;

    if (m_grpSp)
    {
        delete m_grpSp;
        m_grpSp = NULL;
    }
    ;

    m_has_pic = true;
    if (!m_pic)
    {
        m_pic = new CT_GvmlPicture();
    }
    return m_pic;
}

const CT_GvmlPicture& CT_GvmlGroupShape::ChildGroup_1::get_pic() const
{
    if (m_pic)
    {
        return *m_pic;
    }
    return CT_GvmlPicture::default_instance();
}

bool CT_GvmlGroupShape::ChildGroup_1::has_graphicFrame() const
{
    return m_has_graphicFrame;
}

CT_GvmlGraphicalObjectFrame* CT_GvmlGroupShape::ChildGroup_1::mutable_graphicFrame()
{

    m_has_txSp = false;

    if (m_txSp)
    {
        delete m_txSp;
        m_txSp = NULL;
    }
    ;

    m_has_sp = false;

    if (m_sp)
    {
        delete m_sp;
        m_sp = NULL;
    }
    ;

    m_has_cxnSp = false;

    if (m_cxnSp)
    {
        delete m_cxnSp;
        m_cxnSp = NULL;
    }
    ;

    m_has_pic = false;

    if (m_pic)
    {
        delete m_pic;
        m_pic = NULL;
    }
    ;

    m_has_grpSp = false;

    if (m_grpSp)
    {
        delete m_grpSp;
        m_grpSp = NULL;
    }
    ;

    m_has_graphicFrame = true;
    if (!m_graphicFrame)
    {
        m_graphicFrame = new CT_GvmlGraphicalObjectFrame();
    }
    return m_graphicFrame;
}

const CT_GvmlGraphicalObjectFrame& CT_GvmlGroupShape::ChildGroup_1::get_graphicFrame() const
{
    if (m_graphicFrame)
    {
        return *m_graphicFrame;
    }
    return CT_GvmlGraphicalObjectFrame::default_instance();
}

bool CT_GvmlGroupShape::ChildGroup_1::has_grpSp() const
{
    return m_has_grpSp;
}

CT_GvmlGroupShape* CT_GvmlGroupShape::ChildGroup_1::mutable_grpSp()
{

    m_has_txSp = false;

    if (m_txSp)
    {
        delete m_txSp;
        m_txSp = NULL;
    }
    ;

    m_has_sp = false;

    if (m_sp)
    {
        delete m_sp;
        m_sp = NULL;
    }
    ;

    m_has_cxnSp = false;

    if (m_cxnSp)
    {
        delete m_cxnSp;
        m_cxnSp = NULL;
    }
    ;

    m_has_pic = false;

    if (m_pic)
    {
        delete m_pic;
        m_pic = NULL;
    }
    ;

    m_has_graphicFrame = false;

    if (m_graphicFrame)
    {
        delete m_graphicFrame;
        m_graphicFrame = NULL;
    }
    ;

    m_has_grpSp = true;
    if (!m_grpSp)
    {
        m_grpSp = new CT_GvmlGroupShape();
    }
    return m_grpSp;
}

const CT_GvmlGroupShape& CT_GvmlGroupShape::ChildGroup_1::get_grpSp() const
{
    if (m_grpSp)
    {
        return *m_grpSp;
    }
    return CT_GvmlGroupShape::default_instance();
}

CT_GvmlGroupShape* CT_GvmlGroupShape::default_instance_ = NULL;

// CT_Camera
CT_Camera::CT_Camera()
    :m_has_rot(false),
     m_rot(NULL),
     m_has_prst_attr(false),
     m_prst_attr(NULL),
     m_has_fov_attr(false),
     m_fov_attr(NULL),
     m_has_zoom_attr(false),
     m_zoom_attr(NULL)
{
}
CT_Camera::~CT_Camera()
{
    clear();
}
bool CT_Camera::has_rot() const
{
    return m_has_rot;
}

CT_SphereCoords* CT_Camera::mutable_rot()
{
    m_has_rot = true;
    if (!m_rot)
    {
        m_rot = new CT_SphereCoords();
    }
    return m_rot;
}

const CT_SphereCoords& CT_Camera::get_rot() const
{
    if (m_rot)
    {
        return *m_rot;
    }
    return CT_SphereCoords::default_instance();
}

void CT_Camera::clear()
{
    m_has_prst_attr = false;

    if (m_prst_attr)
    {
        delete m_prst_attr;
        m_prst_attr = NULL;
    }


    m_has_fov_attr = false;

    if (m_fov_attr)
    {
        delete m_fov_attr;
        m_fov_attr = NULL;
    }


    m_has_zoom_attr = false;

    if (m_zoom_attr)
    {
        delete m_zoom_attr;
        m_zoom_attr = NULL;
    }


    m_has_rot = false;

    if (m_rot)
    {
        delete m_rot;
        m_rot = NULL;
    }

}

void CT_Camera::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_prst_attr);
    if (m_has_prst_attr)
    {
        m_prst_attr->toXmlAttr("prst", _outStream);
    }



    if (m_has_fov_attr)
    {
        m_fov_attr->toXmlAttr("fov", _outStream);
    }



    if (m_has_zoom_attr)
    {
        m_zoom_attr->toXmlAttr("zoom", _outStream);
    }

    _outStream << ">";


    if (m_has_rot)
    {
        m_rot->toXmlElem("a:rot", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_Camera& CT_Camera::default_instance()
{
    if (!CT_Camera::default_instance_)
    {
        CT_Camera::default_instance_ = new CT_Camera();
    }
    return *CT_Camera::default_instance_;
}

bool CT_Camera::has_prst_attr() const
{
    return m_has_prst_attr;
}

void CT_Camera::set_prst_attr(const ST_PresetCameraType& _prst_attr)
{
    m_has_prst_attr = true;
    m_prst_attr = new ST_PresetCameraType(_prst_attr);
}

const ST_PresetCameraType& CT_Camera::get_prst_attr() const
{
    if (m_prst_attr)
    {
        return *m_prst_attr;
    }
    return ST_PresetCameraType::default_instance();
}

bool CT_Camera::has_fov_attr() const
{
    return m_has_fov_attr;
}

void CT_Camera::set_fov_attr(const ST_FOVAngle& _fov_attr)
{
    m_has_fov_attr = true;
    m_fov_attr = new ST_FOVAngle(_fov_attr);
}

const ST_FOVAngle& CT_Camera::get_fov_attr() const
{
    if (m_fov_attr)
    {
        return *m_fov_attr;
    }
    return ST_FOVAngle::default_instance();
}

bool CT_Camera::has_zoom_attr() const
{
    return m_has_zoom_attr;
}

void CT_Camera::set_zoom_attr(const ST_PositivePercentage& _zoom_attr)
{
    m_has_zoom_attr = true;
    m_zoom_attr = new ST_PositivePercentage(_zoom_attr);
}

const ST_PositivePercentage& CT_Camera::get_zoom_attr() const
{
    if (m_zoom_attr)
    {
        return *m_zoom_attr;
    }
    return ST_PositivePercentage::default_instance();
}

CT_Camera* CT_Camera::default_instance_ = NULL;

// CT_LightRig
CT_LightRig::CT_LightRig()
    :m_has_rot(false),
     m_rot(NULL),
     m_has_rig_attr(false),
     m_rig_attr(NULL),
     m_has_dir_attr(false),
     m_dir_attr(NULL)
{
}
CT_LightRig::~CT_LightRig()
{
    clear();
}
bool CT_LightRig::has_rot() const
{
    return m_has_rot;
}

CT_SphereCoords* CT_LightRig::mutable_rot()
{
    m_has_rot = true;
    if (!m_rot)
    {
        m_rot = new CT_SphereCoords();
    }
    return m_rot;
}

const CT_SphereCoords& CT_LightRig::get_rot() const
{
    if (m_rot)
    {
        return *m_rot;
    }
    return CT_SphereCoords::default_instance();
}

void CT_LightRig::clear()
{
    m_has_rig_attr = false;

    if (m_rig_attr)
    {
        delete m_rig_attr;
        m_rig_attr = NULL;
    }


    m_has_dir_attr = false;

    if (m_dir_attr)
    {
        delete m_dir_attr;
        m_dir_attr = NULL;
    }


    m_has_rot = false;

    if (m_rot)
    {
        delete m_rot;
        m_rot = NULL;
    }

}

void CT_LightRig::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_rig_attr);
    if (m_has_rig_attr)
    {
        m_rig_attr->toXmlAttr("rig", _outStream);
    }


    assert(m_has_dir_attr);
    if (m_has_dir_attr)
    {
        m_dir_attr->toXmlAttr("dir", _outStream);
    }

    _outStream << ">";


    if (m_has_rot)
    {
        m_rot->toXmlElem("a:rot", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_LightRig& CT_LightRig::default_instance()
{
    if (!CT_LightRig::default_instance_)
    {
        CT_LightRig::default_instance_ = new CT_LightRig();
    }
    return *CT_LightRig::default_instance_;
}

bool CT_LightRig::has_rig_attr() const
{
    return m_has_rig_attr;
}

void CT_LightRig::set_rig_attr(const ST_LightRigType& _rig_attr)
{
    m_has_rig_attr = true;
    m_rig_attr = new ST_LightRigType(_rig_attr);
}

const ST_LightRigType& CT_LightRig::get_rig_attr() const
{
    if (m_rig_attr)
    {
        return *m_rig_attr;
    }
    return ST_LightRigType::default_instance();
}

bool CT_LightRig::has_dir_attr() const
{
    return m_has_dir_attr;
}

void CT_LightRig::set_dir_attr(const ST_LightRigDirection& _dir_attr)
{
    m_has_dir_attr = true;
    m_dir_attr = new ST_LightRigDirection(_dir_attr);
}

const ST_LightRigDirection& CT_LightRig::get_dir_attr() const
{
    if (m_dir_attr)
    {
        return *m_dir_attr;
    }
    return ST_LightRigDirection::default_instance();
}

CT_LightRig* CT_LightRig::default_instance_ = NULL;

// CT_Scene3D
CT_Scene3D::CT_Scene3D()
    :m_has_camera(false),
     m_camera(NULL),
     m_has_lightRig(false),
     m_lightRig(NULL),
     m_has_backdrop(false),
     m_backdrop(NULL),
     m_has_extLst(false),
     m_extLst(NULL)
{
}
CT_Scene3D::~CT_Scene3D()
{
    clear();
}
bool CT_Scene3D::has_camera() const
{
    return m_has_camera;
}

CT_Camera* CT_Scene3D::mutable_camera()
{
    m_has_camera = true;
    if (!m_camera)
    {
        m_camera = new CT_Camera();
    }
    return m_camera;
}

const CT_Camera& CT_Scene3D::get_camera() const
{
    if (m_camera)
    {
        return *m_camera;
    }
    return CT_Camera::default_instance();
}

bool CT_Scene3D::has_lightRig() const
{
    return m_has_lightRig;
}

CT_LightRig* CT_Scene3D::mutable_lightRig()
{
    m_has_lightRig = true;
    if (!m_lightRig)
    {
        m_lightRig = new CT_LightRig();
    }
    return m_lightRig;
}

const CT_LightRig& CT_Scene3D::get_lightRig() const
{
    if (m_lightRig)
    {
        return *m_lightRig;
    }
    return CT_LightRig::default_instance();
}

bool CT_Scene3D::has_backdrop() const
{
    return m_has_backdrop;
}

CT_Backdrop* CT_Scene3D::mutable_backdrop()
{
    m_has_backdrop = true;
    if (!m_backdrop)
    {
        m_backdrop = new CT_Backdrop();
    }
    return m_backdrop;
}

const CT_Backdrop& CT_Scene3D::get_backdrop() const
{
    if (m_backdrop)
    {
        return *m_backdrop;
    }
    return CT_Backdrop::default_instance();
}

bool CT_Scene3D::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_Scene3D::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_Scene3D::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_Scene3D::clear()
{
    m_has_camera = false;

    if (m_camera)
    {
        delete m_camera;
        m_camera = NULL;
    }


    m_has_lightRig = false;

    if (m_lightRig)
    {
        delete m_lightRig;
        m_lightRig = NULL;
    }


    m_has_backdrop = false;

    if (m_backdrop)
    {
        delete m_backdrop;
        m_backdrop = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_Scene3D::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    assert(m_has_camera);


    assert(m_has_lightRig);


    if (m_has_camera)
    {
        m_camera->toXmlElem("a:camera", "", _outStream);
    }


    if (m_has_lightRig)
    {
        m_lightRig->toXmlElem("a:lightRig", "", _outStream);
    }


    if (m_has_backdrop)
    {
        m_backdrop->toXmlElem("a:backdrop", "", _outStream);
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_Scene3D& CT_Scene3D::default_instance()
{
    if (!CT_Scene3D::default_instance_)
    {
        CT_Scene3D::default_instance_ = new CT_Scene3D();
    }
    return *CT_Scene3D::default_instance_;
}

CT_Scene3D* CT_Scene3D::default_instance_ = NULL;

// CT_Backdrop
CT_Backdrop::CT_Backdrop()
    :m_has_anchor(false),
     m_anchor(NULL),
     m_has_norm(false),
     m_norm(NULL),
     m_has_up(false),
     m_up(NULL),
     m_has_extLst(false),
     m_extLst(NULL)
{
}
CT_Backdrop::~CT_Backdrop()
{
    clear();
}
bool CT_Backdrop::has_anchor() const
{
    return m_has_anchor;
}

CT_Point3D* CT_Backdrop::mutable_anchor()
{
    m_has_anchor = true;
    if (!m_anchor)
    {
        m_anchor = new CT_Point3D();
    }
    return m_anchor;
}

const CT_Point3D& CT_Backdrop::get_anchor() const
{
    if (m_anchor)
    {
        return *m_anchor;
    }
    return CT_Point3D::default_instance();
}

bool CT_Backdrop::has_norm() const
{
    return m_has_norm;
}

CT_Vector3D* CT_Backdrop::mutable_norm()
{
    m_has_norm = true;
    if (!m_norm)
    {
        m_norm = new CT_Vector3D();
    }
    return m_norm;
}

const CT_Vector3D& CT_Backdrop::get_norm() const
{
    if (m_norm)
    {
        return *m_norm;
    }
    return CT_Vector3D::default_instance();
}

bool CT_Backdrop::has_up() const
{
    return m_has_up;
}

CT_Vector3D* CT_Backdrop::mutable_up()
{
    m_has_up = true;
    if (!m_up)
    {
        m_up = new CT_Vector3D();
    }
    return m_up;
}

const CT_Vector3D& CT_Backdrop::get_up() const
{
    if (m_up)
    {
        return *m_up;
    }
    return CT_Vector3D::default_instance();
}

bool CT_Backdrop::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_Backdrop::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_Backdrop::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_Backdrop::clear()
{
    m_has_anchor = false;

    if (m_anchor)
    {
        delete m_anchor;
        m_anchor = NULL;
    }


    m_has_norm = false;

    if (m_norm)
    {
        delete m_norm;
        m_norm = NULL;
    }


    m_has_up = false;

    if (m_up)
    {
        delete m_up;
        m_up = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_Backdrop::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    assert(m_has_anchor);


    assert(m_has_norm);


    assert(m_has_up);


    if (m_has_anchor)
    {
        m_anchor->toXmlElem("a:anchor", "", _outStream);
    }


    if (m_has_norm)
    {
        m_norm->toXmlElem("a:norm", "", _outStream);
    }


    if (m_has_up)
    {
        m_up->toXmlElem("a:up", "", _outStream);
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_Backdrop& CT_Backdrop::default_instance()
{
    if (!CT_Backdrop::default_instance_)
    {
        CT_Backdrop::default_instance_ = new CT_Backdrop();
    }
    return *CT_Backdrop::default_instance_;
}

CT_Backdrop* CT_Backdrop::default_instance_ = NULL;

// CT_Bevel
CT_Bevel::CT_Bevel()
    :m_has_w_attr(false),
     m_w_attr(NULL),
     m_has_h_attr(false),
     m_h_attr(NULL),
     m_has_prst_attr(false),
     m_prst_attr(NULL)
{
}
CT_Bevel::~CT_Bevel()
{
    clear();
}
void CT_Bevel::clear()
{
    m_has_w_attr = false;

    if (m_w_attr)
    {
        delete m_w_attr;
        m_w_attr = NULL;
    }


    m_has_h_attr = false;

    if (m_h_attr)
    {
        delete m_h_attr;
        m_h_attr = NULL;
    }


    m_has_prst_attr = false;

    if (m_prst_attr)
    {
        delete m_prst_attr;
        m_prst_attr = NULL;
    }

}

void CT_Bevel::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_w_attr)
    {
        m_w_attr->toXmlAttr("w", _outStream);
    }



    if (m_has_h_attr)
    {
        m_h_attr->toXmlAttr("h", _outStream);
    }



    if (m_has_prst_attr)
    {
        m_prst_attr->toXmlAttr("prst", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_Bevel& CT_Bevel::default_instance()
{
    if (!CT_Bevel::default_instance_)
    {
        CT_Bevel::default_instance_ = new CT_Bevel();
    }
    return *CT_Bevel::default_instance_;
}

bool CT_Bevel::has_w_attr() const
{
    return m_has_w_attr;
}

void CT_Bevel::set_w_attr(const ST_PositiveCoordinate& _w_attr)
{
    m_has_w_attr = true;
    m_w_attr = new ST_PositiveCoordinate(_w_attr);
}

const ST_PositiveCoordinate& CT_Bevel::get_w_attr() const
{
    if (m_w_attr)
    {
        return *m_w_attr;
    }
    return ST_PositiveCoordinate::default_instance();
}

bool CT_Bevel::has_h_attr() const
{
    return m_has_h_attr;
}

void CT_Bevel::set_h_attr(const ST_PositiveCoordinate& _h_attr)
{
    m_has_h_attr = true;
    m_h_attr = new ST_PositiveCoordinate(_h_attr);
}

const ST_PositiveCoordinate& CT_Bevel::get_h_attr() const
{
    if (m_h_attr)
    {
        return *m_h_attr;
    }
    return ST_PositiveCoordinate::default_instance();
}

bool CT_Bevel::has_prst_attr() const
{
    return m_has_prst_attr;
}

void CT_Bevel::set_prst_attr(const ST_BevelPresetType& _prst_attr)
{
    m_has_prst_attr = true;
    m_prst_attr = new ST_BevelPresetType(_prst_attr);
}

const ST_BevelPresetType& CT_Bevel::get_prst_attr() const
{
    if (m_prst_attr)
    {
        return *m_prst_attr;
    }
    return ST_BevelPresetType::default_instance();
}

CT_Bevel* CT_Bevel::default_instance_ = NULL;

// CT_Shape3D
CT_Shape3D::CT_Shape3D()
    :m_has_bevelT(false),
     m_bevelT(NULL),
     m_has_bevelB(false),
     m_bevelB(NULL),
     m_has_extrusionClr(false),
     m_extrusionClr(NULL),
     m_has_contourClr(false),
     m_contourClr(NULL),
     m_has_extLst(false),
     m_extLst(NULL),
     m_has_z_attr(false),
     m_z_attr(NULL),
     m_has_extrusionH_attr(false),
     m_extrusionH_attr(NULL),
     m_has_contourW_attr(false),
     m_contourW_attr(NULL),
     m_has_prstMaterial_attr(false),
     m_prstMaterial_attr(NULL)
{
}
CT_Shape3D::~CT_Shape3D()
{
    clear();
}
bool CT_Shape3D::has_bevelT() const
{
    return m_has_bevelT;
}

CT_Bevel* CT_Shape3D::mutable_bevelT()
{
    m_has_bevelT = true;
    if (!m_bevelT)
    {
        m_bevelT = new CT_Bevel();
    }
    return m_bevelT;
}

const CT_Bevel& CT_Shape3D::get_bevelT() const
{
    if (m_bevelT)
    {
        return *m_bevelT;
    }
    return CT_Bevel::default_instance();
}

bool CT_Shape3D::has_bevelB() const
{
    return m_has_bevelB;
}

CT_Bevel* CT_Shape3D::mutable_bevelB()
{
    m_has_bevelB = true;
    if (!m_bevelB)
    {
        m_bevelB = new CT_Bevel();
    }
    return m_bevelB;
}

const CT_Bevel& CT_Shape3D::get_bevelB() const
{
    if (m_bevelB)
    {
        return *m_bevelB;
    }
    return CT_Bevel::default_instance();
}

bool CT_Shape3D::has_extrusionClr() const
{
    return m_has_extrusionClr;
}

CT_Color* CT_Shape3D::mutable_extrusionClr()
{
    m_has_extrusionClr = true;
    if (!m_extrusionClr)
    {
        m_extrusionClr = new CT_Color();
    }
    return m_extrusionClr;
}

const CT_Color& CT_Shape3D::get_extrusionClr() const
{
    if (m_extrusionClr)
    {
        return *m_extrusionClr;
    }
    return CT_Color::default_instance();
}

bool CT_Shape3D::has_contourClr() const
{
    return m_has_contourClr;
}

CT_Color* CT_Shape3D::mutable_contourClr()
{
    m_has_contourClr = true;
    if (!m_contourClr)
    {
        m_contourClr = new CT_Color();
    }
    return m_contourClr;
}

const CT_Color& CT_Shape3D::get_contourClr() const
{
    if (m_contourClr)
    {
        return *m_contourClr;
    }
    return CT_Color::default_instance();
}

bool CT_Shape3D::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_Shape3D::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_Shape3D::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_Shape3D::clear()
{
    m_has_z_attr = false;

    if (m_z_attr)
    {
        delete m_z_attr;
        m_z_attr = NULL;
    }


    m_has_extrusionH_attr = false;

    if (m_extrusionH_attr)
    {
        delete m_extrusionH_attr;
        m_extrusionH_attr = NULL;
    }


    m_has_contourW_attr = false;

    if (m_contourW_attr)
    {
        delete m_contourW_attr;
        m_contourW_attr = NULL;
    }


    m_has_prstMaterial_attr = false;

    if (m_prstMaterial_attr)
    {
        delete m_prstMaterial_attr;
        m_prstMaterial_attr = NULL;
    }


    m_has_bevelT = false;

    if (m_bevelT)
    {
        delete m_bevelT;
        m_bevelT = NULL;
    }


    m_has_bevelB = false;

    if (m_bevelB)
    {
        delete m_bevelB;
        m_bevelB = NULL;
    }


    m_has_extrusionClr = false;

    if (m_extrusionClr)
    {
        delete m_extrusionClr;
        m_extrusionClr = NULL;
    }


    m_has_contourClr = false;

    if (m_contourClr)
    {
        delete m_contourClr;
        m_contourClr = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_Shape3D::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_z_attr)
    {
        m_z_attr->toXmlAttr("z", _outStream);
    }



    if (m_has_extrusionH_attr)
    {
        m_extrusionH_attr->toXmlAttr("extrusionH", _outStream);
    }



    if (m_has_contourW_attr)
    {
        m_contourW_attr->toXmlAttr("contourW", _outStream);
    }



    if (m_has_prstMaterial_attr)
    {
        m_prstMaterial_attr->toXmlAttr("prstMaterial", _outStream);
    }

    _outStream << ">";


    if (m_has_bevelT)
    {
        m_bevelT->toXmlElem("a:bevelT", "", _outStream);
    }


    if (m_has_bevelB)
    {
        m_bevelB->toXmlElem("a:bevelB", "", _outStream);
    }


    if (m_has_extrusionClr)
    {
        m_extrusionClr->toXmlElem("a:extrusionClr", "", _outStream);
    }


    if (m_has_contourClr)
    {
        m_contourClr->toXmlElem("a:contourClr", "", _outStream);
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_Shape3D& CT_Shape3D::default_instance()
{
    if (!CT_Shape3D::default_instance_)
    {
        CT_Shape3D::default_instance_ = new CT_Shape3D();
    }
    return *CT_Shape3D::default_instance_;
}

bool CT_Shape3D::has_z_attr() const
{
    return m_has_z_attr;
}

void CT_Shape3D::set_z_attr(const ST_Coordinate& _z_attr)
{
    m_has_z_attr = true;
    m_z_attr = new ST_Coordinate(_z_attr);
}

const ST_Coordinate& CT_Shape3D::get_z_attr() const
{
    if (m_z_attr)
    {
        return *m_z_attr;
    }
    return ST_Coordinate::default_instance();
}

bool CT_Shape3D::has_extrusionH_attr() const
{
    return m_has_extrusionH_attr;
}

void CT_Shape3D::set_extrusionH_attr(const ST_PositiveCoordinate& _extrusionH_attr)
{
    m_has_extrusionH_attr = true;
    m_extrusionH_attr = new ST_PositiveCoordinate(_extrusionH_attr);
}

const ST_PositiveCoordinate& CT_Shape3D::get_extrusionH_attr() const
{
    if (m_extrusionH_attr)
    {
        return *m_extrusionH_attr;
    }
    return ST_PositiveCoordinate::default_instance();
}

bool CT_Shape3D::has_contourW_attr() const
{
    return m_has_contourW_attr;
}

void CT_Shape3D::set_contourW_attr(const ST_PositiveCoordinate& _contourW_attr)
{
    m_has_contourW_attr = true;
    m_contourW_attr = new ST_PositiveCoordinate(_contourW_attr);
}

const ST_PositiveCoordinate& CT_Shape3D::get_contourW_attr() const
{
    if (m_contourW_attr)
    {
        return *m_contourW_attr;
    }
    return ST_PositiveCoordinate::default_instance();
}

bool CT_Shape3D::has_prstMaterial_attr() const
{
    return m_has_prstMaterial_attr;
}

void CT_Shape3D::set_prstMaterial_attr(const ST_PresetMaterialType& _prstMaterial_attr)
{
    m_has_prstMaterial_attr = true;
    m_prstMaterial_attr = new ST_PresetMaterialType(_prstMaterial_attr);
}

const ST_PresetMaterialType& CT_Shape3D::get_prstMaterial_attr() const
{
    if (m_prstMaterial_attr)
    {
        return *m_prstMaterial_attr;
    }
    return ST_PresetMaterialType::default_instance();
}

CT_Shape3D* CT_Shape3D::default_instance_ = NULL;

// CT_FlatText
CT_FlatText::CT_FlatText()
    :m_has_z_attr(false),
     m_z_attr(NULL)
{
}
CT_FlatText::~CT_FlatText()
{
    clear();
}
void CT_FlatText::clear()
{
    m_has_z_attr = false;

    if (m_z_attr)
    {
        delete m_z_attr;
        m_z_attr = NULL;
    }

}

void CT_FlatText::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_z_attr)
    {
        m_z_attr->toXmlAttr("z", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_FlatText& CT_FlatText::default_instance()
{
    if (!CT_FlatText::default_instance_)
    {
        CT_FlatText::default_instance_ = new CT_FlatText();
    }
    return *CT_FlatText::default_instance_;
}

bool CT_FlatText::has_z_attr() const
{
    return m_has_z_attr;
}

void CT_FlatText::set_z_attr(const ST_Coordinate& _z_attr)
{
    m_has_z_attr = true;
    m_z_attr = new ST_Coordinate(_z_attr);
}

const ST_Coordinate& CT_FlatText::get_z_attr() const
{
    if (m_z_attr)
    {
        return *m_z_attr;
    }
    return ST_Coordinate::default_instance();
}

CT_FlatText* CT_FlatText::default_instance_ = NULL;

// CT_AlphaBiLevelEffect
CT_AlphaBiLevelEffect::CT_AlphaBiLevelEffect()
    :m_has_thresh_attr(false),
     m_thresh_attr(NULL)
{
}
CT_AlphaBiLevelEffect::~CT_AlphaBiLevelEffect()
{
    clear();
}
void CT_AlphaBiLevelEffect::clear()
{
    m_has_thresh_attr = false;

    if (m_thresh_attr)
    {
        delete m_thresh_attr;
        m_thresh_attr = NULL;
    }

}

void CT_AlphaBiLevelEffect::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_thresh_attr);
    if (m_has_thresh_attr)
    {
        m_thresh_attr->toXmlAttr("thresh", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_AlphaBiLevelEffect& CT_AlphaBiLevelEffect::default_instance()
{
    if (!CT_AlphaBiLevelEffect::default_instance_)
    {
        CT_AlphaBiLevelEffect::default_instance_ = new CT_AlphaBiLevelEffect();
    }
    return *CT_AlphaBiLevelEffect::default_instance_;
}

bool CT_AlphaBiLevelEffect::has_thresh_attr() const
{
    return m_has_thresh_attr;
}

void CT_AlphaBiLevelEffect::set_thresh_attr(const ST_PositiveFixedPercentage& _thresh_attr)
{
    m_has_thresh_attr = true;
    m_thresh_attr = new ST_PositiveFixedPercentage(_thresh_attr);
}

const ST_PositiveFixedPercentage& CT_AlphaBiLevelEffect::get_thresh_attr() const
{
    if (m_thresh_attr)
    {
        return *m_thresh_attr;
    }
    return ST_PositiveFixedPercentage::default_instance();
}

CT_AlphaBiLevelEffect* CT_AlphaBiLevelEffect::default_instance_ = NULL;

// CT_AlphaCeilingEffect
CT_AlphaCeilingEffect::CT_AlphaCeilingEffect()

{
}
CT_AlphaCeilingEffect::~CT_AlphaCeilingEffect()
{
    clear();
}
void CT_AlphaCeilingEffect::clear()
{    }

void CT_AlphaCeilingEffect::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_AlphaCeilingEffect& CT_AlphaCeilingEffect::default_instance()
{
    if (!CT_AlphaCeilingEffect::default_instance_)
    {
        CT_AlphaCeilingEffect::default_instance_ = new CT_AlphaCeilingEffect();
    }
    return *CT_AlphaCeilingEffect::default_instance_;
}

CT_AlphaCeilingEffect* CT_AlphaCeilingEffect::default_instance_ = NULL;

// CT_AlphaFloorEffect
CT_AlphaFloorEffect::CT_AlphaFloorEffect()

{
}
CT_AlphaFloorEffect::~CT_AlphaFloorEffect()
{
    clear();
}
void CT_AlphaFloorEffect::clear()
{    }

void CT_AlphaFloorEffect::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_AlphaFloorEffect& CT_AlphaFloorEffect::default_instance()
{
    if (!CT_AlphaFloorEffect::default_instance_)
    {
        CT_AlphaFloorEffect::default_instance_ = new CT_AlphaFloorEffect();
    }
    return *CT_AlphaFloorEffect::default_instance_;
}

CT_AlphaFloorEffect* CT_AlphaFloorEffect::default_instance_ = NULL;

// CT_AlphaInverseEffect
CT_AlphaInverseEffect::CT_AlphaInverseEffect()
    :m_has_scrgbClr(false),
     m_scrgbClr(NULL),
     m_has_srgbClr(false),
     m_srgbClr(NULL),
     m_has_hslClr(false),
     m_hslClr(NULL),
     m_has_sysClr(false),
     m_sysClr(NULL),
     m_has_schemeClr(false),
     m_schemeClr(NULL),
     m_has_prstClr(false),
     m_prstClr(NULL)
{
}
CT_AlphaInverseEffect::~CT_AlphaInverseEffect()
{
    clear();
}
bool CT_AlphaInverseEffect::has_scrgbClr() const
{
    return m_has_scrgbClr;
}

CT_ScRgbColor* CT_AlphaInverseEffect::mutable_scrgbClr()
{

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_scrgbClr = true;
    if (!m_scrgbClr)
    {
        m_scrgbClr = new CT_ScRgbColor();
    }
    return m_scrgbClr;
}

const CT_ScRgbColor& CT_AlphaInverseEffect::get_scrgbClr() const
{
    if (m_scrgbClr)
    {
        return *m_scrgbClr;
    }
    return CT_ScRgbColor::default_instance();
}

bool CT_AlphaInverseEffect::has_srgbClr() const
{
    return m_has_srgbClr;
}

CT_SRgbColor* CT_AlphaInverseEffect::mutable_srgbClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_srgbClr = true;
    if (!m_srgbClr)
    {
        m_srgbClr = new CT_SRgbColor();
    }
    return m_srgbClr;
}

const CT_SRgbColor& CT_AlphaInverseEffect::get_srgbClr() const
{
    if (m_srgbClr)
    {
        return *m_srgbClr;
    }
    return CT_SRgbColor::default_instance();
}

bool CT_AlphaInverseEffect::has_hslClr() const
{
    return m_has_hslClr;
}

CT_HslColor* CT_AlphaInverseEffect::mutable_hslClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_hslClr = true;
    if (!m_hslClr)
    {
        m_hslClr = new CT_HslColor();
    }
    return m_hslClr;
}

const CT_HslColor& CT_AlphaInverseEffect::get_hslClr() const
{
    if (m_hslClr)
    {
        return *m_hslClr;
    }
    return CT_HslColor::default_instance();
}

bool CT_AlphaInverseEffect::has_sysClr() const
{
    return m_has_sysClr;
}

CT_SystemColor* CT_AlphaInverseEffect::mutable_sysClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_sysClr = true;
    if (!m_sysClr)
    {
        m_sysClr = new CT_SystemColor();
    }
    return m_sysClr;
}

const CT_SystemColor& CT_AlphaInverseEffect::get_sysClr() const
{
    if (m_sysClr)
    {
        return *m_sysClr;
    }
    return CT_SystemColor::default_instance();
}

bool CT_AlphaInverseEffect::has_schemeClr() const
{
    return m_has_schemeClr;
}

CT_SchemeColor* CT_AlphaInverseEffect::mutable_schemeClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_schemeClr = true;
    if (!m_schemeClr)
    {
        m_schemeClr = new CT_SchemeColor();
    }
    return m_schemeClr;
}

const CT_SchemeColor& CT_AlphaInverseEffect::get_schemeClr() const
{
    if (m_schemeClr)
    {
        return *m_schemeClr;
    }
    return CT_SchemeColor::default_instance();
}

bool CT_AlphaInverseEffect::has_prstClr() const
{
    return m_has_prstClr;
}

CT_PresetColor* CT_AlphaInverseEffect::mutable_prstClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = true;
    if (!m_prstClr)
    {
        m_prstClr = new CT_PresetColor();
    }
    return m_prstClr;
}

const CT_PresetColor& CT_AlphaInverseEffect::get_prstClr() const
{
    if (m_prstClr)
    {
        return *m_prstClr;
    }
    return CT_PresetColor::default_instance();
}

void CT_AlphaInverseEffect::clear()
{
    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }


    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }


    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }


    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }


    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }


    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }

}

void CT_AlphaInverseEffect::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    {
        bool elemHasValueList[6] = {m_has_scrgbClr, m_has_srgbClr, m_has_hslClr, m_has_sysClr, m_has_schemeClr, m_has_prstClr};
        int cnt = count(elemHasValueList, elemHasValueList + 6, true);
        assert(cnt == 0 || cnt == 1);
    }


    if (m_has_scrgbClr)
    {
        m_scrgbClr->toXmlElem("a:scrgbClr", "", _outStream);
    }


    if (m_has_srgbClr)
    {
        m_srgbClr->toXmlElem("a:srgbClr", "", _outStream);
    }


    if (m_has_hslClr)
    {
        m_hslClr->toXmlElem("a:hslClr", "", _outStream);
    }


    if (m_has_sysClr)
    {
        m_sysClr->toXmlElem("a:sysClr", "", _outStream);
    }


    if (m_has_schemeClr)
    {
        m_schemeClr->toXmlElem("a:schemeClr", "", _outStream);
    }


    if (m_has_prstClr)
    {
        m_prstClr->toXmlElem("a:prstClr", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_AlphaInverseEffect& CT_AlphaInverseEffect::default_instance()
{
    if (!CT_AlphaInverseEffect::default_instance_)
    {
        CT_AlphaInverseEffect::default_instance_ = new CT_AlphaInverseEffect();
    }
    return *CT_AlphaInverseEffect::default_instance_;
}

CT_AlphaInverseEffect* CT_AlphaInverseEffect::default_instance_ = NULL;

// CT_AlphaModulateFixedEffect
CT_AlphaModulateFixedEffect::CT_AlphaModulateFixedEffect()
    :m_has_amt_attr(false),
     m_amt_attr(NULL)
{
}
CT_AlphaModulateFixedEffect::~CT_AlphaModulateFixedEffect()
{
    clear();
}
void CT_AlphaModulateFixedEffect::clear()
{
    m_has_amt_attr = false;

    if (m_amt_attr)
    {
        delete m_amt_attr;
        m_amt_attr = NULL;
    }

}

void CT_AlphaModulateFixedEffect::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_amt_attr)
    {
        m_amt_attr->toXmlAttr("amt", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_AlphaModulateFixedEffect& CT_AlphaModulateFixedEffect::default_instance()
{
    if (!CT_AlphaModulateFixedEffect::default_instance_)
    {
        CT_AlphaModulateFixedEffect::default_instance_ = new CT_AlphaModulateFixedEffect();
    }
    return *CT_AlphaModulateFixedEffect::default_instance_;
}

bool CT_AlphaModulateFixedEffect::has_amt_attr() const
{
    return m_has_amt_attr;
}

void CT_AlphaModulateFixedEffect::set_amt_attr(const ST_PositivePercentage& _amt_attr)
{
    m_has_amt_attr = true;
    m_amt_attr = new ST_PositivePercentage(_amt_attr);
}

const ST_PositivePercentage& CT_AlphaModulateFixedEffect::get_amt_attr() const
{
    if (m_amt_attr)
    {
        return *m_amt_attr;
    }
    return ST_PositivePercentage::default_instance();
}

CT_AlphaModulateFixedEffect* CT_AlphaModulateFixedEffect::default_instance_ = NULL;

// CT_AlphaOutsetEffect
CT_AlphaOutsetEffect::CT_AlphaOutsetEffect()
    :m_has_rad_attr(false),
     m_rad_attr(NULL)
{
}
CT_AlphaOutsetEffect::~CT_AlphaOutsetEffect()
{
    clear();
}
void CT_AlphaOutsetEffect::clear()
{
    m_has_rad_attr = false;

    if (m_rad_attr)
    {
        delete m_rad_attr;
        m_rad_attr = NULL;
    }

}

void CT_AlphaOutsetEffect::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_rad_attr)
    {
        m_rad_attr->toXmlAttr("rad", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_AlphaOutsetEffect& CT_AlphaOutsetEffect::default_instance()
{
    if (!CT_AlphaOutsetEffect::default_instance_)
    {
        CT_AlphaOutsetEffect::default_instance_ = new CT_AlphaOutsetEffect();
    }
    return *CT_AlphaOutsetEffect::default_instance_;
}

bool CT_AlphaOutsetEffect::has_rad_attr() const
{
    return m_has_rad_attr;
}

void CT_AlphaOutsetEffect::set_rad_attr(const ST_Coordinate& _rad_attr)
{
    m_has_rad_attr = true;
    m_rad_attr = new ST_Coordinate(_rad_attr);
}

const ST_Coordinate& CT_AlphaOutsetEffect::get_rad_attr() const
{
    if (m_rad_attr)
    {
        return *m_rad_attr;
    }
    return ST_Coordinate::default_instance();
}

CT_AlphaOutsetEffect* CT_AlphaOutsetEffect::default_instance_ = NULL;

// CT_AlphaReplaceEffect
CT_AlphaReplaceEffect::CT_AlphaReplaceEffect()
    :m_has_a_attr(false),
     m_a_attr(NULL)
{
}
CT_AlphaReplaceEffect::~CT_AlphaReplaceEffect()
{
    clear();
}
void CT_AlphaReplaceEffect::clear()
{
    m_has_a_attr = false;

    if (m_a_attr)
    {
        delete m_a_attr;
        m_a_attr = NULL;
    }

}

void CT_AlphaReplaceEffect::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_a_attr);
    if (m_has_a_attr)
    {
        m_a_attr->toXmlAttr("a", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_AlphaReplaceEffect& CT_AlphaReplaceEffect::default_instance()
{
    if (!CT_AlphaReplaceEffect::default_instance_)
    {
        CT_AlphaReplaceEffect::default_instance_ = new CT_AlphaReplaceEffect();
    }
    return *CT_AlphaReplaceEffect::default_instance_;
}

bool CT_AlphaReplaceEffect::has_a_attr() const
{
    return m_has_a_attr;
}

void CT_AlphaReplaceEffect::set_a_attr(const ST_PositiveFixedPercentage& _a_attr)
{
    m_has_a_attr = true;
    m_a_attr = new ST_PositiveFixedPercentage(_a_attr);
}

const ST_PositiveFixedPercentage& CT_AlphaReplaceEffect::get_a_attr() const
{
    if (m_a_attr)
    {
        return *m_a_attr;
    }
    return ST_PositiveFixedPercentage::default_instance();
}

CT_AlphaReplaceEffect* CT_AlphaReplaceEffect::default_instance_ = NULL;

// CT_BiLevelEffect
CT_BiLevelEffect::CT_BiLevelEffect()
    :m_has_thresh_attr(false),
     m_thresh_attr(NULL)
{
}
CT_BiLevelEffect::~CT_BiLevelEffect()
{
    clear();
}
void CT_BiLevelEffect::clear()
{
    m_has_thresh_attr = false;

    if (m_thresh_attr)
    {
        delete m_thresh_attr;
        m_thresh_attr = NULL;
    }

}

void CT_BiLevelEffect::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_thresh_attr);
    if (m_has_thresh_attr)
    {
        m_thresh_attr->toXmlAttr("thresh", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_BiLevelEffect& CT_BiLevelEffect::default_instance()
{
    if (!CT_BiLevelEffect::default_instance_)
    {
        CT_BiLevelEffect::default_instance_ = new CT_BiLevelEffect();
    }
    return *CT_BiLevelEffect::default_instance_;
}

bool CT_BiLevelEffect::has_thresh_attr() const
{
    return m_has_thresh_attr;
}

void CT_BiLevelEffect::set_thresh_attr(const ST_PositiveFixedPercentage& _thresh_attr)
{
    m_has_thresh_attr = true;
    m_thresh_attr = new ST_PositiveFixedPercentage(_thresh_attr);
}

const ST_PositiveFixedPercentage& CT_BiLevelEffect::get_thresh_attr() const
{
    if (m_thresh_attr)
    {
        return *m_thresh_attr;
    }
    return ST_PositiveFixedPercentage::default_instance();
}

CT_BiLevelEffect* CT_BiLevelEffect::default_instance_ = NULL;

// CT_BlurEffect
CT_BlurEffect::CT_BlurEffect()
    :m_has_rad_attr(false),
     m_rad_attr(NULL),
     m_has_grow_attr(false),
     m_grow_attr(false)
{
}
CT_BlurEffect::~CT_BlurEffect()
{
    clear();
}
void CT_BlurEffect::clear()
{
    m_has_rad_attr = false;

    if (m_rad_attr)
    {
        delete m_rad_attr;
        m_rad_attr = NULL;
    }


    m_has_grow_attr = false;
    m_grow_attr = false;
}

void CT_BlurEffect::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_rad_attr)
    {
        m_rad_attr->toXmlAttr("rad", _outStream);
    }



    if (m_has_grow_attr)
    {
        _outStream << " " << "grow" << "=\"" << XSD::XMLBooleanStr(m_grow_attr) << "\"";
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_BlurEffect& CT_BlurEffect::default_instance()
{
    if (!CT_BlurEffect::default_instance_)
    {
        CT_BlurEffect::default_instance_ = new CT_BlurEffect();
    }
    return *CT_BlurEffect::default_instance_;
}

bool CT_BlurEffect::has_rad_attr() const
{
    return m_has_rad_attr;
}

void CT_BlurEffect::set_rad_attr(const ST_PositiveCoordinate& _rad_attr)
{
    m_has_rad_attr = true;
    m_rad_attr = new ST_PositiveCoordinate(_rad_attr);
}

const ST_PositiveCoordinate& CT_BlurEffect::get_rad_attr() const
{
    if (m_rad_attr)
    {
        return *m_rad_attr;
    }
    return ST_PositiveCoordinate::default_instance();
}

bool CT_BlurEffect::has_grow_attr() const
{
    return m_has_grow_attr;
}

void CT_BlurEffect::set_grow_attr(const XSD::boolean_& _grow_attr)
{
    m_has_grow_attr = true;
    m_grow_attr = _grow_attr;
}

const XSD::boolean_& CT_BlurEffect::get_grow_attr() const
{
    return m_grow_attr;
}

CT_BlurEffect* CT_BlurEffect::default_instance_ = NULL;

// CT_ColorChangeEffect
CT_ColorChangeEffect::CT_ColorChangeEffect()
    :m_has_clrFrom(false),
     m_clrFrom(NULL),
     m_has_clrTo(false),
     m_clrTo(NULL),
     m_has_useA_attr(false),
     m_useA_attr(false)
{
}
CT_ColorChangeEffect::~CT_ColorChangeEffect()
{
    clear();
}
bool CT_ColorChangeEffect::has_clrFrom() const
{
    return m_has_clrFrom;
}

CT_Color* CT_ColorChangeEffect::mutable_clrFrom()
{
    m_has_clrFrom = true;
    if (!m_clrFrom)
    {
        m_clrFrom = new CT_Color();
    }
    return m_clrFrom;
}

const CT_Color& CT_ColorChangeEffect::get_clrFrom() const
{
    if (m_clrFrom)
    {
        return *m_clrFrom;
    }
    return CT_Color::default_instance();
}

bool CT_ColorChangeEffect::has_clrTo() const
{
    return m_has_clrTo;
}

CT_Color* CT_ColorChangeEffect::mutable_clrTo()
{
    m_has_clrTo = true;
    if (!m_clrTo)
    {
        m_clrTo = new CT_Color();
    }
    return m_clrTo;
}

const CT_Color& CT_ColorChangeEffect::get_clrTo() const
{
    if (m_clrTo)
    {
        return *m_clrTo;
    }
    return CT_Color::default_instance();
}

void CT_ColorChangeEffect::clear()
{
    m_has_useA_attr = false;
    m_useA_attr = false;

    m_has_clrFrom = false;

    if (m_clrFrom)
    {
        delete m_clrFrom;
        m_clrFrom = NULL;
    }


    m_has_clrTo = false;

    if (m_clrTo)
    {
        delete m_clrTo;
        m_clrTo = NULL;
    }

}

void CT_ColorChangeEffect::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_useA_attr)
    {
        _outStream << " " << "useA" << "=\"" << XSD::XMLBooleanStr(m_useA_attr) << "\"";
    }

    _outStream << ">";

    assert(m_has_clrFrom);


    assert(m_has_clrTo);


    if (m_has_clrFrom)
    {
        m_clrFrom->toXmlElem("a:clrFrom", "", _outStream);
    }


    if (m_has_clrTo)
    {
        m_clrTo->toXmlElem("a:clrTo", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_ColorChangeEffect& CT_ColorChangeEffect::default_instance()
{
    if (!CT_ColorChangeEffect::default_instance_)
    {
        CT_ColorChangeEffect::default_instance_ = new CT_ColorChangeEffect();
    }
    return *CT_ColorChangeEffect::default_instance_;
}

bool CT_ColorChangeEffect::has_useA_attr() const
{
    return m_has_useA_attr;
}

void CT_ColorChangeEffect::set_useA_attr(const XSD::boolean_& _useA_attr)
{
    m_has_useA_attr = true;
    m_useA_attr = _useA_attr;
}

const XSD::boolean_& CT_ColorChangeEffect::get_useA_attr() const
{
    return m_useA_attr;
}

CT_ColorChangeEffect* CT_ColorChangeEffect::default_instance_ = NULL;

// CT_ColorReplaceEffect
CT_ColorReplaceEffect::CT_ColorReplaceEffect()
    :m_has_scrgbClr(false),
     m_scrgbClr(NULL),
     m_has_srgbClr(false),
     m_srgbClr(NULL),
     m_has_hslClr(false),
     m_hslClr(NULL),
     m_has_sysClr(false),
     m_sysClr(NULL),
     m_has_schemeClr(false),
     m_schemeClr(NULL),
     m_has_prstClr(false),
     m_prstClr(NULL)
{
}
CT_ColorReplaceEffect::~CT_ColorReplaceEffect()
{
    clear();
}
bool CT_ColorReplaceEffect::has_scrgbClr() const
{
    return m_has_scrgbClr;
}

CT_ScRgbColor* CT_ColorReplaceEffect::mutable_scrgbClr()
{

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_scrgbClr = true;
    if (!m_scrgbClr)
    {
        m_scrgbClr = new CT_ScRgbColor();
    }
    return m_scrgbClr;
}

const CT_ScRgbColor& CT_ColorReplaceEffect::get_scrgbClr() const
{
    if (m_scrgbClr)
    {
        return *m_scrgbClr;
    }
    return CT_ScRgbColor::default_instance();
}

bool CT_ColorReplaceEffect::has_srgbClr() const
{
    return m_has_srgbClr;
}

CT_SRgbColor* CT_ColorReplaceEffect::mutable_srgbClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_srgbClr = true;
    if (!m_srgbClr)
    {
        m_srgbClr = new CT_SRgbColor();
    }
    return m_srgbClr;
}

const CT_SRgbColor& CT_ColorReplaceEffect::get_srgbClr() const
{
    if (m_srgbClr)
    {
        return *m_srgbClr;
    }
    return CT_SRgbColor::default_instance();
}

bool CT_ColorReplaceEffect::has_hslClr() const
{
    return m_has_hslClr;
}

CT_HslColor* CT_ColorReplaceEffect::mutable_hslClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_hslClr = true;
    if (!m_hslClr)
    {
        m_hslClr = new CT_HslColor();
    }
    return m_hslClr;
}

const CT_HslColor& CT_ColorReplaceEffect::get_hslClr() const
{
    if (m_hslClr)
    {
        return *m_hslClr;
    }
    return CT_HslColor::default_instance();
}

bool CT_ColorReplaceEffect::has_sysClr() const
{
    return m_has_sysClr;
}

CT_SystemColor* CT_ColorReplaceEffect::mutable_sysClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_sysClr = true;
    if (!m_sysClr)
    {
        m_sysClr = new CT_SystemColor();
    }
    return m_sysClr;
}

const CT_SystemColor& CT_ColorReplaceEffect::get_sysClr() const
{
    if (m_sysClr)
    {
        return *m_sysClr;
    }
    return CT_SystemColor::default_instance();
}

bool CT_ColorReplaceEffect::has_schemeClr() const
{
    return m_has_schemeClr;
}

CT_SchemeColor* CT_ColorReplaceEffect::mutable_schemeClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_schemeClr = true;
    if (!m_schemeClr)
    {
        m_schemeClr = new CT_SchemeColor();
    }
    return m_schemeClr;
}

const CT_SchemeColor& CT_ColorReplaceEffect::get_schemeClr() const
{
    if (m_schemeClr)
    {
        return *m_schemeClr;
    }
    return CT_SchemeColor::default_instance();
}

bool CT_ColorReplaceEffect::has_prstClr() const
{
    return m_has_prstClr;
}

CT_PresetColor* CT_ColorReplaceEffect::mutable_prstClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = true;
    if (!m_prstClr)
    {
        m_prstClr = new CT_PresetColor();
    }
    return m_prstClr;
}

const CT_PresetColor& CT_ColorReplaceEffect::get_prstClr() const
{
    if (m_prstClr)
    {
        return *m_prstClr;
    }
    return CT_PresetColor::default_instance();
}

void CT_ColorReplaceEffect::clear()
{
    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }


    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }


    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }


    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }


    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }


    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }

}

void CT_ColorReplaceEffect::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    {
        bool elemHasValueList[6] = {m_has_scrgbClr, m_has_srgbClr, m_has_hslClr, m_has_sysClr, m_has_schemeClr, m_has_prstClr};
        int cnt = count(elemHasValueList, elemHasValueList + 6, true);
        assert(cnt == 1);
    }


    if (m_has_scrgbClr)
    {
        m_scrgbClr->toXmlElem("a:scrgbClr", "", _outStream);
    }


    if (m_has_srgbClr)
    {
        m_srgbClr->toXmlElem("a:srgbClr", "", _outStream);
    }


    if (m_has_hslClr)
    {
        m_hslClr->toXmlElem("a:hslClr", "", _outStream);
    }


    if (m_has_sysClr)
    {
        m_sysClr->toXmlElem("a:sysClr", "", _outStream);
    }


    if (m_has_schemeClr)
    {
        m_schemeClr->toXmlElem("a:schemeClr", "", _outStream);
    }


    if (m_has_prstClr)
    {
        m_prstClr->toXmlElem("a:prstClr", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_ColorReplaceEffect& CT_ColorReplaceEffect::default_instance()
{
    if (!CT_ColorReplaceEffect::default_instance_)
    {
        CT_ColorReplaceEffect::default_instance_ = new CT_ColorReplaceEffect();
    }
    return *CT_ColorReplaceEffect::default_instance_;
}

CT_ColorReplaceEffect* CT_ColorReplaceEffect::default_instance_ = NULL;

// CT_DuotoneEffect
CT_DuotoneEffect::CT_DuotoneEffect()

{
}
CT_DuotoneEffect::~CT_DuotoneEffect()
{
    clear();
}
CT_ScRgbColor* CT_DuotoneEffect::add_scrgbClr()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_ScRgbColor* pNewChild = pChildGroup->mutable_scrgbClr();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_SRgbColor* CT_DuotoneEffect::add_srgbClr()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_SRgbColor* pNewChild = pChildGroup->mutable_srgbClr();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_HslColor* CT_DuotoneEffect::add_hslClr()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_HslColor* pNewChild = pChildGroup->mutable_hslClr();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_SystemColor* CT_DuotoneEffect::add_sysClr()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_SystemColor* pNewChild = pChildGroup->mutable_sysClr();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_SchemeColor* CT_DuotoneEffect::add_schemeClr()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_SchemeColor* pNewChild = pChildGroup->mutable_schemeClr();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_PresetColor* CT_DuotoneEffect::add_prstClr()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PresetColor* pNewChild = pChildGroup->mutable_prstClr();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

void CT_DuotoneEffect::clear()
{
    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }
}

void CT_DuotoneEffect::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    {
        int elemCnt = count_if(m_childGroupList_1.begin(), m_childGroupList_1.end(), mem_fun(&ChildGroup_1::has_scrgbClr));
        assert(1 <= elemCnt && elemCnt <= 1);
    }


    {
        int elemCnt = count_if(m_childGroupList_1.begin(), m_childGroupList_1.end(), mem_fun(&ChildGroup_1::has_srgbClr));
        assert(1 <= elemCnt && elemCnt <= 1);
    }


    {
        int elemCnt = count_if(m_childGroupList_1.begin(), m_childGroupList_1.end(), mem_fun(&ChildGroup_1::has_hslClr));
        assert(1 <= elemCnt && elemCnt <= 1);
    }


    {
        int elemCnt = count_if(m_childGroupList_1.begin(), m_childGroupList_1.end(), mem_fun(&ChildGroup_1::has_sysClr));
        assert(1 <= elemCnt && elemCnt <= 1);
    }


    {
        int elemCnt = count_if(m_childGroupList_1.begin(), m_childGroupList_1.end(), mem_fun(&ChildGroup_1::has_schemeClr));
        assert(1 <= elemCnt && elemCnt <= 1);
    }


    {
        int elemCnt = count_if(m_childGroupList_1.begin(), m_childGroupList_1.end(), mem_fun(&ChildGroup_1::has_prstClr));
        assert(1 <= elemCnt && elemCnt <= 1);
    }

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_scrgbClr())
            {
                (*iter)->get_scrgbClr().toXmlElem("a:scrgbClr", "", _outStream);
            }


            else if ((*iter)->has_srgbClr())
            {
                (*iter)->get_srgbClr().toXmlElem("a:srgbClr", "", _outStream);
            }


            else if ((*iter)->has_hslClr())
            {
                (*iter)->get_hslClr().toXmlElem("a:hslClr", "", _outStream);
            }


            else if ((*iter)->has_sysClr())
            {
                (*iter)->get_sysClr().toXmlElem("a:sysClr", "", _outStream);
            }


            else if ((*iter)->has_schemeClr())
            {
                (*iter)->get_schemeClr().toXmlElem("a:schemeClr", "", _outStream);
            }


            else if ((*iter)->has_prstClr())
            {
                (*iter)->get_prstClr().toXmlElem("a:prstClr", "", _outStream);
            }


        }
    }

    _outStream << "</" << _elemName << ">";
}

const CT_DuotoneEffect& CT_DuotoneEffect::default_instance()
{
    if (!CT_DuotoneEffect::default_instance_)
    {
        CT_DuotoneEffect::default_instance_ = new CT_DuotoneEffect();
    }
    return *CT_DuotoneEffect::default_instance_;
}


// CT_DuotoneEffect::ChildGroup_1
CT_DuotoneEffect::ChildGroup_1::ChildGroup_1()
    :m_has_scrgbClr(false),
     m_scrgbClr(NULL),
     m_has_srgbClr(false),
     m_srgbClr(NULL),
     m_has_hslClr(false),
     m_hslClr(NULL),
     m_has_sysClr(false),
     m_sysClr(NULL),
     m_has_schemeClr(false),
     m_schemeClr(NULL),
     m_has_prstClr(false),
     m_prstClr(NULL)
{
}
bool CT_DuotoneEffect::ChildGroup_1::has_scrgbClr() const
{
    return m_has_scrgbClr;
}

CT_ScRgbColor* CT_DuotoneEffect::ChildGroup_1::mutable_scrgbClr()
{

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_scrgbClr = true;
    if (!m_scrgbClr)
    {
        m_scrgbClr = new CT_ScRgbColor();
    }
    return m_scrgbClr;
}

const CT_ScRgbColor& CT_DuotoneEffect::ChildGroup_1::get_scrgbClr() const
{
    if (m_scrgbClr)
    {
        return *m_scrgbClr;
    }
    return CT_ScRgbColor::default_instance();
}

bool CT_DuotoneEffect::ChildGroup_1::has_srgbClr() const
{
    return m_has_srgbClr;
}

CT_SRgbColor* CT_DuotoneEffect::ChildGroup_1::mutable_srgbClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_srgbClr = true;
    if (!m_srgbClr)
    {
        m_srgbClr = new CT_SRgbColor();
    }
    return m_srgbClr;
}

const CT_SRgbColor& CT_DuotoneEffect::ChildGroup_1::get_srgbClr() const
{
    if (m_srgbClr)
    {
        return *m_srgbClr;
    }
    return CT_SRgbColor::default_instance();
}

bool CT_DuotoneEffect::ChildGroup_1::has_hslClr() const
{
    return m_has_hslClr;
}

CT_HslColor* CT_DuotoneEffect::ChildGroup_1::mutable_hslClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_hslClr = true;
    if (!m_hslClr)
    {
        m_hslClr = new CT_HslColor();
    }
    return m_hslClr;
}

const CT_HslColor& CT_DuotoneEffect::ChildGroup_1::get_hslClr() const
{
    if (m_hslClr)
    {
        return *m_hslClr;
    }
    return CT_HslColor::default_instance();
}

bool CT_DuotoneEffect::ChildGroup_1::has_sysClr() const
{
    return m_has_sysClr;
}

CT_SystemColor* CT_DuotoneEffect::ChildGroup_1::mutable_sysClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_sysClr = true;
    if (!m_sysClr)
    {
        m_sysClr = new CT_SystemColor();
    }
    return m_sysClr;
}

const CT_SystemColor& CT_DuotoneEffect::ChildGroup_1::get_sysClr() const
{
    if (m_sysClr)
    {
        return *m_sysClr;
    }
    return CT_SystemColor::default_instance();
}

bool CT_DuotoneEffect::ChildGroup_1::has_schemeClr() const
{
    return m_has_schemeClr;
}

CT_SchemeColor* CT_DuotoneEffect::ChildGroup_1::mutable_schemeClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_schemeClr = true;
    if (!m_schemeClr)
    {
        m_schemeClr = new CT_SchemeColor();
    }
    return m_schemeClr;
}

const CT_SchemeColor& CT_DuotoneEffect::ChildGroup_1::get_schemeClr() const
{
    if (m_schemeClr)
    {
        return *m_schemeClr;
    }
    return CT_SchemeColor::default_instance();
}

bool CT_DuotoneEffect::ChildGroup_1::has_prstClr() const
{
    return m_has_prstClr;
}

CT_PresetColor* CT_DuotoneEffect::ChildGroup_1::mutable_prstClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = true;
    if (!m_prstClr)
    {
        m_prstClr = new CT_PresetColor();
    }
    return m_prstClr;
}

const CT_PresetColor& CT_DuotoneEffect::ChildGroup_1::get_prstClr() const
{
    if (m_prstClr)
    {
        return *m_prstClr;
    }
    return CT_PresetColor::default_instance();
}

CT_DuotoneEffect* CT_DuotoneEffect::default_instance_ = NULL;

// CT_GlowEffect
CT_GlowEffect::CT_GlowEffect()
    :m_has_scrgbClr(false),
     m_scrgbClr(NULL),
     m_has_srgbClr(false),
     m_srgbClr(NULL),
     m_has_hslClr(false),
     m_hslClr(NULL),
     m_has_sysClr(false),
     m_sysClr(NULL),
     m_has_schemeClr(false),
     m_schemeClr(NULL),
     m_has_prstClr(false),
     m_prstClr(NULL),
     m_has_rad_attr(false),
     m_rad_attr(NULL)
{
}
CT_GlowEffect::~CT_GlowEffect()
{
    clear();
}
bool CT_GlowEffect::has_scrgbClr() const
{
    return m_has_scrgbClr;
}

CT_ScRgbColor* CT_GlowEffect::mutable_scrgbClr()
{

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_scrgbClr = true;
    if (!m_scrgbClr)
    {
        m_scrgbClr = new CT_ScRgbColor();
    }
    return m_scrgbClr;
}

const CT_ScRgbColor& CT_GlowEffect::get_scrgbClr() const
{
    if (m_scrgbClr)
    {
        return *m_scrgbClr;
    }
    return CT_ScRgbColor::default_instance();
}

bool CT_GlowEffect::has_srgbClr() const
{
    return m_has_srgbClr;
}

CT_SRgbColor* CT_GlowEffect::mutable_srgbClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_srgbClr = true;
    if (!m_srgbClr)
    {
        m_srgbClr = new CT_SRgbColor();
    }
    return m_srgbClr;
}

const CT_SRgbColor& CT_GlowEffect::get_srgbClr() const
{
    if (m_srgbClr)
    {
        return *m_srgbClr;
    }
    return CT_SRgbColor::default_instance();
}

bool CT_GlowEffect::has_hslClr() const
{
    return m_has_hslClr;
}

CT_HslColor* CT_GlowEffect::mutable_hslClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_hslClr = true;
    if (!m_hslClr)
    {
        m_hslClr = new CT_HslColor();
    }
    return m_hslClr;
}

const CT_HslColor& CT_GlowEffect::get_hslClr() const
{
    if (m_hslClr)
    {
        return *m_hslClr;
    }
    return CT_HslColor::default_instance();
}

bool CT_GlowEffect::has_sysClr() const
{
    return m_has_sysClr;
}

CT_SystemColor* CT_GlowEffect::mutable_sysClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_sysClr = true;
    if (!m_sysClr)
    {
        m_sysClr = new CT_SystemColor();
    }
    return m_sysClr;
}

const CT_SystemColor& CT_GlowEffect::get_sysClr() const
{
    if (m_sysClr)
    {
        return *m_sysClr;
    }
    return CT_SystemColor::default_instance();
}

bool CT_GlowEffect::has_schemeClr() const
{
    return m_has_schemeClr;
}

CT_SchemeColor* CT_GlowEffect::mutable_schemeClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_schemeClr = true;
    if (!m_schemeClr)
    {
        m_schemeClr = new CT_SchemeColor();
    }
    return m_schemeClr;
}

const CT_SchemeColor& CT_GlowEffect::get_schemeClr() const
{
    if (m_schemeClr)
    {
        return *m_schemeClr;
    }
    return CT_SchemeColor::default_instance();
}

bool CT_GlowEffect::has_prstClr() const
{
    return m_has_prstClr;
}

CT_PresetColor* CT_GlowEffect::mutable_prstClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = true;
    if (!m_prstClr)
    {
        m_prstClr = new CT_PresetColor();
    }
    return m_prstClr;
}

const CT_PresetColor& CT_GlowEffect::get_prstClr() const
{
    if (m_prstClr)
    {
        return *m_prstClr;
    }
    return CT_PresetColor::default_instance();
}

void CT_GlowEffect::clear()
{
    m_has_rad_attr = false;

    if (m_rad_attr)
    {
        delete m_rad_attr;
        m_rad_attr = NULL;
    }


    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }


    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }


    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }


    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }


    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }


    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }

}

void CT_GlowEffect::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_rad_attr)
    {
        m_rad_attr->toXmlAttr("rad", _outStream);
    }

    _outStream << ">";

    {
        bool elemHasValueList[6] = {m_has_scrgbClr, m_has_srgbClr, m_has_hslClr, m_has_sysClr, m_has_schemeClr, m_has_prstClr};
        int cnt = count(elemHasValueList, elemHasValueList + 6, true);
        assert(cnt == 1);
    }


    if (m_has_scrgbClr)
    {
        m_scrgbClr->toXmlElem("a:scrgbClr", "", _outStream);
    }


    if (m_has_srgbClr)
    {
        m_srgbClr->toXmlElem("a:srgbClr", "", _outStream);
    }


    if (m_has_hslClr)
    {
        m_hslClr->toXmlElem("a:hslClr", "", _outStream);
    }


    if (m_has_sysClr)
    {
        m_sysClr->toXmlElem("a:sysClr", "", _outStream);
    }


    if (m_has_schemeClr)
    {
        m_schemeClr->toXmlElem("a:schemeClr", "", _outStream);
    }


    if (m_has_prstClr)
    {
        m_prstClr->toXmlElem("a:prstClr", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_GlowEffect& CT_GlowEffect::default_instance()
{
    if (!CT_GlowEffect::default_instance_)
    {
        CT_GlowEffect::default_instance_ = new CT_GlowEffect();
    }
    return *CT_GlowEffect::default_instance_;
}

bool CT_GlowEffect::has_rad_attr() const
{
    return m_has_rad_attr;
}

void CT_GlowEffect::set_rad_attr(const ST_PositiveCoordinate& _rad_attr)
{
    m_has_rad_attr = true;
    m_rad_attr = new ST_PositiveCoordinate(_rad_attr);
}

const ST_PositiveCoordinate& CT_GlowEffect::get_rad_attr() const
{
    if (m_rad_attr)
    {
        return *m_rad_attr;
    }
    return ST_PositiveCoordinate::default_instance();
}

CT_GlowEffect* CT_GlowEffect::default_instance_ = NULL;

// CT_GrayscaleEffect
CT_GrayscaleEffect::CT_GrayscaleEffect()

{
}
CT_GrayscaleEffect::~CT_GrayscaleEffect()
{
    clear();
}
void CT_GrayscaleEffect::clear()
{    }

void CT_GrayscaleEffect::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_GrayscaleEffect& CT_GrayscaleEffect::default_instance()
{
    if (!CT_GrayscaleEffect::default_instance_)
    {
        CT_GrayscaleEffect::default_instance_ = new CT_GrayscaleEffect();
    }
    return *CT_GrayscaleEffect::default_instance_;
}

CT_GrayscaleEffect* CT_GrayscaleEffect::default_instance_ = NULL;

// CT_HSLEffect
CT_HSLEffect::CT_HSLEffect()
    :m_has_hue_attr(false),
     m_hue_attr(NULL),
     m_has_sat_attr(false),
     m_sat_attr(NULL),
     m_has_lum_attr(false),
     m_lum_attr(NULL)
{
}
CT_HSLEffect::~CT_HSLEffect()
{
    clear();
}
void CT_HSLEffect::clear()
{
    m_has_hue_attr = false;

    if (m_hue_attr)
    {
        delete m_hue_attr;
        m_hue_attr = NULL;
    }


    m_has_sat_attr = false;

    if (m_sat_attr)
    {
        delete m_sat_attr;
        m_sat_attr = NULL;
    }


    m_has_lum_attr = false;

    if (m_lum_attr)
    {
        delete m_lum_attr;
        m_lum_attr = NULL;
    }

}

void CT_HSLEffect::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_hue_attr)
    {
        m_hue_attr->toXmlAttr("hue", _outStream);
    }



    if (m_has_sat_attr)
    {
        m_sat_attr->toXmlAttr("sat", _outStream);
    }



    if (m_has_lum_attr)
    {
        m_lum_attr->toXmlAttr("lum", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_HSLEffect& CT_HSLEffect::default_instance()
{
    if (!CT_HSLEffect::default_instance_)
    {
        CT_HSLEffect::default_instance_ = new CT_HSLEffect();
    }
    return *CT_HSLEffect::default_instance_;
}

bool CT_HSLEffect::has_hue_attr() const
{
    return m_has_hue_attr;
}

void CT_HSLEffect::set_hue_attr(const ST_PositiveFixedAngle& _hue_attr)
{
    m_has_hue_attr = true;
    m_hue_attr = new ST_PositiveFixedAngle(_hue_attr);
}

const ST_PositiveFixedAngle& CT_HSLEffect::get_hue_attr() const
{
    if (m_hue_attr)
    {
        return *m_hue_attr;
    }
    return ST_PositiveFixedAngle::default_instance();
}

bool CT_HSLEffect::has_sat_attr() const
{
    return m_has_sat_attr;
}

void CT_HSLEffect::set_sat_attr(const ST_FixedPercentage& _sat_attr)
{
    m_has_sat_attr = true;
    m_sat_attr = new ST_FixedPercentage(_sat_attr);
}

const ST_FixedPercentage& CT_HSLEffect::get_sat_attr() const
{
    if (m_sat_attr)
    {
        return *m_sat_attr;
    }
    return ST_FixedPercentage::default_instance();
}

bool CT_HSLEffect::has_lum_attr() const
{
    return m_has_lum_attr;
}

void CT_HSLEffect::set_lum_attr(const ST_FixedPercentage& _lum_attr)
{
    m_has_lum_attr = true;
    m_lum_attr = new ST_FixedPercentage(_lum_attr);
}

const ST_FixedPercentage& CT_HSLEffect::get_lum_attr() const
{
    if (m_lum_attr)
    {
        return *m_lum_attr;
    }
    return ST_FixedPercentage::default_instance();
}

CT_HSLEffect* CT_HSLEffect::default_instance_ = NULL;

// CT_InnerShadowEffect
CT_InnerShadowEffect::CT_InnerShadowEffect()
    :m_has_scrgbClr(false),
     m_scrgbClr(NULL),
     m_has_srgbClr(false),
     m_srgbClr(NULL),
     m_has_hslClr(false),
     m_hslClr(NULL),
     m_has_sysClr(false),
     m_sysClr(NULL),
     m_has_schemeClr(false),
     m_schemeClr(NULL),
     m_has_prstClr(false),
     m_prstClr(NULL),
     m_has_blurRad_attr(false),
     m_blurRad_attr(NULL),
     m_has_dist_attr(false),
     m_dist_attr(NULL),
     m_has_dir_attr(false),
     m_dir_attr(NULL)
{
}
CT_InnerShadowEffect::~CT_InnerShadowEffect()
{
    clear();
}
bool CT_InnerShadowEffect::has_scrgbClr() const
{
    return m_has_scrgbClr;
}

CT_ScRgbColor* CT_InnerShadowEffect::mutable_scrgbClr()
{

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_scrgbClr = true;
    if (!m_scrgbClr)
    {
        m_scrgbClr = new CT_ScRgbColor();
    }
    return m_scrgbClr;
}

const CT_ScRgbColor& CT_InnerShadowEffect::get_scrgbClr() const
{
    if (m_scrgbClr)
    {
        return *m_scrgbClr;
    }
    return CT_ScRgbColor::default_instance();
}

bool CT_InnerShadowEffect::has_srgbClr() const
{
    return m_has_srgbClr;
}

CT_SRgbColor* CT_InnerShadowEffect::mutable_srgbClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_srgbClr = true;
    if (!m_srgbClr)
    {
        m_srgbClr = new CT_SRgbColor();
    }
    return m_srgbClr;
}

const CT_SRgbColor& CT_InnerShadowEffect::get_srgbClr() const
{
    if (m_srgbClr)
    {
        return *m_srgbClr;
    }
    return CT_SRgbColor::default_instance();
}

bool CT_InnerShadowEffect::has_hslClr() const
{
    return m_has_hslClr;
}

CT_HslColor* CT_InnerShadowEffect::mutable_hslClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_hslClr = true;
    if (!m_hslClr)
    {
        m_hslClr = new CT_HslColor();
    }
    return m_hslClr;
}

const CT_HslColor& CT_InnerShadowEffect::get_hslClr() const
{
    if (m_hslClr)
    {
        return *m_hslClr;
    }
    return CT_HslColor::default_instance();
}

bool CT_InnerShadowEffect::has_sysClr() const
{
    return m_has_sysClr;
}

CT_SystemColor* CT_InnerShadowEffect::mutable_sysClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_sysClr = true;
    if (!m_sysClr)
    {
        m_sysClr = new CT_SystemColor();
    }
    return m_sysClr;
}

const CT_SystemColor& CT_InnerShadowEffect::get_sysClr() const
{
    if (m_sysClr)
    {
        return *m_sysClr;
    }
    return CT_SystemColor::default_instance();
}

bool CT_InnerShadowEffect::has_schemeClr() const
{
    return m_has_schemeClr;
}

CT_SchemeColor* CT_InnerShadowEffect::mutable_schemeClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_schemeClr = true;
    if (!m_schemeClr)
    {
        m_schemeClr = new CT_SchemeColor();
    }
    return m_schemeClr;
}

const CT_SchemeColor& CT_InnerShadowEffect::get_schemeClr() const
{
    if (m_schemeClr)
    {
        return *m_schemeClr;
    }
    return CT_SchemeColor::default_instance();
}

bool CT_InnerShadowEffect::has_prstClr() const
{
    return m_has_prstClr;
}

CT_PresetColor* CT_InnerShadowEffect::mutable_prstClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = true;
    if (!m_prstClr)
    {
        m_prstClr = new CT_PresetColor();
    }
    return m_prstClr;
}

const CT_PresetColor& CT_InnerShadowEffect::get_prstClr() const
{
    if (m_prstClr)
    {
        return *m_prstClr;
    }
    return CT_PresetColor::default_instance();
}

void CT_InnerShadowEffect::clear()
{
    m_has_blurRad_attr = false;

    if (m_blurRad_attr)
    {
        delete m_blurRad_attr;
        m_blurRad_attr = NULL;
    }


    m_has_dist_attr = false;

    if (m_dist_attr)
    {
        delete m_dist_attr;
        m_dist_attr = NULL;
    }


    m_has_dir_attr = false;

    if (m_dir_attr)
    {
        delete m_dir_attr;
        m_dir_attr = NULL;
    }


    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }


    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }


    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }


    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }


    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }


    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }

}

void CT_InnerShadowEffect::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_blurRad_attr)
    {
        m_blurRad_attr->toXmlAttr("blurRad", _outStream);
    }



    if (m_has_dist_attr)
    {
        m_dist_attr->toXmlAttr("dist", _outStream);
    }



    if (m_has_dir_attr)
    {
        m_dir_attr->toXmlAttr("dir", _outStream);
    }

    _outStream << ">";

    {
        bool elemHasValueList[6] = {m_has_scrgbClr, m_has_srgbClr, m_has_hslClr, m_has_sysClr, m_has_schemeClr, m_has_prstClr};
        int cnt = count(elemHasValueList, elemHasValueList + 6, true);
        assert(cnt == 1);
    }


    if (m_has_scrgbClr)
    {
        m_scrgbClr->toXmlElem("a:scrgbClr", "", _outStream);
    }


    if (m_has_srgbClr)
    {
        m_srgbClr->toXmlElem("a:srgbClr", "", _outStream);
    }


    if (m_has_hslClr)
    {
        m_hslClr->toXmlElem("a:hslClr", "", _outStream);
    }


    if (m_has_sysClr)
    {
        m_sysClr->toXmlElem("a:sysClr", "", _outStream);
    }


    if (m_has_schemeClr)
    {
        m_schemeClr->toXmlElem("a:schemeClr", "", _outStream);
    }


    if (m_has_prstClr)
    {
        m_prstClr->toXmlElem("a:prstClr", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_InnerShadowEffect& CT_InnerShadowEffect::default_instance()
{
    if (!CT_InnerShadowEffect::default_instance_)
    {
        CT_InnerShadowEffect::default_instance_ = new CT_InnerShadowEffect();
    }
    return *CT_InnerShadowEffect::default_instance_;
}

bool CT_InnerShadowEffect::has_blurRad_attr() const
{
    return m_has_blurRad_attr;
}

void CT_InnerShadowEffect::set_blurRad_attr(const ST_PositiveCoordinate& _blurRad_attr)
{
    m_has_blurRad_attr = true;
    m_blurRad_attr = new ST_PositiveCoordinate(_blurRad_attr);
}

const ST_PositiveCoordinate& CT_InnerShadowEffect::get_blurRad_attr() const
{
    if (m_blurRad_attr)
    {
        return *m_blurRad_attr;
    }
    return ST_PositiveCoordinate::default_instance();
}

bool CT_InnerShadowEffect::has_dist_attr() const
{
    return m_has_dist_attr;
}

void CT_InnerShadowEffect::set_dist_attr(const ST_PositiveCoordinate& _dist_attr)
{
    m_has_dist_attr = true;
    m_dist_attr = new ST_PositiveCoordinate(_dist_attr);
}

const ST_PositiveCoordinate& CT_InnerShadowEffect::get_dist_attr() const
{
    if (m_dist_attr)
    {
        return *m_dist_attr;
    }
    return ST_PositiveCoordinate::default_instance();
}

bool CT_InnerShadowEffect::has_dir_attr() const
{
    return m_has_dir_attr;
}

void CT_InnerShadowEffect::set_dir_attr(const ST_PositiveFixedAngle& _dir_attr)
{
    m_has_dir_attr = true;
    m_dir_attr = new ST_PositiveFixedAngle(_dir_attr);
}

const ST_PositiveFixedAngle& CT_InnerShadowEffect::get_dir_attr() const
{
    if (m_dir_attr)
    {
        return *m_dir_attr;
    }
    return ST_PositiveFixedAngle::default_instance();
}

CT_InnerShadowEffect* CT_InnerShadowEffect::default_instance_ = NULL;

// CT_LuminanceEffect
CT_LuminanceEffect::CT_LuminanceEffect()
    :m_has_bright_attr(false),
     m_bright_attr(NULL),
     m_has_contrast_attr(false),
     m_contrast_attr(NULL)
{
}
CT_LuminanceEffect::~CT_LuminanceEffect()
{
    clear();
}
void CT_LuminanceEffect::clear()
{
    m_has_bright_attr = false;

    if (m_bright_attr)
    {
        delete m_bright_attr;
        m_bright_attr = NULL;
    }


    m_has_contrast_attr = false;

    if (m_contrast_attr)
    {
        delete m_contrast_attr;
        m_contrast_attr = NULL;
    }

}

void CT_LuminanceEffect::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_bright_attr)
    {
        m_bright_attr->toXmlAttr("bright", _outStream);
    }



    if (m_has_contrast_attr)
    {
        m_contrast_attr->toXmlAttr("contrast", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_LuminanceEffect& CT_LuminanceEffect::default_instance()
{
    if (!CT_LuminanceEffect::default_instance_)
    {
        CT_LuminanceEffect::default_instance_ = new CT_LuminanceEffect();
    }
    return *CT_LuminanceEffect::default_instance_;
}

bool CT_LuminanceEffect::has_bright_attr() const
{
    return m_has_bright_attr;
}

void CT_LuminanceEffect::set_bright_attr(const ST_FixedPercentage& _bright_attr)
{
    m_has_bright_attr = true;
    m_bright_attr = new ST_FixedPercentage(_bright_attr);
}

const ST_FixedPercentage& CT_LuminanceEffect::get_bright_attr() const
{
    if (m_bright_attr)
    {
        return *m_bright_attr;
    }
    return ST_FixedPercentage::default_instance();
}

bool CT_LuminanceEffect::has_contrast_attr() const
{
    return m_has_contrast_attr;
}

void CT_LuminanceEffect::set_contrast_attr(const ST_FixedPercentage& _contrast_attr)
{
    m_has_contrast_attr = true;
    m_contrast_attr = new ST_FixedPercentage(_contrast_attr);
}

const ST_FixedPercentage& CT_LuminanceEffect::get_contrast_attr() const
{
    if (m_contrast_attr)
    {
        return *m_contrast_attr;
    }
    return ST_FixedPercentage::default_instance();
}

CT_LuminanceEffect* CT_LuminanceEffect::default_instance_ = NULL;

// CT_OuterShadowEffect
CT_OuterShadowEffect::CT_OuterShadowEffect()
    :m_has_scrgbClr(false),
     m_scrgbClr(NULL),
     m_has_srgbClr(false),
     m_srgbClr(NULL),
     m_has_hslClr(false),
     m_hslClr(NULL),
     m_has_sysClr(false),
     m_sysClr(NULL),
     m_has_schemeClr(false),
     m_schemeClr(NULL),
     m_has_prstClr(false),
     m_prstClr(NULL),
     m_has_blurRad_attr(false),
     m_blurRad_attr(NULL),
     m_has_dist_attr(false),
     m_dist_attr(NULL),
     m_has_dir_attr(false),
     m_dir_attr(NULL),
     m_has_sx_attr(false),
     m_sx_attr(NULL),
     m_has_sy_attr(false),
     m_sy_attr(NULL),
     m_has_kx_attr(false),
     m_kx_attr(NULL),
     m_has_ky_attr(false),
     m_ky_attr(NULL),
     m_has_algn_attr(false),
     m_algn_attr(NULL),
     m_has_rotWithShape_attr(false),
     m_rotWithShape_attr(false)
{
}
CT_OuterShadowEffect::~CT_OuterShadowEffect()
{
    clear();
}
bool CT_OuterShadowEffect::has_scrgbClr() const
{
    return m_has_scrgbClr;
}

CT_ScRgbColor* CT_OuterShadowEffect::mutable_scrgbClr()
{

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_scrgbClr = true;
    if (!m_scrgbClr)
    {
        m_scrgbClr = new CT_ScRgbColor();
    }
    return m_scrgbClr;
}

const CT_ScRgbColor& CT_OuterShadowEffect::get_scrgbClr() const
{
    if (m_scrgbClr)
    {
        return *m_scrgbClr;
    }
    return CT_ScRgbColor::default_instance();
}

bool CT_OuterShadowEffect::has_srgbClr() const
{
    return m_has_srgbClr;
}

CT_SRgbColor* CT_OuterShadowEffect::mutable_srgbClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_srgbClr = true;
    if (!m_srgbClr)
    {
        m_srgbClr = new CT_SRgbColor();
    }
    return m_srgbClr;
}

const CT_SRgbColor& CT_OuterShadowEffect::get_srgbClr() const
{
    if (m_srgbClr)
    {
        return *m_srgbClr;
    }
    return CT_SRgbColor::default_instance();
}

bool CT_OuterShadowEffect::has_hslClr() const
{
    return m_has_hslClr;
}

CT_HslColor* CT_OuterShadowEffect::mutable_hslClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_hslClr = true;
    if (!m_hslClr)
    {
        m_hslClr = new CT_HslColor();
    }
    return m_hslClr;
}

const CT_HslColor& CT_OuterShadowEffect::get_hslClr() const
{
    if (m_hslClr)
    {
        return *m_hslClr;
    }
    return CT_HslColor::default_instance();
}

bool CT_OuterShadowEffect::has_sysClr() const
{
    return m_has_sysClr;
}

CT_SystemColor* CT_OuterShadowEffect::mutable_sysClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_sysClr = true;
    if (!m_sysClr)
    {
        m_sysClr = new CT_SystemColor();
    }
    return m_sysClr;
}

const CT_SystemColor& CT_OuterShadowEffect::get_sysClr() const
{
    if (m_sysClr)
    {
        return *m_sysClr;
    }
    return CT_SystemColor::default_instance();
}

bool CT_OuterShadowEffect::has_schemeClr() const
{
    return m_has_schemeClr;
}

CT_SchemeColor* CT_OuterShadowEffect::mutable_schemeClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_schemeClr = true;
    if (!m_schemeClr)
    {
        m_schemeClr = new CT_SchemeColor();
    }
    return m_schemeClr;
}

const CT_SchemeColor& CT_OuterShadowEffect::get_schemeClr() const
{
    if (m_schemeClr)
    {
        return *m_schemeClr;
    }
    return CT_SchemeColor::default_instance();
}

bool CT_OuterShadowEffect::has_prstClr() const
{
    return m_has_prstClr;
}

CT_PresetColor* CT_OuterShadowEffect::mutable_prstClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = true;
    if (!m_prstClr)
    {
        m_prstClr = new CT_PresetColor();
    }
    return m_prstClr;
}

const CT_PresetColor& CT_OuterShadowEffect::get_prstClr() const
{
    if (m_prstClr)
    {
        return *m_prstClr;
    }
    return CT_PresetColor::default_instance();
}

void CT_OuterShadowEffect::clear()
{
    m_has_blurRad_attr = false;

    if (m_blurRad_attr)
    {
        delete m_blurRad_attr;
        m_blurRad_attr = NULL;
    }


    m_has_dist_attr = false;

    if (m_dist_attr)
    {
        delete m_dist_attr;
        m_dist_attr = NULL;
    }


    m_has_dir_attr = false;

    if (m_dir_attr)
    {
        delete m_dir_attr;
        m_dir_attr = NULL;
    }


    m_has_sx_attr = false;

    if (m_sx_attr)
    {
        delete m_sx_attr;
        m_sx_attr = NULL;
    }


    m_has_sy_attr = false;

    if (m_sy_attr)
    {
        delete m_sy_attr;
        m_sy_attr = NULL;
    }


    m_has_kx_attr = false;

    if (m_kx_attr)
    {
        delete m_kx_attr;
        m_kx_attr = NULL;
    }


    m_has_ky_attr = false;

    if (m_ky_attr)
    {
        delete m_ky_attr;
        m_ky_attr = NULL;
    }


    m_has_algn_attr = false;

    if (m_algn_attr)
    {
        delete m_algn_attr;
        m_algn_attr = NULL;
    }


    m_has_rotWithShape_attr = false;
    m_rotWithShape_attr = false;

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }


    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }


    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }


    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }


    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }


    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }

}

void CT_OuterShadowEffect::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_blurRad_attr)
    {
        m_blurRad_attr->toXmlAttr("blurRad", _outStream);
    }



    if (m_has_dist_attr)
    {
        m_dist_attr->toXmlAttr("dist", _outStream);
    }



    if (m_has_dir_attr)
    {
        m_dir_attr->toXmlAttr("dir", _outStream);
    }



    if (m_has_sx_attr)
    {
        m_sx_attr->toXmlAttr("sx", _outStream);
    }



    if (m_has_sy_attr)
    {
        m_sy_attr->toXmlAttr("sy", _outStream);
    }



    if (m_has_kx_attr)
    {
        m_kx_attr->toXmlAttr("kx", _outStream);
    }



    if (m_has_ky_attr)
    {
        m_ky_attr->toXmlAttr("ky", _outStream);
    }



    if (m_has_algn_attr)
    {
        m_algn_attr->toXmlAttr("algn", _outStream);
    }



    if (m_has_rotWithShape_attr)
    {
        _outStream << " " << "rotWithShape" << "=\"" << XSD::XMLBooleanStr(m_rotWithShape_attr) << "\"";
    }

    _outStream << ">";

    {
        bool elemHasValueList[6] = {m_has_scrgbClr, m_has_srgbClr, m_has_hslClr, m_has_sysClr, m_has_schemeClr, m_has_prstClr};
        int cnt = count(elemHasValueList, elemHasValueList + 6, true);
        assert(cnt == 1);
    }


    if (m_has_scrgbClr)
    {
        m_scrgbClr->toXmlElem("a:scrgbClr", "", _outStream);
    }


    if (m_has_srgbClr)
    {
        m_srgbClr->toXmlElem("a:srgbClr", "", _outStream);
    }


    if (m_has_hslClr)
    {
        m_hslClr->toXmlElem("a:hslClr", "", _outStream);
    }


    if (m_has_sysClr)
    {
        m_sysClr->toXmlElem("a:sysClr", "", _outStream);
    }


    if (m_has_schemeClr)
    {
        m_schemeClr->toXmlElem("a:schemeClr", "", _outStream);
    }


    if (m_has_prstClr)
    {
        m_prstClr->toXmlElem("a:prstClr", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_OuterShadowEffect& CT_OuterShadowEffect::default_instance()
{
    if (!CT_OuterShadowEffect::default_instance_)
    {
        CT_OuterShadowEffect::default_instance_ = new CT_OuterShadowEffect();
    }
    return *CT_OuterShadowEffect::default_instance_;
}

bool CT_OuterShadowEffect::has_blurRad_attr() const
{
    return m_has_blurRad_attr;
}

void CT_OuterShadowEffect::set_blurRad_attr(const ST_PositiveCoordinate& _blurRad_attr)
{
    m_has_blurRad_attr = true;
    m_blurRad_attr = new ST_PositiveCoordinate(_blurRad_attr);
}

const ST_PositiveCoordinate& CT_OuterShadowEffect::get_blurRad_attr() const
{
    if (m_blurRad_attr)
    {
        return *m_blurRad_attr;
    }
    return ST_PositiveCoordinate::default_instance();
}

bool CT_OuterShadowEffect::has_dist_attr() const
{
    return m_has_dist_attr;
}

void CT_OuterShadowEffect::set_dist_attr(const ST_PositiveCoordinate& _dist_attr)
{
    m_has_dist_attr = true;
    m_dist_attr = new ST_PositiveCoordinate(_dist_attr);
}

const ST_PositiveCoordinate& CT_OuterShadowEffect::get_dist_attr() const
{
    if (m_dist_attr)
    {
        return *m_dist_attr;
    }
    return ST_PositiveCoordinate::default_instance();
}

bool CT_OuterShadowEffect::has_dir_attr() const
{
    return m_has_dir_attr;
}

void CT_OuterShadowEffect::set_dir_attr(const ST_PositiveFixedAngle& _dir_attr)
{
    m_has_dir_attr = true;
    m_dir_attr = new ST_PositiveFixedAngle(_dir_attr);
}

const ST_PositiveFixedAngle& CT_OuterShadowEffect::get_dir_attr() const
{
    if (m_dir_attr)
    {
        return *m_dir_attr;
    }
    return ST_PositiveFixedAngle::default_instance();
}

bool CT_OuterShadowEffect::has_sx_attr() const
{
    return m_has_sx_attr;
}

void CT_OuterShadowEffect::set_sx_attr(const ST_Percentage& _sx_attr)
{
    m_has_sx_attr = true;
    m_sx_attr = new ST_Percentage(_sx_attr);
}

const ST_Percentage& CT_OuterShadowEffect::get_sx_attr() const
{
    if (m_sx_attr)
    {
        return *m_sx_attr;
    }
    return ST_Percentage::default_instance();
}

bool CT_OuterShadowEffect::has_sy_attr() const
{
    return m_has_sy_attr;
}

void CT_OuterShadowEffect::set_sy_attr(const ST_Percentage& _sy_attr)
{
    m_has_sy_attr = true;
    m_sy_attr = new ST_Percentage(_sy_attr);
}

const ST_Percentage& CT_OuterShadowEffect::get_sy_attr() const
{
    if (m_sy_attr)
    {
        return *m_sy_attr;
    }
    return ST_Percentage::default_instance();
}

bool CT_OuterShadowEffect::has_kx_attr() const
{
    return m_has_kx_attr;
}

void CT_OuterShadowEffect::set_kx_attr(const ST_FixedAngle& _kx_attr)
{
    m_has_kx_attr = true;
    m_kx_attr = new ST_FixedAngle(_kx_attr);
}

const ST_FixedAngle& CT_OuterShadowEffect::get_kx_attr() const
{
    if (m_kx_attr)
    {
        return *m_kx_attr;
    }
    return ST_FixedAngle::default_instance();
}

bool CT_OuterShadowEffect::has_ky_attr() const
{
    return m_has_ky_attr;
}

void CT_OuterShadowEffect::set_ky_attr(const ST_FixedAngle& _ky_attr)
{
    m_has_ky_attr = true;
    m_ky_attr = new ST_FixedAngle(_ky_attr);
}

const ST_FixedAngle& CT_OuterShadowEffect::get_ky_attr() const
{
    if (m_ky_attr)
    {
        return *m_ky_attr;
    }
    return ST_FixedAngle::default_instance();
}

bool CT_OuterShadowEffect::has_algn_attr() const
{
    return m_has_algn_attr;
}

void CT_OuterShadowEffect::set_algn_attr(const ST_RectAlignment& _algn_attr)
{
    m_has_algn_attr = true;
    m_algn_attr = new ST_RectAlignment(_algn_attr);
}

const ST_RectAlignment& CT_OuterShadowEffect::get_algn_attr() const
{
    if (m_algn_attr)
    {
        return *m_algn_attr;
    }
    return ST_RectAlignment::default_instance();
}

bool CT_OuterShadowEffect::has_rotWithShape_attr() const
{
    return m_has_rotWithShape_attr;
}

void CT_OuterShadowEffect::set_rotWithShape_attr(const XSD::boolean_& _rotWithShape_attr)
{
    m_has_rotWithShape_attr = true;
    m_rotWithShape_attr = _rotWithShape_attr;
}

const XSD::boolean_& CT_OuterShadowEffect::get_rotWithShape_attr() const
{
    return m_rotWithShape_attr;
}

CT_OuterShadowEffect* CT_OuterShadowEffect::default_instance_ = NULL;

// CT_PresetShadowEffect
CT_PresetShadowEffect::CT_PresetShadowEffect()
    :m_has_scrgbClr(false),
     m_scrgbClr(NULL),
     m_has_srgbClr(false),
     m_srgbClr(NULL),
     m_has_hslClr(false),
     m_hslClr(NULL),
     m_has_sysClr(false),
     m_sysClr(NULL),
     m_has_schemeClr(false),
     m_schemeClr(NULL),
     m_has_prstClr(false),
     m_prstClr(NULL),
     m_has_prst_attr(false),
     m_prst_attr(NULL),
     m_has_dist_attr(false),
     m_dist_attr(NULL),
     m_has_dir_attr(false),
     m_dir_attr(NULL)
{
}
CT_PresetShadowEffect::~CT_PresetShadowEffect()
{
    clear();
}
bool CT_PresetShadowEffect::has_scrgbClr() const
{
    return m_has_scrgbClr;
}

CT_ScRgbColor* CT_PresetShadowEffect::mutable_scrgbClr()
{

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_scrgbClr = true;
    if (!m_scrgbClr)
    {
        m_scrgbClr = new CT_ScRgbColor();
    }
    return m_scrgbClr;
}

const CT_ScRgbColor& CT_PresetShadowEffect::get_scrgbClr() const
{
    if (m_scrgbClr)
    {
        return *m_scrgbClr;
    }
    return CT_ScRgbColor::default_instance();
}

bool CT_PresetShadowEffect::has_srgbClr() const
{
    return m_has_srgbClr;
}

CT_SRgbColor* CT_PresetShadowEffect::mutable_srgbClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_srgbClr = true;
    if (!m_srgbClr)
    {
        m_srgbClr = new CT_SRgbColor();
    }
    return m_srgbClr;
}

const CT_SRgbColor& CT_PresetShadowEffect::get_srgbClr() const
{
    if (m_srgbClr)
    {
        return *m_srgbClr;
    }
    return CT_SRgbColor::default_instance();
}

bool CT_PresetShadowEffect::has_hslClr() const
{
    return m_has_hslClr;
}

CT_HslColor* CT_PresetShadowEffect::mutable_hslClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_hslClr = true;
    if (!m_hslClr)
    {
        m_hslClr = new CT_HslColor();
    }
    return m_hslClr;
}

const CT_HslColor& CT_PresetShadowEffect::get_hslClr() const
{
    if (m_hslClr)
    {
        return *m_hslClr;
    }
    return CT_HslColor::default_instance();
}

bool CT_PresetShadowEffect::has_sysClr() const
{
    return m_has_sysClr;
}

CT_SystemColor* CT_PresetShadowEffect::mutable_sysClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_sysClr = true;
    if (!m_sysClr)
    {
        m_sysClr = new CT_SystemColor();
    }
    return m_sysClr;
}

const CT_SystemColor& CT_PresetShadowEffect::get_sysClr() const
{
    if (m_sysClr)
    {
        return *m_sysClr;
    }
    return CT_SystemColor::default_instance();
}

bool CT_PresetShadowEffect::has_schemeClr() const
{
    return m_has_schemeClr;
}

CT_SchemeColor* CT_PresetShadowEffect::mutable_schemeClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_schemeClr = true;
    if (!m_schemeClr)
    {
        m_schemeClr = new CT_SchemeColor();
    }
    return m_schemeClr;
}

const CT_SchemeColor& CT_PresetShadowEffect::get_schemeClr() const
{
    if (m_schemeClr)
    {
        return *m_schemeClr;
    }
    return CT_SchemeColor::default_instance();
}

bool CT_PresetShadowEffect::has_prstClr() const
{
    return m_has_prstClr;
}

CT_PresetColor* CT_PresetShadowEffect::mutable_prstClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = true;
    if (!m_prstClr)
    {
        m_prstClr = new CT_PresetColor();
    }
    return m_prstClr;
}

const CT_PresetColor& CT_PresetShadowEffect::get_prstClr() const
{
    if (m_prstClr)
    {
        return *m_prstClr;
    }
    return CT_PresetColor::default_instance();
}

void CT_PresetShadowEffect::clear()
{
    m_has_prst_attr = false;

    if (m_prst_attr)
    {
        delete m_prst_attr;
        m_prst_attr = NULL;
    }


    m_has_dist_attr = false;

    if (m_dist_attr)
    {
        delete m_dist_attr;
        m_dist_attr = NULL;
    }


    m_has_dir_attr = false;

    if (m_dir_attr)
    {
        delete m_dir_attr;
        m_dir_attr = NULL;
    }


    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }


    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }


    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }


    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }


    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }


    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }

}

void CT_PresetShadowEffect::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_prst_attr);
    if (m_has_prst_attr)
    {
        m_prst_attr->toXmlAttr("prst", _outStream);
    }



    if (m_has_dist_attr)
    {
        m_dist_attr->toXmlAttr("dist", _outStream);
    }



    if (m_has_dir_attr)
    {
        m_dir_attr->toXmlAttr("dir", _outStream);
    }

    _outStream << ">";

    {
        bool elemHasValueList[6] = {m_has_scrgbClr, m_has_srgbClr, m_has_hslClr, m_has_sysClr, m_has_schemeClr, m_has_prstClr};
        int cnt = count(elemHasValueList, elemHasValueList + 6, true);
        assert(cnt == 1);
    }


    if (m_has_scrgbClr)
    {
        m_scrgbClr->toXmlElem("a:scrgbClr", "", _outStream);
    }


    if (m_has_srgbClr)
    {
        m_srgbClr->toXmlElem("a:srgbClr", "", _outStream);
    }


    if (m_has_hslClr)
    {
        m_hslClr->toXmlElem("a:hslClr", "", _outStream);
    }


    if (m_has_sysClr)
    {
        m_sysClr->toXmlElem("a:sysClr", "", _outStream);
    }


    if (m_has_schemeClr)
    {
        m_schemeClr->toXmlElem("a:schemeClr", "", _outStream);
    }


    if (m_has_prstClr)
    {
        m_prstClr->toXmlElem("a:prstClr", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_PresetShadowEffect& CT_PresetShadowEffect::default_instance()
{
    if (!CT_PresetShadowEffect::default_instance_)
    {
        CT_PresetShadowEffect::default_instance_ = new CT_PresetShadowEffect();
    }
    return *CT_PresetShadowEffect::default_instance_;
}

bool CT_PresetShadowEffect::has_prst_attr() const
{
    return m_has_prst_attr;
}

void CT_PresetShadowEffect::set_prst_attr(const ST_PresetShadowVal& _prst_attr)
{
    m_has_prst_attr = true;
    m_prst_attr = new ST_PresetShadowVal(_prst_attr);
}

const ST_PresetShadowVal& CT_PresetShadowEffect::get_prst_attr() const
{
    if (m_prst_attr)
    {
        return *m_prst_attr;
    }
    return ST_PresetShadowVal::default_instance();
}

bool CT_PresetShadowEffect::has_dist_attr() const
{
    return m_has_dist_attr;
}

void CT_PresetShadowEffect::set_dist_attr(const ST_PositiveCoordinate& _dist_attr)
{
    m_has_dist_attr = true;
    m_dist_attr = new ST_PositiveCoordinate(_dist_attr);
}

const ST_PositiveCoordinate& CT_PresetShadowEffect::get_dist_attr() const
{
    if (m_dist_attr)
    {
        return *m_dist_attr;
    }
    return ST_PositiveCoordinate::default_instance();
}

bool CT_PresetShadowEffect::has_dir_attr() const
{
    return m_has_dir_attr;
}

void CT_PresetShadowEffect::set_dir_attr(const ST_PositiveFixedAngle& _dir_attr)
{
    m_has_dir_attr = true;
    m_dir_attr = new ST_PositiveFixedAngle(_dir_attr);
}

const ST_PositiveFixedAngle& CT_PresetShadowEffect::get_dir_attr() const
{
    if (m_dir_attr)
    {
        return *m_dir_attr;
    }
    return ST_PositiveFixedAngle::default_instance();
}

CT_PresetShadowEffect* CT_PresetShadowEffect::default_instance_ = NULL;

// CT_ReflectionEffect
CT_ReflectionEffect::CT_ReflectionEffect()
    :m_has_blurRad_attr(false),
     m_blurRad_attr(NULL),
     m_has_stA_attr(false),
     m_stA_attr(NULL),
     m_has_stPos_attr(false),
     m_stPos_attr(NULL),
     m_has_endA_attr(false),
     m_endA_attr(NULL),
     m_has_endPos_attr(false),
     m_endPos_attr(NULL),
     m_has_dist_attr(false),
     m_dist_attr(NULL),
     m_has_dir_attr(false),
     m_dir_attr(NULL),
     m_has_fadeDir_attr(false),
     m_fadeDir_attr(NULL),
     m_has_sx_attr(false),
     m_sx_attr(NULL),
     m_has_sy_attr(false),
     m_sy_attr(NULL),
     m_has_kx_attr(false),
     m_kx_attr(NULL),
     m_has_ky_attr(false),
     m_ky_attr(NULL),
     m_has_algn_attr(false),
     m_algn_attr(NULL),
     m_has_rotWithShape_attr(false),
     m_rotWithShape_attr(false)
{
}
CT_ReflectionEffect::~CT_ReflectionEffect()
{
    clear();
}
void CT_ReflectionEffect::clear()
{
    m_has_blurRad_attr = false;

    if (m_blurRad_attr)
    {
        delete m_blurRad_attr;
        m_blurRad_attr = NULL;
    }


    m_has_stA_attr = false;

    if (m_stA_attr)
    {
        delete m_stA_attr;
        m_stA_attr = NULL;
    }


    m_has_stPos_attr = false;

    if (m_stPos_attr)
    {
        delete m_stPos_attr;
        m_stPos_attr = NULL;
    }


    m_has_endA_attr = false;

    if (m_endA_attr)
    {
        delete m_endA_attr;
        m_endA_attr = NULL;
    }


    m_has_endPos_attr = false;

    if (m_endPos_attr)
    {
        delete m_endPos_attr;
        m_endPos_attr = NULL;
    }


    m_has_dist_attr = false;

    if (m_dist_attr)
    {
        delete m_dist_attr;
        m_dist_attr = NULL;
    }


    m_has_dir_attr = false;

    if (m_dir_attr)
    {
        delete m_dir_attr;
        m_dir_attr = NULL;
    }


    m_has_fadeDir_attr = false;

    if (m_fadeDir_attr)
    {
        delete m_fadeDir_attr;
        m_fadeDir_attr = NULL;
    }


    m_has_sx_attr = false;

    if (m_sx_attr)
    {
        delete m_sx_attr;
        m_sx_attr = NULL;
    }


    m_has_sy_attr = false;

    if (m_sy_attr)
    {
        delete m_sy_attr;
        m_sy_attr = NULL;
    }


    m_has_kx_attr = false;

    if (m_kx_attr)
    {
        delete m_kx_attr;
        m_kx_attr = NULL;
    }


    m_has_ky_attr = false;

    if (m_ky_attr)
    {
        delete m_ky_attr;
        m_ky_attr = NULL;
    }


    m_has_algn_attr = false;

    if (m_algn_attr)
    {
        delete m_algn_attr;
        m_algn_attr = NULL;
    }


    m_has_rotWithShape_attr = false;
    m_rotWithShape_attr = false;
}

void CT_ReflectionEffect::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_blurRad_attr)
    {
        m_blurRad_attr->toXmlAttr("blurRad", _outStream);
    }



    if (m_has_stA_attr)
    {
        m_stA_attr->toXmlAttr("stA", _outStream);
    }



    if (m_has_stPos_attr)
    {
        m_stPos_attr->toXmlAttr("stPos", _outStream);
    }



    if (m_has_endA_attr)
    {
        m_endA_attr->toXmlAttr("endA", _outStream);
    }



    if (m_has_endPos_attr)
    {
        m_endPos_attr->toXmlAttr("endPos", _outStream);
    }



    if (m_has_dist_attr)
    {
        m_dist_attr->toXmlAttr("dist", _outStream);
    }



    if (m_has_dir_attr)
    {
        m_dir_attr->toXmlAttr("dir", _outStream);
    }



    if (m_has_fadeDir_attr)
    {
        m_fadeDir_attr->toXmlAttr("fadeDir", _outStream);
    }



    if (m_has_sx_attr)
    {
        m_sx_attr->toXmlAttr("sx", _outStream);
    }



    if (m_has_sy_attr)
    {
        m_sy_attr->toXmlAttr("sy", _outStream);
    }



    if (m_has_kx_attr)
    {
        m_kx_attr->toXmlAttr("kx", _outStream);
    }



    if (m_has_ky_attr)
    {
        m_ky_attr->toXmlAttr("ky", _outStream);
    }



    if (m_has_algn_attr)
    {
        m_algn_attr->toXmlAttr("algn", _outStream);
    }



    if (m_has_rotWithShape_attr)
    {
        _outStream << " " << "rotWithShape" << "=\"" << XSD::XMLBooleanStr(m_rotWithShape_attr) << "\"";
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_ReflectionEffect& CT_ReflectionEffect::default_instance()
{
    if (!CT_ReflectionEffect::default_instance_)
    {
        CT_ReflectionEffect::default_instance_ = new CT_ReflectionEffect();
    }
    return *CT_ReflectionEffect::default_instance_;
}

bool CT_ReflectionEffect::has_blurRad_attr() const
{
    return m_has_blurRad_attr;
}

void CT_ReflectionEffect::set_blurRad_attr(const ST_PositiveCoordinate& _blurRad_attr)
{
    m_has_blurRad_attr = true;
    m_blurRad_attr = new ST_PositiveCoordinate(_blurRad_attr);
}

const ST_PositiveCoordinate& CT_ReflectionEffect::get_blurRad_attr() const
{
    if (m_blurRad_attr)
    {
        return *m_blurRad_attr;
    }
    return ST_PositiveCoordinate::default_instance();
}

bool CT_ReflectionEffect::has_stA_attr() const
{
    return m_has_stA_attr;
}

void CT_ReflectionEffect::set_stA_attr(const ST_PositiveFixedPercentage& _stA_attr)
{
    m_has_stA_attr = true;
    m_stA_attr = new ST_PositiveFixedPercentage(_stA_attr);
}

const ST_PositiveFixedPercentage& CT_ReflectionEffect::get_stA_attr() const
{
    if (m_stA_attr)
    {
        return *m_stA_attr;
    }
    return ST_PositiveFixedPercentage::default_instance();
}

bool CT_ReflectionEffect::has_stPos_attr() const
{
    return m_has_stPos_attr;
}

void CT_ReflectionEffect::set_stPos_attr(const ST_PositiveFixedPercentage& _stPos_attr)
{
    m_has_stPos_attr = true;
    m_stPos_attr = new ST_PositiveFixedPercentage(_stPos_attr);
}

const ST_PositiveFixedPercentage& CT_ReflectionEffect::get_stPos_attr() const
{
    if (m_stPos_attr)
    {
        return *m_stPos_attr;
    }
    return ST_PositiveFixedPercentage::default_instance();
}

bool CT_ReflectionEffect::has_endA_attr() const
{
    return m_has_endA_attr;
}

void CT_ReflectionEffect::set_endA_attr(const ST_PositiveFixedPercentage& _endA_attr)
{
    m_has_endA_attr = true;
    m_endA_attr = new ST_PositiveFixedPercentage(_endA_attr);
}

const ST_PositiveFixedPercentage& CT_ReflectionEffect::get_endA_attr() const
{
    if (m_endA_attr)
    {
        return *m_endA_attr;
    }
    return ST_PositiveFixedPercentage::default_instance();
}

bool CT_ReflectionEffect::has_endPos_attr() const
{
    return m_has_endPos_attr;
}

void CT_ReflectionEffect::set_endPos_attr(const ST_PositiveFixedPercentage& _endPos_attr)
{
    m_has_endPos_attr = true;
    m_endPos_attr = new ST_PositiveFixedPercentage(_endPos_attr);
}

const ST_PositiveFixedPercentage& CT_ReflectionEffect::get_endPos_attr() const
{
    if (m_endPos_attr)
    {
        return *m_endPos_attr;
    }
    return ST_PositiveFixedPercentage::default_instance();
}

bool CT_ReflectionEffect::has_dist_attr() const
{
    return m_has_dist_attr;
}

void CT_ReflectionEffect::set_dist_attr(const ST_PositiveCoordinate& _dist_attr)
{
    m_has_dist_attr = true;
    m_dist_attr = new ST_PositiveCoordinate(_dist_attr);
}

const ST_PositiveCoordinate& CT_ReflectionEffect::get_dist_attr() const
{
    if (m_dist_attr)
    {
        return *m_dist_attr;
    }
    return ST_PositiveCoordinate::default_instance();
}

bool CT_ReflectionEffect::has_dir_attr() const
{
    return m_has_dir_attr;
}

void CT_ReflectionEffect::set_dir_attr(const ST_PositiveFixedAngle& _dir_attr)
{
    m_has_dir_attr = true;
    m_dir_attr = new ST_PositiveFixedAngle(_dir_attr);
}

const ST_PositiveFixedAngle& CT_ReflectionEffect::get_dir_attr() const
{
    if (m_dir_attr)
    {
        return *m_dir_attr;
    }
    return ST_PositiveFixedAngle::default_instance();
}

bool CT_ReflectionEffect::has_fadeDir_attr() const
{
    return m_has_fadeDir_attr;
}

void CT_ReflectionEffect::set_fadeDir_attr(const ST_PositiveFixedAngle& _fadeDir_attr)
{
    m_has_fadeDir_attr = true;
    m_fadeDir_attr = new ST_PositiveFixedAngle(_fadeDir_attr);
}

const ST_PositiveFixedAngle& CT_ReflectionEffect::get_fadeDir_attr() const
{
    if (m_fadeDir_attr)
    {
        return *m_fadeDir_attr;
    }
    return ST_PositiveFixedAngle::default_instance();
}

bool CT_ReflectionEffect::has_sx_attr() const
{
    return m_has_sx_attr;
}

void CT_ReflectionEffect::set_sx_attr(const ST_Percentage& _sx_attr)
{
    m_has_sx_attr = true;
    m_sx_attr = new ST_Percentage(_sx_attr);
}

const ST_Percentage& CT_ReflectionEffect::get_sx_attr() const
{
    if (m_sx_attr)
    {
        return *m_sx_attr;
    }
    return ST_Percentage::default_instance();
}

bool CT_ReflectionEffect::has_sy_attr() const
{
    return m_has_sy_attr;
}

void CT_ReflectionEffect::set_sy_attr(const ST_Percentage& _sy_attr)
{
    m_has_sy_attr = true;
    m_sy_attr = new ST_Percentage(_sy_attr);
}

const ST_Percentage& CT_ReflectionEffect::get_sy_attr() const
{
    if (m_sy_attr)
    {
        return *m_sy_attr;
    }
    return ST_Percentage::default_instance();
}

bool CT_ReflectionEffect::has_kx_attr() const
{
    return m_has_kx_attr;
}

void CT_ReflectionEffect::set_kx_attr(const ST_FixedAngle& _kx_attr)
{
    m_has_kx_attr = true;
    m_kx_attr = new ST_FixedAngle(_kx_attr);
}

const ST_FixedAngle& CT_ReflectionEffect::get_kx_attr() const
{
    if (m_kx_attr)
    {
        return *m_kx_attr;
    }
    return ST_FixedAngle::default_instance();
}

bool CT_ReflectionEffect::has_ky_attr() const
{
    return m_has_ky_attr;
}

void CT_ReflectionEffect::set_ky_attr(const ST_FixedAngle& _ky_attr)
{
    m_has_ky_attr = true;
    m_ky_attr = new ST_FixedAngle(_ky_attr);
}

const ST_FixedAngle& CT_ReflectionEffect::get_ky_attr() const
{
    if (m_ky_attr)
    {
        return *m_ky_attr;
    }
    return ST_FixedAngle::default_instance();
}

bool CT_ReflectionEffect::has_algn_attr() const
{
    return m_has_algn_attr;
}

void CT_ReflectionEffect::set_algn_attr(const ST_RectAlignment& _algn_attr)
{
    m_has_algn_attr = true;
    m_algn_attr = new ST_RectAlignment(_algn_attr);
}

const ST_RectAlignment& CT_ReflectionEffect::get_algn_attr() const
{
    if (m_algn_attr)
    {
        return *m_algn_attr;
    }
    return ST_RectAlignment::default_instance();
}

bool CT_ReflectionEffect::has_rotWithShape_attr() const
{
    return m_has_rotWithShape_attr;
}

void CT_ReflectionEffect::set_rotWithShape_attr(const XSD::boolean_& _rotWithShape_attr)
{
    m_has_rotWithShape_attr = true;
    m_rotWithShape_attr = _rotWithShape_attr;
}

const XSD::boolean_& CT_ReflectionEffect::get_rotWithShape_attr() const
{
    return m_rotWithShape_attr;
}

CT_ReflectionEffect* CT_ReflectionEffect::default_instance_ = NULL;

// CT_RelativeOffsetEffect
CT_RelativeOffsetEffect::CT_RelativeOffsetEffect()
    :m_has_tx_attr(false),
     m_tx_attr(NULL),
     m_has_ty_attr(false),
     m_ty_attr(NULL)
{
}
CT_RelativeOffsetEffect::~CT_RelativeOffsetEffect()
{
    clear();
}
void CT_RelativeOffsetEffect::clear()
{
    m_has_tx_attr = false;

    if (m_tx_attr)
    {
        delete m_tx_attr;
        m_tx_attr = NULL;
    }


    m_has_ty_attr = false;

    if (m_ty_attr)
    {
        delete m_ty_attr;
        m_ty_attr = NULL;
    }

}

void CT_RelativeOffsetEffect::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_tx_attr)
    {
        m_tx_attr->toXmlAttr("tx", _outStream);
    }



    if (m_has_ty_attr)
    {
        m_ty_attr->toXmlAttr("ty", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_RelativeOffsetEffect& CT_RelativeOffsetEffect::default_instance()
{
    if (!CT_RelativeOffsetEffect::default_instance_)
    {
        CT_RelativeOffsetEffect::default_instance_ = new CT_RelativeOffsetEffect();
    }
    return *CT_RelativeOffsetEffect::default_instance_;
}

bool CT_RelativeOffsetEffect::has_tx_attr() const
{
    return m_has_tx_attr;
}

void CT_RelativeOffsetEffect::set_tx_attr(const ST_Percentage& _tx_attr)
{
    m_has_tx_attr = true;
    m_tx_attr = new ST_Percentage(_tx_attr);
}

const ST_Percentage& CT_RelativeOffsetEffect::get_tx_attr() const
{
    if (m_tx_attr)
    {
        return *m_tx_attr;
    }
    return ST_Percentage::default_instance();
}

bool CT_RelativeOffsetEffect::has_ty_attr() const
{
    return m_has_ty_attr;
}

void CT_RelativeOffsetEffect::set_ty_attr(const ST_Percentage& _ty_attr)
{
    m_has_ty_attr = true;
    m_ty_attr = new ST_Percentage(_ty_attr);
}

const ST_Percentage& CT_RelativeOffsetEffect::get_ty_attr() const
{
    if (m_ty_attr)
    {
        return *m_ty_attr;
    }
    return ST_Percentage::default_instance();
}

CT_RelativeOffsetEffect* CT_RelativeOffsetEffect::default_instance_ = NULL;

// CT_SoftEdgesEffect
CT_SoftEdgesEffect::CT_SoftEdgesEffect()
    :m_has_rad_attr(false),
     m_rad_attr(NULL)
{
}
CT_SoftEdgesEffect::~CT_SoftEdgesEffect()
{
    clear();
}
void CT_SoftEdgesEffect::clear()
{
    m_has_rad_attr = false;

    if (m_rad_attr)
    {
        delete m_rad_attr;
        m_rad_attr = NULL;
    }

}

void CT_SoftEdgesEffect::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_rad_attr);
    if (m_has_rad_attr)
    {
        m_rad_attr->toXmlAttr("rad", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_SoftEdgesEffect& CT_SoftEdgesEffect::default_instance()
{
    if (!CT_SoftEdgesEffect::default_instance_)
    {
        CT_SoftEdgesEffect::default_instance_ = new CT_SoftEdgesEffect();
    }
    return *CT_SoftEdgesEffect::default_instance_;
}

bool CT_SoftEdgesEffect::has_rad_attr() const
{
    return m_has_rad_attr;
}

void CT_SoftEdgesEffect::set_rad_attr(const ST_PositiveCoordinate& _rad_attr)
{
    m_has_rad_attr = true;
    m_rad_attr = new ST_PositiveCoordinate(_rad_attr);
}

const ST_PositiveCoordinate& CT_SoftEdgesEffect::get_rad_attr() const
{
    if (m_rad_attr)
    {
        return *m_rad_attr;
    }
    return ST_PositiveCoordinate::default_instance();
}

CT_SoftEdgesEffect* CT_SoftEdgesEffect::default_instance_ = NULL;

// CT_TintEffect
CT_TintEffect::CT_TintEffect()
    :m_has_hue_attr(false),
     m_hue_attr(NULL),
     m_has_amt_attr(false),
     m_amt_attr(NULL)
{
}
CT_TintEffect::~CT_TintEffect()
{
    clear();
}
void CT_TintEffect::clear()
{
    m_has_hue_attr = false;

    if (m_hue_attr)
    {
        delete m_hue_attr;
        m_hue_attr = NULL;
    }


    m_has_amt_attr = false;

    if (m_amt_attr)
    {
        delete m_amt_attr;
        m_amt_attr = NULL;
    }

}

void CT_TintEffect::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_hue_attr)
    {
        m_hue_attr->toXmlAttr("hue", _outStream);
    }



    if (m_has_amt_attr)
    {
        m_amt_attr->toXmlAttr("amt", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_TintEffect& CT_TintEffect::default_instance()
{
    if (!CT_TintEffect::default_instance_)
    {
        CT_TintEffect::default_instance_ = new CT_TintEffect();
    }
    return *CT_TintEffect::default_instance_;
}

bool CT_TintEffect::has_hue_attr() const
{
    return m_has_hue_attr;
}

void CT_TintEffect::set_hue_attr(const ST_PositiveFixedAngle& _hue_attr)
{
    m_has_hue_attr = true;
    m_hue_attr = new ST_PositiveFixedAngle(_hue_attr);
}

const ST_PositiveFixedAngle& CT_TintEffect::get_hue_attr() const
{
    if (m_hue_attr)
    {
        return *m_hue_attr;
    }
    return ST_PositiveFixedAngle::default_instance();
}

bool CT_TintEffect::has_amt_attr() const
{
    return m_has_amt_attr;
}

void CT_TintEffect::set_amt_attr(const ST_FixedPercentage& _amt_attr)
{
    m_has_amt_attr = true;
    m_amt_attr = new ST_FixedPercentage(_amt_attr);
}

const ST_FixedPercentage& CT_TintEffect::get_amt_attr() const
{
    if (m_amt_attr)
    {
        return *m_amt_attr;
    }
    return ST_FixedPercentage::default_instance();
}

CT_TintEffect* CT_TintEffect::default_instance_ = NULL;

// CT_TransformEffect
CT_TransformEffect::CT_TransformEffect()
    :m_has_sx_attr(false),
     m_sx_attr(NULL),
     m_has_sy_attr(false),
     m_sy_attr(NULL),
     m_has_kx_attr(false),
     m_kx_attr(NULL),
     m_has_ky_attr(false),
     m_ky_attr(NULL),
     m_has_tx_attr(false),
     m_tx_attr(NULL),
     m_has_ty_attr(false),
     m_ty_attr(NULL)
{
}
CT_TransformEffect::~CT_TransformEffect()
{
    clear();
}
void CT_TransformEffect::clear()
{
    m_has_sx_attr = false;

    if (m_sx_attr)
    {
        delete m_sx_attr;
        m_sx_attr = NULL;
    }


    m_has_sy_attr = false;

    if (m_sy_attr)
    {
        delete m_sy_attr;
        m_sy_attr = NULL;
    }


    m_has_kx_attr = false;

    if (m_kx_attr)
    {
        delete m_kx_attr;
        m_kx_attr = NULL;
    }


    m_has_ky_attr = false;

    if (m_ky_attr)
    {
        delete m_ky_attr;
        m_ky_attr = NULL;
    }


    m_has_tx_attr = false;

    if (m_tx_attr)
    {
        delete m_tx_attr;
        m_tx_attr = NULL;
    }


    m_has_ty_attr = false;

    if (m_ty_attr)
    {
        delete m_ty_attr;
        m_ty_attr = NULL;
    }

}

void CT_TransformEffect::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_sx_attr)
    {
        m_sx_attr->toXmlAttr("sx", _outStream);
    }



    if (m_has_sy_attr)
    {
        m_sy_attr->toXmlAttr("sy", _outStream);
    }



    if (m_has_kx_attr)
    {
        m_kx_attr->toXmlAttr("kx", _outStream);
    }



    if (m_has_ky_attr)
    {
        m_ky_attr->toXmlAttr("ky", _outStream);
    }



    if (m_has_tx_attr)
    {
        m_tx_attr->toXmlAttr("tx", _outStream);
    }



    if (m_has_ty_attr)
    {
        m_ty_attr->toXmlAttr("ty", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_TransformEffect& CT_TransformEffect::default_instance()
{
    if (!CT_TransformEffect::default_instance_)
    {
        CT_TransformEffect::default_instance_ = new CT_TransformEffect();
    }
    return *CT_TransformEffect::default_instance_;
}

bool CT_TransformEffect::has_sx_attr() const
{
    return m_has_sx_attr;
}

void CT_TransformEffect::set_sx_attr(const ST_Percentage& _sx_attr)
{
    m_has_sx_attr = true;
    m_sx_attr = new ST_Percentage(_sx_attr);
}

const ST_Percentage& CT_TransformEffect::get_sx_attr() const
{
    if (m_sx_attr)
    {
        return *m_sx_attr;
    }
    return ST_Percentage::default_instance();
}

bool CT_TransformEffect::has_sy_attr() const
{
    return m_has_sy_attr;
}

void CT_TransformEffect::set_sy_attr(const ST_Percentage& _sy_attr)
{
    m_has_sy_attr = true;
    m_sy_attr = new ST_Percentage(_sy_attr);
}

const ST_Percentage& CT_TransformEffect::get_sy_attr() const
{
    if (m_sy_attr)
    {
        return *m_sy_attr;
    }
    return ST_Percentage::default_instance();
}

bool CT_TransformEffect::has_kx_attr() const
{
    return m_has_kx_attr;
}

void CT_TransformEffect::set_kx_attr(const ST_FixedAngle& _kx_attr)
{
    m_has_kx_attr = true;
    m_kx_attr = new ST_FixedAngle(_kx_attr);
}

const ST_FixedAngle& CT_TransformEffect::get_kx_attr() const
{
    if (m_kx_attr)
    {
        return *m_kx_attr;
    }
    return ST_FixedAngle::default_instance();
}

bool CT_TransformEffect::has_ky_attr() const
{
    return m_has_ky_attr;
}

void CT_TransformEffect::set_ky_attr(const ST_FixedAngle& _ky_attr)
{
    m_has_ky_attr = true;
    m_ky_attr = new ST_FixedAngle(_ky_attr);
}

const ST_FixedAngle& CT_TransformEffect::get_ky_attr() const
{
    if (m_ky_attr)
    {
        return *m_ky_attr;
    }
    return ST_FixedAngle::default_instance();
}

bool CT_TransformEffect::has_tx_attr() const
{
    return m_has_tx_attr;
}

void CT_TransformEffect::set_tx_attr(const ST_Coordinate& _tx_attr)
{
    m_has_tx_attr = true;
    m_tx_attr = new ST_Coordinate(_tx_attr);
}

const ST_Coordinate& CT_TransformEffect::get_tx_attr() const
{
    if (m_tx_attr)
    {
        return *m_tx_attr;
    }
    return ST_Coordinate::default_instance();
}

bool CT_TransformEffect::has_ty_attr() const
{
    return m_has_ty_attr;
}

void CT_TransformEffect::set_ty_attr(const ST_Coordinate& _ty_attr)
{
    m_has_ty_attr = true;
    m_ty_attr = new ST_Coordinate(_ty_attr);
}

const ST_Coordinate& CT_TransformEffect::get_ty_attr() const
{
    if (m_ty_attr)
    {
        return *m_ty_attr;
    }
    return ST_Coordinate::default_instance();
}

CT_TransformEffect* CT_TransformEffect::default_instance_ = NULL;

// CT_NoFillProperties
CT_NoFillProperties::CT_NoFillProperties()

{
}
CT_NoFillProperties::~CT_NoFillProperties()
{
    clear();
}
void CT_NoFillProperties::clear()
{    }

void CT_NoFillProperties::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_NoFillProperties& CT_NoFillProperties::default_instance()
{
    if (!CT_NoFillProperties::default_instance_)
    {
        CT_NoFillProperties::default_instance_ = new CT_NoFillProperties();
    }
    return *CT_NoFillProperties::default_instance_;
}

CT_NoFillProperties* CT_NoFillProperties::default_instance_ = NULL;

// CT_SolidColorFillProperties
CT_SolidColorFillProperties::CT_SolidColorFillProperties()
    :m_has_scrgbClr(false),
     m_scrgbClr(NULL),
     m_has_srgbClr(false),
     m_srgbClr(NULL),
     m_has_hslClr(false),
     m_hslClr(NULL),
     m_has_sysClr(false),
     m_sysClr(NULL),
     m_has_schemeClr(false),
     m_schemeClr(NULL),
     m_has_prstClr(false),
     m_prstClr(NULL)
{
}
CT_SolidColorFillProperties::~CT_SolidColorFillProperties()
{
    clear();
}
bool CT_SolidColorFillProperties::has_scrgbClr() const
{
    return m_has_scrgbClr;
}

CT_ScRgbColor* CT_SolidColorFillProperties::mutable_scrgbClr()
{

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_scrgbClr = true;
    if (!m_scrgbClr)
    {
        m_scrgbClr = new CT_ScRgbColor();
    }
    return m_scrgbClr;
}

const CT_ScRgbColor& CT_SolidColorFillProperties::get_scrgbClr() const
{
    if (m_scrgbClr)
    {
        return *m_scrgbClr;
    }
    return CT_ScRgbColor::default_instance();
}

bool CT_SolidColorFillProperties::has_srgbClr() const
{
    return m_has_srgbClr;
}

CT_SRgbColor* CT_SolidColorFillProperties::mutable_srgbClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_srgbClr = true;
    if (!m_srgbClr)
    {
        m_srgbClr = new CT_SRgbColor();
    }
    return m_srgbClr;
}

const CT_SRgbColor& CT_SolidColorFillProperties::get_srgbClr() const
{
    if (m_srgbClr)
    {
        return *m_srgbClr;
    }
    return CT_SRgbColor::default_instance();
}

bool CT_SolidColorFillProperties::has_hslClr() const
{
    return m_has_hslClr;
}

CT_HslColor* CT_SolidColorFillProperties::mutable_hslClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_hslClr = true;
    if (!m_hslClr)
    {
        m_hslClr = new CT_HslColor();
    }
    return m_hslClr;
}

const CT_HslColor& CT_SolidColorFillProperties::get_hslClr() const
{
    if (m_hslClr)
    {
        return *m_hslClr;
    }
    return CT_HslColor::default_instance();
}

bool CT_SolidColorFillProperties::has_sysClr() const
{
    return m_has_sysClr;
}

CT_SystemColor* CT_SolidColorFillProperties::mutable_sysClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_sysClr = true;
    if (!m_sysClr)
    {
        m_sysClr = new CT_SystemColor();
    }
    return m_sysClr;
}

const CT_SystemColor& CT_SolidColorFillProperties::get_sysClr() const
{
    if (m_sysClr)
    {
        return *m_sysClr;
    }
    return CT_SystemColor::default_instance();
}

bool CT_SolidColorFillProperties::has_schemeClr() const
{
    return m_has_schemeClr;
}

CT_SchemeColor* CT_SolidColorFillProperties::mutable_schemeClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_schemeClr = true;
    if (!m_schemeClr)
    {
        m_schemeClr = new CT_SchemeColor();
    }
    return m_schemeClr;
}

const CT_SchemeColor& CT_SolidColorFillProperties::get_schemeClr() const
{
    if (m_schemeClr)
    {
        return *m_schemeClr;
    }
    return CT_SchemeColor::default_instance();
}

bool CT_SolidColorFillProperties::has_prstClr() const
{
    return m_has_prstClr;
}

CT_PresetColor* CT_SolidColorFillProperties::mutable_prstClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = true;
    if (!m_prstClr)
    {
        m_prstClr = new CT_PresetColor();
    }
    return m_prstClr;
}

const CT_PresetColor& CT_SolidColorFillProperties::get_prstClr() const
{
    if (m_prstClr)
    {
        return *m_prstClr;
    }
    return CT_PresetColor::default_instance();
}

void CT_SolidColorFillProperties::clear()
{
    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }


    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }


    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }


    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }


    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }


    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }

}

void CT_SolidColorFillProperties::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    {
        bool elemHasValueList[6] = {m_has_scrgbClr, m_has_srgbClr, m_has_hslClr, m_has_sysClr, m_has_schemeClr, m_has_prstClr};
        int cnt = count(elemHasValueList, elemHasValueList + 6, true);
        assert(cnt == 0 || cnt == 1);
    }


    if (m_has_scrgbClr)
    {
        m_scrgbClr->toXmlElem("a:scrgbClr", "", _outStream);
    }


    if (m_has_srgbClr)
    {
        m_srgbClr->toXmlElem("a:srgbClr", "", _outStream);
    }


    if (m_has_hslClr)
    {
        m_hslClr->toXmlElem("a:hslClr", "", _outStream);
    }


    if (m_has_sysClr)
    {
        m_sysClr->toXmlElem("a:sysClr", "", _outStream);
    }


    if (m_has_schemeClr)
    {
        m_schemeClr->toXmlElem("a:schemeClr", "", _outStream);
    }


    if (m_has_prstClr)
    {
        m_prstClr->toXmlElem("a:prstClr", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_SolidColorFillProperties& CT_SolidColorFillProperties::default_instance()
{
    if (!CT_SolidColorFillProperties::default_instance_)
    {
        CT_SolidColorFillProperties::default_instance_ = new CT_SolidColorFillProperties();
    }
    return *CT_SolidColorFillProperties::default_instance_;
}

CT_SolidColorFillProperties* CT_SolidColorFillProperties::default_instance_ = NULL;

// CT_LinearShadeProperties
CT_LinearShadeProperties::CT_LinearShadeProperties()
    :m_has_ang_attr(false),
     m_ang_attr(NULL),
     m_has_scaled_attr(false),
     m_scaled_attr(false)
{
}
CT_LinearShadeProperties::~CT_LinearShadeProperties()
{
    clear();
}
void CT_LinearShadeProperties::clear()
{
    m_has_ang_attr = false;

    if (m_ang_attr)
    {
        delete m_ang_attr;
        m_ang_attr = NULL;
    }


    m_has_scaled_attr = false;
    m_scaled_attr = false;
}

void CT_LinearShadeProperties::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_ang_attr)
    {
        m_ang_attr->toXmlAttr("ang", _outStream);
    }



    if (m_has_scaled_attr)
    {
        _outStream << " " << "scaled" << "=\"" << XSD::XMLBooleanStr(m_scaled_attr) << "\"";
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_LinearShadeProperties& CT_LinearShadeProperties::default_instance()
{
    if (!CT_LinearShadeProperties::default_instance_)
    {
        CT_LinearShadeProperties::default_instance_ = new CT_LinearShadeProperties();
    }
    return *CT_LinearShadeProperties::default_instance_;
}

bool CT_LinearShadeProperties::has_ang_attr() const
{
    return m_has_ang_attr;
}

void CT_LinearShadeProperties::set_ang_attr(const ST_PositiveFixedAngle& _ang_attr)
{
    m_has_ang_attr = true;
    m_ang_attr = new ST_PositiveFixedAngle(_ang_attr);
}

const ST_PositiveFixedAngle& CT_LinearShadeProperties::get_ang_attr() const
{
    if (m_ang_attr)
    {
        return *m_ang_attr;
    }
    return ST_PositiveFixedAngle::default_instance();
}

bool CT_LinearShadeProperties::has_scaled_attr() const
{
    return m_has_scaled_attr;
}

void CT_LinearShadeProperties::set_scaled_attr(const XSD::boolean_& _scaled_attr)
{
    m_has_scaled_attr = true;
    m_scaled_attr = _scaled_attr;
}

const XSD::boolean_& CT_LinearShadeProperties::get_scaled_attr() const
{
    return m_scaled_attr;
}

CT_LinearShadeProperties* CT_LinearShadeProperties::default_instance_ = NULL;

// CT_PathShadeProperties
CT_PathShadeProperties::CT_PathShadeProperties()
    :m_has_fillToRect(false),
     m_fillToRect(NULL),
     m_has_path_attr(false),
     m_path_attr(NULL)
{
}
CT_PathShadeProperties::~CT_PathShadeProperties()
{
    clear();
}
bool CT_PathShadeProperties::has_fillToRect() const
{
    return m_has_fillToRect;
}

CT_RelativeRect* CT_PathShadeProperties::mutable_fillToRect()
{
    m_has_fillToRect = true;
    if (!m_fillToRect)
    {
        m_fillToRect = new CT_RelativeRect();
    }
    return m_fillToRect;
}

const CT_RelativeRect& CT_PathShadeProperties::get_fillToRect() const
{
    if (m_fillToRect)
    {
        return *m_fillToRect;
    }
    return CT_RelativeRect::default_instance();
}

void CT_PathShadeProperties::clear()
{
    m_has_path_attr = false;

    if (m_path_attr)
    {
        delete m_path_attr;
        m_path_attr = NULL;
    }


    m_has_fillToRect = false;

    if (m_fillToRect)
    {
        delete m_fillToRect;
        m_fillToRect = NULL;
    }

}

void CT_PathShadeProperties::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_path_attr)
    {
        m_path_attr->toXmlAttr("path", _outStream);
    }

    _outStream << ">";


    if (m_has_fillToRect)
    {
        m_fillToRect->toXmlElem("a:fillToRect", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_PathShadeProperties& CT_PathShadeProperties::default_instance()
{
    if (!CT_PathShadeProperties::default_instance_)
    {
        CT_PathShadeProperties::default_instance_ = new CT_PathShadeProperties();
    }
    return *CT_PathShadeProperties::default_instance_;
}

bool CT_PathShadeProperties::has_path_attr() const
{
    return m_has_path_attr;
}

void CT_PathShadeProperties::set_path_attr(const ST_PathShadeType& _path_attr)
{
    m_has_path_attr = true;
    m_path_attr = new ST_PathShadeType(_path_attr);
}

const ST_PathShadeType& CT_PathShadeProperties::get_path_attr() const
{
    if (m_path_attr)
    {
        return *m_path_attr;
    }
    return ST_PathShadeType::default_instance();
}

CT_PathShadeProperties* CT_PathShadeProperties::default_instance_ = NULL;

// CT_GradientStop
CT_GradientStop::CT_GradientStop()
    :m_has_scrgbClr(false),
     m_scrgbClr(NULL),
     m_has_srgbClr(false),
     m_srgbClr(NULL),
     m_has_hslClr(false),
     m_hslClr(NULL),
     m_has_sysClr(false),
     m_sysClr(NULL),
     m_has_schemeClr(false),
     m_schemeClr(NULL),
     m_has_prstClr(false),
     m_prstClr(NULL),
     m_has_pos_attr(false),
     m_pos_attr(NULL)
{
}
CT_GradientStop::~CT_GradientStop()
{
    clear();
}
bool CT_GradientStop::has_scrgbClr() const
{
    return m_has_scrgbClr;
}

CT_ScRgbColor* CT_GradientStop::mutable_scrgbClr()
{

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_scrgbClr = true;
    if (!m_scrgbClr)
    {
        m_scrgbClr = new CT_ScRgbColor();
    }
    return m_scrgbClr;
}

const CT_ScRgbColor& CT_GradientStop::get_scrgbClr() const
{
    if (m_scrgbClr)
    {
        return *m_scrgbClr;
    }
    return CT_ScRgbColor::default_instance();
}

bool CT_GradientStop::has_srgbClr() const
{
    return m_has_srgbClr;
}

CT_SRgbColor* CT_GradientStop::mutable_srgbClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_srgbClr = true;
    if (!m_srgbClr)
    {
        m_srgbClr = new CT_SRgbColor();
    }
    return m_srgbClr;
}

const CT_SRgbColor& CT_GradientStop::get_srgbClr() const
{
    if (m_srgbClr)
    {
        return *m_srgbClr;
    }
    return CT_SRgbColor::default_instance();
}

bool CT_GradientStop::has_hslClr() const
{
    return m_has_hslClr;
}

CT_HslColor* CT_GradientStop::mutable_hslClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_hslClr = true;
    if (!m_hslClr)
    {
        m_hslClr = new CT_HslColor();
    }
    return m_hslClr;
}

const CT_HslColor& CT_GradientStop::get_hslClr() const
{
    if (m_hslClr)
    {
        return *m_hslClr;
    }
    return CT_HslColor::default_instance();
}

bool CT_GradientStop::has_sysClr() const
{
    return m_has_sysClr;
}

CT_SystemColor* CT_GradientStop::mutable_sysClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_sysClr = true;
    if (!m_sysClr)
    {
        m_sysClr = new CT_SystemColor();
    }
    return m_sysClr;
}

const CT_SystemColor& CT_GradientStop::get_sysClr() const
{
    if (m_sysClr)
    {
        return *m_sysClr;
    }
    return CT_SystemColor::default_instance();
}

bool CT_GradientStop::has_schemeClr() const
{
    return m_has_schemeClr;
}

CT_SchemeColor* CT_GradientStop::mutable_schemeClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_schemeClr = true;
    if (!m_schemeClr)
    {
        m_schemeClr = new CT_SchemeColor();
    }
    return m_schemeClr;
}

const CT_SchemeColor& CT_GradientStop::get_schemeClr() const
{
    if (m_schemeClr)
    {
        return *m_schemeClr;
    }
    return CT_SchemeColor::default_instance();
}

bool CT_GradientStop::has_prstClr() const
{
    return m_has_prstClr;
}

CT_PresetColor* CT_GradientStop::mutable_prstClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = true;
    if (!m_prstClr)
    {
        m_prstClr = new CT_PresetColor();
    }
    return m_prstClr;
}

const CT_PresetColor& CT_GradientStop::get_prstClr() const
{
    if (m_prstClr)
    {
        return *m_prstClr;
    }
    return CT_PresetColor::default_instance();
}

void CT_GradientStop::clear()
{
    m_has_pos_attr = false;

    if (m_pos_attr)
    {
        delete m_pos_attr;
        m_pos_attr = NULL;
    }


    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }


    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }


    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }


    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }


    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }


    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }

}

void CT_GradientStop::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_pos_attr);
    if (m_has_pos_attr)
    {
        m_pos_attr->toXmlAttr("pos", _outStream);
    }

    _outStream << ">";

    {
        bool elemHasValueList[6] = {m_has_scrgbClr, m_has_srgbClr, m_has_hslClr, m_has_sysClr, m_has_schemeClr, m_has_prstClr};
        int cnt = count(elemHasValueList, elemHasValueList + 6, true);
        assert(cnt == 1);
    }


    if (m_has_scrgbClr)
    {
        m_scrgbClr->toXmlElem("a:scrgbClr", "", _outStream);
    }


    if (m_has_srgbClr)
    {
        m_srgbClr->toXmlElem("a:srgbClr", "", _outStream);
    }


    if (m_has_hslClr)
    {
        m_hslClr->toXmlElem("a:hslClr", "", _outStream);
    }


    if (m_has_sysClr)
    {
        m_sysClr->toXmlElem("a:sysClr", "", _outStream);
    }


    if (m_has_schemeClr)
    {
        m_schemeClr->toXmlElem("a:schemeClr", "", _outStream);
    }


    if (m_has_prstClr)
    {
        m_prstClr->toXmlElem("a:prstClr", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_GradientStop& CT_GradientStop::default_instance()
{
    if (!CT_GradientStop::default_instance_)
    {
        CT_GradientStop::default_instance_ = new CT_GradientStop();
    }
    return *CT_GradientStop::default_instance_;
}

bool CT_GradientStop::has_pos_attr() const
{
    return m_has_pos_attr;
}

void CT_GradientStop::set_pos_attr(const ST_PositiveFixedPercentage& _pos_attr)
{
    m_has_pos_attr = true;
    m_pos_attr = new ST_PositiveFixedPercentage(_pos_attr);
}

const ST_PositiveFixedPercentage& CT_GradientStop::get_pos_attr() const
{
    if (m_pos_attr)
    {
        return *m_pos_attr;
    }
    return ST_PositiveFixedPercentage::default_instance();
}

CT_GradientStop* CT_GradientStop::default_instance_ = NULL;

// CT_GradientStopList
CT_GradientStopList::CT_GradientStopList()

{
}
CT_GradientStopList::~CT_GradientStopList()
{
    clear();
}
CT_GradientStop* CT_GradientStopList::add_gs()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_GradientStop* pNewChild = pChildGroup->mutable_gs();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

void CT_GradientStopList::clear()
{
    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }
}

void CT_GradientStopList::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    {
        int elemCnt = count_if(m_childGroupList_1.begin(), m_childGroupList_1.end(), mem_fun(&ChildGroup_1::has_gs));
        assert(2 <= elemCnt);
    }

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_gs())
            {
                (*iter)->get_gs().toXmlElem("a:gs", "", _outStream);
            }


        }
    }

    _outStream << "</" << _elemName << ">";
}

const CT_GradientStopList& CT_GradientStopList::default_instance()
{
    if (!CT_GradientStopList::default_instance_)
    {
        CT_GradientStopList::default_instance_ = new CT_GradientStopList();
    }
    return *CT_GradientStopList::default_instance_;
}


// CT_GradientStopList::ChildGroup_1
CT_GradientStopList::ChildGroup_1::ChildGroup_1()
    :m_has_gs(false),
     m_gs(NULL)
{
}
bool CT_GradientStopList::ChildGroup_1::has_gs() const
{
    return m_has_gs;
}

CT_GradientStop* CT_GradientStopList::ChildGroup_1::mutable_gs()
{

    m_has_gs = true;
    if (!m_gs)
    {
        m_gs = new CT_GradientStop();
    }
    return m_gs;
}

const CT_GradientStop& CT_GradientStopList::ChildGroup_1::get_gs() const
{
    if (m_gs)
    {
        return *m_gs;
    }
    return CT_GradientStop::default_instance();
}

CT_GradientStopList* CT_GradientStopList::default_instance_ = NULL;

// CT_GradientFillProperties
CT_GradientFillProperties::CT_GradientFillProperties()
    :m_has_gsLst(false),
     m_gsLst(NULL),
     m_has_lin(false),
     m_lin(NULL),
     m_has_path(false),
     m_path(NULL),
     m_has_tileRect(false),
     m_tileRect(NULL),
     m_has_flip_attr(false),
     m_flip_attr(NULL),
     m_has_rotWithShape_attr(false),
     m_rotWithShape_attr(false)
{
}
CT_GradientFillProperties::~CT_GradientFillProperties()
{
    clear();
}
bool CT_GradientFillProperties::has_gsLst() const
{
    return m_has_gsLst;
}

CT_GradientStopList* CT_GradientFillProperties::mutable_gsLst()
{
    m_has_gsLst = true;
    if (!m_gsLst)
    {
        m_gsLst = new CT_GradientStopList();
    }
    return m_gsLst;
}

const CT_GradientStopList& CT_GradientFillProperties::get_gsLst() const
{
    if (m_gsLst)
    {
        return *m_gsLst;
    }
    return CT_GradientStopList::default_instance();
}

bool CT_GradientFillProperties::has_lin() const
{
    return m_has_lin;
}

CT_LinearShadeProperties* CT_GradientFillProperties::mutable_lin()
{

    m_has_path = false;

    if (m_path)
    {
        delete m_path;
        m_path = NULL;
    }
    ;

    m_has_lin = true;
    if (!m_lin)
    {
        m_lin = new CT_LinearShadeProperties();
    }
    return m_lin;
}

const CT_LinearShadeProperties& CT_GradientFillProperties::get_lin() const
{
    if (m_lin)
    {
        return *m_lin;
    }
    return CT_LinearShadeProperties::default_instance();
}

bool CT_GradientFillProperties::has_path() const
{
    return m_has_path;
}

CT_PathShadeProperties* CT_GradientFillProperties::mutable_path()
{

    m_has_lin = false;

    if (m_lin)
    {
        delete m_lin;
        m_lin = NULL;
    }
    ;

    m_has_path = true;
    if (!m_path)
    {
        m_path = new CT_PathShadeProperties();
    }
    return m_path;
}

const CT_PathShadeProperties& CT_GradientFillProperties::get_path() const
{
    if (m_path)
    {
        return *m_path;
    }
    return CT_PathShadeProperties::default_instance();
}

bool CT_GradientFillProperties::has_tileRect() const
{
    return m_has_tileRect;
}

CT_RelativeRect* CT_GradientFillProperties::mutable_tileRect()
{
    m_has_tileRect = true;
    if (!m_tileRect)
    {
        m_tileRect = new CT_RelativeRect();
    }
    return m_tileRect;
}

const CT_RelativeRect& CT_GradientFillProperties::get_tileRect() const
{
    if (m_tileRect)
    {
        return *m_tileRect;
    }
    return CT_RelativeRect::default_instance();
}

void CT_GradientFillProperties::clear()
{
    m_has_flip_attr = false;

    if (m_flip_attr)
    {
        delete m_flip_attr;
        m_flip_attr = NULL;
    }


    m_has_rotWithShape_attr = false;
    m_rotWithShape_attr = false;

    m_has_gsLst = false;

    if (m_gsLst)
    {
        delete m_gsLst;
        m_gsLst = NULL;
    }


    m_has_lin = false;

    if (m_lin)
    {
        delete m_lin;
        m_lin = NULL;
    }


    m_has_path = false;

    if (m_path)
    {
        delete m_path;
        m_path = NULL;
    }


    m_has_tileRect = false;

    if (m_tileRect)
    {
        delete m_tileRect;
        m_tileRect = NULL;
    }

}

void CT_GradientFillProperties::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_flip_attr)
    {
        m_flip_attr->toXmlAttr("flip", _outStream);
    }



    if (m_has_rotWithShape_attr)
    {
        _outStream << " " << "rotWithShape" << "=\"" << XSD::XMLBooleanStr(m_rotWithShape_attr) << "\"";
    }

    _outStream << ">";


    if (m_has_gsLst)
    {
        m_gsLst->toXmlElem("a:gsLst", "", _outStream);
    }

    {
        bool elemHasValueList[2] = {m_has_lin, m_has_path};
        int cnt = count(elemHasValueList, elemHasValueList + 2, true);
        assert(cnt == 0 || cnt == 1);
    }


    if (m_has_lin)
    {
        m_lin->toXmlElem("a:lin", "", _outStream);
    }


    if (m_has_path)
    {
        m_path->toXmlElem("a:path", "", _outStream);
    }


    if (m_has_tileRect)
    {
        m_tileRect->toXmlElem("a:tileRect", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_GradientFillProperties& CT_GradientFillProperties::default_instance()
{
    if (!CT_GradientFillProperties::default_instance_)
    {
        CT_GradientFillProperties::default_instance_ = new CT_GradientFillProperties();
    }
    return *CT_GradientFillProperties::default_instance_;
}

bool CT_GradientFillProperties::has_flip_attr() const
{
    return m_has_flip_attr;
}

void CT_GradientFillProperties::set_flip_attr(const ST_TileFlipMode& _flip_attr)
{
    m_has_flip_attr = true;
    m_flip_attr = new ST_TileFlipMode(_flip_attr);
}

const ST_TileFlipMode& CT_GradientFillProperties::get_flip_attr() const
{
    if (m_flip_attr)
    {
        return *m_flip_attr;
    }
    return ST_TileFlipMode::default_instance();
}

bool CT_GradientFillProperties::has_rotWithShape_attr() const
{
    return m_has_rotWithShape_attr;
}

void CT_GradientFillProperties::set_rotWithShape_attr(const XSD::boolean_& _rotWithShape_attr)
{
    m_has_rotWithShape_attr = true;
    m_rotWithShape_attr = _rotWithShape_attr;
}

const XSD::boolean_& CT_GradientFillProperties::get_rotWithShape_attr() const
{
    return m_rotWithShape_attr;
}

CT_GradientFillProperties* CT_GradientFillProperties::default_instance_ = NULL;

// CT_TileInfoProperties
CT_TileInfoProperties::CT_TileInfoProperties()
    :m_has_tx_attr(false),
     m_tx_attr(NULL),
     m_has_ty_attr(false),
     m_ty_attr(NULL),
     m_has_sx_attr(false),
     m_sx_attr(NULL),
     m_has_sy_attr(false),
     m_sy_attr(NULL),
     m_has_flip_attr(false),
     m_flip_attr(NULL),
     m_has_algn_attr(false),
     m_algn_attr(NULL)
{
}
CT_TileInfoProperties::~CT_TileInfoProperties()
{
    clear();
}
void CT_TileInfoProperties::clear()
{
    m_has_tx_attr = false;

    if (m_tx_attr)
    {
        delete m_tx_attr;
        m_tx_attr = NULL;
    }


    m_has_ty_attr = false;

    if (m_ty_attr)
    {
        delete m_ty_attr;
        m_ty_attr = NULL;
    }


    m_has_sx_attr = false;

    if (m_sx_attr)
    {
        delete m_sx_attr;
        m_sx_attr = NULL;
    }


    m_has_sy_attr = false;

    if (m_sy_attr)
    {
        delete m_sy_attr;
        m_sy_attr = NULL;
    }


    m_has_flip_attr = false;

    if (m_flip_attr)
    {
        delete m_flip_attr;
        m_flip_attr = NULL;
    }


    m_has_algn_attr = false;

    if (m_algn_attr)
    {
        delete m_algn_attr;
        m_algn_attr = NULL;
    }

}

void CT_TileInfoProperties::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_tx_attr)
    {
        m_tx_attr->toXmlAttr("tx", _outStream);
    }



    if (m_has_ty_attr)
    {
        m_ty_attr->toXmlAttr("ty", _outStream);
    }



    if (m_has_sx_attr)
    {
        m_sx_attr->toXmlAttr("sx", _outStream);
    }



    if (m_has_sy_attr)
    {
        m_sy_attr->toXmlAttr("sy", _outStream);
    }



    if (m_has_flip_attr)
    {
        m_flip_attr->toXmlAttr("flip", _outStream);
    }



    if (m_has_algn_attr)
    {
        m_algn_attr->toXmlAttr("algn", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_TileInfoProperties& CT_TileInfoProperties::default_instance()
{
    if (!CT_TileInfoProperties::default_instance_)
    {
        CT_TileInfoProperties::default_instance_ = new CT_TileInfoProperties();
    }
    return *CT_TileInfoProperties::default_instance_;
}

bool CT_TileInfoProperties::has_tx_attr() const
{
    return m_has_tx_attr;
}

void CT_TileInfoProperties::set_tx_attr(const ST_Coordinate& _tx_attr)
{
    m_has_tx_attr = true;
    m_tx_attr = new ST_Coordinate(_tx_attr);
}

const ST_Coordinate& CT_TileInfoProperties::get_tx_attr() const
{
    if (m_tx_attr)
    {
        return *m_tx_attr;
    }
    return ST_Coordinate::default_instance();
}

bool CT_TileInfoProperties::has_ty_attr() const
{
    return m_has_ty_attr;
}

void CT_TileInfoProperties::set_ty_attr(const ST_Coordinate& _ty_attr)
{
    m_has_ty_attr = true;
    m_ty_attr = new ST_Coordinate(_ty_attr);
}

const ST_Coordinate& CT_TileInfoProperties::get_ty_attr() const
{
    if (m_ty_attr)
    {
        return *m_ty_attr;
    }
    return ST_Coordinate::default_instance();
}

bool CT_TileInfoProperties::has_sx_attr() const
{
    return m_has_sx_attr;
}

void CT_TileInfoProperties::set_sx_attr(const ST_Percentage& _sx_attr)
{
    m_has_sx_attr = true;
    m_sx_attr = new ST_Percentage(_sx_attr);
}

const ST_Percentage& CT_TileInfoProperties::get_sx_attr() const
{
    if (m_sx_attr)
    {
        return *m_sx_attr;
    }
    return ST_Percentage::default_instance();
}

bool CT_TileInfoProperties::has_sy_attr() const
{
    return m_has_sy_attr;
}

void CT_TileInfoProperties::set_sy_attr(const ST_Percentage& _sy_attr)
{
    m_has_sy_attr = true;
    m_sy_attr = new ST_Percentage(_sy_attr);
}

const ST_Percentage& CT_TileInfoProperties::get_sy_attr() const
{
    if (m_sy_attr)
    {
        return *m_sy_attr;
    }
    return ST_Percentage::default_instance();
}

bool CT_TileInfoProperties::has_flip_attr() const
{
    return m_has_flip_attr;
}

void CT_TileInfoProperties::set_flip_attr(const ST_TileFlipMode& _flip_attr)
{
    m_has_flip_attr = true;
    m_flip_attr = new ST_TileFlipMode(_flip_attr);
}

const ST_TileFlipMode& CT_TileInfoProperties::get_flip_attr() const
{
    if (m_flip_attr)
    {
        return *m_flip_attr;
    }
    return ST_TileFlipMode::default_instance();
}

bool CT_TileInfoProperties::has_algn_attr() const
{
    return m_has_algn_attr;
}

void CT_TileInfoProperties::set_algn_attr(const ST_RectAlignment& _algn_attr)
{
    m_has_algn_attr = true;
    m_algn_attr = new ST_RectAlignment(_algn_attr);
}

const ST_RectAlignment& CT_TileInfoProperties::get_algn_attr() const
{
    if (m_algn_attr)
    {
        return *m_algn_attr;
    }
    return ST_RectAlignment::default_instance();
}

CT_TileInfoProperties* CT_TileInfoProperties::default_instance_ = NULL;

// CT_StretchInfoProperties
CT_StretchInfoProperties::CT_StretchInfoProperties()
    :m_has_fillRect(false),
     m_fillRect(NULL)
{
}
CT_StretchInfoProperties::~CT_StretchInfoProperties()
{
    clear();
}
bool CT_StretchInfoProperties::has_fillRect() const
{
    return m_has_fillRect;
}

CT_RelativeRect* CT_StretchInfoProperties::mutable_fillRect()
{
    m_has_fillRect = true;
    if (!m_fillRect)
    {
        m_fillRect = new CT_RelativeRect();
    }
    return m_fillRect;
}

const CT_RelativeRect& CT_StretchInfoProperties::get_fillRect() const
{
    if (m_fillRect)
    {
        return *m_fillRect;
    }
    return CT_RelativeRect::default_instance();
}

void CT_StretchInfoProperties::clear()
{
    m_has_fillRect = false;

    if (m_fillRect)
    {
        delete m_fillRect;
        m_fillRect = NULL;
    }

}

void CT_StretchInfoProperties::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";


    if (m_has_fillRect)
    {
        m_fillRect->toXmlElem("a:fillRect", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_StretchInfoProperties& CT_StretchInfoProperties::default_instance()
{
    if (!CT_StretchInfoProperties::default_instance_)
    {
        CT_StretchInfoProperties::default_instance_ = new CT_StretchInfoProperties();
    }
    return *CT_StretchInfoProperties::default_instance_;
}

CT_StretchInfoProperties* CT_StretchInfoProperties::default_instance_ = NULL;

// CT_Blip
CT_Blip::CT_Blip()
    :m_has_extLst(false),
     m_extLst(NULL),
     m_has_r_embed_attr(false),
     m_r_embed_attr(NULL),
     m_has_r_link_attr(false),
     m_r_link_attr(NULL),
     m_has_cstate_attr(false),
     m_cstate_attr(NULL)
{
}
CT_Blip::~CT_Blip()
{
    clear();
}
CT_AlphaBiLevelEffect* CT_Blip::add_alphaBiLevel()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_AlphaBiLevelEffect* pNewChild = pChildGroup->mutable_alphaBiLevel();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_AlphaCeilingEffect* CT_Blip::add_alphaCeiling()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_AlphaCeilingEffect* pNewChild = pChildGroup->mutable_alphaCeiling();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_AlphaFloorEffect* CT_Blip::add_alphaFloor()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_AlphaFloorEffect* pNewChild = pChildGroup->mutable_alphaFloor();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_AlphaInverseEffect* CT_Blip::add_alphaInv()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_AlphaInverseEffect* pNewChild = pChildGroup->mutable_alphaInv();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_AlphaModulateEffect* CT_Blip::add_alphaMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_AlphaModulateEffect* pNewChild = pChildGroup->mutable_alphaMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_AlphaModulateFixedEffect* CT_Blip::add_alphaModFix()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_AlphaModulateFixedEffect* pNewChild = pChildGroup->mutable_alphaModFix();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_AlphaReplaceEffect* CT_Blip::add_alphaRepl()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_AlphaReplaceEffect* pNewChild = pChildGroup->mutable_alphaRepl();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_BiLevelEffect* CT_Blip::add_biLevel()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_BiLevelEffect* pNewChild = pChildGroup->mutable_biLevel();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_BlurEffect* CT_Blip::add_blur()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_BlurEffect* pNewChild = pChildGroup->mutable_blur();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_ColorChangeEffect* CT_Blip::add_clrChange()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_ColorChangeEffect* pNewChild = pChildGroup->mutable_clrChange();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_ColorReplaceEffect* CT_Blip::add_clrRepl()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_ColorReplaceEffect* pNewChild = pChildGroup->mutable_clrRepl();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_DuotoneEffect* CT_Blip::add_duotone()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_DuotoneEffect* pNewChild = pChildGroup->mutable_duotone();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_FillOverlayEffect* CT_Blip::add_fillOverlay()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_FillOverlayEffect* pNewChild = pChildGroup->mutable_fillOverlay();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_GrayscaleEffect* CT_Blip::add_grayscl()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_GrayscaleEffect* pNewChild = pChildGroup->mutable_grayscl();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_HSLEffect* CT_Blip::add_hsl()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_HSLEffect* pNewChild = pChildGroup->mutable_hsl();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_LuminanceEffect* CT_Blip::add_lum()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_LuminanceEffect* pNewChild = pChildGroup->mutable_lum();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_TintEffect* CT_Blip::add_tint()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_TintEffect* pNewChild = pChildGroup->mutable_tint();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

bool CT_Blip::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_Blip::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_Blip::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_Blip::clear()
{
    m_has_r_embed_attr = false;

    if (m_r_embed_attr)
    {
        delete m_r_embed_attr;
        m_r_embed_attr = NULL;
    }


    m_has_r_link_attr = false;

    if (m_r_link_attr)
    {
        delete m_r_link_attr;
        m_r_link_attr = NULL;
    }


    m_has_cstate_attr = false;

    if (m_cstate_attr)
    {
        delete m_cstate_attr;
        m_cstate_attr = NULL;
    }


    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }

    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_Blip::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_r_embed_attr)
    {
        m_r_embed_attr->toXmlAttr("r:embed", _outStream);
    }



    if (m_has_r_link_attr)
    {
        m_r_link_attr->toXmlAttr("r:link", _outStream);
    }



    if (m_has_cstate_attr)
    {
        m_cstate_attr->toXmlAttr("cstate", _outStream);
    }

    _outStream << ">";

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_alphaBiLevel())
            {
                (*iter)->get_alphaBiLevel().toXmlElem("a:alphaBiLevel", "", _outStream);
            }


            else if ((*iter)->has_alphaCeiling())
            {
                (*iter)->get_alphaCeiling().toXmlElem("a:alphaCeiling", "", _outStream);
            }


            else if ((*iter)->has_alphaFloor())
            {
                (*iter)->get_alphaFloor().toXmlElem("a:alphaFloor", "", _outStream);
            }


            else if ((*iter)->has_alphaInv())
            {
                (*iter)->get_alphaInv().toXmlElem("a:alphaInv", "", _outStream);
            }


            else if ((*iter)->has_alphaMod())
            {
                (*iter)->get_alphaMod().toXmlElem("a:alphaMod", "", _outStream);
            }


            else if ((*iter)->has_alphaModFix())
            {
                (*iter)->get_alphaModFix().toXmlElem("a:alphaModFix", "", _outStream);
            }


            else if ((*iter)->has_alphaRepl())
            {
                (*iter)->get_alphaRepl().toXmlElem("a:alphaRepl", "", _outStream);
            }


            else if ((*iter)->has_biLevel())
            {
                (*iter)->get_biLevel().toXmlElem("a:biLevel", "", _outStream);
            }


            else if ((*iter)->has_blur())
            {
                (*iter)->get_blur().toXmlElem("a:blur", "", _outStream);
            }


            else if ((*iter)->has_clrChange())
            {
                (*iter)->get_clrChange().toXmlElem("a:clrChange", "", _outStream);
            }


            else if ((*iter)->has_clrRepl())
            {
                (*iter)->get_clrRepl().toXmlElem("a:clrRepl", "", _outStream);
            }


            else if ((*iter)->has_duotone())
            {
                (*iter)->get_duotone().toXmlElem("a:duotone", "", _outStream);
            }


            else if ((*iter)->has_fillOverlay())
            {
                (*iter)->get_fillOverlay().toXmlElem("a:fillOverlay", "", _outStream);
            }


            else if ((*iter)->has_grayscl())
            {
                (*iter)->get_grayscl().toXmlElem("a:grayscl", "", _outStream);
            }


            else if ((*iter)->has_hsl())
            {
                (*iter)->get_hsl().toXmlElem("a:hsl", "", _outStream);
            }


            else if ((*iter)->has_lum())
            {
                (*iter)->get_lum().toXmlElem("a:lum", "", _outStream);
            }


            else if ((*iter)->has_tint())
            {
                (*iter)->get_tint().toXmlElem("a:tint", "", _outStream);
            }


        }
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_Blip& CT_Blip::default_instance()
{
    if (!CT_Blip::default_instance_)
    {
        CT_Blip::default_instance_ = new CT_Blip();
    }
    return *CT_Blip::default_instance_;
}

bool CT_Blip::has_r_embed_attr() const
{
    return m_has_r_embed_attr;
}

void CT_Blip::set_r_embed_attr(const ns_r::ST_RelationshipId& _r_embed_attr)
{
    m_has_r_embed_attr = true;
    m_r_embed_attr = new ns_r::ST_RelationshipId(_r_embed_attr);
}

const ns_r::ST_RelationshipId& CT_Blip::get_r_embed_attr() const
{
    if (m_r_embed_attr)
    {
        return *m_r_embed_attr;
    }
    return ns_r::ST_RelationshipId::default_instance();
}

bool CT_Blip::has_r_link_attr() const
{
    return m_has_r_link_attr;
}

void CT_Blip::set_r_link_attr(const ns_r::ST_RelationshipId& _r_link_attr)
{
    m_has_r_link_attr = true;
    m_r_link_attr = new ns_r::ST_RelationshipId(_r_link_attr);
}

const ns_r::ST_RelationshipId& CT_Blip::get_r_link_attr() const
{
    if (m_r_link_attr)
    {
        return *m_r_link_attr;
    }
    return ns_r::ST_RelationshipId::default_instance();
}

bool CT_Blip::has_cstate_attr() const
{
    return m_has_cstate_attr;
}

void CT_Blip::set_cstate_attr(const ST_BlipCompression& _cstate_attr)
{
    m_has_cstate_attr = true;
    m_cstate_attr = new ST_BlipCompression(_cstate_attr);
}

const ST_BlipCompression& CT_Blip::get_cstate_attr() const
{
    if (m_cstate_attr)
    {
        return *m_cstate_attr;
    }
    return ST_BlipCompression::default_instance();
}


// CT_Blip::ChildGroup_1
CT_Blip::ChildGroup_1::ChildGroup_1()
    :m_has_alphaBiLevel(false),
     m_alphaBiLevel(NULL),
     m_has_alphaCeiling(false),
     m_alphaCeiling(NULL),
     m_has_alphaFloor(false),
     m_alphaFloor(NULL),
     m_has_alphaInv(false),
     m_alphaInv(NULL),
     m_has_alphaMod(false),
     m_alphaMod(NULL),
     m_has_alphaModFix(false),
     m_alphaModFix(NULL),
     m_has_alphaRepl(false),
     m_alphaRepl(NULL),
     m_has_biLevel(false),
     m_biLevel(NULL),
     m_has_blur(false),
     m_blur(NULL),
     m_has_clrChange(false),
     m_clrChange(NULL),
     m_has_clrRepl(false),
     m_clrRepl(NULL),
     m_has_duotone(false),
     m_duotone(NULL),
     m_has_fillOverlay(false),
     m_fillOverlay(NULL),
     m_has_grayscl(false),
     m_grayscl(NULL),
     m_has_hsl(false),
     m_hsl(NULL),
     m_has_lum(false),
     m_lum(NULL),
     m_has_tint(false),
     m_tint(NULL)
{
}
bool CT_Blip::ChildGroup_1::has_alphaBiLevel() const
{
    return m_has_alphaBiLevel;
}

CT_AlphaBiLevelEffect* CT_Blip::ChildGroup_1::mutable_alphaBiLevel()
{

    m_has_alphaCeiling = false;

    if (m_alphaCeiling)
    {
        delete m_alphaCeiling;
        m_alphaCeiling = NULL;
    }
    ;

    m_has_alphaFloor = false;

    if (m_alphaFloor)
    {
        delete m_alphaFloor;
        m_alphaFloor = NULL;
    }
    ;

    m_has_alphaInv = false;

    if (m_alphaInv)
    {
        delete m_alphaInv;
        m_alphaInv = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_alphaModFix = false;

    if (m_alphaModFix)
    {
        delete m_alphaModFix;
        m_alphaModFix = NULL;
    }
    ;

    m_has_alphaRepl = false;

    if (m_alphaRepl)
    {
        delete m_alphaRepl;
        m_alphaRepl = NULL;
    }
    ;

    m_has_biLevel = false;

    if (m_biLevel)
    {
        delete m_biLevel;
        m_biLevel = NULL;
    }
    ;

    m_has_blur = false;

    if (m_blur)
    {
        delete m_blur;
        m_blur = NULL;
    }
    ;

    m_has_clrChange = false;

    if (m_clrChange)
    {
        delete m_clrChange;
        m_clrChange = NULL;
    }
    ;

    m_has_clrRepl = false;

    if (m_clrRepl)
    {
        delete m_clrRepl;
        m_clrRepl = NULL;
    }
    ;

    m_has_duotone = false;

    if (m_duotone)
    {
        delete m_duotone;
        m_duotone = NULL;
    }
    ;

    m_has_fillOverlay = false;

    if (m_fillOverlay)
    {
        delete m_fillOverlay;
        m_fillOverlay = NULL;
    }
    ;

    m_has_grayscl = false;

    if (m_grayscl)
    {
        delete m_grayscl;
        m_grayscl = NULL;
    }
    ;

    m_has_hsl = false;

    if (m_hsl)
    {
        delete m_hsl;
        m_hsl = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_alphaBiLevel = true;
    if (!m_alphaBiLevel)
    {
        m_alphaBiLevel = new CT_AlphaBiLevelEffect();
    }
    return m_alphaBiLevel;
}

const CT_AlphaBiLevelEffect& CT_Blip::ChildGroup_1::get_alphaBiLevel() const
{
    if (m_alphaBiLevel)
    {
        return *m_alphaBiLevel;
    }
    return CT_AlphaBiLevelEffect::default_instance();
}

bool CT_Blip::ChildGroup_1::has_alphaCeiling() const
{
    return m_has_alphaCeiling;
}

CT_AlphaCeilingEffect* CT_Blip::ChildGroup_1::mutable_alphaCeiling()
{

    m_has_alphaBiLevel = false;

    if (m_alphaBiLevel)
    {
        delete m_alphaBiLevel;
        m_alphaBiLevel = NULL;
    }
    ;

    m_has_alphaFloor = false;

    if (m_alphaFloor)
    {
        delete m_alphaFloor;
        m_alphaFloor = NULL;
    }
    ;

    m_has_alphaInv = false;

    if (m_alphaInv)
    {
        delete m_alphaInv;
        m_alphaInv = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_alphaModFix = false;

    if (m_alphaModFix)
    {
        delete m_alphaModFix;
        m_alphaModFix = NULL;
    }
    ;

    m_has_alphaRepl = false;

    if (m_alphaRepl)
    {
        delete m_alphaRepl;
        m_alphaRepl = NULL;
    }
    ;

    m_has_biLevel = false;

    if (m_biLevel)
    {
        delete m_biLevel;
        m_biLevel = NULL;
    }
    ;

    m_has_blur = false;

    if (m_blur)
    {
        delete m_blur;
        m_blur = NULL;
    }
    ;

    m_has_clrChange = false;

    if (m_clrChange)
    {
        delete m_clrChange;
        m_clrChange = NULL;
    }
    ;

    m_has_clrRepl = false;

    if (m_clrRepl)
    {
        delete m_clrRepl;
        m_clrRepl = NULL;
    }
    ;

    m_has_duotone = false;

    if (m_duotone)
    {
        delete m_duotone;
        m_duotone = NULL;
    }
    ;

    m_has_fillOverlay = false;

    if (m_fillOverlay)
    {
        delete m_fillOverlay;
        m_fillOverlay = NULL;
    }
    ;

    m_has_grayscl = false;

    if (m_grayscl)
    {
        delete m_grayscl;
        m_grayscl = NULL;
    }
    ;

    m_has_hsl = false;

    if (m_hsl)
    {
        delete m_hsl;
        m_hsl = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_alphaCeiling = true;
    if (!m_alphaCeiling)
    {
        m_alphaCeiling = new CT_AlphaCeilingEffect();
    }
    return m_alphaCeiling;
}

const CT_AlphaCeilingEffect& CT_Blip::ChildGroup_1::get_alphaCeiling() const
{
    if (m_alphaCeiling)
    {
        return *m_alphaCeiling;
    }
    return CT_AlphaCeilingEffect::default_instance();
}

bool CT_Blip::ChildGroup_1::has_alphaFloor() const
{
    return m_has_alphaFloor;
}

CT_AlphaFloorEffect* CT_Blip::ChildGroup_1::mutable_alphaFloor()
{

    m_has_alphaBiLevel = false;

    if (m_alphaBiLevel)
    {
        delete m_alphaBiLevel;
        m_alphaBiLevel = NULL;
    }
    ;

    m_has_alphaCeiling = false;

    if (m_alphaCeiling)
    {
        delete m_alphaCeiling;
        m_alphaCeiling = NULL;
    }
    ;

    m_has_alphaInv = false;

    if (m_alphaInv)
    {
        delete m_alphaInv;
        m_alphaInv = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_alphaModFix = false;

    if (m_alphaModFix)
    {
        delete m_alphaModFix;
        m_alphaModFix = NULL;
    }
    ;

    m_has_alphaRepl = false;

    if (m_alphaRepl)
    {
        delete m_alphaRepl;
        m_alphaRepl = NULL;
    }
    ;

    m_has_biLevel = false;

    if (m_biLevel)
    {
        delete m_biLevel;
        m_biLevel = NULL;
    }
    ;

    m_has_blur = false;

    if (m_blur)
    {
        delete m_blur;
        m_blur = NULL;
    }
    ;

    m_has_clrChange = false;

    if (m_clrChange)
    {
        delete m_clrChange;
        m_clrChange = NULL;
    }
    ;

    m_has_clrRepl = false;

    if (m_clrRepl)
    {
        delete m_clrRepl;
        m_clrRepl = NULL;
    }
    ;

    m_has_duotone = false;

    if (m_duotone)
    {
        delete m_duotone;
        m_duotone = NULL;
    }
    ;

    m_has_fillOverlay = false;

    if (m_fillOverlay)
    {
        delete m_fillOverlay;
        m_fillOverlay = NULL;
    }
    ;

    m_has_grayscl = false;

    if (m_grayscl)
    {
        delete m_grayscl;
        m_grayscl = NULL;
    }
    ;

    m_has_hsl = false;

    if (m_hsl)
    {
        delete m_hsl;
        m_hsl = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_alphaFloor = true;
    if (!m_alphaFloor)
    {
        m_alphaFloor = new CT_AlphaFloorEffect();
    }
    return m_alphaFloor;
}

const CT_AlphaFloorEffect& CT_Blip::ChildGroup_1::get_alphaFloor() const
{
    if (m_alphaFloor)
    {
        return *m_alphaFloor;
    }
    return CT_AlphaFloorEffect::default_instance();
}

bool CT_Blip::ChildGroup_1::has_alphaInv() const
{
    return m_has_alphaInv;
}

CT_AlphaInverseEffect* CT_Blip::ChildGroup_1::mutable_alphaInv()
{

    m_has_alphaBiLevel = false;

    if (m_alphaBiLevel)
    {
        delete m_alphaBiLevel;
        m_alphaBiLevel = NULL;
    }
    ;

    m_has_alphaCeiling = false;

    if (m_alphaCeiling)
    {
        delete m_alphaCeiling;
        m_alphaCeiling = NULL;
    }
    ;

    m_has_alphaFloor = false;

    if (m_alphaFloor)
    {
        delete m_alphaFloor;
        m_alphaFloor = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_alphaModFix = false;

    if (m_alphaModFix)
    {
        delete m_alphaModFix;
        m_alphaModFix = NULL;
    }
    ;

    m_has_alphaRepl = false;

    if (m_alphaRepl)
    {
        delete m_alphaRepl;
        m_alphaRepl = NULL;
    }
    ;

    m_has_biLevel = false;

    if (m_biLevel)
    {
        delete m_biLevel;
        m_biLevel = NULL;
    }
    ;

    m_has_blur = false;

    if (m_blur)
    {
        delete m_blur;
        m_blur = NULL;
    }
    ;

    m_has_clrChange = false;

    if (m_clrChange)
    {
        delete m_clrChange;
        m_clrChange = NULL;
    }
    ;

    m_has_clrRepl = false;

    if (m_clrRepl)
    {
        delete m_clrRepl;
        m_clrRepl = NULL;
    }
    ;

    m_has_duotone = false;

    if (m_duotone)
    {
        delete m_duotone;
        m_duotone = NULL;
    }
    ;

    m_has_fillOverlay = false;

    if (m_fillOverlay)
    {
        delete m_fillOverlay;
        m_fillOverlay = NULL;
    }
    ;

    m_has_grayscl = false;

    if (m_grayscl)
    {
        delete m_grayscl;
        m_grayscl = NULL;
    }
    ;

    m_has_hsl = false;

    if (m_hsl)
    {
        delete m_hsl;
        m_hsl = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_alphaInv = true;
    if (!m_alphaInv)
    {
        m_alphaInv = new CT_AlphaInverseEffect();
    }
    return m_alphaInv;
}

const CT_AlphaInverseEffect& CT_Blip::ChildGroup_1::get_alphaInv() const
{
    if (m_alphaInv)
    {
        return *m_alphaInv;
    }
    return CT_AlphaInverseEffect::default_instance();
}

bool CT_Blip::ChildGroup_1::has_alphaMod() const
{
    return m_has_alphaMod;
}

CT_AlphaModulateEffect* CT_Blip::ChildGroup_1::mutable_alphaMod()
{

    m_has_alphaBiLevel = false;

    if (m_alphaBiLevel)
    {
        delete m_alphaBiLevel;
        m_alphaBiLevel = NULL;
    }
    ;

    m_has_alphaCeiling = false;

    if (m_alphaCeiling)
    {
        delete m_alphaCeiling;
        m_alphaCeiling = NULL;
    }
    ;

    m_has_alphaFloor = false;

    if (m_alphaFloor)
    {
        delete m_alphaFloor;
        m_alphaFloor = NULL;
    }
    ;

    m_has_alphaInv = false;

    if (m_alphaInv)
    {
        delete m_alphaInv;
        m_alphaInv = NULL;
    }
    ;

    m_has_alphaModFix = false;

    if (m_alphaModFix)
    {
        delete m_alphaModFix;
        m_alphaModFix = NULL;
    }
    ;

    m_has_alphaRepl = false;

    if (m_alphaRepl)
    {
        delete m_alphaRepl;
        m_alphaRepl = NULL;
    }
    ;

    m_has_biLevel = false;

    if (m_biLevel)
    {
        delete m_biLevel;
        m_biLevel = NULL;
    }
    ;

    m_has_blur = false;

    if (m_blur)
    {
        delete m_blur;
        m_blur = NULL;
    }
    ;

    m_has_clrChange = false;

    if (m_clrChange)
    {
        delete m_clrChange;
        m_clrChange = NULL;
    }
    ;

    m_has_clrRepl = false;

    if (m_clrRepl)
    {
        delete m_clrRepl;
        m_clrRepl = NULL;
    }
    ;

    m_has_duotone = false;

    if (m_duotone)
    {
        delete m_duotone;
        m_duotone = NULL;
    }
    ;

    m_has_fillOverlay = false;

    if (m_fillOverlay)
    {
        delete m_fillOverlay;
        m_fillOverlay = NULL;
    }
    ;

    m_has_grayscl = false;

    if (m_grayscl)
    {
        delete m_grayscl;
        m_grayscl = NULL;
    }
    ;

    m_has_hsl = false;

    if (m_hsl)
    {
        delete m_hsl;
        m_hsl = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_alphaMod = true;
    if (!m_alphaMod)
    {
        m_alphaMod = new CT_AlphaModulateEffect();
    }
    return m_alphaMod;
}

const CT_AlphaModulateEffect& CT_Blip::ChildGroup_1::get_alphaMod() const
{
    if (m_alphaMod)
    {
        return *m_alphaMod;
    }
    return CT_AlphaModulateEffect::default_instance();
}

bool CT_Blip::ChildGroup_1::has_alphaModFix() const
{
    return m_has_alphaModFix;
}

CT_AlphaModulateFixedEffect* CT_Blip::ChildGroup_1::mutable_alphaModFix()
{

    m_has_alphaBiLevel = false;

    if (m_alphaBiLevel)
    {
        delete m_alphaBiLevel;
        m_alphaBiLevel = NULL;
    }
    ;

    m_has_alphaCeiling = false;

    if (m_alphaCeiling)
    {
        delete m_alphaCeiling;
        m_alphaCeiling = NULL;
    }
    ;

    m_has_alphaFloor = false;

    if (m_alphaFloor)
    {
        delete m_alphaFloor;
        m_alphaFloor = NULL;
    }
    ;

    m_has_alphaInv = false;

    if (m_alphaInv)
    {
        delete m_alphaInv;
        m_alphaInv = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_alphaRepl = false;

    if (m_alphaRepl)
    {
        delete m_alphaRepl;
        m_alphaRepl = NULL;
    }
    ;

    m_has_biLevel = false;

    if (m_biLevel)
    {
        delete m_biLevel;
        m_biLevel = NULL;
    }
    ;

    m_has_blur = false;

    if (m_blur)
    {
        delete m_blur;
        m_blur = NULL;
    }
    ;

    m_has_clrChange = false;

    if (m_clrChange)
    {
        delete m_clrChange;
        m_clrChange = NULL;
    }
    ;

    m_has_clrRepl = false;

    if (m_clrRepl)
    {
        delete m_clrRepl;
        m_clrRepl = NULL;
    }
    ;

    m_has_duotone = false;

    if (m_duotone)
    {
        delete m_duotone;
        m_duotone = NULL;
    }
    ;

    m_has_fillOverlay = false;

    if (m_fillOverlay)
    {
        delete m_fillOverlay;
        m_fillOverlay = NULL;
    }
    ;

    m_has_grayscl = false;

    if (m_grayscl)
    {
        delete m_grayscl;
        m_grayscl = NULL;
    }
    ;

    m_has_hsl = false;

    if (m_hsl)
    {
        delete m_hsl;
        m_hsl = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_alphaModFix = true;
    if (!m_alphaModFix)
    {
        m_alphaModFix = new CT_AlphaModulateFixedEffect();
    }
    return m_alphaModFix;
}

const CT_AlphaModulateFixedEffect& CT_Blip::ChildGroup_1::get_alphaModFix() const
{
    if (m_alphaModFix)
    {
        return *m_alphaModFix;
    }
    return CT_AlphaModulateFixedEffect::default_instance();
}

bool CT_Blip::ChildGroup_1::has_alphaRepl() const
{
    return m_has_alphaRepl;
}

CT_AlphaReplaceEffect* CT_Blip::ChildGroup_1::mutable_alphaRepl()
{

    m_has_alphaBiLevel = false;

    if (m_alphaBiLevel)
    {
        delete m_alphaBiLevel;
        m_alphaBiLevel = NULL;
    }
    ;

    m_has_alphaCeiling = false;

    if (m_alphaCeiling)
    {
        delete m_alphaCeiling;
        m_alphaCeiling = NULL;
    }
    ;

    m_has_alphaFloor = false;

    if (m_alphaFloor)
    {
        delete m_alphaFloor;
        m_alphaFloor = NULL;
    }
    ;

    m_has_alphaInv = false;

    if (m_alphaInv)
    {
        delete m_alphaInv;
        m_alphaInv = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_alphaModFix = false;

    if (m_alphaModFix)
    {
        delete m_alphaModFix;
        m_alphaModFix = NULL;
    }
    ;

    m_has_biLevel = false;

    if (m_biLevel)
    {
        delete m_biLevel;
        m_biLevel = NULL;
    }
    ;

    m_has_blur = false;

    if (m_blur)
    {
        delete m_blur;
        m_blur = NULL;
    }
    ;

    m_has_clrChange = false;

    if (m_clrChange)
    {
        delete m_clrChange;
        m_clrChange = NULL;
    }
    ;

    m_has_clrRepl = false;

    if (m_clrRepl)
    {
        delete m_clrRepl;
        m_clrRepl = NULL;
    }
    ;

    m_has_duotone = false;

    if (m_duotone)
    {
        delete m_duotone;
        m_duotone = NULL;
    }
    ;

    m_has_fillOverlay = false;

    if (m_fillOverlay)
    {
        delete m_fillOverlay;
        m_fillOverlay = NULL;
    }
    ;

    m_has_grayscl = false;

    if (m_grayscl)
    {
        delete m_grayscl;
        m_grayscl = NULL;
    }
    ;

    m_has_hsl = false;

    if (m_hsl)
    {
        delete m_hsl;
        m_hsl = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_alphaRepl = true;
    if (!m_alphaRepl)
    {
        m_alphaRepl = new CT_AlphaReplaceEffect();
    }
    return m_alphaRepl;
}

const CT_AlphaReplaceEffect& CT_Blip::ChildGroup_1::get_alphaRepl() const
{
    if (m_alphaRepl)
    {
        return *m_alphaRepl;
    }
    return CT_AlphaReplaceEffect::default_instance();
}

bool CT_Blip::ChildGroup_1::has_biLevel() const
{
    return m_has_biLevel;
}

CT_BiLevelEffect* CT_Blip::ChildGroup_1::mutable_biLevel()
{

    m_has_alphaBiLevel = false;

    if (m_alphaBiLevel)
    {
        delete m_alphaBiLevel;
        m_alphaBiLevel = NULL;
    }
    ;

    m_has_alphaCeiling = false;

    if (m_alphaCeiling)
    {
        delete m_alphaCeiling;
        m_alphaCeiling = NULL;
    }
    ;

    m_has_alphaFloor = false;

    if (m_alphaFloor)
    {
        delete m_alphaFloor;
        m_alphaFloor = NULL;
    }
    ;

    m_has_alphaInv = false;

    if (m_alphaInv)
    {
        delete m_alphaInv;
        m_alphaInv = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_alphaModFix = false;

    if (m_alphaModFix)
    {
        delete m_alphaModFix;
        m_alphaModFix = NULL;
    }
    ;

    m_has_alphaRepl = false;

    if (m_alphaRepl)
    {
        delete m_alphaRepl;
        m_alphaRepl = NULL;
    }
    ;

    m_has_blur = false;

    if (m_blur)
    {
        delete m_blur;
        m_blur = NULL;
    }
    ;

    m_has_clrChange = false;

    if (m_clrChange)
    {
        delete m_clrChange;
        m_clrChange = NULL;
    }
    ;

    m_has_clrRepl = false;

    if (m_clrRepl)
    {
        delete m_clrRepl;
        m_clrRepl = NULL;
    }
    ;

    m_has_duotone = false;

    if (m_duotone)
    {
        delete m_duotone;
        m_duotone = NULL;
    }
    ;

    m_has_fillOverlay = false;

    if (m_fillOverlay)
    {
        delete m_fillOverlay;
        m_fillOverlay = NULL;
    }
    ;

    m_has_grayscl = false;

    if (m_grayscl)
    {
        delete m_grayscl;
        m_grayscl = NULL;
    }
    ;

    m_has_hsl = false;

    if (m_hsl)
    {
        delete m_hsl;
        m_hsl = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_biLevel = true;
    if (!m_biLevel)
    {
        m_biLevel = new CT_BiLevelEffect();
    }
    return m_biLevel;
}

const CT_BiLevelEffect& CT_Blip::ChildGroup_1::get_biLevel() const
{
    if (m_biLevel)
    {
        return *m_biLevel;
    }
    return CT_BiLevelEffect::default_instance();
}

bool CT_Blip::ChildGroup_1::has_blur() const
{
    return m_has_blur;
}

CT_BlurEffect* CT_Blip::ChildGroup_1::mutable_blur()
{

    m_has_alphaBiLevel = false;

    if (m_alphaBiLevel)
    {
        delete m_alphaBiLevel;
        m_alphaBiLevel = NULL;
    }
    ;

    m_has_alphaCeiling = false;

    if (m_alphaCeiling)
    {
        delete m_alphaCeiling;
        m_alphaCeiling = NULL;
    }
    ;

    m_has_alphaFloor = false;

    if (m_alphaFloor)
    {
        delete m_alphaFloor;
        m_alphaFloor = NULL;
    }
    ;

    m_has_alphaInv = false;

    if (m_alphaInv)
    {
        delete m_alphaInv;
        m_alphaInv = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_alphaModFix = false;

    if (m_alphaModFix)
    {
        delete m_alphaModFix;
        m_alphaModFix = NULL;
    }
    ;

    m_has_alphaRepl = false;

    if (m_alphaRepl)
    {
        delete m_alphaRepl;
        m_alphaRepl = NULL;
    }
    ;

    m_has_biLevel = false;

    if (m_biLevel)
    {
        delete m_biLevel;
        m_biLevel = NULL;
    }
    ;

    m_has_clrChange = false;

    if (m_clrChange)
    {
        delete m_clrChange;
        m_clrChange = NULL;
    }
    ;

    m_has_clrRepl = false;

    if (m_clrRepl)
    {
        delete m_clrRepl;
        m_clrRepl = NULL;
    }
    ;

    m_has_duotone = false;

    if (m_duotone)
    {
        delete m_duotone;
        m_duotone = NULL;
    }
    ;

    m_has_fillOverlay = false;

    if (m_fillOverlay)
    {
        delete m_fillOverlay;
        m_fillOverlay = NULL;
    }
    ;

    m_has_grayscl = false;

    if (m_grayscl)
    {
        delete m_grayscl;
        m_grayscl = NULL;
    }
    ;

    m_has_hsl = false;

    if (m_hsl)
    {
        delete m_hsl;
        m_hsl = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_blur = true;
    if (!m_blur)
    {
        m_blur = new CT_BlurEffect();
    }
    return m_blur;
}

const CT_BlurEffect& CT_Blip::ChildGroup_1::get_blur() const
{
    if (m_blur)
    {
        return *m_blur;
    }
    return CT_BlurEffect::default_instance();
}

bool CT_Blip::ChildGroup_1::has_clrChange() const
{
    return m_has_clrChange;
}

CT_ColorChangeEffect* CT_Blip::ChildGroup_1::mutable_clrChange()
{

    m_has_alphaBiLevel = false;

    if (m_alphaBiLevel)
    {
        delete m_alphaBiLevel;
        m_alphaBiLevel = NULL;
    }
    ;

    m_has_alphaCeiling = false;

    if (m_alphaCeiling)
    {
        delete m_alphaCeiling;
        m_alphaCeiling = NULL;
    }
    ;

    m_has_alphaFloor = false;

    if (m_alphaFloor)
    {
        delete m_alphaFloor;
        m_alphaFloor = NULL;
    }
    ;

    m_has_alphaInv = false;

    if (m_alphaInv)
    {
        delete m_alphaInv;
        m_alphaInv = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_alphaModFix = false;

    if (m_alphaModFix)
    {
        delete m_alphaModFix;
        m_alphaModFix = NULL;
    }
    ;

    m_has_alphaRepl = false;

    if (m_alphaRepl)
    {
        delete m_alphaRepl;
        m_alphaRepl = NULL;
    }
    ;

    m_has_biLevel = false;

    if (m_biLevel)
    {
        delete m_biLevel;
        m_biLevel = NULL;
    }
    ;

    m_has_blur = false;

    if (m_blur)
    {
        delete m_blur;
        m_blur = NULL;
    }
    ;

    m_has_clrRepl = false;

    if (m_clrRepl)
    {
        delete m_clrRepl;
        m_clrRepl = NULL;
    }
    ;

    m_has_duotone = false;

    if (m_duotone)
    {
        delete m_duotone;
        m_duotone = NULL;
    }
    ;

    m_has_fillOverlay = false;

    if (m_fillOverlay)
    {
        delete m_fillOverlay;
        m_fillOverlay = NULL;
    }
    ;

    m_has_grayscl = false;

    if (m_grayscl)
    {
        delete m_grayscl;
        m_grayscl = NULL;
    }
    ;

    m_has_hsl = false;

    if (m_hsl)
    {
        delete m_hsl;
        m_hsl = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_clrChange = true;
    if (!m_clrChange)
    {
        m_clrChange = new CT_ColorChangeEffect();
    }
    return m_clrChange;
}

const CT_ColorChangeEffect& CT_Blip::ChildGroup_1::get_clrChange() const
{
    if (m_clrChange)
    {
        return *m_clrChange;
    }
    return CT_ColorChangeEffect::default_instance();
}

bool CT_Blip::ChildGroup_1::has_clrRepl() const
{
    return m_has_clrRepl;
}

CT_ColorReplaceEffect* CT_Blip::ChildGroup_1::mutable_clrRepl()
{

    m_has_alphaBiLevel = false;

    if (m_alphaBiLevel)
    {
        delete m_alphaBiLevel;
        m_alphaBiLevel = NULL;
    }
    ;

    m_has_alphaCeiling = false;

    if (m_alphaCeiling)
    {
        delete m_alphaCeiling;
        m_alphaCeiling = NULL;
    }
    ;

    m_has_alphaFloor = false;

    if (m_alphaFloor)
    {
        delete m_alphaFloor;
        m_alphaFloor = NULL;
    }
    ;

    m_has_alphaInv = false;

    if (m_alphaInv)
    {
        delete m_alphaInv;
        m_alphaInv = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_alphaModFix = false;

    if (m_alphaModFix)
    {
        delete m_alphaModFix;
        m_alphaModFix = NULL;
    }
    ;

    m_has_alphaRepl = false;

    if (m_alphaRepl)
    {
        delete m_alphaRepl;
        m_alphaRepl = NULL;
    }
    ;

    m_has_biLevel = false;

    if (m_biLevel)
    {
        delete m_biLevel;
        m_biLevel = NULL;
    }
    ;

    m_has_blur = false;

    if (m_blur)
    {
        delete m_blur;
        m_blur = NULL;
    }
    ;

    m_has_clrChange = false;

    if (m_clrChange)
    {
        delete m_clrChange;
        m_clrChange = NULL;
    }
    ;

    m_has_duotone = false;

    if (m_duotone)
    {
        delete m_duotone;
        m_duotone = NULL;
    }
    ;

    m_has_fillOverlay = false;

    if (m_fillOverlay)
    {
        delete m_fillOverlay;
        m_fillOverlay = NULL;
    }
    ;

    m_has_grayscl = false;

    if (m_grayscl)
    {
        delete m_grayscl;
        m_grayscl = NULL;
    }
    ;

    m_has_hsl = false;

    if (m_hsl)
    {
        delete m_hsl;
        m_hsl = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_clrRepl = true;
    if (!m_clrRepl)
    {
        m_clrRepl = new CT_ColorReplaceEffect();
    }
    return m_clrRepl;
}

const CT_ColorReplaceEffect& CT_Blip::ChildGroup_1::get_clrRepl() const
{
    if (m_clrRepl)
    {
        return *m_clrRepl;
    }
    return CT_ColorReplaceEffect::default_instance();
}

bool CT_Blip::ChildGroup_1::has_duotone() const
{
    return m_has_duotone;
}

CT_DuotoneEffect* CT_Blip::ChildGroup_1::mutable_duotone()
{

    m_has_alphaBiLevel = false;

    if (m_alphaBiLevel)
    {
        delete m_alphaBiLevel;
        m_alphaBiLevel = NULL;
    }
    ;

    m_has_alphaCeiling = false;

    if (m_alphaCeiling)
    {
        delete m_alphaCeiling;
        m_alphaCeiling = NULL;
    }
    ;

    m_has_alphaFloor = false;

    if (m_alphaFloor)
    {
        delete m_alphaFloor;
        m_alphaFloor = NULL;
    }
    ;

    m_has_alphaInv = false;

    if (m_alphaInv)
    {
        delete m_alphaInv;
        m_alphaInv = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_alphaModFix = false;

    if (m_alphaModFix)
    {
        delete m_alphaModFix;
        m_alphaModFix = NULL;
    }
    ;

    m_has_alphaRepl = false;

    if (m_alphaRepl)
    {
        delete m_alphaRepl;
        m_alphaRepl = NULL;
    }
    ;

    m_has_biLevel = false;

    if (m_biLevel)
    {
        delete m_biLevel;
        m_biLevel = NULL;
    }
    ;

    m_has_blur = false;

    if (m_blur)
    {
        delete m_blur;
        m_blur = NULL;
    }
    ;

    m_has_clrChange = false;

    if (m_clrChange)
    {
        delete m_clrChange;
        m_clrChange = NULL;
    }
    ;

    m_has_clrRepl = false;

    if (m_clrRepl)
    {
        delete m_clrRepl;
        m_clrRepl = NULL;
    }
    ;

    m_has_fillOverlay = false;

    if (m_fillOverlay)
    {
        delete m_fillOverlay;
        m_fillOverlay = NULL;
    }
    ;

    m_has_grayscl = false;

    if (m_grayscl)
    {
        delete m_grayscl;
        m_grayscl = NULL;
    }
    ;

    m_has_hsl = false;

    if (m_hsl)
    {
        delete m_hsl;
        m_hsl = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_duotone = true;
    if (!m_duotone)
    {
        m_duotone = new CT_DuotoneEffect();
    }
    return m_duotone;
}

const CT_DuotoneEffect& CT_Blip::ChildGroup_1::get_duotone() const
{
    if (m_duotone)
    {
        return *m_duotone;
    }
    return CT_DuotoneEffect::default_instance();
}

bool CT_Blip::ChildGroup_1::has_fillOverlay() const
{
    return m_has_fillOverlay;
}

CT_FillOverlayEffect* CT_Blip::ChildGroup_1::mutable_fillOverlay()
{

    m_has_alphaBiLevel = false;

    if (m_alphaBiLevel)
    {
        delete m_alphaBiLevel;
        m_alphaBiLevel = NULL;
    }
    ;

    m_has_alphaCeiling = false;

    if (m_alphaCeiling)
    {
        delete m_alphaCeiling;
        m_alphaCeiling = NULL;
    }
    ;

    m_has_alphaFloor = false;

    if (m_alphaFloor)
    {
        delete m_alphaFloor;
        m_alphaFloor = NULL;
    }
    ;

    m_has_alphaInv = false;

    if (m_alphaInv)
    {
        delete m_alphaInv;
        m_alphaInv = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_alphaModFix = false;

    if (m_alphaModFix)
    {
        delete m_alphaModFix;
        m_alphaModFix = NULL;
    }
    ;

    m_has_alphaRepl = false;

    if (m_alphaRepl)
    {
        delete m_alphaRepl;
        m_alphaRepl = NULL;
    }
    ;

    m_has_biLevel = false;

    if (m_biLevel)
    {
        delete m_biLevel;
        m_biLevel = NULL;
    }
    ;

    m_has_blur = false;

    if (m_blur)
    {
        delete m_blur;
        m_blur = NULL;
    }
    ;

    m_has_clrChange = false;

    if (m_clrChange)
    {
        delete m_clrChange;
        m_clrChange = NULL;
    }
    ;

    m_has_clrRepl = false;

    if (m_clrRepl)
    {
        delete m_clrRepl;
        m_clrRepl = NULL;
    }
    ;

    m_has_duotone = false;

    if (m_duotone)
    {
        delete m_duotone;
        m_duotone = NULL;
    }
    ;

    m_has_grayscl = false;

    if (m_grayscl)
    {
        delete m_grayscl;
        m_grayscl = NULL;
    }
    ;

    m_has_hsl = false;

    if (m_hsl)
    {
        delete m_hsl;
        m_hsl = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_fillOverlay = true;
    if (!m_fillOverlay)
    {
        m_fillOverlay = new CT_FillOverlayEffect();
    }
    return m_fillOverlay;
}

const CT_FillOverlayEffect& CT_Blip::ChildGroup_1::get_fillOverlay() const
{
    if (m_fillOverlay)
    {
        return *m_fillOverlay;
    }
    return CT_FillOverlayEffect::default_instance();
}

bool CT_Blip::ChildGroup_1::has_grayscl() const
{
    return m_has_grayscl;
}

CT_GrayscaleEffect* CT_Blip::ChildGroup_1::mutable_grayscl()
{

    m_has_alphaBiLevel = false;

    if (m_alphaBiLevel)
    {
        delete m_alphaBiLevel;
        m_alphaBiLevel = NULL;
    }
    ;

    m_has_alphaCeiling = false;

    if (m_alphaCeiling)
    {
        delete m_alphaCeiling;
        m_alphaCeiling = NULL;
    }
    ;

    m_has_alphaFloor = false;

    if (m_alphaFloor)
    {
        delete m_alphaFloor;
        m_alphaFloor = NULL;
    }
    ;

    m_has_alphaInv = false;

    if (m_alphaInv)
    {
        delete m_alphaInv;
        m_alphaInv = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_alphaModFix = false;

    if (m_alphaModFix)
    {
        delete m_alphaModFix;
        m_alphaModFix = NULL;
    }
    ;

    m_has_alphaRepl = false;

    if (m_alphaRepl)
    {
        delete m_alphaRepl;
        m_alphaRepl = NULL;
    }
    ;

    m_has_biLevel = false;

    if (m_biLevel)
    {
        delete m_biLevel;
        m_biLevel = NULL;
    }
    ;

    m_has_blur = false;

    if (m_blur)
    {
        delete m_blur;
        m_blur = NULL;
    }
    ;

    m_has_clrChange = false;

    if (m_clrChange)
    {
        delete m_clrChange;
        m_clrChange = NULL;
    }
    ;

    m_has_clrRepl = false;

    if (m_clrRepl)
    {
        delete m_clrRepl;
        m_clrRepl = NULL;
    }
    ;

    m_has_duotone = false;

    if (m_duotone)
    {
        delete m_duotone;
        m_duotone = NULL;
    }
    ;

    m_has_fillOverlay = false;

    if (m_fillOverlay)
    {
        delete m_fillOverlay;
        m_fillOverlay = NULL;
    }
    ;

    m_has_hsl = false;

    if (m_hsl)
    {
        delete m_hsl;
        m_hsl = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_grayscl = true;
    if (!m_grayscl)
    {
        m_grayscl = new CT_GrayscaleEffect();
    }
    return m_grayscl;
}

const CT_GrayscaleEffect& CT_Blip::ChildGroup_1::get_grayscl() const
{
    if (m_grayscl)
    {
        return *m_grayscl;
    }
    return CT_GrayscaleEffect::default_instance();
}

bool CT_Blip::ChildGroup_1::has_hsl() const
{
    return m_has_hsl;
}

CT_HSLEffect* CT_Blip::ChildGroup_1::mutable_hsl()
{

    m_has_alphaBiLevel = false;

    if (m_alphaBiLevel)
    {
        delete m_alphaBiLevel;
        m_alphaBiLevel = NULL;
    }
    ;

    m_has_alphaCeiling = false;

    if (m_alphaCeiling)
    {
        delete m_alphaCeiling;
        m_alphaCeiling = NULL;
    }
    ;

    m_has_alphaFloor = false;

    if (m_alphaFloor)
    {
        delete m_alphaFloor;
        m_alphaFloor = NULL;
    }
    ;

    m_has_alphaInv = false;

    if (m_alphaInv)
    {
        delete m_alphaInv;
        m_alphaInv = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_alphaModFix = false;

    if (m_alphaModFix)
    {
        delete m_alphaModFix;
        m_alphaModFix = NULL;
    }
    ;

    m_has_alphaRepl = false;

    if (m_alphaRepl)
    {
        delete m_alphaRepl;
        m_alphaRepl = NULL;
    }
    ;

    m_has_biLevel = false;

    if (m_biLevel)
    {
        delete m_biLevel;
        m_biLevel = NULL;
    }
    ;

    m_has_blur = false;

    if (m_blur)
    {
        delete m_blur;
        m_blur = NULL;
    }
    ;

    m_has_clrChange = false;

    if (m_clrChange)
    {
        delete m_clrChange;
        m_clrChange = NULL;
    }
    ;

    m_has_clrRepl = false;

    if (m_clrRepl)
    {
        delete m_clrRepl;
        m_clrRepl = NULL;
    }
    ;

    m_has_duotone = false;

    if (m_duotone)
    {
        delete m_duotone;
        m_duotone = NULL;
    }
    ;

    m_has_fillOverlay = false;

    if (m_fillOverlay)
    {
        delete m_fillOverlay;
        m_fillOverlay = NULL;
    }
    ;

    m_has_grayscl = false;

    if (m_grayscl)
    {
        delete m_grayscl;
        m_grayscl = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_hsl = true;
    if (!m_hsl)
    {
        m_hsl = new CT_HSLEffect();
    }
    return m_hsl;
}

const CT_HSLEffect& CT_Blip::ChildGroup_1::get_hsl() const
{
    if (m_hsl)
    {
        return *m_hsl;
    }
    return CT_HSLEffect::default_instance();
}

bool CT_Blip::ChildGroup_1::has_lum() const
{
    return m_has_lum;
}

CT_LuminanceEffect* CT_Blip::ChildGroup_1::mutable_lum()
{

    m_has_alphaBiLevel = false;

    if (m_alphaBiLevel)
    {
        delete m_alphaBiLevel;
        m_alphaBiLevel = NULL;
    }
    ;

    m_has_alphaCeiling = false;

    if (m_alphaCeiling)
    {
        delete m_alphaCeiling;
        m_alphaCeiling = NULL;
    }
    ;

    m_has_alphaFloor = false;

    if (m_alphaFloor)
    {
        delete m_alphaFloor;
        m_alphaFloor = NULL;
    }
    ;

    m_has_alphaInv = false;

    if (m_alphaInv)
    {
        delete m_alphaInv;
        m_alphaInv = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_alphaModFix = false;

    if (m_alphaModFix)
    {
        delete m_alphaModFix;
        m_alphaModFix = NULL;
    }
    ;

    m_has_alphaRepl = false;

    if (m_alphaRepl)
    {
        delete m_alphaRepl;
        m_alphaRepl = NULL;
    }
    ;

    m_has_biLevel = false;

    if (m_biLevel)
    {
        delete m_biLevel;
        m_biLevel = NULL;
    }
    ;

    m_has_blur = false;

    if (m_blur)
    {
        delete m_blur;
        m_blur = NULL;
    }
    ;

    m_has_clrChange = false;

    if (m_clrChange)
    {
        delete m_clrChange;
        m_clrChange = NULL;
    }
    ;

    m_has_clrRepl = false;

    if (m_clrRepl)
    {
        delete m_clrRepl;
        m_clrRepl = NULL;
    }
    ;

    m_has_duotone = false;

    if (m_duotone)
    {
        delete m_duotone;
        m_duotone = NULL;
    }
    ;

    m_has_fillOverlay = false;

    if (m_fillOverlay)
    {
        delete m_fillOverlay;
        m_fillOverlay = NULL;
    }
    ;

    m_has_grayscl = false;

    if (m_grayscl)
    {
        delete m_grayscl;
        m_grayscl = NULL;
    }
    ;

    m_has_hsl = false;

    if (m_hsl)
    {
        delete m_hsl;
        m_hsl = NULL;
    }
    ;

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_lum = true;
    if (!m_lum)
    {
        m_lum = new CT_LuminanceEffect();
    }
    return m_lum;
}

const CT_LuminanceEffect& CT_Blip::ChildGroup_1::get_lum() const
{
    if (m_lum)
    {
        return *m_lum;
    }
    return CT_LuminanceEffect::default_instance();
}

bool CT_Blip::ChildGroup_1::has_tint() const
{
    return m_has_tint;
}

CT_TintEffect* CT_Blip::ChildGroup_1::mutable_tint()
{

    m_has_alphaBiLevel = false;

    if (m_alphaBiLevel)
    {
        delete m_alphaBiLevel;
        m_alphaBiLevel = NULL;
    }
    ;

    m_has_alphaCeiling = false;

    if (m_alphaCeiling)
    {
        delete m_alphaCeiling;
        m_alphaCeiling = NULL;
    }
    ;

    m_has_alphaFloor = false;

    if (m_alphaFloor)
    {
        delete m_alphaFloor;
        m_alphaFloor = NULL;
    }
    ;

    m_has_alphaInv = false;

    if (m_alphaInv)
    {
        delete m_alphaInv;
        m_alphaInv = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_alphaModFix = false;

    if (m_alphaModFix)
    {
        delete m_alphaModFix;
        m_alphaModFix = NULL;
    }
    ;

    m_has_alphaRepl = false;

    if (m_alphaRepl)
    {
        delete m_alphaRepl;
        m_alphaRepl = NULL;
    }
    ;

    m_has_biLevel = false;

    if (m_biLevel)
    {
        delete m_biLevel;
        m_biLevel = NULL;
    }
    ;

    m_has_blur = false;

    if (m_blur)
    {
        delete m_blur;
        m_blur = NULL;
    }
    ;

    m_has_clrChange = false;

    if (m_clrChange)
    {
        delete m_clrChange;
        m_clrChange = NULL;
    }
    ;

    m_has_clrRepl = false;

    if (m_clrRepl)
    {
        delete m_clrRepl;
        m_clrRepl = NULL;
    }
    ;

    m_has_duotone = false;

    if (m_duotone)
    {
        delete m_duotone;
        m_duotone = NULL;
    }
    ;

    m_has_fillOverlay = false;

    if (m_fillOverlay)
    {
        delete m_fillOverlay;
        m_fillOverlay = NULL;
    }
    ;

    m_has_grayscl = false;

    if (m_grayscl)
    {
        delete m_grayscl;
        m_grayscl = NULL;
    }
    ;

    m_has_hsl = false;

    if (m_hsl)
    {
        delete m_hsl;
        m_hsl = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_tint = true;
    if (!m_tint)
    {
        m_tint = new CT_TintEffect();
    }
    return m_tint;
}

const CT_TintEffect& CT_Blip::ChildGroup_1::get_tint() const
{
    if (m_tint)
    {
        return *m_tint;
    }
    return CT_TintEffect::default_instance();
}

CT_Blip* CT_Blip::default_instance_ = NULL;

// CT_BlipFillProperties
CT_BlipFillProperties::CT_BlipFillProperties()
    :m_has_blip(false),
     m_blip(NULL),
     m_has_srcRect(false),
     m_srcRect(NULL),
     m_has_tile(false),
     m_tile(NULL),
     m_has_stretch(false),
     m_stretch(NULL),
     m_has_dpi_attr(false),
     m_dpi_attr(0),
     m_has_rotWithShape_attr(false),
     m_rotWithShape_attr(false)
{
}
CT_BlipFillProperties::~CT_BlipFillProperties()
{
    clear();
}
bool CT_BlipFillProperties::has_blip() const
{
    return m_has_blip;
}

CT_Blip* CT_BlipFillProperties::mutable_blip()
{
    m_has_blip = true;
    if (!m_blip)
    {
        m_blip = new CT_Blip();
    }
    return m_blip;
}

const CT_Blip& CT_BlipFillProperties::get_blip() const
{
    if (m_blip)
    {
        return *m_blip;
    }
    return CT_Blip::default_instance();
}

bool CT_BlipFillProperties::has_srcRect() const
{
    return m_has_srcRect;
}

CT_RelativeRect* CT_BlipFillProperties::mutable_srcRect()
{
    m_has_srcRect = true;
    if (!m_srcRect)
    {
        m_srcRect = new CT_RelativeRect();
    }
    return m_srcRect;
}

const CT_RelativeRect& CT_BlipFillProperties::get_srcRect() const
{
    if (m_srcRect)
    {
        return *m_srcRect;
    }
    return CT_RelativeRect::default_instance();
}

bool CT_BlipFillProperties::has_tile() const
{
    return m_has_tile;
}

CT_TileInfoProperties* CT_BlipFillProperties::mutable_tile()
{

    m_has_stretch = false;

    if (m_stretch)
    {
        delete m_stretch;
        m_stretch = NULL;
    }
    ;

    m_has_tile = true;
    if (!m_tile)
    {
        m_tile = new CT_TileInfoProperties();
    }
    return m_tile;
}

const CT_TileInfoProperties& CT_BlipFillProperties::get_tile() const
{
    if (m_tile)
    {
        return *m_tile;
    }
    return CT_TileInfoProperties::default_instance();
}

bool CT_BlipFillProperties::has_stretch() const
{
    return m_has_stretch;
}

CT_StretchInfoProperties* CT_BlipFillProperties::mutable_stretch()
{

    m_has_tile = false;

    if (m_tile)
    {
        delete m_tile;
        m_tile = NULL;
    }
    ;

    m_has_stretch = true;
    if (!m_stretch)
    {
        m_stretch = new CT_StretchInfoProperties();
    }
    return m_stretch;
}

const CT_StretchInfoProperties& CT_BlipFillProperties::get_stretch() const
{
    if (m_stretch)
    {
        return *m_stretch;
    }
    return CT_StretchInfoProperties::default_instance();
}

void CT_BlipFillProperties::clear()
{
    m_has_dpi_attr = false;
    m_dpi_attr = 0;

    m_has_rotWithShape_attr = false;
    m_rotWithShape_attr = false;

    m_has_blip = false;

    if (m_blip)
    {
        delete m_blip;
        m_blip = NULL;
    }


    m_has_srcRect = false;

    if (m_srcRect)
    {
        delete m_srcRect;
        m_srcRect = NULL;
    }


    m_has_tile = false;

    if (m_tile)
    {
        delete m_tile;
        m_tile = NULL;
    }


    m_has_stretch = false;

    if (m_stretch)
    {
        delete m_stretch;
        m_stretch = NULL;
    }

}

void CT_BlipFillProperties::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_dpi_attr)
    {
        _outStream << " " << "dpi" << "=\"" << m_dpi_attr << "\"";
    }



    if (m_has_rotWithShape_attr)
    {
        _outStream << " " << "rotWithShape" << "=\"" << XSD::XMLBooleanStr(m_rotWithShape_attr) << "\"";
    }

    _outStream << ">";


    if (m_has_blip)
    {
        m_blip->toXmlElem("a:blip", "", _outStream);
    }


    if (m_has_srcRect)
    {
        m_srcRect->toXmlElem("a:srcRect", "", _outStream);
    }

    {
        bool elemHasValueList[2] = {m_has_tile, m_has_stretch};
        int cnt = count(elemHasValueList, elemHasValueList + 2, true);
        assert(cnt == 0 || cnt == 1);
    }


    if (m_has_tile)
    {
        m_tile->toXmlElem("a:tile", "", _outStream);
    }


    if (m_has_stretch)
    {
        m_stretch->toXmlElem("a:stretch", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_BlipFillProperties& CT_BlipFillProperties::default_instance()
{
    if (!CT_BlipFillProperties::default_instance_)
    {
        CT_BlipFillProperties::default_instance_ = new CT_BlipFillProperties();
    }
    return *CT_BlipFillProperties::default_instance_;
}

bool CT_BlipFillProperties::has_dpi_attr() const
{
    return m_has_dpi_attr;
}

void CT_BlipFillProperties::set_dpi_attr(const XSD::unsignedInt_& _dpi_attr)
{
    m_has_dpi_attr = true;
    m_dpi_attr = _dpi_attr;
}

const XSD::unsignedInt_& CT_BlipFillProperties::get_dpi_attr() const
{
    return m_dpi_attr;
}

bool CT_BlipFillProperties::has_rotWithShape_attr() const
{
    return m_has_rotWithShape_attr;
}

void CT_BlipFillProperties::set_rotWithShape_attr(const XSD::boolean_& _rotWithShape_attr)
{
    m_has_rotWithShape_attr = true;
    m_rotWithShape_attr = _rotWithShape_attr;
}

const XSD::boolean_& CT_BlipFillProperties::get_rotWithShape_attr() const
{
    return m_rotWithShape_attr;
}

CT_BlipFillProperties* CT_BlipFillProperties::default_instance_ = NULL;

// CT_PatternFillProperties
CT_PatternFillProperties::CT_PatternFillProperties()
    :m_has_fgClr(false),
     m_fgClr(NULL),
     m_has_bgClr(false),
     m_bgClr(NULL),
     m_has_prst_attr(false),
     m_prst_attr(NULL)
{
}
CT_PatternFillProperties::~CT_PatternFillProperties()
{
    clear();
}
bool CT_PatternFillProperties::has_fgClr() const
{
    return m_has_fgClr;
}

CT_Color* CT_PatternFillProperties::mutable_fgClr()
{
    m_has_fgClr = true;
    if (!m_fgClr)
    {
        m_fgClr = new CT_Color();
    }
    return m_fgClr;
}

const CT_Color& CT_PatternFillProperties::get_fgClr() const
{
    if (m_fgClr)
    {
        return *m_fgClr;
    }
    return CT_Color::default_instance();
}

bool CT_PatternFillProperties::has_bgClr() const
{
    return m_has_bgClr;
}

CT_Color* CT_PatternFillProperties::mutable_bgClr()
{
    m_has_bgClr = true;
    if (!m_bgClr)
    {
        m_bgClr = new CT_Color();
    }
    return m_bgClr;
}

const CT_Color& CT_PatternFillProperties::get_bgClr() const
{
    if (m_bgClr)
    {
        return *m_bgClr;
    }
    return CT_Color::default_instance();
}

void CT_PatternFillProperties::clear()
{
    m_has_prst_attr = false;

    if (m_prst_attr)
    {
        delete m_prst_attr;
        m_prst_attr = NULL;
    }


    m_has_fgClr = false;

    if (m_fgClr)
    {
        delete m_fgClr;
        m_fgClr = NULL;
    }


    m_has_bgClr = false;

    if (m_bgClr)
    {
        delete m_bgClr;
        m_bgClr = NULL;
    }

}

void CT_PatternFillProperties::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_prst_attr)
    {
        m_prst_attr->toXmlAttr("prst", _outStream);
    }

    _outStream << ">";


    if (m_has_fgClr)
    {
        m_fgClr->toXmlElem("a:fgClr", "", _outStream);
    }


    if (m_has_bgClr)
    {
        m_bgClr->toXmlElem("a:bgClr", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_PatternFillProperties& CT_PatternFillProperties::default_instance()
{
    if (!CT_PatternFillProperties::default_instance_)
    {
        CT_PatternFillProperties::default_instance_ = new CT_PatternFillProperties();
    }
    return *CT_PatternFillProperties::default_instance_;
}

bool CT_PatternFillProperties::has_prst_attr() const
{
    return m_has_prst_attr;
}

void CT_PatternFillProperties::set_prst_attr(const ST_PresetPatternVal& _prst_attr)
{
    m_has_prst_attr = true;
    m_prst_attr = new ST_PresetPatternVal(_prst_attr);
}

const ST_PresetPatternVal& CT_PatternFillProperties::get_prst_attr() const
{
    if (m_prst_attr)
    {
        return *m_prst_attr;
    }
    return ST_PresetPatternVal::default_instance();
}

CT_PatternFillProperties* CT_PatternFillProperties::default_instance_ = NULL;

// CT_GroupFillProperties
CT_GroupFillProperties::CT_GroupFillProperties()

{
}
CT_GroupFillProperties::~CT_GroupFillProperties()
{
    clear();
}
void CT_GroupFillProperties::clear()
{    }

void CT_GroupFillProperties::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_GroupFillProperties& CT_GroupFillProperties::default_instance()
{
    if (!CT_GroupFillProperties::default_instance_)
    {
        CT_GroupFillProperties::default_instance_ = new CT_GroupFillProperties();
    }
    return *CT_GroupFillProperties::default_instance_;
}

CT_GroupFillProperties* CT_GroupFillProperties::default_instance_ = NULL;

// CT_FillProperties
CT_FillProperties::CT_FillProperties()
    :m_has_noFill(false),
     m_noFill(NULL),
     m_has_solidFill(false),
     m_solidFill(NULL),
     m_has_gradFill(false),
     m_gradFill(NULL),
     m_has_blipFill(false),
     m_blipFill(NULL),
     m_has_pattFill(false),
     m_pattFill(NULL),
     m_has_grpFill(false),
     m_grpFill(NULL)
{
}
CT_FillProperties::~CT_FillProperties()
{
    clear();
}
bool CT_FillProperties::has_noFill() const
{
    return m_has_noFill;
}

CT_NoFillProperties* CT_FillProperties::mutable_noFill()
{

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_noFill = true;
    if (!m_noFill)
    {
        m_noFill = new CT_NoFillProperties();
    }
    return m_noFill;
}

const CT_NoFillProperties& CT_FillProperties::get_noFill() const
{
    if (m_noFill)
    {
        return *m_noFill;
    }
    return CT_NoFillProperties::default_instance();
}

bool CT_FillProperties::has_solidFill() const
{
    return m_has_solidFill;
}

CT_SolidColorFillProperties* CT_FillProperties::mutable_solidFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_solidFill = true;
    if (!m_solidFill)
    {
        m_solidFill = new CT_SolidColorFillProperties();
    }
    return m_solidFill;
}

const CT_SolidColorFillProperties& CT_FillProperties::get_solidFill() const
{
    if (m_solidFill)
    {
        return *m_solidFill;
    }
    return CT_SolidColorFillProperties::default_instance();
}

bool CT_FillProperties::has_gradFill() const
{
    return m_has_gradFill;
}

CT_GradientFillProperties* CT_FillProperties::mutable_gradFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_gradFill = true;
    if (!m_gradFill)
    {
        m_gradFill = new CT_GradientFillProperties();
    }
    return m_gradFill;
}

const CT_GradientFillProperties& CT_FillProperties::get_gradFill() const
{
    if (m_gradFill)
    {
        return *m_gradFill;
    }
    return CT_GradientFillProperties::default_instance();
}

bool CT_FillProperties::has_blipFill() const
{
    return m_has_blipFill;
}

CT_BlipFillProperties* CT_FillProperties::mutable_blipFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_blipFill = true;
    if (!m_blipFill)
    {
        m_blipFill = new CT_BlipFillProperties();
    }
    return m_blipFill;
}

const CT_BlipFillProperties& CT_FillProperties::get_blipFill() const
{
    if (m_blipFill)
    {
        return *m_blipFill;
    }
    return CT_BlipFillProperties::default_instance();
}

bool CT_FillProperties::has_pattFill() const
{
    return m_has_pattFill;
}

CT_PatternFillProperties* CT_FillProperties::mutable_pattFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_pattFill = true;
    if (!m_pattFill)
    {
        m_pattFill = new CT_PatternFillProperties();
    }
    return m_pattFill;
}

const CT_PatternFillProperties& CT_FillProperties::get_pattFill() const
{
    if (m_pattFill)
    {
        return *m_pattFill;
    }
    return CT_PatternFillProperties::default_instance();
}

bool CT_FillProperties::has_grpFill() const
{
    return m_has_grpFill;
}

CT_GroupFillProperties* CT_FillProperties::mutable_grpFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = true;
    if (!m_grpFill)
    {
        m_grpFill = new CT_GroupFillProperties();
    }
    return m_grpFill;
}

const CT_GroupFillProperties& CT_FillProperties::get_grpFill() const
{
    if (m_grpFill)
    {
        return *m_grpFill;
    }
    return CT_GroupFillProperties::default_instance();
}

void CT_FillProperties::clear()
{
    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }


    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }


    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }


    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }


    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }


    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }

}

void CT_FillProperties::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    {
        bool elemHasValueList[6] = {m_has_noFill, m_has_solidFill, m_has_gradFill, m_has_blipFill, m_has_pattFill, m_has_grpFill};
        int cnt = count(elemHasValueList, elemHasValueList + 6, true);
        assert(cnt == 1);
    }


    if (m_has_noFill)
    {
        m_noFill->toXmlElem("a:noFill", "", _outStream);
    }


    if (m_has_solidFill)
    {
        m_solidFill->toXmlElem("a:solidFill", "", _outStream);
    }


    if (m_has_gradFill)
    {
        m_gradFill->toXmlElem("a:gradFill", "", _outStream);
    }


    if (m_has_blipFill)
    {
        m_blipFill->toXmlElem("a:blipFill", "", _outStream);
    }


    if (m_has_pattFill)
    {
        m_pattFill->toXmlElem("a:pattFill", "", _outStream);
    }


    if (m_has_grpFill)
    {
        m_grpFill->toXmlElem("a:grpFill", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_FillProperties& CT_FillProperties::default_instance()
{
    if (!CT_FillProperties::default_instance_)
    {
        CT_FillProperties::default_instance_ = new CT_FillProperties();
    }
    return *CT_FillProperties::default_instance_;
}

CT_FillProperties* CT_FillProperties::default_instance_ = NULL;

// CT_FillEffect
CT_FillEffect::CT_FillEffect()
    :m_has_noFill(false),
     m_noFill(NULL),
     m_has_solidFill(false),
     m_solidFill(NULL),
     m_has_gradFill(false),
     m_gradFill(NULL),
     m_has_blipFill(false),
     m_blipFill(NULL),
     m_has_pattFill(false),
     m_pattFill(NULL),
     m_has_grpFill(false),
     m_grpFill(NULL)
{
}
CT_FillEffect::~CT_FillEffect()
{
    clear();
}
bool CT_FillEffect::has_noFill() const
{
    return m_has_noFill;
}

CT_NoFillProperties* CT_FillEffect::mutable_noFill()
{

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_noFill = true;
    if (!m_noFill)
    {
        m_noFill = new CT_NoFillProperties();
    }
    return m_noFill;
}

const CT_NoFillProperties& CT_FillEffect::get_noFill() const
{
    if (m_noFill)
    {
        return *m_noFill;
    }
    return CT_NoFillProperties::default_instance();
}

bool CT_FillEffect::has_solidFill() const
{
    return m_has_solidFill;
}

CT_SolidColorFillProperties* CT_FillEffect::mutable_solidFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_solidFill = true;
    if (!m_solidFill)
    {
        m_solidFill = new CT_SolidColorFillProperties();
    }
    return m_solidFill;
}

const CT_SolidColorFillProperties& CT_FillEffect::get_solidFill() const
{
    if (m_solidFill)
    {
        return *m_solidFill;
    }
    return CT_SolidColorFillProperties::default_instance();
}

bool CT_FillEffect::has_gradFill() const
{
    return m_has_gradFill;
}

CT_GradientFillProperties* CT_FillEffect::mutable_gradFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_gradFill = true;
    if (!m_gradFill)
    {
        m_gradFill = new CT_GradientFillProperties();
    }
    return m_gradFill;
}

const CT_GradientFillProperties& CT_FillEffect::get_gradFill() const
{
    if (m_gradFill)
    {
        return *m_gradFill;
    }
    return CT_GradientFillProperties::default_instance();
}

bool CT_FillEffect::has_blipFill() const
{
    return m_has_blipFill;
}

CT_BlipFillProperties* CT_FillEffect::mutable_blipFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_blipFill = true;
    if (!m_blipFill)
    {
        m_blipFill = new CT_BlipFillProperties();
    }
    return m_blipFill;
}

const CT_BlipFillProperties& CT_FillEffect::get_blipFill() const
{
    if (m_blipFill)
    {
        return *m_blipFill;
    }
    return CT_BlipFillProperties::default_instance();
}

bool CT_FillEffect::has_pattFill() const
{
    return m_has_pattFill;
}

CT_PatternFillProperties* CT_FillEffect::mutable_pattFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_pattFill = true;
    if (!m_pattFill)
    {
        m_pattFill = new CT_PatternFillProperties();
    }
    return m_pattFill;
}

const CT_PatternFillProperties& CT_FillEffect::get_pattFill() const
{
    if (m_pattFill)
    {
        return *m_pattFill;
    }
    return CT_PatternFillProperties::default_instance();
}

bool CT_FillEffect::has_grpFill() const
{
    return m_has_grpFill;
}

CT_GroupFillProperties* CT_FillEffect::mutable_grpFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = true;
    if (!m_grpFill)
    {
        m_grpFill = new CT_GroupFillProperties();
    }
    return m_grpFill;
}

const CT_GroupFillProperties& CT_FillEffect::get_grpFill() const
{
    if (m_grpFill)
    {
        return *m_grpFill;
    }
    return CT_GroupFillProperties::default_instance();
}

void CT_FillEffect::clear()
{
    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }


    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }


    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }


    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }


    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }


    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }

}

void CT_FillEffect::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    {
        bool elemHasValueList[6] = {m_has_noFill, m_has_solidFill, m_has_gradFill, m_has_blipFill, m_has_pattFill, m_has_grpFill};
        int cnt = count(elemHasValueList, elemHasValueList + 6, true);
        assert(cnt == 1);
    }


    if (m_has_noFill)
    {
        m_noFill->toXmlElem("a:noFill", "", _outStream);
    }


    if (m_has_solidFill)
    {
        m_solidFill->toXmlElem("a:solidFill", "", _outStream);
    }


    if (m_has_gradFill)
    {
        m_gradFill->toXmlElem("a:gradFill", "", _outStream);
    }


    if (m_has_blipFill)
    {
        m_blipFill->toXmlElem("a:blipFill", "", _outStream);
    }


    if (m_has_pattFill)
    {
        m_pattFill->toXmlElem("a:pattFill", "", _outStream);
    }


    if (m_has_grpFill)
    {
        m_grpFill->toXmlElem("a:grpFill", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_FillEffect& CT_FillEffect::default_instance()
{
    if (!CT_FillEffect::default_instance_)
    {
        CT_FillEffect::default_instance_ = new CT_FillEffect();
    }
    return *CT_FillEffect::default_instance_;
}

CT_FillEffect* CT_FillEffect::default_instance_ = NULL;

// CT_FillOverlayEffect
CT_FillOverlayEffect::CT_FillOverlayEffect()
    :m_has_noFill(false),
     m_noFill(NULL),
     m_has_solidFill(false),
     m_solidFill(NULL),
     m_has_gradFill(false),
     m_gradFill(NULL),
     m_has_blipFill(false),
     m_blipFill(NULL),
     m_has_pattFill(false),
     m_pattFill(NULL),
     m_has_grpFill(false),
     m_grpFill(NULL),
     m_has_blend_attr(false),
     m_blend_attr(NULL)
{
}
CT_FillOverlayEffect::~CT_FillOverlayEffect()
{
    clear();
}
bool CT_FillOverlayEffect::has_noFill() const
{
    return m_has_noFill;
}

CT_NoFillProperties* CT_FillOverlayEffect::mutable_noFill()
{

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_noFill = true;
    if (!m_noFill)
    {
        m_noFill = new CT_NoFillProperties();
    }
    return m_noFill;
}

const CT_NoFillProperties& CT_FillOverlayEffect::get_noFill() const
{
    if (m_noFill)
    {
        return *m_noFill;
    }
    return CT_NoFillProperties::default_instance();
}

bool CT_FillOverlayEffect::has_solidFill() const
{
    return m_has_solidFill;
}

CT_SolidColorFillProperties* CT_FillOverlayEffect::mutable_solidFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_solidFill = true;
    if (!m_solidFill)
    {
        m_solidFill = new CT_SolidColorFillProperties();
    }
    return m_solidFill;
}

const CT_SolidColorFillProperties& CT_FillOverlayEffect::get_solidFill() const
{
    if (m_solidFill)
    {
        return *m_solidFill;
    }
    return CT_SolidColorFillProperties::default_instance();
}

bool CT_FillOverlayEffect::has_gradFill() const
{
    return m_has_gradFill;
}

CT_GradientFillProperties* CT_FillOverlayEffect::mutable_gradFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_gradFill = true;
    if (!m_gradFill)
    {
        m_gradFill = new CT_GradientFillProperties();
    }
    return m_gradFill;
}

const CT_GradientFillProperties& CT_FillOverlayEffect::get_gradFill() const
{
    if (m_gradFill)
    {
        return *m_gradFill;
    }
    return CT_GradientFillProperties::default_instance();
}

bool CT_FillOverlayEffect::has_blipFill() const
{
    return m_has_blipFill;
}

CT_BlipFillProperties* CT_FillOverlayEffect::mutable_blipFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_blipFill = true;
    if (!m_blipFill)
    {
        m_blipFill = new CT_BlipFillProperties();
    }
    return m_blipFill;
}

const CT_BlipFillProperties& CT_FillOverlayEffect::get_blipFill() const
{
    if (m_blipFill)
    {
        return *m_blipFill;
    }
    return CT_BlipFillProperties::default_instance();
}

bool CT_FillOverlayEffect::has_pattFill() const
{
    return m_has_pattFill;
}

CT_PatternFillProperties* CT_FillOverlayEffect::mutable_pattFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_pattFill = true;
    if (!m_pattFill)
    {
        m_pattFill = new CT_PatternFillProperties();
    }
    return m_pattFill;
}

const CT_PatternFillProperties& CT_FillOverlayEffect::get_pattFill() const
{
    if (m_pattFill)
    {
        return *m_pattFill;
    }
    return CT_PatternFillProperties::default_instance();
}

bool CT_FillOverlayEffect::has_grpFill() const
{
    return m_has_grpFill;
}

CT_GroupFillProperties* CT_FillOverlayEffect::mutable_grpFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = true;
    if (!m_grpFill)
    {
        m_grpFill = new CT_GroupFillProperties();
    }
    return m_grpFill;
}

const CT_GroupFillProperties& CT_FillOverlayEffect::get_grpFill() const
{
    if (m_grpFill)
    {
        return *m_grpFill;
    }
    return CT_GroupFillProperties::default_instance();
}

void CT_FillOverlayEffect::clear()
{
    m_has_blend_attr = false;

    if (m_blend_attr)
    {
        delete m_blend_attr;
        m_blend_attr = NULL;
    }


    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }


    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }


    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }


    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }


    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }


    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }

}

void CT_FillOverlayEffect::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_blend_attr);
    if (m_has_blend_attr)
    {
        m_blend_attr->toXmlAttr("blend", _outStream);
    }

    _outStream << ">";

    {
        bool elemHasValueList[6] = {m_has_noFill, m_has_solidFill, m_has_gradFill, m_has_blipFill, m_has_pattFill, m_has_grpFill};
        int cnt = count(elemHasValueList, elemHasValueList + 6, true);
        assert(cnt == 1);
    }


    if (m_has_noFill)
    {
        m_noFill->toXmlElem("a:noFill", "", _outStream);
    }


    if (m_has_solidFill)
    {
        m_solidFill->toXmlElem("a:solidFill", "", _outStream);
    }


    if (m_has_gradFill)
    {
        m_gradFill->toXmlElem("a:gradFill", "", _outStream);
    }


    if (m_has_blipFill)
    {
        m_blipFill->toXmlElem("a:blipFill", "", _outStream);
    }


    if (m_has_pattFill)
    {
        m_pattFill->toXmlElem("a:pattFill", "", _outStream);
    }


    if (m_has_grpFill)
    {
        m_grpFill->toXmlElem("a:grpFill", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_FillOverlayEffect& CT_FillOverlayEffect::default_instance()
{
    if (!CT_FillOverlayEffect::default_instance_)
    {
        CT_FillOverlayEffect::default_instance_ = new CT_FillOverlayEffect();
    }
    return *CT_FillOverlayEffect::default_instance_;
}

bool CT_FillOverlayEffect::has_blend_attr() const
{
    return m_has_blend_attr;
}

void CT_FillOverlayEffect::set_blend_attr(const ST_BlendMode& _blend_attr)
{
    m_has_blend_attr = true;
    m_blend_attr = new ST_BlendMode(_blend_attr);
}

const ST_BlendMode& CT_FillOverlayEffect::get_blend_attr() const
{
    if (m_blend_attr)
    {
        return *m_blend_attr;
    }
    return ST_BlendMode::default_instance();
}

CT_FillOverlayEffect* CT_FillOverlayEffect::default_instance_ = NULL;

// CT_EffectReference
CT_EffectReference::CT_EffectReference()
    :m_has_ref_attr(false),
     m_ref_attr("")
{
}
CT_EffectReference::~CT_EffectReference()
{
    clear();
}
void CT_EffectReference::clear()
{
    m_has_ref_attr = false;
    m_ref_attr.clear();
}

void CT_EffectReference::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_ref_attr);
    if (m_has_ref_attr)
    {
        _outStream << " " << "ref" << "=\"" << m_ref_attr << "\"";
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_EffectReference& CT_EffectReference::default_instance()
{
    if (!CT_EffectReference::default_instance_)
    {
        CT_EffectReference::default_instance_ = new CT_EffectReference();
    }
    return *CT_EffectReference::default_instance_;
}

bool CT_EffectReference::has_ref_attr() const
{
    return m_has_ref_attr;
}

void CT_EffectReference::set_ref_attr(const XSD::token_& _ref_attr)
{
    m_has_ref_attr = true;
    m_ref_attr = _ref_attr;
}

const XSD::token_& CT_EffectReference::get_ref_attr() const
{
    return m_ref_attr;
}

CT_EffectReference* CT_EffectReference::default_instance_ = NULL;

// CT_EffectContainer
CT_EffectContainer::CT_EffectContainer()
    :m_has_type_attr(false),
     m_type_attr(NULL),
     m_has_name_attr(false),
     m_name_attr("")
{
}
CT_EffectContainer::~CT_EffectContainer()
{
    clear();
}
void CT_EffectContainer::clear()
{
    m_has_type_attr = false;

    if (m_type_attr)
    {
        delete m_type_attr;
        m_type_attr = NULL;
    }


    m_has_name_attr = false;
    m_name_attr.clear();
}

void CT_EffectContainer::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_type_attr)
    {
        m_type_attr->toXmlAttr("type", _outStream);
    }



    if (m_has_name_attr)
    {
        _outStream << " " << "name" << "=\"" << m_name_attr << "\"";
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_EffectContainer& CT_EffectContainer::default_instance()
{
    if (!CT_EffectContainer::default_instance_)
    {
        CT_EffectContainer::default_instance_ = new CT_EffectContainer();
    }
    return *CT_EffectContainer::default_instance_;
}

bool CT_EffectContainer::has_type_attr() const
{
    return m_has_type_attr;
}

void CT_EffectContainer::set_type_attr(const ST_EffectContainerType& _type_attr)
{
    m_has_type_attr = true;
    m_type_attr = new ST_EffectContainerType(_type_attr);
}

const ST_EffectContainerType& CT_EffectContainer::get_type_attr() const
{
    if (m_type_attr)
    {
        return *m_type_attr;
    }
    return ST_EffectContainerType::default_instance();
}

bool CT_EffectContainer::has_name_attr() const
{
    return m_has_name_attr;
}

void CT_EffectContainer::set_name_attr(const XSD::token_& _name_attr)
{
    m_has_name_attr = true;
    m_name_attr = _name_attr;
}

const XSD::token_& CT_EffectContainer::get_name_attr() const
{
    return m_name_attr;
}

CT_EffectContainer* CT_EffectContainer::default_instance_ = NULL;

// CT_AlphaModulateEffect
CT_AlphaModulateEffect::CT_AlphaModulateEffect()
    :m_has_cont(false),
     m_cont(NULL)
{
}
CT_AlphaModulateEffect::~CT_AlphaModulateEffect()
{
    clear();
}
bool CT_AlphaModulateEffect::has_cont() const
{
    return m_has_cont;
}

CT_EffectContainer* CT_AlphaModulateEffect::mutable_cont()
{
    m_has_cont = true;
    if (!m_cont)
    {
        m_cont = new CT_EffectContainer();
    }
    return m_cont;
}

const CT_EffectContainer& CT_AlphaModulateEffect::get_cont() const
{
    if (m_cont)
    {
        return *m_cont;
    }
    return CT_EffectContainer::default_instance();
}

void CT_AlphaModulateEffect::clear()
{
    m_has_cont = false;

    if (m_cont)
    {
        delete m_cont;
        m_cont = NULL;
    }

}

void CT_AlphaModulateEffect::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    assert(m_has_cont);


    if (m_has_cont)
    {
        m_cont->toXmlElem("a:cont", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_AlphaModulateEffect& CT_AlphaModulateEffect::default_instance()
{
    if (!CT_AlphaModulateEffect::default_instance_)
    {
        CT_AlphaModulateEffect::default_instance_ = new CT_AlphaModulateEffect();
    }
    return *CT_AlphaModulateEffect::default_instance_;
}

CT_AlphaModulateEffect* CT_AlphaModulateEffect::default_instance_ = NULL;

// CT_BlendEffect
CT_BlendEffect::CT_BlendEffect()
    :m_has_cont(false),
     m_cont(NULL),
     m_has_blend_attr(false),
     m_blend_attr(NULL)
{
}
CT_BlendEffect::~CT_BlendEffect()
{
    clear();
}
bool CT_BlendEffect::has_cont() const
{
    return m_has_cont;
}

CT_EffectContainer* CT_BlendEffect::mutable_cont()
{
    m_has_cont = true;
    if (!m_cont)
    {
        m_cont = new CT_EffectContainer();
    }
    return m_cont;
}

const CT_EffectContainer& CT_BlendEffect::get_cont() const
{
    if (m_cont)
    {
        return *m_cont;
    }
    return CT_EffectContainer::default_instance();
}

void CT_BlendEffect::clear()
{
    m_has_blend_attr = false;

    if (m_blend_attr)
    {
        delete m_blend_attr;
        m_blend_attr = NULL;
    }


    m_has_cont = false;

    if (m_cont)
    {
        delete m_cont;
        m_cont = NULL;
    }

}

void CT_BlendEffect::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_blend_attr);
    if (m_has_blend_attr)
    {
        m_blend_attr->toXmlAttr("blend", _outStream);
    }

    _outStream << ">";

    assert(m_has_cont);


    if (m_has_cont)
    {
        m_cont->toXmlElem("a:cont", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_BlendEffect& CT_BlendEffect::default_instance()
{
    if (!CT_BlendEffect::default_instance_)
    {
        CT_BlendEffect::default_instance_ = new CT_BlendEffect();
    }
    return *CT_BlendEffect::default_instance_;
}

bool CT_BlendEffect::has_blend_attr() const
{
    return m_has_blend_attr;
}

void CT_BlendEffect::set_blend_attr(const ST_BlendMode& _blend_attr)
{
    m_has_blend_attr = true;
    m_blend_attr = new ST_BlendMode(_blend_attr);
}

const ST_BlendMode& CT_BlendEffect::get_blend_attr() const
{
    if (m_blend_attr)
    {
        return *m_blend_attr;
    }
    return ST_BlendMode::default_instance();
}

CT_BlendEffect* CT_BlendEffect::default_instance_ = NULL;

// CT_EffectList
CT_EffectList::CT_EffectList()
    :m_has_blur(false),
     m_blur(NULL),
     m_has_fillOverlay(false),
     m_fillOverlay(NULL),
     m_has_glow(false),
     m_glow(NULL),
     m_has_innerShdw(false),
     m_innerShdw(NULL),
     m_has_outerShdw(false),
     m_outerShdw(NULL),
     m_has_prstShdw(false),
     m_prstShdw(NULL),
     m_has_reflection(false),
     m_reflection(NULL),
     m_has_softEdge(false),
     m_softEdge(NULL)
{
}
CT_EffectList::~CT_EffectList()
{
    clear();
}
bool CT_EffectList::has_blur() const
{
    return m_has_blur;
}

CT_BlurEffect* CT_EffectList::mutable_blur()
{
    m_has_blur = true;
    if (!m_blur)
    {
        m_blur = new CT_BlurEffect();
    }
    return m_blur;
}

const CT_BlurEffect& CT_EffectList::get_blur() const
{
    if (m_blur)
    {
        return *m_blur;
    }
    return CT_BlurEffect::default_instance();
}

bool CT_EffectList::has_fillOverlay() const
{
    return m_has_fillOverlay;
}

CT_FillOverlayEffect* CT_EffectList::mutable_fillOverlay()
{
    m_has_fillOverlay = true;
    if (!m_fillOverlay)
    {
        m_fillOverlay = new CT_FillOverlayEffect();
    }
    return m_fillOverlay;
}

const CT_FillOverlayEffect& CT_EffectList::get_fillOverlay() const
{
    if (m_fillOverlay)
    {
        return *m_fillOverlay;
    }
    return CT_FillOverlayEffect::default_instance();
}

bool CT_EffectList::has_glow() const
{
    return m_has_glow;
}

CT_GlowEffect* CT_EffectList::mutable_glow()
{
    m_has_glow = true;
    if (!m_glow)
    {
        m_glow = new CT_GlowEffect();
    }
    return m_glow;
}

const CT_GlowEffect& CT_EffectList::get_glow() const
{
    if (m_glow)
    {
        return *m_glow;
    }
    return CT_GlowEffect::default_instance();
}

bool CT_EffectList::has_innerShdw() const
{
    return m_has_innerShdw;
}

CT_InnerShadowEffect* CT_EffectList::mutable_innerShdw()
{
    m_has_innerShdw = true;
    if (!m_innerShdw)
    {
        m_innerShdw = new CT_InnerShadowEffect();
    }
    return m_innerShdw;
}

const CT_InnerShadowEffect& CT_EffectList::get_innerShdw() const
{
    if (m_innerShdw)
    {
        return *m_innerShdw;
    }
    return CT_InnerShadowEffect::default_instance();
}

bool CT_EffectList::has_outerShdw() const
{
    return m_has_outerShdw;
}

CT_OuterShadowEffect* CT_EffectList::mutable_outerShdw()
{
    m_has_outerShdw = true;
    if (!m_outerShdw)
    {
        m_outerShdw = new CT_OuterShadowEffect();
    }
    return m_outerShdw;
}

const CT_OuterShadowEffect& CT_EffectList::get_outerShdw() const
{
    if (m_outerShdw)
    {
        return *m_outerShdw;
    }
    return CT_OuterShadowEffect::default_instance();
}

bool CT_EffectList::has_prstShdw() const
{
    return m_has_prstShdw;
}

CT_PresetShadowEffect* CT_EffectList::mutable_prstShdw()
{
    m_has_prstShdw = true;
    if (!m_prstShdw)
    {
        m_prstShdw = new CT_PresetShadowEffect();
    }
    return m_prstShdw;
}

const CT_PresetShadowEffect& CT_EffectList::get_prstShdw() const
{
    if (m_prstShdw)
    {
        return *m_prstShdw;
    }
    return CT_PresetShadowEffect::default_instance();
}

bool CT_EffectList::has_reflection() const
{
    return m_has_reflection;
}

CT_ReflectionEffect* CT_EffectList::mutable_reflection()
{
    m_has_reflection = true;
    if (!m_reflection)
    {
        m_reflection = new CT_ReflectionEffect();
    }
    return m_reflection;
}

const CT_ReflectionEffect& CT_EffectList::get_reflection() const
{
    if (m_reflection)
    {
        return *m_reflection;
    }
    return CT_ReflectionEffect::default_instance();
}

bool CT_EffectList::has_softEdge() const
{
    return m_has_softEdge;
}

CT_SoftEdgesEffect* CT_EffectList::mutable_softEdge()
{
    m_has_softEdge = true;
    if (!m_softEdge)
    {
        m_softEdge = new CT_SoftEdgesEffect();
    }
    return m_softEdge;
}

const CT_SoftEdgesEffect& CT_EffectList::get_softEdge() const
{
    if (m_softEdge)
    {
        return *m_softEdge;
    }
    return CT_SoftEdgesEffect::default_instance();
}

void CT_EffectList::clear()
{
    m_has_blur = false;

    if (m_blur)
    {
        delete m_blur;
        m_blur = NULL;
    }


    m_has_fillOverlay = false;

    if (m_fillOverlay)
    {
        delete m_fillOverlay;
        m_fillOverlay = NULL;
    }


    m_has_glow = false;

    if (m_glow)
    {
        delete m_glow;
        m_glow = NULL;
    }


    m_has_innerShdw = false;

    if (m_innerShdw)
    {
        delete m_innerShdw;
        m_innerShdw = NULL;
    }


    m_has_outerShdw = false;

    if (m_outerShdw)
    {
        delete m_outerShdw;
        m_outerShdw = NULL;
    }


    m_has_prstShdw = false;

    if (m_prstShdw)
    {
        delete m_prstShdw;
        m_prstShdw = NULL;
    }


    m_has_reflection = false;

    if (m_reflection)
    {
        delete m_reflection;
        m_reflection = NULL;
    }


    m_has_softEdge = false;

    if (m_softEdge)
    {
        delete m_softEdge;
        m_softEdge = NULL;
    }

}

void CT_EffectList::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";


    if (m_has_blur)
    {
        m_blur->toXmlElem("a:blur", "", _outStream);
    }


    if (m_has_fillOverlay)
    {
        m_fillOverlay->toXmlElem("a:fillOverlay", "", _outStream);
    }


    if (m_has_glow)
    {
        m_glow->toXmlElem("a:glow", "", _outStream);
    }


    if (m_has_innerShdw)
    {
        m_innerShdw->toXmlElem("a:innerShdw", "", _outStream);
    }


    if (m_has_outerShdw)
    {
        m_outerShdw->toXmlElem("a:outerShdw", "", _outStream);
    }


    if (m_has_prstShdw)
    {
        m_prstShdw->toXmlElem("a:prstShdw", "", _outStream);
    }


    if (m_has_reflection)
    {
        m_reflection->toXmlElem("a:reflection", "", _outStream);
    }


    if (m_has_softEdge)
    {
        m_softEdge->toXmlElem("a:softEdge", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_EffectList& CT_EffectList::default_instance()
{
    if (!CT_EffectList::default_instance_)
    {
        CT_EffectList::default_instance_ = new CT_EffectList();
    }
    return *CT_EffectList::default_instance_;
}

CT_EffectList* CT_EffectList::default_instance_ = NULL;

// CT_EffectProperties
CT_EffectProperties::CT_EffectProperties()
    :m_has_effectLst(false),
     m_effectLst(NULL),
     m_has_effectDag(false),
     m_effectDag(NULL)
{
}
CT_EffectProperties::~CT_EffectProperties()
{
    clear();
}
bool CT_EffectProperties::has_effectLst() const
{
    return m_has_effectLst;
}

CT_EffectList* CT_EffectProperties::mutable_effectLst()
{

    m_has_effectDag = false;

    if (m_effectDag)
    {
        delete m_effectDag;
        m_effectDag = NULL;
    }
    ;

    m_has_effectLst = true;
    if (!m_effectLst)
    {
        m_effectLst = new CT_EffectList();
    }
    return m_effectLst;
}

const CT_EffectList& CT_EffectProperties::get_effectLst() const
{
    if (m_effectLst)
    {
        return *m_effectLst;
    }
    return CT_EffectList::default_instance();
}

bool CT_EffectProperties::has_effectDag() const
{
    return m_has_effectDag;
}

CT_EffectContainer* CT_EffectProperties::mutable_effectDag()
{

    m_has_effectLst = false;

    if (m_effectLst)
    {
        delete m_effectLst;
        m_effectLst = NULL;
    }
    ;

    m_has_effectDag = true;
    if (!m_effectDag)
    {
        m_effectDag = new CT_EffectContainer();
    }
    return m_effectDag;
}

const CT_EffectContainer& CT_EffectProperties::get_effectDag() const
{
    if (m_effectDag)
    {
        return *m_effectDag;
    }
    return CT_EffectContainer::default_instance();
}

void CT_EffectProperties::clear()
{
    m_has_effectLst = false;

    if (m_effectLst)
    {
        delete m_effectLst;
        m_effectLst = NULL;
    }


    m_has_effectDag = false;

    if (m_effectDag)
    {
        delete m_effectDag;
        m_effectDag = NULL;
    }

}

void CT_EffectProperties::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    {
        bool elemHasValueList[2] = {m_has_effectLst, m_has_effectDag};
        int cnt = count(elemHasValueList, elemHasValueList + 2, true);
        assert(cnt == 1);
    }


    if (m_has_effectLst)
    {
        m_effectLst->toXmlElem("a:effectLst", "", _outStream);
    }


    if (m_has_effectDag)
    {
        m_effectDag->toXmlElem("a:effectDag", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_EffectProperties& CT_EffectProperties::default_instance()
{
    if (!CT_EffectProperties::default_instance_)
    {
        CT_EffectProperties::default_instance_ = new CT_EffectProperties();
    }
    return *CT_EffectProperties::default_instance_;
}

CT_EffectProperties* CT_EffectProperties::default_instance_ = NULL;

// CT_GeomGuide
CT_GeomGuide::CT_GeomGuide()
    :m_has_name_attr(false),
     m_name_attr(NULL),
     m_has_fmla_attr(false),
     m_fmla_attr(NULL)
{
}
CT_GeomGuide::~CT_GeomGuide()
{
    clear();
}
void CT_GeomGuide::clear()
{
    m_has_name_attr = false;

    if (m_name_attr)
    {
        delete m_name_attr;
        m_name_attr = NULL;
    }


    m_has_fmla_attr = false;

    if (m_fmla_attr)
    {
        delete m_fmla_attr;
        m_fmla_attr = NULL;
    }

}

void CT_GeomGuide::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_name_attr);
    if (m_has_name_attr)
    {
        m_name_attr->toXmlAttr("name", _outStream);
    }


    assert(m_has_fmla_attr);
    if (m_has_fmla_attr)
    {
        m_fmla_attr->toXmlAttr("fmla", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_GeomGuide& CT_GeomGuide::default_instance()
{
    if (!CT_GeomGuide::default_instance_)
    {
        CT_GeomGuide::default_instance_ = new CT_GeomGuide();
    }
    return *CT_GeomGuide::default_instance_;
}

bool CT_GeomGuide::has_name_attr() const
{
    return m_has_name_attr;
}

void CT_GeomGuide::set_name_attr(const ST_GeomGuideName& _name_attr)
{
    m_has_name_attr = true;
    m_name_attr = new ST_GeomGuideName(_name_attr);
}

const ST_GeomGuideName& CT_GeomGuide::get_name_attr() const
{
    if (m_name_attr)
    {
        return *m_name_attr;
    }
    return ST_GeomGuideName::default_instance();
}

bool CT_GeomGuide::has_fmla_attr() const
{
    return m_has_fmla_attr;
}

void CT_GeomGuide::set_fmla_attr(const ST_GeomGuideFormula& _fmla_attr)
{
    m_has_fmla_attr = true;
    m_fmla_attr = new ST_GeomGuideFormula(_fmla_attr);
}

const ST_GeomGuideFormula& CT_GeomGuide::get_fmla_attr() const
{
    if (m_fmla_attr)
    {
        return *m_fmla_attr;
    }
    return ST_GeomGuideFormula::default_instance();
}

CT_GeomGuide* CT_GeomGuide::default_instance_ = NULL;

// CT_GeomGuideList
CT_GeomGuideList::CT_GeomGuideList()

{
}
CT_GeomGuideList::~CT_GeomGuideList()
{
    clear();
}
CT_GeomGuide* CT_GeomGuideList::add_gd()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_GeomGuide* pNewChild = pChildGroup->mutable_gd();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

void CT_GeomGuideList::clear()
{
    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }
}

void CT_GeomGuideList::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_gd())
            {
                (*iter)->get_gd().toXmlElem("a:gd", "", _outStream);
            }


        }
    }

    _outStream << "</" << _elemName << ">";
}

const CT_GeomGuideList& CT_GeomGuideList::default_instance()
{
    if (!CT_GeomGuideList::default_instance_)
    {
        CT_GeomGuideList::default_instance_ = new CT_GeomGuideList();
    }
    return *CT_GeomGuideList::default_instance_;
}


// CT_GeomGuideList::ChildGroup_1
CT_GeomGuideList::ChildGroup_1::ChildGroup_1()
    :m_has_gd(false),
     m_gd(NULL)
{
}
bool CT_GeomGuideList::ChildGroup_1::has_gd() const
{
    return m_has_gd;
}

CT_GeomGuide* CT_GeomGuideList::ChildGroup_1::mutable_gd()
{

    m_has_gd = true;
    if (!m_gd)
    {
        m_gd = new CT_GeomGuide();
    }
    return m_gd;
}

const CT_GeomGuide& CT_GeomGuideList::ChildGroup_1::get_gd() const
{
    if (m_gd)
    {
        return *m_gd;
    }
    return CT_GeomGuide::default_instance();
}

CT_GeomGuideList* CT_GeomGuideList::default_instance_ = NULL;

// CT_AdjPoint2D
CT_AdjPoint2D::CT_AdjPoint2D()
    :m_has_x_attr(false),
     m_x_attr(NULL),
     m_has_y_attr(false),
     m_y_attr(NULL)
{
}
CT_AdjPoint2D::~CT_AdjPoint2D()
{
    clear();
}
void CT_AdjPoint2D::clear()
{
    m_has_x_attr = false;

    if (m_x_attr)
    {
        delete m_x_attr;
        m_x_attr = NULL;
    }


    m_has_y_attr = false;

    if (m_y_attr)
    {
        delete m_y_attr;
        m_y_attr = NULL;
    }

}

void CT_AdjPoint2D::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_x_attr);
    if (m_has_x_attr)
    {
        m_x_attr->toXmlAttr("x", _outStream);
    }


    assert(m_has_y_attr);
    if (m_has_y_attr)
    {
        m_y_attr->toXmlAttr("y", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_AdjPoint2D& CT_AdjPoint2D::default_instance()
{
    if (!CT_AdjPoint2D::default_instance_)
    {
        CT_AdjPoint2D::default_instance_ = new CT_AdjPoint2D();
    }
    return *CT_AdjPoint2D::default_instance_;
}

bool CT_AdjPoint2D::has_x_attr() const
{
    return m_has_x_attr;
}

void CT_AdjPoint2D::set_x_attr(const ST_AdjCoordinate& _x_attr)
{
    m_has_x_attr = true;
    m_x_attr = new ST_AdjCoordinate(_x_attr);
}

const ST_AdjCoordinate& CT_AdjPoint2D::get_x_attr() const
{
    if (m_x_attr)
    {
        return *m_x_attr;
    }
    return ST_AdjCoordinate::default_instance();
}

bool CT_AdjPoint2D::has_y_attr() const
{
    return m_has_y_attr;
}

void CT_AdjPoint2D::set_y_attr(const ST_AdjCoordinate& _y_attr)
{
    m_has_y_attr = true;
    m_y_attr = new ST_AdjCoordinate(_y_attr);
}

const ST_AdjCoordinate& CT_AdjPoint2D::get_y_attr() const
{
    if (m_y_attr)
    {
        return *m_y_attr;
    }
    return ST_AdjCoordinate::default_instance();
}

CT_AdjPoint2D* CT_AdjPoint2D::default_instance_ = NULL;

// CT_GeomRect
CT_GeomRect::CT_GeomRect()
    :m_has_l_attr(false),
     m_l_attr(NULL),
     m_has_t_attr(false),
     m_t_attr(NULL),
     m_has_r_attr(false),
     m_r_attr(NULL),
     m_has_b_attr(false),
     m_b_attr(NULL)
{
}
CT_GeomRect::~CT_GeomRect()
{
    clear();
}
void CT_GeomRect::clear()
{
    m_has_l_attr = false;

    if (m_l_attr)
    {
        delete m_l_attr;
        m_l_attr = NULL;
    }


    m_has_t_attr = false;

    if (m_t_attr)
    {
        delete m_t_attr;
        m_t_attr = NULL;
    }


    m_has_r_attr = false;

    if (m_r_attr)
    {
        delete m_r_attr;
        m_r_attr = NULL;
    }


    m_has_b_attr = false;

    if (m_b_attr)
    {
        delete m_b_attr;
        m_b_attr = NULL;
    }

}

void CT_GeomRect::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_l_attr);
    if (m_has_l_attr)
    {
        m_l_attr->toXmlAttr("l", _outStream);
    }


    assert(m_has_t_attr);
    if (m_has_t_attr)
    {
        m_t_attr->toXmlAttr("t", _outStream);
    }


    assert(m_has_r_attr);
    if (m_has_r_attr)
    {
        m_r_attr->toXmlAttr("r", _outStream);
    }


    assert(m_has_b_attr);
    if (m_has_b_attr)
    {
        m_b_attr->toXmlAttr("b", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_GeomRect& CT_GeomRect::default_instance()
{
    if (!CT_GeomRect::default_instance_)
    {
        CT_GeomRect::default_instance_ = new CT_GeomRect();
    }
    return *CT_GeomRect::default_instance_;
}

bool CT_GeomRect::has_l_attr() const
{
    return m_has_l_attr;
}

void CT_GeomRect::set_l_attr(const ST_AdjCoordinate& _l_attr)
{
    m_has_l_attr = true;
    m_l_attr = new ST_AdjCoordinate(_l_attr);
}

const ST_AdjCoordinate& CT_GeomRect::get_l_attr() const
{
    if (m_l_attr)
    {
        return *m_l_attr;
    }
    return ST_AdjCoordinate::default_instance();
}

bool CT_GeomRect::has_t_attr() const
{
    return m_has_t_attr;
}

void CT_GeomRect::set_t_attr(const ST_AdjCoordinate& _t_attr)
{
    m_has_t_attr = true;
    m_t_attr = new ST_AdjCoordinate(_t_attr);
}

const ST_AdjCoordinate& CT_GeomRect::get_t_attr() const
{
    if (m_t_attr)
    {
        return *m_t_attr;
    }
    return ST_AdjCoordinate::default_instance();
}

bool CT_GeomRect::has_r_attr() const
{
    return m_has_r_attr;
}

void CT_GeomRect::set_r_attr(const ST_AdjCoordinate& _r_attr)
{
    m_has_r_attr = true;
    m_r_attr = new ST_AdjCoordinate(_r_attr);
}

const ST_AdjCoordinate& CT_GeomRect::get_r_attr() const
{
    if (m_r_attr)
    {
        return *m_r_attr;
    }
    return ST_AdjCoordinate::default_instance();
}

bool CT_GeomRect::has_b_attr() const
{
    return m_has_b_attr;
}

void CT_GeomRect::set_b_attr(const ST_AdjCoordinate& _b_attr)
{
    m_has_b_attr = true;
    m_b_attr = new ST_AdjCoordinate(_b_attr);
}

const ST_AdjCoordinate& CT_GeomRect::get_b_attr() const
{
    if (m_b_attr)
    {
        return *m_b_attr;
    }
    return ST_AdjCoordinate::default_instance();
}

CT_GeomRect* CT_GeomRect::default_instance_ = NULL;

// CT_XYAdjustHandle
CT_XYAdjustHandle::CT_XYAdjustHandle()
    :m_has_pos(false),
     m_pos(NULL),
     m_has_gdRefX_attr(false),
     m_gdRefX_attr(NULL),
     m_has_minX_attr(false),
     m_minX_attr(NULL),
     m_has_maxX_attr(false),
     m_maxX_attr(NULL),
     m_has_gdRefY_attr(false),
     m_gdRefY_attr(NULL),
     m_has_minY_attr(false),
     m_minY_attr(NULL),
     m_has_maxY_attr(false),
     m_maxY_attr(NULL)
{
}
CT_XYAdjustHandle::~CT_XYAdjustHandle()
{
    clear();
}
bool CT_XYAdjustHandle::has_pos() const
{
    return m_has_pos;
}

CT_AdjPoint2D* CT_XYAdjustHandle::mutable_pos()
{
    m_has_pos = true;
    if (!m_pos)
    {
        m_pos = new CT_AdjPoint2D();
    }
    return m_pos;
}

const CT_AdjPoint2D& CT_XYAdjustHandle::get_pos() const
{
    if (m_pos)
    {
        return *m_pos;
    }
    return CT_AdjPoint2D::default_instance();
}

void CT_XYAdjustHandle::clear()
{
    m_has_gdRefX_attr = false;

    if (m_gdRefX_attr)
    {
        delete m_gdRefX_attr;
        m_gdRefX_attr = NULL;
    }


    m_has_minX_attr = false;

    if (m_minX_attr)
    {
        delete m_minX_attr;
        m_minX_attr = NULL;
    }


    m_has_maxX_attr = false;

    if (m_maxX_attr)
    {
        delete m_maxX_attr;
        m_maxX_attr = NULL;
    }


    m_has_gdRefY_attr = false;

    if (m_gdRefY_attr)
    {
        delete m_gdRefY_attr;
        m_gdRefY_attr = NULL;
    }


    m_has_minY_attr = false;

    if (m_minY_attr)
    {
        delete m_minY_attr;
        m_minY_attr = NULL;
    }


    m_has_maxY_attr = false;

    if (m_maxY_attr)
    {
        delete m_maxY_attr;
        m_maxY_attr = NULL;
    }


    m_has_pos = false;

    if (m_pos)
    {
        delete m_pos;
        m_pos = NULL;
    }

}

void CT_XYAdjustHandle::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_gdRefX_attr)
    {
        m_gdRefX_attr->toXmlAttr("gdRefX", _outStream);
    }



    if (m_has_minX_attr)
    {
        m_minX_attr->toXmlAttr("minX", _outStream);
    }



    if (m_has_maxX_attr)
    {
        m_maxX_attr->toXmlAttr("maxX", _outStream);
    }



    if (m_has_gdRefY_attr)
    {
        m_gdRefY_attr->toXmlAttr("gdRefY", _outStream);
    }



    if (m_has_minY_attr)
    {
        m_minY_attr->toXmlAttr("minY", _outStream);
    }



    if (m_has_maxY_attr)
    {
        m_maxY_attr->toXmlAttr("maxY", _outStream);
    }

    _outStream << ">";

    assert(m_has_pos);


    if (m_has_pos)
    {
        m_pos->toXmlElem("a:pos", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_XYAdjustHandle& CT_XYAdjustHandle::default_instance()
{
    if (!CT_XYAdjustHandle::default_instance_)
    {
        CT_XYAdjustHandle::default_instance_ = new CT_XYAdjustHandle();
    }
    return *CT_XYAdjustHandle::default_instance_;
}

bool CT_XYAdjustHandle::has_gdRefX_attr() const
{
    return m_has_gdRefX_attr;
}

void CT_XYAdjustHandle::set_gdRefX_attr(const ST_GeomGuideName& _gdRefX_attr)
{
    m_has_gdRefX_attr = true;
    m_gdRefX_attr = new ST_GeomGuideName(_gdRefX_attr);
}

const ST_GeomGuideName& CT_XYAdjustHandle::get_gdRefX_attr() const
{
    if (m_gdRefX_attr)
    {
        return *m_gdRefX_attr;
    }
    return ST_GeomGuideName::default_instance();
}

bool CT_XYAdjustHandle::has_minX_attr() const
{
    return m_has_minX_attr;
}

void CT_XYAdjustHandle::set_minX_attr(const ST_AdjCoordinate& _minX_attr)
{
    m_has_minX_attr = true;
    m_minX_attr = new ST_AdjCoordinate(_minX_attr);
}

const ST_AdjCoordinate& CT_XYAdjustHandle::get_minX_attr() const
{
    if (m_minX_attr)
    {
        return *m_minX_attr;
    }
    return ST_AdjCoordinate::default_instance();
}

bool CT_XYAdjustHandle::has_maxX_attr() const
{
    return m_has_maxX_attr;
}

void CT_XYAdjustHandle::set_maxX_attr(const ST_AdjCoordinate& _maxX_attr)
{
    m_has_maxX_attr = true;
    m_maxX_attr = new ST_AdjCoordinate(_maxX_attr);
}

const ST_AdjCoordinate& CT_XYAdjustHandle::get_maxX_attr() const
{
    if (m_maxX_attr)
    {
        return *m_maxX_attr;
    }
    return ST_AdjCoordinate::default_instance();
}

bool CT_XYAdjustHandle::has_gdRefY_attr() const
{
    return m_has_gdRefY_attr;
}

void CT_XYAdjustHandle::set_gdRefY_attr(const ST_GeomGuideName& _gdRefY_attr)
{
    m_has_gdRefY_attr = true;
    m_gdRefY_attr = new ST_GeomGuideName(_gdRefY_attr);
}

const ST_GeomGuideName& CT_XYAdjustHandle::get_gdRefY_attr() const
{
    if (m_gdRefY_attr)
    {
        return *m_gdRefY_attr;
    }
    return ST_GeomGuideName::default_instance();
}

bool CT_XYAdjustHandle::has_minY_attr() const
{
    return m_has_minY_attr;
}

void CT_XYAdjustHandle::set_minY_attr(const ST_AdjCoordinate& _minY_attr)
{
    m_has_minY_attr = true;
    m_minY_attr = new ST_AdjCoordinate(_minY_attr);
}

const ST_AdjCoordinate& CT_XYAdjustHandle::get_minY_attr() const
{
    if (m_minY_attr)
    {
        return *m_minY_attr;
    }
    return ST_AdjCoordinate::default_instance();
}

bool CT_XYAdjustHandle::has_maxY_attr() const
{
    return m_has_maxY_attr;
}

void CT_XYAdjustHandle::set_maxY_attr(const ST_AdjCoordinate& _maxY_attr)
{
    m_has_maxY_attr = true;
    m_maxY_attr = new ST_AdjCoordinate(_maxY_attr);
}

const ST_AdjCoordinate& CT_XYAdjustHandle::get_maxY_attr() const
{
    if (m_maxY_attr)
    {
        return *m_maxY_attr;
    }
    return ST_AdjCoordinate::default_instance();
}

CT_XYAdjustHandle* CT_XYAdjustHandle::default_instance_ = NULL;

// CT_PolarAdjustHandle
CT_PolarAdjustHandle::CT_PolarAdjustHandle()
    :m_has_pos(false),
     m_pos(NULL),
     m_has_gdRefR_attr(false),
     m_gdRefR_attr(NULL),
     m_has_minR_attr(false),
     m_minR_attr(NULL),
     m_has_maxR_attr(false),
     m_maxR_attr(NULL),
     m_has_gdRefAng_attr(false),
     m_gdRefAng_attr(NULL),
     m_has_minAng_attr(false),
     m_minAng_attr(NULL),
     m_has_maxAng_attr(false),
     m_maxAng_attr(NULL)
{
}
CT_PolarAdjustHandle::~CT_PolarAdjustHandle()
{
    clear();
}
bool CT_PolarAdjustHandle::has_pos() const
{
    return m_has_pos;
}

CT_AdjPoint2D* CT_PolarAdjustHandle::mutable_pos()
{
    m_has_pos = true;
    if (!m_pos)
    {
        m_pos = new CT_AdjPoint2D();
    }
    return m_pos;
}

const CT_AdjPoint2D& CT_PolarAdjustHandle::get_pos() const
{
    if (m_pos)
    {
        return *m_pos;
    }
    return CT_AdjPoint2D::default_instance();
}

void CT_PolarAdjustHandle::clear()
{
    m_has_gdRefR_attr = false;

    if (m_gdRefR_attr)
    {
        delete m_gdRefR_attr;
        m_gdRefR_attr = NULL;
    }


    m_has_minR_attr = false;

    if (m_minR_attr)
    {
        delete m_minR_attr;
        m_minR_attr = NULL;
    }


    m_has_maxR_attr = false;

    if (m_maxR_attr)
    {
        delete m_maxR_attr;
        m_maxR_attr = NULL;
    }


    m_has_gdRefAng_attr = false;

    if (m_gdRefAng_attr)
    {
        delete m_gdRefAng_attr;
        m_gdRefAng_attr = NULL;
    }


    m_has_minAng_attr = false;

    if (m_minAng_attr)
    {
        delete m_minAng_attr;
        m_minAng_attr = NULL;
    }


    m_has_maxAng_attr = false;

    if (m_maxAng_attr)
    {
        delete m_maxAng_attr;
        m_maxAng_attr = NULL;
    }


    m_has_pos = false;

    if (m_pos)
    {
        delete m_pos;
        m_pos = NULL;
    }

}

void CT_PolarAdjustHandle::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_gdRefR_attr)
    {
        m_gdRefR_attr->toXmlAttr("gdRefR", _outStream);
    }



    if (m_has_minR_attr)
    {
        m_minR_attr->toXmlAttr("minR", _outStream);
    }



    if (m_has_maxR_attr)
    {
        m_maxR_attr->toXmlAttr("maxR", _outStream);
    }



    if (m_has_gdRefAng_attr)
    {
        m_gdRefAng_attr->toXmlAttr("gdRefAng", _outStream);
    }



    if (m_has_minAng_attr)
    {
        m_minAng_attr->toXmlAttr("minAng", _outStream);
    }



    if (m_has_maxAng_attr)
    {
        m_maxAng_attr->toXmlAttr("maxAng", _outStream);
    }

    _outStream << ">";

    assert(m_has_pos);


    if (m_has_pos)
    {
        m_pos->toXmlElem("a:pos", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_PolarAdjustHandle& CT_PolarAdjustHandle::default_instance()
{
    if (!CT_PolarAdjustHandle::default_instance_)
    {
        CT_PolarAdjustHandle::default_instance_ = new CT_PolarAdjustHandle();
    }
    return *CT_PolarAdjustHandle::default_instance_;
}

bool CT_PolarAdjustHandle::has_gdRefR_attr() const
{
    return m_has_gdRefR_attr;
}

void CT_PolarAdjustHandle::set_gdRefR_attr(const ST_GeomGuideName& _gdRefR_attr)
{
    m_has_gdRefR_attr = true;
    m_gdRefR_attr = new ST_GeomGuideName(_gdRefR_attr);
}

const ST_GeomGuideName& CT_PolarAdjustHandle::get_gdRefR_attr() const
{
    if (m_gdRefR_attr)
    {
        return *m_gdRefR_attr;
    }
    return ST_GeomGuideName::default_instance();
}

bool CT_PolarAdjustHandle::has_minR_attr() const
{
    return m_has_minR_attr;
}

void CT_PolarAdjustHandle::set_minR_attr(const ST_AdjCoordinate& _minR_attr)
{
    m_has_minR_attr = true;
    m_minR_attr = new ST_AdjCoordinate(_minR_attr);
}

const ST_AdjCoordinate& CT_PolarAdjustHandle::get_minR_attr() const
{
    if (m_minR_attr)
    {
        return *m_minR_attr;
    }
    return ST_AdjCoordinate::default_instance();
}

bool CT_PolarAdjustHandle::has_maxR_attr() const
{
    return m_has_maxR_attr;
}

void CT_PolarAdjustHandle::set_maxR_attr(const ST_AdjCoordinate& _maxR_attr)
{
    m_has_maxR_attr = true;
    m_maxR_attr = new ST_AdjCoordinate(_maxR_attr);
}

const ST_AdjCoordinate& CT_PolarAdjustHandle::get_maxR_attr() const
{
    if (m_maxR_attr)
    {
        return *m_maxR_attr;
    }
    return ST_AdjCoordinate::default_instance();
}

bool CT_PolarAdjustHandle::has_gdRefAng_attr() const
{
    return m_has_gdRefAng_attr;
}

void CT_PolarAdjustHandle::set_gdRefAng_attr(const ST_GeomGuideName& _gdRefAng_attr)
{
    m_has_gdRefAng_attr = true;
    m_gdRefAng_attr = new ST_GeomGuideName(_gdRefAng_attr);
}

const ST_GeomGuideName& CT_PolarAdjustHandle::get_gdRefAng_attr() const
{
    if (m_gdRefAng_attr)
    {
        return *m_gdRefAng_attr;
    }
    return ST_GeomGuideName::default_instance();
}

bool CT_PolarAdjustHandle::has_minAng_attr() const
{
    return m_has_minAng_attr;
}

void CT_PolarAdjustHandle::set_minAng_attr(const ST_AdjAngle& _minAng_attr)
{
    m_has_minAng_attr = true;
    m_minAng_attr = new ST_AdjAngle(_minAng_attr);
}

const ST_AdjAngle& CT_PolarAdjustHandle::get_minAng_attr() const
{
    if (m_minAng_attr)
    {
        return *m_minAng_attr;
    }
    return ST_AdjAngle::default_instance();
}

bool CT_PolarAdjustHandle::has_maxAng_attr() const
{
    return m_has_maxAng_attr;
}

void CT_PolarAdjustHandle::set_maxAng_attr(const ST_AdjAngle& _maxAng_attr)
{
    m_has_maxAng_attr = true;
    m_maxAng_attr = new ST_AdjAngle(_maxAng_attr);
}

const ST_AdjAngle& CT_PolarAdjustHandle::get_maxAng_attr() const
{
    if (m_maxAng_attr)
    {
        return *m_maxAng_attr;
    }
    return ST_AdjAngle::default_instance();
}

CT_PolarAdjustHandle* CT_PolarAdjustHandle::default_instance_ = NULL;

// CT_ConnectionSite
CT_ConnectionSite::CT_ConnectionSite()
    :m_has_pos(false),
     m_pos(NULL),
     m_has_ang_attr(false),
     m_ang_attr(NULL)
{
}
CT_ConnectionSite::~CT_ConnectionSite()
{
    clear();
}
bool CT_ConnectionSite::has_pos() const
{
    return m_has_pos;
}

CT_AdjPoint2D* CT_ConnectionSite::mutable_pos()
{
    m_has_pos = true;
    if (!m_pos)
    {
        m_pos = new CT_AdjPoint2D();
    }
    return m_pos;
}

const CT_AdjPoint2D& CT_ConnectionSite::get_pos() const
{
    if (m_pos)
    {
        return *m_pos;
    }
    return CT_AdjPoint2D::default_instance();
}

void CT_ConnectionSite::clear()
{
    m_has_ang_attr = false;

    if (m_ang_attr)
    {
        delete m_ang_attr;
        m_ang_attr = NULL;
    }


    m_has_pos = false;

    if (m_pos)
    {
        delete m_pos;
        m_pos = NULL;
    }

}

void CT_ConnectionSite::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_ang_attr);
    if (m_has_ang_attr)
    {
        m_ang_attr->toXmlAttr("ang", _outStream);
    }

    _outStream << ">";

    assert(m_has_pos);


    if (m_has_pos)
    {
        m_pos->toXmlElem("a:pos", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_ConnectionSite& CT_ConnectionSite::default_instance()
{
    if (!CT_ConnectionSite::default_instance_)
    {
        CT_ConnectionSite::default_instance_ = new CT_ConnectionSite();
    }
    return *CT_ConnectionSite::default_instance_;
}

bool CT_ConnectionSite::has_ang_attr() const
{
    return m_has_ang_attr;
}

void CT_ConnectionSite::set_ang_attr(const ST_AdjAngle& _ang_attr)
{
    m_has_ang_attr = true;
    m_ang_attr = new ST_AdjAngle(_ang_attr);
}

const ST_AdjAngle& CT_ConnectionSite::get_ang_attr() const
{
    if (m_ang_attr)
    {
        return *m_ang_attr;
    }
    return ST_AdjAngle::default_instance();
}

CT_ConnectionSite* CT_ConnectionSite::default_instance_ = NULL;

// CT_AdjustHandleList
CT_AdjustHandleList::CT_AdjustHandleList()

{
}
CT_AdjustHandleList::~CT_AdjustHandleList()
{
    clear();
}
CT_XYAdjustHandle* CT_AdjustHandleList::add_ahXY()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_XYAdjustHandle* pNewChild = pChildGroup->mutable_ahXY();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_PolarAdjustHandle* CT_AdjustHandleList::add_ahPolar()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_PolarAdjustHandle* pNewChild = pChildGroup->mutable_ahPolar();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

void CT_AdjustHandleList::clear()
{
    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }
}

void CT_AdjustHandleList::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_ahXY())
            {
                (*iter)->get_ahXY().toXmlElem("a:ahXY", "", _outStream);
            }


            else if ((*iter)->has_ahPolar())
            {
                (*iter)->get_ahPolar().toXmlElem("a:ahPolar", "", _outStream);
            }


        }
    }

    _outStream << "</" << _elemName << ">";
}

const CT_AdjustHandleList& CT_AdjustHandleList::default_instance()
{
    if (!CT_AdjustHandleList::default_instance_)
    {
        CT_AdjustHandleList::default_instance_ = new CT_AdjustHandleList();
    }
    return *CT_AdjustHandleList::default_instance_;
}


// CT_AdjustHandleList::ChildGroup_1
CT_AdjustHandleList::ChildGroup_1::ChildGroup_1()
    :m_has_ahXY(false),
     m_ahXY(NULL),
     m_has_ahPolar(false),
     m_ahPolar(NULL)
{
}
bool CT_AdjustHandleList::ChildGroup_1::has_ahXY() const
{
    return m_has_ahXY;
}

CT_XYAdjustHandle* CT_AdjustHandleList::ChildGroup_1::mutable_ahXY()
{

    m_has_ahPolar = false;

    if (m_ahPolar)
    {
        delete m_ahPolar;
        m_ahPolar = NULL;
    }
    ;

    m_has_ahXY = true;
    if (!m_ahXY)
    {
        m_ahXY = new CT_XYAdjustHandle();
    }
    return m_ahXY;
}

const CT_XYAdjustHandle& CT_AdjustHandleList::ChildGroup_1::get_ahXY() const
{
    if (m_ahXY)
    {
        return *m_ahXY;
    }
    return CT_XYAdjustHandle::default_instance();
}

bool CT_AdjustHandleList::ChildGroup_1::has_ahPolar() const
{
    return m_has_ahPolar;
}

CT_PolarAdjustHandle* CT_AdjustHandleList::ChildGroup_1::mutable_ahPolar()
{

    m_has_ahXY = false;

    if (m_ahXY)
    {
        delete m_ahXY;
        m_ahXY = NULL;
    }
    ;

    m_has_ahPolar = true;
    if (!m_ahPolar)
    {
        m_ahPolar = new CT_PolarAdjustHandle();
    }
    return m_ahPolar;
}

const CT_PolarAdjustHandle& CT_AdjustHandleList::ChildGroup_1::get_ahPolar() const
{
    if (m_ahPolar)
    {
        return *m_ahPolar;
    }
    return CT_PolarAdjustHandle::default_instance();
}

CT_AdjustHandleList* CT_AdjustHandleList::default_instance_ = NULL;

// CT_ConnectionSiteList
CT_ConnectionSiteList::CT_ConnectionSiteList()

{
}
CT_ConnectionSiteList::~CT_ConnectionSiteList()
{
    clear();
}
CT_ConnectionSite* CT_ConnectionSiteList::add_cxn()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_ConnectionSite* pNewChild = pChildGroup->mutable_cxn();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

void CT_ConnectionSiteList::clear()
{
    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }
}

void CT_ConnectionSiteList::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_cxn())
            {
                (*iter)->get_cxn().toXmlElem("a:cxn", "", _outStream);
            }


        }
    }

    _outStream << "</" << _elemName << ">";
}

const CT_ConnectionSiteList& CT_ConnectionSiteList::default_instance()
{
    if (!CT_ConnectionSiteList::default_instance_)
    {
        CT_ConnectionSiteList::default_instance_ = new CT_ConnectionSiteList();
    }
    return *CT_ConnectionSiteList::default_instance_;
}


// CT_ConnectionSiteList::ChildGroup_1
CT_ConnectionSiteList::ChildGroup_1::ChildGroup_1()
    :m_has_cxn(false),
     m_cxn(NULL)
{
}
bool CT_ConnectionSiteList::ChildGroup_1::has_cxn() const
{
    return m_has_cxn;
}

CT_ConnectionSite* CT_ConnectionSiteList::ChildGroup_1::mutable_cxn()
{

    m_has_cxn = true;
    if (!m_cxn)
    {
        m_cxn = new CT_ConnectionSite();
    }
    return m_cxn;
}

const CT_ConnectionSite& CT_ConnectionSiteList::ChildGroup_1::get_cxn() const
{
    if (m_cxn)
    {
        return *m_cxn;
    }
    return CT_ConnectionSite::default_instance();
}

CT_ConnectionSiteList* CT_ConnectionSiteList::default_instance_ = NULL;

// CT_Connection
CT_Connection::CT_Connection()
    :m_has_id_attr(false),
     m_id_attr(NULL),
     m_has_idx_attr(false),
     m_idx_attr(0)
{
}
CT_Connection::~CT_Connection()
{
    clear();
}
void CT_Connection::clear()
{
    m_has_id_attr = false;

    if (m_id_attr)
    {
        delete m_id_attr;
        m_id_attr = NULL;
    }


    m_has_idx_attr = false;
    m_idx_attr = 0;
}

void CT_Connection::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_id_attr);
    if (m_has_id_attr)
    {
        m_id_attr->toXmlAttr("id", _outStream);
    }


    assert(m_has_idx_attr);
    if (m_has_idx_attr)
    {
        _outStream << " " << "idx" << "=\"" << m_idx_attr << "\"";
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_Connection& CT_Connection::default_instance()
{
    if (!CT_Connection::default_instance_)
    {
        CT_Connection::default_instance_ = new CT_Connection();
    }
    return *CT_Connection::default_instance_;
}

bool CT_Connection::has_id_attr() const
{
    return m_has_id_attr;
}

void CT_Connection::set_id_attr(const ST_DrawingElementId& _id_attr)
{
    m_has_id_attr = true;
    m_id_attr = new ST_DrawingElementId(_id_attr);
}

const ST_DrawingElementId& CT_Connection::get_id_attr() const
{
    if (m_id_attr)
    {
        return *m_id_attr;
    }
    return ST_DrawingElementId::default_instance();
}

bool CT_Connection::has_idx_attr() const
{
    return m_has_idx_attr;
}

void CT_Connection::set_idx_attr(const XSD::unsignedInt_& _idx_attr)
{
    m_has_idx_attr = true;
    m_idx_attr = _idx_attr;
}

const XSD::unsignedInt_& CT_Connection::get_idx_attr() const
{
    return m_idx_attr;
}

CT_Connection* CT_Connection::default_instance_ = NULL;

// CT_Path2DMoveTo
CT_Path2DMoveTo::CT_Path2DMoveTo()
    :m_has_pt(false),
     m_pt(NULL)
{
}
CT_Path2DMoveTo::~CT_Path2DMoveTo()
{
    clear();
}
bool CT_Path2DMoveTo::has_pt() const
{
    return m_has_pt;
}

CT_AdjPoint2D* CT_Path2DMoveTo::mutable_pt()
{
    m_has_pt = true;
    if (!m_pt)
    {
        m_pt = new CT_AdjPoint2D();
    }
    return m_pt;
}

const CT_AdjPoint2D& CT_Path2DMoveTo::get_pt() const
{
    if (m_pt)
    {
        return *m_pt;
    }
    return CT_AdjPoint2D::default_instance();
}

void CT_Path2DMoveTo::clear()
{
    m_has_pt = false;

    if (m_pt)
    {
        delete m_pt;
        m_pt = NULL;
    }

}

void CT_Path2DMoveTo::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    assert(m_has_pt);


    if (m_has_pt)
    {
        m_pt->toXmlElem("a:pt", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_Path2DMoveTo& CT_Path2DMoveTo::default_instance()
{
    if (!CT_Path2DMoveTo::default_instance_)
    {
        CT_Path2DMoveTo::default_instance_ = new CT_Path2DMoveTo();
    }
    return *CT_Path2DMoveTo::default_instance_;
}

CT_Path2DMoveTo* CT_Path2DMoveTo::default_instance_ = NULL;

// CT_Path2DLineTo
CT_Path2DLineTo::CT_Path2DLineTo()
    :m_has_pt(false),
     m_pt(NULL)
{
}
CT_Path2DLineTo::~CT_Path2DLineTo()
{
    clear();
}
bool CT_Path2DLineTo::has_pt() const
{
    return m_has_pt;
}

CT_AdjPoint2D* CT_Path2DLineTo::mutable_pt()
{
    m_has_pt = true;
    if (!m_pt)
    {
        m_pt = new CT_AdjPoint2D();
    }
    return m_pt;
}

const CT_AdjPoint2D& CT_Path2DLineTo::get_pt() const
{
    if (m_pt)
    {
        return *m_pt;
    }
    return CT_AdjPoint2D::default_instance();
}

void CT_Path2DLineTo::clear()
{
    m_has_pt = false;

    if (m_pt)
    {
        delete m_pt;
        m_pt = NULL;
    }

}

void CT_Path2DLineTo::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    assert(m_has_pt);


    if (m_has_pt)
    {
        m_pt->toXmlElem("a:pt", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_Path2DLineTo& CT_Path2DLineTo::default_instance()
{
    if (!CT_Path2DLineTo::default_instance_)
    {
        CT_Path2DLineTo::default_instance_ = new CT_Path2DLineTo();
    }
    return *CT_Path2DLineTo::default_instance_;
}

CT_Path2DLineTo* CT_Path2DLineTo::default_instance_ = NULL;

// CT_Path2DArcTo
CT_Path2DArcTo::CT_Path2DArcTo()
    :m_has_wR_attr(false),
     m_wR_attr(NULL),
     m_has_hR_attr(false),
     m_hR_attr(NULL),
     m_has_stAng_attr(false),
     m_stAng_attr(NULL),
     m_has_swAng_attr(false),
     m_swAng_attr(NULL)
{
}
CT_Path2DArcTo::~CT_Path2DArcTo()
{
    clear();
}
void CT_Path2DArcTo::clear()
{
    m_has_wR_attr = false;

    if (m_wR_attr)
    {
        delete m_wR_attr;
        m_wR_attr = NULL;
    }


    m_has_hR_attr = false;

    if (m_hR_attr)
    {
        delete m_hR_attr;
        m_hR_attr = NULL;
    }


    m_has_stAng_attr = false;

    if (m_stAng_attr)
    {
        delete m_stAng_attr;
        m_stAng_attr = NULL;
    }


    m_has_swAng_attr = false;

    if (m_swAng_attr)
    {
        delete m_swAng_attr;
        m_swAng_attr = NULL;
    }

}

void CT_Path2DArcTo::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_wR_attr);
    if (m_has_wR_attr)
    {
        m_wR_attr->toXmlAttr("wR", _outStream);
    }


    assert(m_has_hR_attr);
    if (m_has_hR_attr)
    {
        m_hR_attr->toXmlAttr("hR", _outStream);
    }


    assert(m_has_stAng_attr);
    if (m_has_stAng_attr)
    {
        m_stAng_attr->toXmlAttr("stAng", _outStream);
    }


    assert(m_has_swAng_attr);
    if (m_has_swAng_attr)
    {
        m_swAng_attr->toXmlAttr("swAng", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_Path2DArcTo& CT_Path2DArcTo::default_instance()
{
    if (!CT_Path2DArcTo::default_instance_)
    {
        CT_Path2DArcTo::default_instance_ = new CT_Path2DArcTo();
    }
    return *CT_Path2DArcTo::default_instance_;
}

bool CT_Path2DArcTo::has_wR_attr() const
{
    return m_has_wR_attr;
}

void CT_Path2DArcTo::set_wR_attr(const ST_AdjCoordinate& _wR_attr)
{
    m_has_wR_attr = true;
    m_wR_attr = new ST_AdjCoordinate(_wR_attr);
}

const ST_AdjCoordinate& CT_Path2DArcTo::get_wR_attr() const
{
    if (m_wR_attr)
    {
        return *m_wR_attr;
    }
    return ST_AdjCoordinate::default_instance();
}

bool CT_Path2DArcTo::has_hR_attr() const
{
    return m_has_hR_attr;
}

void CT_Path2DArcTo::set_hR_attr(const ST_AdjCoordinate& _hR_attr)
{
    m_has_hR_attr = true;
    m_hR_attr = new ST_AdjCoordinate(_hR_attr);
}

const ST_AdjCoordinate& CT_Path2DArcTo::get_hR_attr() const
{
    if (m_hR_attr)
    {
        return *m_hR_attr;
    }
    return ST_AdjCoordinate::default_instance();
}

bool CT_Path2DArcTo::has_stAng_attr() const
{
    return m_has_stAng_attr;
}

void CT_Path2DArcTo::set_stAng_attr(const ST_AdjAngle& _stAng_attr)
{
    m_has_stAng_attr = true;
    m_stAng_attr = new ST_AdjAngle(_stAng_attr);
}

const ST_AdjAngle& CT_Path2DArcTo::get_stAng_attr() const
{
    if (m_stAng_attr)
    {
        return *m_stAng_attr;
    }
    return ST_AdjAngle::default_instance();
}

bool CT_Path2DArcTo::has_swAng_attr() const
{
    return m_has_swAng_attr;
}

void CT_Path2DArcTo::set_swAng_attr(const ST_AdjAngle& _swAng_attr)
{
    m_has_swAng_attr = true;
    m_swAng_attr = new ST_AdjAngle(_swAng_attr);
}

const ST_AdjAngle& CT_Path2DArcTo::get_swAng_attr() const
{
    if (m_swAng_attr)
    {
        return *m_swAng_attr;
    }
    return ST_AdjAngle::default_instance();
}

CT_Path2DArcTo* CT_Path2DArcTo::default_instance_ = NULL;

// CT_Path2DQuadBezierTo
CT_Path2DQuadBezierTo::CT_Path2DQuadBezierTo()

{
}
CT_Path2DQuadBezierTo::~CT_Path2DQuadBezierTo()
{
    clear();
}
CT_AdjPoint2D* CT_Path2DQuadBezierTo::add_pt()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_AdjPoint2D* pNewChild = pChildGroup->mutable_pt();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

void CT_Path2DQuadBezierTo::clear()
{
    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }
}

void CT_Path2DQuadBezierTo::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    {
        int elemCnt = count_if(m_childGroupList_1.begin(), m_childGroupList_1.end(), mem_fun(&ChildGroup_1::has_pt));
        assert(2 <= elemCnt && elemCnt <= 2);
    }

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_pt())
            {
                (*iter)->get_pt().toXmlElem("a:pt", "", _outStream);
            }


        }
    }

    _outStream << "</" << _elemName << ">";
}

const CT_Path2DQuadBezierTo& CT_Path2DQuadBezierTo::default_instance()
{
    if (!CT_Path2DQuadBezierTo::default_instance_)
    {
        CT_Path2DQuadBezierTo::default_instance_ = new CT_Path2DQuadBezierTo();
    }
    return *CT_Path2DQuadBezierTo::default_instance_;
}


// CT_Path2DQuadBezierTo::ChildGroup_1
CT_Path2DQuadBezierTo::ChildGroup_1::ChildGroup_1()
    :m_has_pt(false),
     m_pt(NULL)
{
}
bool CT_Path2DQuadBezierTo::ChildGroup_1::has_pt() const
{
    return m_has_pt;
}

CT_AdjPoint2D* CT_Path2DQuadBezierTo::ChildGroup_1::mutable_pt()
{

    m_has_pt = true;
    if (!m_pt)
    {
        m_pt = new CT_AdjPoint2D();
    }
    return m_pt;
}

const CT_AdjPoint2D& CT_Path2DQuadBezierTo::ChildGroup_1::get_pt() const
{
    if (m_pt)
    {
        return *m_pt;
    }
    return CT_AdjPoint2D::default_instance();
}

CT_Path2DQuadBezierTo* CT_Path2DQuadBezierTo::default_instance_ = NULL;

// CT_Path2DCubicBezierTo
CT_Path2DCubicBezierTo::CT_Path2DCubicBezierTo()

{
}
CT_Path2DCubicBezierTo::~CT_Path2DCubicBezierTo()
{
    clear();
}
CT_AdjPoint2D* CT_Path2DCubicBezierTo::add_pt()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_AdjPoint2D* pNewChild = pChildGroup->mutable_pt();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

void CT_Path2DCubicBezierTo::clear()
{
    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }
}

void CT_Path2DCubicBezierTo::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    {
        int elemCnt = count_if(m_childGroupList_1.begin(), m_childGroupList_1.end(), mem_fun(&ChildGroup_1::has_pt));
        assert(3 <= elemCnt && elemCnt <= 3);
    }

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_pt())
            {
                (*iter)->get_pt().toXmlElem("a:pt", "", _outStream);
            }


        }
    }

    _outStream << "</" << _elemName << ">";
}

const CT_Path2DCubicBezierTo& CT_Path2DCubicBezierTo::default_instance()
{
    if (!CT_Path2DCubicBezierTo::default_instance_)
    {
        CT_Path2DCubicBezierTo::default_instance_ = new CT_Path2DCubicBezierTo();
    }
    return *CT_Path2DCubicBezierTo::default_instance_;
}


// CT_Path2DCubicBezierTo::ChildGroup_1
CT_Path2DCubicBezierTo::ChildGroup_1::ChildGroup_1()
    :m_has_pt(false),
     m_pt(NULL)
{
}
bool CT_Path2DCubicBezierTo::ChildGroup_1::has_pt() const
{
    return m_has_pt;
}

CT_AdjPoint2D* CT_Path2DCubicBezierTo::ChildGroup_1::mutable_pt()
{

    m_has_pt = true;
    if (!m_pt)
    {
        m_pt = new CT_AdjPoint2D();
    }
    return m_pt;
}

const CT_AdjPoint2D& CT_Path2DCubicBezierTo::ChildGroup_1::get_pt() const
{
    if (m_pt)
    {
        return *m_pt;
    }
    return CT_AdjPoint2D::default_instance();
}

CT_Path2DCubicBezierTo* CT_Path2DCubicBezierTo::default_instance_ = NULL;

// CT_Path2DClose
CT_Path2DClose::CT_Path2DClose()

{
}
CT_Path2DClose::~CT_Path2DClose()
{
    clear();
}
void CT_Path2DClose::clear()
{    }

void CT_Path2DClose::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_Path2DClose& CT_Path2DClose::default_instance()
{
    if (!CT_Path2DClose::default_instance_)
    {
        CT_Path2DClose::default_instance_ = new CT_Path2DClose();
    }
    return *CT_Path2DClose::default_instance_;
}

CT_Path2DClose* CT_Path2DClose::default_instance_ = NULL;

// CT_Path2D
CT_Path2D::CT_Path2D()
    :m_has_w_attr(false),
     m_w_attr(NULL),
     m_has_h_attr(false),
     m_h_attr(NULL),
     m_has_fill_attr(false),
     m_fill_attr(NULL),
     m_has_stroke_attr(false),
     m_stroke_attr(false),
     m_has_extrusionOk_attr(false),
     m_extrusionOk_attr(false)
{
}
CT_Path2D::~CT_Path2D()
{
    clear();
}
CT_Path2DClose* CT_Path2D::add_close()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Path2DClose* pNewChild = pChildGroup->mutable_close();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Path2DMoveTo* CT_Path2D::add_moveTo()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Path2DMoveTo* pNewChild = pChildGroup->mutable_moveTo();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Path2DLineTo* CT_Path2D::add_lnTo()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Path2DLineTo* pNewChild = pChildGroup->mutable_lnTo();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Path2DArcTo* CT_Path2D::add_arcTo()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Path2DArcTo* pNewChild = pChildGroup->mutable_arcTo();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Path2DQuadBezierTo* CT_Path2D::add_quadBezTo()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Path2DQuadBezierTo* pNewChild = pChildGroup->mutable_quadBezTo();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_Path2DCubicBezierTo* CT_Path2D::add_cubicBezTo()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Path2DCubicBezierTo* pNewChild = pChildGroup->mutable_cubicBezTo();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

void CT_Path2D::clear()
{
    m_has_w_attr = false;

    if (m_w_attr)
    {
        delete m_w_attr;
        m_w_attr = NULL;
    }


    m_has_h_attr = false;

    if (m_h_attr)
    {
        delete m_h_attr;
        m_h_attr = NULL;
    }


    m_has_fill_attr = false;

    if (m_fill_attr)
    {
        delete m_fill_attr;
        m_fill_attr = NULL;
    }


    m_has_stroke_attr = false;
    m_stroke_attr = false;

    m_has_extrusionOk_attr = false;
    m_extrusionOk_attr = false;

    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }
}

void CT_Path2D::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_w_attr)
    {
        m_w_attr->toXmlAttr("w", _outStream);
    }



    if (m_has_h_attr)
    {
        m_h_attr->toXmlAttr("h", _outStream);
    }



    if (m_has_fill_attr)
    {
        m_fill_attr->toXmlAttr("fill", _outStream);
    }



    if (m_has_stroke_attr)
    {
        _outStream << " " << "stroke" << "=\"" << XSD::XMLBooleanStr(m_stroke_attr) << "\"";
    }



    if (m_has_extrusionOk_attr)
    {
        _outStream << " " << "extrusionOk" << "=\"" << XSD::XMLBooleanStr(m_extrusionOk_attr) << "\"";
    }

    _outStream << ">";

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_close())
            {
                (*iter)->get_close().toXmlElem("a:close", "", _outStream);
            }


            else if ((*iter)->has_moveTo())
            {
                (*iter)->get_moveTo().toXmlElem("a:moveTo", "", _outStream);
            }


            else if ((*iter)->has_lnTo())
            {
                (*iter)->get_lnTo().toXmlElem("a:lnTo", "", _outStream);
            }


            else if ((*iter)->has_arcTo())
            {
                (*iter)->get_arcTo().toXmlElem("a:arcTo", "", _outStream);
            }


            else if ((*iter)->has_quadBezTo())
            {
                (*iter)->get_quadBezTo().toXmlElem("a:quadBezTo", "", _outStream);
            }


            else if ((*iter)->has_cubicBezTo())
            {
                (*iter)->get_cubicBezTo().toXmlElem("a:cubicBezTo", "", _outStream);
            }


        }
    }

    _outStream << "</" << _elemName << ">";
}

const CT_Path2D& CT_Path2D::default_instance()
{
    if (!CT_Path2D::default_instance_)
    {
        CT_Path2D::default_instance_ = new CT_Path2D();
    }
    return *CT_Path2D::default_instance_;
}

bool CT_Path2D::has_w_attr() const
{
    return m_has_w_attr;
}

void CT_Path2D::set_w_attr(const ST_PositiveCoordinate& _w_attr)
{
    m_has_w_attr = true;
    m_w_attr = new ST_PositiveCoordinate(_w_attr);
}

const ST_PositiveCoordinate& CT_Path2D::get_w_attr() const
{
    if (m_w_attr)
    {
        return *m_w_attr;
    }
    return ST_PositiveCoordinate::default_instance();
}

bool CT_Path2D::has_h_attr() const
{
    return m_has_h_attr;
}

void CT_Path2D::set_h_attr(const ST_PositiveCoordinate& _h_attr)
{
    m_has_h_attr = true;
    m_h_attr = new ST_PositiveCoordinate(_h_attr);
}

const ST_PositiveCoordinate& CT_Path2D::get_h_attr() const
{
    if (m_h_attr)
    {
        return *m_h_attr;
    }
    return ST_PositiveCoordinate::default_instance();
}

bool CT_Path2D::has_fill_attr() const
{
    return m_has_fill_attr;
}

void CT_Path2D::set_fill_attr(const ST_PathFillMode& _fill_attr)
{
    m_has_fill_attr = true;
    m_fill_attr = new ST_PathFillMode(_fill_attr);
}

const ST_PathFillMode& CT_Path2D::get_fill_attr() const
{
    if (m_fill_attr)
    {
        return *m_fill_attr;
    }
    return ST_PathFillMode::default_instance();
}

bool CT_Path2D::has_stroke_attr() const
{
    return m_has_stroke_attr;
}

void CT_Path2D::set_stroke_attr(const XSD::boolean_& _stroke_attr)
{
    m_has_stroke_attr = true;
    m_stroke_attr = _stroke_attr;
}

const XSD::boolean_& CT_Path2D::get_stroke_attr() const
{
    return m_stroke_attr;
}

bool CT_Path2D::has_extrusionOk_attr() const
{
    return m_has_extrusionOk_attr;
}

void CT_Path2D::set_extrusionOk_attr(const XSD::boolean_& _extrusionOk_attr)
{
    m_has_extrusionOk_attr = true;
    m_extrusionOk_attr = _extrusionOk_attr;
}

const XSD::boolean_& CT_Path2D::get_extrusionOk_attr() const
{
    return m_extrusionOk_attr;
}


// CT_Path2D::ChildGroup_1
CT_Path2D::ChildGroup_1::ChildGroup_1()
    :m_has_close(false),
     m_close(NULL),
     m_has_moveTo(false),
     m_moveTo(NULL),
     m_has_lnTo(false),
     m_lnTo(NULL),
     m_has_arcTo(false),
     m_arcTo(NULL),
     m_has_quadBezTo(false),
     m_quadBezTo(NULL),
     m_has_cubicBezTo(false),
     m_cubicBezTo(NULL)
{
}
bool CT_Path2D::ChildGroup_1::has_close() const
{
    return m_has_close;
}

CT_Path2DClose* CT_Path2D::ChildGroup_1::mutable_close()
{

    m_has_moveTo = false;

    if (m_moveTo)
    {
        delete m_moveTo;
        m_moveTo = NULL;
    }
    ;

    m_has_lnTo = false;

    if (m_lnTo)
    {
        delete m_lnTo;
        m_lnTo = NULL;
    }
    ;

    m_has_arcTo = false;

    if (m_arcTo)
    {
        delete m_arcTo;
        m_arcTo = NULL;
    }
    ;

    m_has_quadBezTo = false;

    if (m_quadBezTo)
    {
        delete m_quadBezTo;
        m_quadBezTo = NULL;
    }
    ;

    m_has_cubicBezTo = false;

    if (m_cubicBezTo)
    {
        delete m_cubicBezTo;
        m_cubicBezTo = NULL;
    }
    ;

    m_has_close = true;
    if (!m_close)
    {
        m_close = new CT_Path2DClose();
    }
    return m_close;
}

const CT_Path2DClose& CT_Path2D::ChildGroup_1::get_close() const
{
    if (m_close)
    {
        return *m_close;
    }
    return CT_Path2DClose::default_instance();
}

bool CT_Path2D::ChildGroup_1::has_moveTo() const
{
    return m_has_moveTo;
}

CT_Path2DMoveTo* CT_Path2D::ChildGroup_1::mutable_moveTo()
{

    m_has_close = false;

    if (m_close)
    {
        delete m_close;
        m_close = NULL;
    }
    ;

    m_has_lnTo = false;

    if (m_lnTo)
    {
        delete m_lnTo;
        m_lnTo = NULL;
    }
    ;

    m_has_arcTo = false;

    if (m_arcTo)
    {
        delete m_arcTo;
        m_arcTo = NULL;
    }
    ;

    m_has_quadBezTo = false;

    if (m_quadBezTo)
    {
        delete m_quadBezTo;
        m_quadBezTo = NULL;
    }
    ;

    m_has_cubicBezTo = false;

    if (m_cubicBezTo)
    {
        delete m_cubicBezTo;
        m_cubicBezTo = NULL;
    }
    ;

    m_has_moveTo = true;
    if (!m_moveTo)
    {
        m_moveTo = new CT_Path2DMoveTo();
    }
    return m_moveTo;
}

const CT_Path2DMoveTo& CT_Path2D::ChildGroup_1::get_moveTo() const
{
    if (m_moveTo)
    {
        return *m_moveTo;
    }
    return CT_Path2DMoveTo::default_instance();
}

bool CT_Path2D::ChildGroup_1::has_lnTo() const
{
    return m_has_lnTo;
}

CT_Path2DLineTo* CT_Path2D::ChildGroup_1::mutable_lnTo()
{

    m_has_close = false;

    if (m_close)
    {
        delete m_close;
        m_close = NULL;
    }
    ;

    m_has_moveTo = false;

    if (m_moveTo)
    {
        delete m_moveTo;
        m_moveTo = NULL;
    }
    ;

    m_has_arcTo = false;

    if (m_arcTo)
    {
        delete m_arcTo;
        m_arcTo = NULL;
    }
    ;

    m_has_quadBezTo = false;

    if (m_quadBezTo)
    {
        delete m_quadBezTo;
        m_quadBezTo = NULL;
    }
    ;

    m_has_cubicBezTo = false;

    if (m_cubicBezTo)
    {
        delete m_cubicBezTo;
        m_cubicBezTo = NULL;
    }
    ;

    m_has_lnTo = true;
    if (!m_lnTo)
    {
        m_lnTo = new CT_Path2DLineTo();
    }
    return m_lnTo;
}

const CT_Path2DLineTo& CT_Path2D::ChildGroup_1::get_lnTo() const
{
    if (m_lnTo)
    {
        return *m_lnTo;
    }
    return CT_Path2DLineTo::default_instance();
}

bool CT_Path2D::ChildGroup_1::has_arcTo() const
{
    return m_has_arcTo;
}

CT_Path2DArcTo* CT_Path2D::ChildGroup_1::mutable_arcTo()
{

    m_has_close = false;

    if (m_close)
    {
        delete m_close;
        m_close = NULL;
    }
    ;

    m_has_moveTo = false;

    if (m_moveTo)
    {
        delete m_moveTo;
        m_moveTo = NULL;
    }
    ;

    m_has_lnTo = false;

    if (m_lnTo)
    {
        delete m_lnTo;
        m_lnTo = NULL;
    }
    ;

    m_has_quadBezTo = false;

    if (m_quadBezTo)
    {
        delete m_quadBezTo;
        m_quadBezTo = NULL;
    }
    ;

    m_has_cubicBezTo = false;

    if (m_cubicBezTo)
    {
        delete m_cubicBezTo;
        m_cubicBezTo = NULL;
    }
    ;

    m_has_arcTo = true;
    if (!m_arcTo)
    {
        m_arcTo = new CT_Path2DArcTo();
    }
    return m_arcTo;
}

const CT_Path2DArcTo& CT_Path2D::ChildGroup_1::get_arcTo() const
{
    if (m_arcTo)
    {
        return *m_arcTo;
    }
    return CT_Path2DArcTo::default_instance();
}

bool CT_Path2D::ChildGroup_1::has_quadBezTo() const
{
    return m_has_quadBezTo;
}

CT_Path2DQuadBezierTo* CT_Path2D::ChildGroup_1::mutable_quadBezTo()
{

    m_has_close = false;

    if (m_close)
    {
        delete m_close;
        m_close = NULL;
    }
    ;

    m_has_moveTo = false;

    if (m_moveTo)
    {
        delete m_moveTo;
        m_moveTo = NULL;
    }
    ;

    m_has_lnTo = false;

    if (m_lnTo)
    {
        delete m_lnTo;
        m_lnTo = NULL;
    }
    ;

    m_has_arcTo = false;

    if (m_arcTo)
    {
        delete m_arcTo;
        m_arcTo = NULL;
    }
    ;

    m_has_cubicBezTo = false;

    if (m_cubicBezTo)
    {
        delete m_cubicBezTo;
        m_cubicBezTo = NULL;
    }
    ;

    m_has_quadBezTo = true;
    if (!m_quadBezTo)
    {
        m_quadBezTo = new CT_Path2DQuadBezierTo();
    }
    return m_quadBezTo;
}

const CT_Path2DQuadBezierTo& CT_Path2D::ChildGroup_1::get_quadBezTo() const
{
    if (m_quadBezTo)
    {
        return *m_quadBezTo;
    }
    return CT_Path2DQuadBezierTo::default_instance();
}

bool CT_Path2D::ChildGroup_1::has_cubicBezTo() const
{
    return m_has_cubicBezTo;
}

CT_Path2DCubicBezierTo* CT_Path2D::ChildGroup_1::mutable_cubicBezTo()
{

    m_has_close = false;

    if (m_close)
    {
        delete m_close;
        m_close = NULL;
    }
    ;

    m_has_moveTo = false;

    if (m_moveTo)
    {
        delete m_moveTo;
        m_moveTo = NULL;
    }
    ;

    m_has_lnTo = false;

    if (m_lnTo)
    {
        delete m_lnTo;
        m_lnTo = NULL;
    }
    ;

    m_has_arcTo = false;

    if (m_arcTo)
    {
        delete m_arcTo;
        m_arcTo = NULL;
    }
    ;

    m_has_quadBezTo = false;

    if (m_quadBezTo)
    {
        delete m_quadBezTo;
        m_quadBezTo = NULL;
    }
    ;

    m_has_cubicBezTo = true;
    if (!m_cubicBezTo)
    {
        m_cubicBezTo = new CT_Path2DCubicBezierTo();
    }
    return m_cubicBezTo;
}

const CT_Path2DCubicBezierTo& CT_Path2D::ChildGroup_1::get_cubicBezTo() const
{
    if (m_cubicBezTo)
    {
        return *m_cubicBezTo;
    }
    return CT_Path2DCubicBezierTo::default_instance();
}

CT_Path2D* CT_Path2D::default_instance_ = NULL;

// CT_Path2DList
CT_Path2DList::CT_Path2DList()

{
}
CT_Path2DList::~CT_Path2DList()
{
    clear();
}
CT_Path2D* CT_Path2DList::add_path()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_Path2D* pNewChild = pChildGroup->mutable_path();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

void CT_Path2DList::clear()
{
    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }
}

void CT_Path2DList::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_path())
            {
                (*iter)->get_path().toXmlElem("a:path", "", _outStream);
            }


        }
    }

    _outStream << "</" << _elemName << ">";
}

const CT_Path2DList& CT_Path2DList::default_instance()
{
    if (!CT_Path2DList::default_instance_)
    {
        CT_Path2DList::default_instance_ = new CT_Path2DList();
    }
    return *CT_Path2DList::default_instance_;
}


// CT_Path2DList::ChildGroup_1
CT_Path2DList::ChildGroup_1::ChildGroup_1()
    :m_has_path(false),
     m_path(NULL)
{
}
bool CT_Path2DList::ChildGroup_1::has_path() const
{
    return m_has_path;
}

CT_Path2D* CT_Path2DList::ChildGroup_1::mutable_path()
{

    m_has_path = true;
    if (!m_path)
    {
        m_path = new CT_Path2D();
    }
    return m_path;
}

const CT_Path2D& CT_Path2DList::ChildGroup_1::get_path() const
{
    if (m_path)
    {
        return *m_path;
    }
    return CT_Path2D::default_instance();
}

CT_Path2DList* CT_Path2DList::default_instance_ = NULL;

// CT_PresetGeometry2D
CT_PresetGeometry2D::CT_PresetGeometry2D()
    :m_has_avLst(false),
     m_avLst(NULL),
     m_has_prst_attr(false),
     m_prst_attr(NULL)
{
}
CT_PresetGeometry2D::~CT_PresetGeometry2D()
{
    clear();
}
bool CT_PresetGeometry2D::has_avLst() const
{
    return m_has_avLst;
}

CT_GeomGuideList* CT_PresetGeometry2D::mutable_avLst()
{
    m_has_avLst = true;
    if (!m_avLst)
    {
        m_avLst = new CT_GeomGuideList();
    }
    return m_avLst;
}

const CT_GeomGuideList& CT_PresetGeometry2D::get_avLst() const
{
    if (m_avLst)
    {
        return *m_avLst;
    }
    return CT_GeomGuideList::default_instance();
}

void CT_PresetGeometry2D::clear()
{
    m_has_prst_attr = false;

    if (m_prst_attr)
    {
        delete m_prst_attr;
        m_prst_attr = NULL;
    }


    m_has_avLst = false;

    if (m_avLst)
    {
        delete m_avLst;
        m_avLst = NULL;
    }

}

void CT_PresetGeometry2D::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_prst_attr);
    if (m_has_prst_attr)
    {
        m_prst_attr->toXmlAttr("prst", _outStream);
    }

    _outStream << ">";


    if (m_has_avLst)
    {
        m_avLst->toXmlElem("a:avLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_PresetGeometry2D& CT_PresetGeometry2D::default_instance()
{
    if (!CT_PresetGeometry2D::default_instance_)
    {
        CT_PresetGeometry2D::default_instance_ = new CT_PresetGeometry2D();
    }
    return *CT_PresetGeometry2D::default_instance_;
}

bool CT_PresetGeometry2D::has_prst_attr() const
{
    return m_has_prst_attr;
}

void CT_PresetGeometry2D::set_prst_attr(const ST_ShapeType& _prst_attr)
{
    m_has_prst_attr = true;
    m_prst_attr = new ST_ShapeType(_prst_attr);
}

const ST_ShapeType& CT_PresetGeometry2D::get_prst_attr() const
{
    if (m_prst_attr)
    {
        return *m_prst_attr;
    }
    return ST_ShapeType::default_instance();
}

CT_PresetGeometry2D* CT_PresetGeometry2D::default_instance_ = NULL;

// CT_PresetTextShape
CT_PresetTextShape::CT_PresetTextShape()
    :m_has_avLst(false),
     m_avLst(NULL),
     m_has_prst_attr(false),
     m_prst_attr(NULL)
{
}
CT_PresetTextShape::~CT_PresetTextShape()
{
    clear();
}
bool CT_PresetTextShape::has_avLst() const
{
    return m_has_avLst;
}

CT_GeomGuideList* CT_PresetTextShape::mutable_avLst()
{
    m_has_avLst = true;
    if (!m_avLst)
    {
        m_avLst = new CT_GeomGuideList();
    }
    return m_avLst;
}

const CT_GeomGuideList& CT_PresetTextShape::get_avLst() const
{
    if (m_avLst)
    {
        return *m_avLst;
    }
    return CT_GeomGuideList::default_instance();
}

void CT_PresetTextShape::clear()
{
    m_has_prst_attr = false;

    if (m_prst_attr)
    {
        delete m_prst_attr;
        m_prst_attr = NULL;
    }


    m_has_avLst = false;

    if (m_avLst)
    {
        delete m_avLst;
        m_avLst = NULL;
    }

}

void CT_PresetTextShape::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_prst_attr);
    if (m_has_prst_attr)
    {
        m_prst_attr->toXmlAttr("prst", _outStream);
    }

    _outStream << ">";


    if (m_has_avLst)
    {
        m_avLst->toXmlElem("a:avLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_PresetTextShape& CT_PresetTextShape::default_instance()
{
    if (!CT_PresetTextShape::default_instance_)
    {
        CT_PresetTextShape::default_instance_ = new CT_PresetTextShape();
    }
    return *CT_PresetTextShape::default_instance_;
}

bool CT_PresetTextShape::has_prst_attr() const
{
    return m_has_prst_attr;
}

void CT_PresetTextShape::set_prst_attr(const ST_TextShapeType& _prst_attr)
{
    m_has_prst_attr = true;
    m_prst_attr = new ST_TextShapeType(_prst_attr);
}

const ST_TextShapeType& CT_PresetTextShape::get_prst_attr() const
{
    if (m_prst_attr)
    {
        return *m_prst_attr;
    }
    return ST_TextShapeType::default_instance();
}

CT_PresetTextShape* CT_PresetTextShape::default_instance_ = NULL;

// CT_CustomGeometry2D
CT_CustomGeometry2D::CT_CustomGeometry2D()
    :m_has_avLst(false),
     m_avLst(NULL),
     m_has_gdLst(false),
     m_gdLst(NULL),
     m_has_ahLst(false),
     m_ahLst(NULL),
     m_has_cxnLst(false),
     m_cxnLst(NULL),
     m_has_rect(false),
     m_rect(NULL),
     m_has_pathLst(false),
     m_pathLst(NULL)
{
}
CT_CustomGeometry2D::~CT_CustomGeometry2D()
{
    clear();
}
bool CT_CustomGeometry2D::has_avLst() const
{
    return m_has_avLst;
}

CT_GeomGuideList* CT_CustomGeometry2D::mutable_avLst()
{
    m_has_avLst = true;
    if (!m_avLst)
    {
        m_avLst = new CT_GeomGuideList();
    }
    return m_avLst;
}

const CT_GeomGuideList& CT_CustomGeometry2D::get_avLst() const
{
    if (m_avLst)
    {
        return *m_avLst;
    }
    return CT_GeomGuideList::default_instance();
}

bool CT_CustomGeometry2D::has_gdLst() const
{
    return m_has_gdLst;
}

CT_GeomGuideList* CT_CustomGeometry2D::mutable_gdLst()
{
    m_has_gdLst = true;
    if (!m_gdLst)
    {
        m_gdLst = new CT_GeomGuideList();
    }
    return m_gdLst;
}

const CT_GeomGuideList& CT_CustomGeometry2D::get_gdLst() const
{
    if (m_gdLst)
    {
        return *m_gdLst;
    }
    return CT_GeomGuideList::default_instance();
}

bool CT_CustomGeometry2D::has_ahLst() const
{
    return m_has_ahLst;
}

CT_AdjustHandleList* CT_CustomGeometry2D::mutable_ahLst()
{
    m_has_ahLst = true;
    if (!m_ahLst)
    {
        m_ahLst = new CT_AdjustHandleList();
    }
    return m_ahLst;
}

const CT_AdjustHandleList& CT_CustomGeometry2D::get_ahLst() const
{
    if (m_ahLst)
    {
        return *m_ahLst;
    }
    return CT_AdjustHandleList::default_instance();
}

bool CT_CustomGeometry2D::has_cxnLst() const
{
    return m_has_cxnLst;
}

CT_ConnectionSiteList* CT_CustomGeometry2D::mutable_cxnLst()
{
    m_has_cxnLst = true;
    if (!m_cxnLst)
    {
        m_cxnLst = new CT_ConnectionSiteList();
    }
    return m_cxnLst;
}

const CT_ConnectionSiteList& CT_CustomGeometry2D::get_cxnLst() const
{
    if (m_cxnLst)
    {
        return *m_cxnLst;
    }
    return CT_ConnectionSiteList::default_instance();
}

bool CT_CustomGeometry2D::has_rect() const
{
    return m_has_rect;
}

CT_GeomRect* CT_CustomGeometry2D::mutable_rect()
{
    m_has_rect = true;
    if (!m_rect)
    {
        m_rect = new CT_GeomRect();
    }
    return m_rect;
}

const CT_GeomRect& CT_CustomGeometry2D::get_rect() const
{
    if (m_rect)
    {
        return *m_rect;
    }
    return CT_GeomRect::default_instance();
}

bool CT_CustomGeometry2D::has_pathLst() const
{
    return m_has_pathLst;
}

CT_Path2DList* CT_CustomGeometry2D::mutable_pathLst()
{
    m_has_pathLst = true;
    if (!m_pathLst)
    {
        m_pathLst = new CT_Path2DList();
    }
    return m_pathLst;
}

const CT_Path2DList& CT_CustomGeometry2D::get_pathLst() const
{
    if (m_pathLst)
    {
        return *m_pathLst;
    }
    return CT_Path2DList::default_instance();
}

void CT_CustomGeometry2D::clear()
{
    m_has_avLst = false;

    if (m_avLst)
    {
        delete m_avLst;
        m_avLst = NULL;
    }


    m_has_gdLst = false;

    if (m_gdLst)
    {
        delete m_gdLst;
        m_gdLst = NULL;
    }


    m_has_ahLst = false;

    if (m_ahLst)
    {
        delete m_ahLst;
        m_ahLst = NULL;
    }


    m_has_cxnLst = false;

    if (m_cxnLst)
    {
        delete m_cxnLst;
        m_cxnLst = NULL;
    }


    m_has_rect = false;

    if (m_rect)
    {
        delete m_rect;
        m_rect = NULL;
    }


    m_has_pathLst = false;

    if (m_pathLst)
    {
        delete m_pathLst;
        m_pathLst = NULL;
    }

}

void CT_CustomGeometry2D::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    assert(m_has_pathLst);


    if (m_has_avLst)
    {
        m_avLst->toXmlElem("a:avLst", "", _outStream);
    }


    if (m_has_gdLst)
    {
        m_gdLst->toXmlElem("a:gdLst", "", _outStream);
    }


    if (m_has_ahLst)
    {
        m_ahLst->toXmlElem("a:ahLst", "", _outStream);
    }


    if (m_has_cxnLst)
    {
        m_cxnLst->toXmlElem("a:cxnLst", "", _outStream);
    }


    if (m_has_rect)
    {
        m_rect->toXmlElem("a:rect", "", _outStream);
    }


    if (m_has_pathLst)
    {
        m_pathLst->toXmlElem("a:pathLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_CustomGeometry2D& CT_CustomGeometry2D::default_instance()
{
    if (!CT_CustomGeometry2D::default_instance_)
    {
        CT_CustomGeometry2D::default_instance_ = new CT_CustomGeometry2D();
    }
    return *CT_CustomGeometry2D::default_instance_;
}

CT_CustomGeometry2D* CT_CustomGeometry2D::default_instance_ = NULL;

// CT_LineEndProperties
CT_LineEndProperties::CT_LineEndProperties()
    :m_has_type_attr(false),
     m_type_attr(NULL),
     m_has_w_attr(false),
     m_w_attr(NULL),
     m_has_len_attr(false),
     m_len_attr(NULL)
{
}
CT_LineEndProperties::~CT_LineEndProperties()
{
    clear();
}
void CT_LineEndProperties::clear()
{
    m_has_type_attr = false;

    if (m_type_attr)
    {
        delete m_type_attr;
        m_type_attr = NULL;
    }


    m_has_w_attr = false;

    if (m_w_attr)
    {
        delete m_w_attr;
        m_w_attr = NULL;
    }


    m_has_len_attr = false;

    if (m_len_attr)
    {
        delete m_len_attr;
        m_len_attr = NULL;
    }

}

void CT_LineEndProperties::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_type_attr)
    {
        m_type_attr->toXmlAttr("type", _outStream);
    }



    if (m_has_w_attr)
    {
        m_w_attr->toXmlAttr("w", _outStream);
    }



    if (m_has_len_attr)
    {
        m_len_attr->toXmlAttr("len", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_LineEndProperties& CT_LineEndProperties::default_instance()
{
    if (!CT_LineEndProperties::default_instance_)
    {
        CT_LineEndProperties::default_instance_ = new CT_LineEndProperties();
    }
    return *CT_LineEndProperties::default_instance_;
}

bool CT_LineEndProperties::has_type_attr() const
{
    return m_has_type_attr;
}

void CT_LineEndProperties::set_type_attr(const ST_LineEndType& _type_attr)
{
    m_has_type_attr = true;
    m_type_attr = new ST_LineEndType(_type_attr);
}

const ST_LineEndType& CT_LineEndProperties::get_type_attr() const
{
    if (m_type_attr)
    {
        return *m_type_attr;
    }
    return ST_LineEndType::default_instance();
}

bool CT_LineEndProperties::has_w_attr() const
{
    return m_has_w_attr;
}

void CT_LineEndProperties::set_w_attr(const ST_LineEndWidth& _w_attr)
{
    m_has_w_attr = true;
    m_w_attr = new ST_LineEndWidth(_w_attr);
}

const ST_LineEndWidth& CT_LineEndProperties::get_w_attr() const
{
    if (m_w_attr)
    {
        return *m_w_attr;
    }
    return ST_LineEndWidth::default_instance();
}

bool CT_LineEndProperties::has_len_attr() const
{
    return m_has_len_attr;
}

void CT_LineEndProperties::set_len_attr(const ST_LineEndLength& _len_attr)
{
    m_has_len_attr = true;
    m_len_attr = new ST_LineEndLength(_len_attr);
}

const ST_LineEndLength& CT_LineEndProperties::get_len_attr() const
{
    if (m_len_attr)
    {
        return *m_len_attr;
    }
    return ST_LineEndLength::default_instance();
}

CT_LineEndProperties* CT_LineEndProperties::default_instance_ = NULL;

// CT_LineJoinBevel
CT_LineJoinBevel::CT_LineJoinBevel()

{
}
CT_LineJoinBevel::~CT_LineJoinBevel()
{
    clear();
}
void CT_LineJoinBevel::clear()
{    }

void CT_LineJoinBevel::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_LineJoinBevel& CT_LineJoinBevel::default_instance()
{
    if (!CT_LineJoinBevel::default_instance_)
    {
        CT_LineJoinBevel::default_instance_ = new CT_LineJoinBevel();
    }
    return *CT_LineJoinBevel::default_instance_;
}

CT_LineJoinBevel* CT_LineJoinBevel::default_instance_ = NULL;

// CT_LineJoinRound
CT_LineJoinRound::CT_LineJoinRound()

{
}
CT_LineJoinRound::~CT_LineJoinRound()
{
    clear();
}
void CT_LineJoinRound::clear()
{    }

void CT_LineJoinRound::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_LineJoinRound& CT_LineJoinRound::default_instance()
{
    if (!CT_LineJoinRound::default_instance_)
    {
        CT_LineJoinRound::default_instance_ = new CT_LineJoinRound();
    }
    return *CT_LineJoinRound::default_instance_;
}

CT_LineJoinRound* CT_LineJoinRound::default_instance_ = NULL;

// CT_LineJoinMiterProperties
CT_LineJoinMiterProperties::CT_LineJoinMiterProperties()
    :m_has_lim_attr(false),
     m_lim_attr(NULL)
{
}
CT_LineJoinMiterProperties::~CT_LineJoinMiterProperties()
{
    clear();
}
void CT_LineJoinMiterProperties::clear()
{
    m_has_lim_attr = false;

    if (m_lim_attr)
    {
        delete m_lim_attr;
        m_lim_attr = NULL;
    }

}

void CT_LineJoinMiterProperties::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_lim_attr)
    {
        m_lim_attr->toXmlAttr("lim", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_LineJoinMiterProperties& CT_LineJoinMiterProperties::default_instance()
{
    if (!CT_LineJoinMiterProperties::default_instance_)
    {
        CT_LineJoinMiterProperties::default_instance_ = new CT_LineJoinMiterProperties();
    }
    return *CT_LineJoinMiterProperties::default_instance_;
}

bool CT_LineJoinMiterProperties::has_lim_attr() const
{
    return m_has_lim_attr;
}

void CT_LineJoinMiterProperties::set_lim_attr(const ST_PositivePercentage& _lim_attr)
{
    m_has_lim_attr = true;
    m_lim_attr = new ST_PositivePercentage(_lim_attr);
}

const ST_PositivePercentage& CT_LineJoinMiterProperties::get_lim_attr() const
{
    if (m_lim_attr)
    {
        return *m_lim_attr;
    }
    return ST_PositivePercentage::default_instance();
}

CT_LineJoinMiterProperties* CT_LineJoinMiterProperties::default_instance_ = NULL;

// CT_PresetLineDashProperties
CT_PresetLineDashProperties::CT_PresetLineDashProperties()
    :m_has_val_attr(false),
     m_val_attr(NULL)
{
}
CT_PresetLineDashProperties::~CT_PresetLineDashProperties()
{
    clear();
}
void CT_PresetLineDashProperties::clear()
{
    m_has_val_attr = false;

    if (m_val_attr)
    {
        delete m_val_attr;
        m_val_attr = NULL;
    }

}

void CT_PresetLineDashProperties::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_val_attr)
    {
        m_val_attr->toXmlAttr("val", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_PresetLineDashProperties& CT_PresetLineDashProperties::default_instance()
{
    if (!CT_PresetLineDashProperties::default_instance_)
    {
        CT_PresetLineDashProperties::default_instance_ = new CT_PresetLineDashProperties();
    }
    return *CT_PresetLineDashProperties::default_instance_;
}

bool CT_PresetLineDashProperties::has_val_attr() const
{
    return m_has_val_attr;
}

void CT_PresetLineDashProperties::set_val_attr(const ST_PresetLineDashVal& _val_attr)
{
    m_has_val_attr = true;
    m_val_attr = new ST_PresetLineDashVal(_val_attr);
}

const ST_PresetLineDashVal& CT_PresetLineDashProperties::get_val_attr() const
{
    if (m_val_attr)
    {
        return *m_val_attr;
    }
    return ST_PresetLineDashVal::default_instance();
}

CT_PresetLineDashProperties* CT_PresetLineDashProperties::default_instance_ = NULL;

// CT_DashStop
CT_DashStop::CT_DashStop()
    :m_has_d_attr(false),
     m_d_attr(NULL),
     m_has_sp_attr(false),
     m_sp_attr(NULL)
{
}
CT_DashStop::~CT_DashStop()
{
    clear();
}
void CT_DashStop::clear()
{
    m_has_d_attr = false;

    if (m_d_attr)
    {
        delete m_d_attr;
        m_d_attr = NULL;
    }


    m_has_sp_attr = false;

    if (m_sp_attr)
    {
        delete m_sp_attr;
        m_sp_attr = NULL;
    }

}

void CT_DashStop::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_d_attr);
    if (m_has_d_attr)
    {
        m_d_attr->toXmlAttr("d", _outStream);
    }


    assert(m_has_sp_attr);
    if (m_has_sp_attr)
    {
        m_sp_attr->toXmlAttr("sp", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_DashStop& CT_DashStop::default_instance()
{
    if (!CT_DashStop::default_instance_)
    {
        CT_DashStop::default_instance_ = new CT_DashStop();
    }
    return *CT_DashStop::default_instance_;
}

bool CT_DashStop::has_d_attr() const
{
    return m_has_d_attr;
}

void CT_DashStop::set_d_attr(const ST_PositivePercentage& _d_attr)
{
    m_has_d_attr = true;
    m_d_attr = new ST_PositivePercentage(_d_attr);
}

const ST_PositivePercentage& CT_DashStop::get_d_attr() const
{
    if (m_d_attr)
    {
        return *m_d_attr;
    }
    return ST_PositivePercentage::default_instance();
}

bool CT_DashStop::has_sp_attr() const
{
    return m_has_sp_attr;
}

void CT_DashStop::set_sp_attr(const ST_PositivePercentage& _sp_attr)
{
    m_has_sp_attr = true;
    m_sp_attr = new ST_PositivePercentage(_sp_attr);
}

const ST_PositivePercentage& CT_DashStop::get_sp_attr() const
{
    if (m_sp_attr)
    {
        return *m_sp_attr;
    }
    return ST_PositivePercentage::default_instance();
}

CT_DashStop* CT_DashStop::default_instance_ = NULL;

// CT_DashStopList
CT_DashStopList::CT_DashStopList()

{
}
CT_DashStopList::~CT_DashStopList()
{
    clear();
}
CT_DashStop* CT_DashStopList::add_ds()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_DashStop* pNewChild = pChildGroup->mutable_ds();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

void CT_DashStopList::clear()
{
    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }
}

void CT_DashStopList::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_ds())
            {
                (*iter)->get_ds().toXmlElem("a:ds", "", _outStream);
            }


        }
    }

    _outStream << "</" << _elemName << ">";
}

const CT_DashStopList& CT_DashStopList::default_instance()
{
    if (!CT_DashStopList::default_instance_)
    {
        CT_DashStopList::default_instance_ = new CT_DashStopList();
    }
    return *CT_DashStopList::default_instance_;
}


// CT_DashStopList::ChildGroup_1
CT_DashStopList::ChildGroup_1::ChildGroup_1()
    :m_has_ds(false),
     m_ds(NULL)
{
}
bool CT_DashStopList::ChildGroup_1::has_ds() const
{
    return m_has_ds;
}

CT_DashStop* CT_DashStopList::ChildGroup_1::mutable_ds()
{

    m_has_ds = true;
    if (!m_ds)
    {
        m_ds = new CT_DashStop();
    }
    return m_ds;
}

const CT_DashStop& CT_DashStopList::ChildGroup_1::get_ds() const
{
    if (m_ds)
    {
        return *m_ds;
    }
    return CT_DashStop::default_instance();
}

CT_DashStopList* CT_DashStopList::default_instance_ = NULL;

// CT_LineProperties
CT_LineProperties::CT_LineProperties()
    :m_has_noFill(false),
     m_noFill(NULL),
     m_has_solidFill(false),
     m_solidFill(NULL),
     m_has_gradFill(false),
     m_gradFill(NULL),
     m_has_pattFill(false),
     m_pattFill(NULL),
     m_has_prstDash(false),
     m_prstDash(NULL),
     m_has_custDash(false),
     m_custDash(NULL),
     m_has_round(false),
     m_round(NULL),
     m_has_bevel(false),
     m_bevel(NULL),
     m_has_miter(false),
     m_miter(NULL),
     m_has_headEnd(false),
     m_headEnd(NULL),
     m_has_tailEnd(false),
     m_tailEnd(NULL),
     m_has_extLst(false),
     m_extLst(NULL),
     m_has_w_attr(false),
     m_w_attr(NULL),
     m_has_cap_attr(false),
     m_cap_attr(NULL),
     m_has_cmpd_attr(false),
     m_cmpd_attr(NULL),
     m_has_algn_attr(false),
     m_algn_attr(NULL)
{
}
CT_LineProperties::~CT_LineProperties()
{
    clear();
}
bool CT_LineProperties::has_noFill() const
{
    return m_has_noFill;
}

CT_NoFillProperties* CT_LineProperties::mutable_noFill()
{

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_noFill = true;
    if (!m_noFill)
    {
        m_noFill = new CT_NoFillProperties();
    }
    return m_noFill;
}

const CT_NoFillProperties& CT_LineProperties::get_noFill() const
{
    if (m_noFill)
    {
        return *m_noFill;
    }
    return CT_NoFillProperties::default_instance();
}

bool CT_LineProperties::has_solidFill() const
{
    return m_has_solidFill;
}

CT_SolidColorFillProperties* CT_LineProperties::mutable_solidFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_solidFill = true;
    if (!m_solidFill)
    {
        m_solidFill = new CT_SolidColorFillProperties();
    }
    return m_solidFill;
}

const CT_SolidColorFillProperties& CT_LineProperties::get_solidFill() const
{
    if (m_solidFill)
    {
        return *m_solidFill;
    }
    return CT_SolidColorFillProperties::default_instance();
}

bool CT_LineProperties::has_gradFill() const
{
    return m_has_gradFill;
}

CT_GradientFillProperties* CT_LineProperties::mutable_gradFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_gradFill = true;
    if (!m_gradFill)
    {
        m_gradFill = new CT_GradientFillProperties();
    }
    return m_gradFill;
}

const CT_GradientFillProperties& CT_LineProperties::get_gradFill() const
{
    if (m_gradFill)
    {
        return *m_gradFill;
    }
    return CT_GradientFillProperties::default_instance();
}

bool CT_LineProperties::has_pattFill() const
{
    return m_has_pattFill;
}

CT_PatternFillProperties* CT_LineProperties::mutable_pattFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_pattFill = true;
    if (!m_pattFill)
    {
        m_pattFill = new CT_PatternFillProperties();
    }
    return m_pattFill;
}

const CT_PatternFillProperties& CT_LineProperties::get_pattFill() const
{
    if (m_pattFill)
    {
        return *m_pattFill;
    }
    return CT_PatternFillProperties::default_instance();
}

bool CT_LineProperties::has_prstDash() const
{
    return m_has_prstDash;
}

CT_PresetLineDashProperties* CT_LineProperties::mutable_prstDash()
{

    m_has_custDash = false;

    if (m_custDash)
    {
        delete m_custDash;
        m_custDash = NULL;
    }
    ;

    m_has_prstDash = true;
    if (!m_prstDash)
    {
        m_prstDash = new CT_PresetLineDashProperties();
    }
    return m_prstDash;
}

const CT_PresetLineDashProperties& CT_LineProperties::get_prstDash() const
{
    if (m_prstDash)
    {
        return *m_prstDash;
    }
    return CT_PresetLineDashProperties::default_instance();
}

bool CT_LineProperties::has_custDash() const
{
    return m_has_custDash;
}

CT_DashStopList* CT_LineProperties::mutable_custDash()
{

    m_has_prstDash = false;

    if (m_prstDash)
    {
        delete m_prstDash;
        m_prstDash = NULL;
    }
    ;

    m_has_custDash = true;
    if (!m_custDash)
    {
        m_custDash = new CT_DashStopList();
    }
    return m_custDash;
}

const CT_DashStopList& CT_LineProperties::get_custDash() const
{
    if (m_custDash)
    {
        return *m_custDash;
    }
    return CT_DashStopList::default_instance();
}

bool CT_LineProperties::has_round() const
{
    return m_has_round;
}

CT_LineJoinRound* CT_LineProperties::mutable_round()
{

    m_has_bevel = false;

    if (m_bevel)
    {
        delete m_bevel;
        m_bevel = NULL;
    }
    ;

    m_has_miter = false;

    if (m_miter)
    {
        delete m_miter;
        m_miter = NULL;
    }
    ;

    m_has_round = true;
    if (!m_round)
    {
        m_round = new CT_LineJoinRound();
    }
    return m_round;
}

const CT_LineJoinRound& CT_LineProperties::get_round() const
{
    if (m_round)
    {
        return *m_round;
    }
    return CT_LineJoinRound::default_instance();
}

bool CT_LineProperties::has_bevel() const
{
    return m_has_bevel;
}

CT_LineJoinBevel* CT_LineProperties::mutable_bevel()
{

    m_has_round = false;

    if (m_round)
    {
        delete m_round;
        m_round = NULL;
    }
    ;

    m_has_miter = false;

    if (m_miter)
    {
        delete m_miter;
        m_miter = NULL;
    }
    ;

    m_has_bevel = true;
    if (!m_bevel)
    {
        m_bevel = new CT_LineJoinBevel();
    }
    return m_bevel;
}

const CT_LineJoinBevel& CT_LineProperties::get_bevel() const
{
    if (m_bevel)
    {
        return *m_bevel;
    }
    return CT_LineJoinBevel::default_instance();
}

bool CT_LineProperties::has_miter() const
{
    return m_has_miter;
}

CT_LineJoinMiterProperties* CT_LineProperties::mutable_miter()
{

    m_has_round = false;

    if (m_round)
    {
        delete m_round;
        m_round = NULL;
    }
    ;

    m_has_bevel = false;

    if (m_bevel)
    {
        delete m_bevel;
        m_bevel = NULL;
    }
    ;

    m_has_miter = true;
    if (!m_miter)
    {
        m_miter = new CT_LineJoinMiterProperties();
    }
    return m_miter;
}

const CT_LineJoinMiterProperties& CT_LineProperties::get_miter() const
{
    if (m_miter)
    {
        return *m_miter;
    }
    return CT_LineJoinMiterProperties::default_instance();
}

bool CT_LineProperties::has_headEnd() const
{
    return m_has_headEnd;
}

CT_LineEndProperties* CT_LineProperties::mutable_headEnd()
{
    m_has_headEnd = true;
    if (!m_headEnd)
    {
        m_headEnd = new CT_LineEndProperties();
    }
    return m_headEnd;
}

const CT_LineEndProperties& CT_LineProperties::get_headEnd() const
{
    if (m_headEnd)
    {
        return *m_headEnd;
    }
    return CT_LineEndProperties::default_instance();
}

bool CT_LineProperties::has_tailEnd() const
{
    return m_has_tailEnd;
}

CT_LineEndProperties* CT_LineProperties::mutable_tailEnd()
{
    m_has_tailEnd = true;
    if (!m_tailEnd)
    {
        m_tailEnd = new CT_LineEndProperties();
    }
    return m_tailEnd;
}

const CT_LineEndProperties& CT_LineProperties::get_tailEnd() const
{
    if (m_tailEnd)
    {
        return *m_tailEnd;
    }
    return CT_LineEndProperties::default_instance();
}

bool CT_LineProperties::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_LineProperties::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_LineProperties::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_LineProperties::clear()
{
    m_has_w_attr = false;

    if (m_w_attr)
    {
        delete m_w_attr;
        m_w_attr = NULL;
    }


    m_has_cap_attr = false;

    if (m_cap_attr)
    {
        delete m_cap_attr;
        m_cap_attr = NULL;
    }


    m_has_cmpd_attr = false;

    if (m_cmpd_attr)
    {
        delete m_cmpd_attr;
        m_cmpd_attr = NULL;
    }


    m_has_algn_attr = false;

    if (m_algn_attr)
    {
        delete m_algn_attr;
        m_algn_attr = NULL;
    }


    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }


    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }


    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }


    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }


    m_has_prstDash = false;

    if (m_prstDash)
    {
        delete m_prstDash;
        m_prstDash = NULL;
    }


    m_has_custDash = false;

    if (m_custDash)
    {
        delete m_custDash;
        m_custDash = NULL;
    }


    m_has_round = false;

    if (m_round)
    {
        delete m_round;
        m_round = NULL;
    }


    m_has_bevel = false;

    if (m_bevel)
    {
        delete m_bevel;
        m_bevel = NULL;
    }


    m_has_miter = false;

    if (m_miter)
    {
        delete m_miter;
        m_miter = NULL;
    }


    m_has_headEnd = false;

    if (m_headEnd)
    {
        delete m_headEnd;
        m_headEnd = NULL;
    }


    m_has_tailEnd = false;

    if (m_tailEnd)
    {
        delete m_tailEnd;
        m_tailEnd = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_LineProperties::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_w_attr)
    {
        m_w_attr->toXmlAttr("w", _outStream);
    }



    if (m_has_cap_attr)
    {
        m_cap_attr->toXmlAttr("cap", _outStream);
    }



    if (m_has_cmpd_attr)
    {
        m_cmpd_attr->toXmlAttr("cmpd", _outStream);
    }



    if (m_has_algn_attr)
    {
        m_algn_attr->toXmlAttr("algn", _outStream);
    }

    _outStream << ">";

    {
        bool elemHasValueList[4] = {m_has_noFill, m_has_solidFill, m_has_gradFill, m_has_pattFill};
        int cnt = count(elemHasValueList, elemHasValueList + 4, true);
        assert(cnt == 0 || cnt == 1);
    }


    if (m_has_noFill)
    {
        m_noFill->toXmlElem("a:noFill", "", _outStream);
    }


    if (m_has_solidFill)
    {
        m_solidFill->toXmlElem("a:solidFill", "", _outStream);
    }


    if (m_has_gradFill)
    {
        m_gradFill->toXmlElem("a:gradFill", "", _outStream);
    }


    if (m_has_pattFill)
    {
        m_pattFill->toXmlElem("a:pattFill", "", _outStream);
    }

    {
        bool elemHasValueList[2] = {m_has_prstDash, m_has_custDash};
        int cnt = count(elemHasValueList, elemHasValueList + 2, true);
        assert(cnt == 0 || cnt == 1);
    }


    if (m_has_prstDash)
    {
        m_prstDash->toXmlElem("a:prstDash", "", _outStream);
    }


    if (m_has_custDash)
    {
        m_custDash->toXmlElem("a:custDash", "", _outStream);
    }

    {
        bool elemHasValueList[3] = {m_has_round, m_has_bevel, m_has_miter};
        int cnt = count(elemHasValueList, elemHasValueList + 3, true);
        assert(cnt == 0 || cnt == 1);
    }


    if (m_has_round)
    {
        m_round->toXmlElem("a:round", "", _outStream);
    }


    if (m_has_bevel)
    {
        m_bevel->toXmlElem("a:bevel", "", _outStream);
    }


    if (m_has_miter)
    {
        m_miter->toXmlElem("a:miter", "", _outStream);
    }


    if (m_has_headEnd)
    {
        m_headEnd->toXmlElem("a:headEnd", "", _outStream);
    }


    if (m_has_tailEnd)
    {
        m_tailEnd->toXmlElem("a:tailEnd", "", _outStream);
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_LineProperties& CT_LineProperties::default_instance()
{
    if (!CT_LineProperties::default_instance_)
    {
        CT_LineProperties::default_instance_ = new CT_LineProperties();
    }
    return *CT_LineProperties::default_instance_;
}

bool CT_LineProperties::has_w_attr() const
{
    return m_has_w_attr;
}

void CT_LineProperties::set_w_attr(const ST_LineWidth& _w_attr)
{
    m_has_w_attr = true;
    m_w_attr = new ST_LineWidth(_w_attr);
}

const ST_LineWidth& CT_LineProperties::get_w_attr() const
{
    if (m_w_attr)
    {
        return *m_w_attr;
    }
    return ST_LineWidth::default_instance();
}

bool CT_LineProperties::has_cap_attr() const
{
    return m_has_cap_attr;
}

void CT_LineProperties::set_cap_attr(const ST_LineCap& _cap_attr)
{
    m_has_cap_attr = true;
    m_cap_attr = new ST_LineCap(_cap_attr);
}

const ST_LineCap& CT_LineProperties::get_cap_attr() const
{
    if (m_cap_attr)
    {
        return *m_cap_attr;
    }
    return ST_LineCap::default_instance();
}

bool CT_LineProperties::has_cmpd_attr() const
{
    return m_has_cmpd_attr;
}

void CT_LineProperties::set_cmpd_attr(const ST_CompoundLine& _cmpd_attr)
{
    m_has_cmpd_attr = true;
    m_cmpd_attr = new ST_CompoundLine(_cmpd_attr);
}

const ST_CompoundLine& CT_LineProperties::get_cmpd_attr() const
{
    if (m_cmpd_attr)
    {
        return *m_cmpd_attr;
    }
    return ST_CompoundLine::default_instance();
}

bool CT_LineProperties::has_algn_attr() const
{
    return m_has_algn_attr;
}

void CT_LineProperties::set_algn_attr(const ST_PenAlignment& _algn_attr)
{
    m_has_algn_attr = true;
    m_algn_attr = new ST_PenAlignment(_algn_attr);
}

const ST_PenAlignment& CT_LineProperties::get_algn_attr() const
{
    if (m_algn_attr)
    {
        return *m_algn_attr;
    }
    return ST_PenAlignment::default_instance();
}

CT_LineProperties* CT_LineProperties::default_instance_ = NULL;

// CT_ShapeProperties
CT_ShapeProperties::CT_ShapeProperties()
    :m_has_xfrm(false),
     m_xfrm(NULL),
     m_has_custGeom(false),
     m_custGeom(NULL),
     m_has_prstGeom(false),
     m_prstGeom(NULL),
     m_has_noFill(false),
     m_noFill(NULL),
     m_has_solidFill(false),
     m_solidFill(NULL),
     m_has_gradFill(false),
     m_gradFill(NULL),
     m_has_blipFill(false),
     m_blipFill(NULL),
     m_has_pattFill(false),
     m_pattFill(NULL),
     m_has_grpFill(false),
     m_grpFill(NULL),
     m_has_ln(false),
     m_ln(NULL),
     m_has_effectLst(false),
     m_effectLst(NULL),
     m_has_effectDag(false),
     m_effectDag(NULL),
     m_has_scene3d(false),
     m_scene3d(NULL),
     m_has_sp3d(false),
     m_sp3d(NULL),
     m_has_extLst(false),
     m_extLst(NULL),
     m_has_bwMode_attr(false),
     m_bwMode_attr(NULL)
{
}
CT_ShapeProperties::~CT_ShapeProperties()
{
    clear();
}
bool CT_ShapeProperties::has_xfrm() const
{
    return m_has_xfrm;
}

CT_Transform2D* CT_ShapeProperties::mutable_xfrm()
{
    m_has_xfrm = true;
    if (!m_xfrm)
    {
        m_xfrm = new CT_Transform2D();
    }
    return m_xfrm;
}

const CT_Transform2D& CT_ShapeProperties::get_xfrm() const
{
    if (m_xfrm)
    {
        return *m_xfrm;
    }
    return CT_Transform2D::default_instance();
}

bool CT_ShapeProperties::has_custGeom() const
{
    return m_has_custGeom;
}

CT_CustomGeometry2D* CT_ShapeProperties::mutable_custGeom()
{

    m_has_prstGeom = false;

    if (m_prstGeom)
    {
        delete m_prstGeom;
        m_prstGeom = NULL;
    }
    ;

    m_has_custGeom = true;
    if (!m_custGeom)
    {
        m_custGeom = new CT_CustomGeometry2D();
    }
    return m_custGeom;
}

const CT_CustomGeometry2D& CT_ShapeProperties::get_custGeom() const
{
    if (m_custGeom)
    {
        return *m_custGeom;
    }
    return CT_CustomGeometry2D::default_instance();
}

bool CT_ShapeProperties::has_prstGeom() const
{
    return m_has_prstGeom;
}

CT_PresetGeometry2D* CT_ShapeProperties::mutable_prstGeom()
{

    m_has_custGeom = false;

    if (m_custGeom)
    {
        delete m_custGeom;
        m_custGeom = NULL;
    }
    ;

    m_has_prstGeom = true;
    if (!m_prstGeom)
    {
        m_prstGeom = new CT_PresetGeometry2D();
    }
    return m_prstGeom;
}

const CT_PresetGeometry2D& CT_ShapeProperties::get_prstGeom() const
{
    if (m_prstGeom)
    {
        return *m_prstGeom;
    }
    return CT_PresetGeometry2D::default_instance();
}

bool CT_ShapeProperties::has_noFill() const
{
    return m_has_noFill;
}

CT_NoFillProperties* CT_ShapeProperties::mutable_noFill()
{

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_noFill = true;
    if (!m_noFill)
    {
        m_noFill = new CT_NoFillProperties();
    }
    return m_noFill;
}

const CT_NoFillProperties& CT_ShapeProperties::get_noFill() const
{
    if (m_noFill)
    {
        return *m_noFill;
    }
    return CT_NoFillProperties::default_instance();
}

bool CT_ShapeProperties::has_solidFill() const
{
    return m_has_solidFill;
}

CT_SolidColorFillProperties* CT_ShapeProperties::mutable_solidFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_solidFill = true;
    if (!m_solidFill)
    {
        m_solidFill = new CT_SolidColorFillProperties();
    }
    return m_solidFill;
}

const CT_SolidColorFillProperties& CT_ShapeProperties::get_solidFill() const
{
    if (m_solidFill)
    {
        return *m_solidFill;
    }
    return CT_SolidColorFillProperties::default_instance();
}

bool CT_ShapeProperties::has_gradFill() const
{
    return m_has_gradFill;
}

CT_GradientFillProperties* CT_ShapeProperties::mutable_gradFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_gradFill = true;
    if (!m_gradFill)
    {
        m_gradFill = new CT_GradientFillProperties();
    }
    return m_gradFill;
}

const CT_GradientFillProperties& CT_ShapeProperties::get_gradFill() const
{
    if (m_gradFill)
    {
        return *m_gradFill;
    }
    return CT_GradientFillProperties::default_instance();
}

bool CT_ShapeProperties::has_blipFill() const
{
    return m_has_blipFill;
}

CT_BlipFillProperties* CT_ShapeProperties::mutable_blipFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_blipFill = true;
    if (!m_blipFill)
    {
        m_blipFill = new CT_BlipFillProperties();
    }
    return m_blipFill;
}

const CT_BlipFillProperties& CT_ShapeProperties::get_blipFill() const
{
    if (m_blipFill)
    {
        return *m_blipFill;
    }
    return CT_BlipFillProperties::default_instance();
}

bool CT_ShapeProperties::has_pattFill() const
{
    return m_has_pattFill;
}

CT_PatternFillProperties* CT_ShapeProperties::mutable_pattFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_pattFill = true;
    if (!m_pattFill)
    {
        m_pattFill = new CT_PatternFillProperties();
    }
    return m_pattFill;
}

const CT_PatternFillProperties& CT_ShapeProperties::get_pattFill() const
{
    if (m_pattFill)
    {
        return *m_pattFill;
    }
    return CT_PatternFillProperties::default_instance();
}

bool CT_ShapeProperties::has_grpFill() const
{
    return m_has_grpFill;
}

CT_GroupFillProperties* CT_ShapeProperties::mutable_grpFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = true;
    if (!m_grpFill)
    {
        m_grpFill = new CT_GroupFillProperties();
    }
    return m_grpFill;
}

const CT_GroupFillProperties& CT_ShapeProperties::get_grpFill() const
{
    if (m_grpFill)
    {
        return *m_grpFill;
    }
    return CT_GroupFillProperties::default_instance();
}

bool CT_ShapeProperties::has_ln() const
{
    return m_has_ln;
}

CT_LineProperties* CT_ShapeProperties::mutable_ln()
{
    m_has_ln = true;
    if (!m_ln)
    {
        m_ln = new CT_LineProperties();
    }
    return m_ln;
}

const CT_LineProperties& CT_ShapeProperties::get_ln() const
{
    if (m_ln)
    {
        return *m_ln;
    }
    return CT_LineProperties::default_instance();
}

bool CT_ShapeProperties::has_effectLst() const
{
    return m_has_effectLst;
}

CT_EffectList* CT_ShapeProperties::mutable_effectLst()
{

    m_has_effectDag = false;

    if (m_effectDag)
    {
        delete m_effectDag;
        m_effectDag = NULL;
    }
    ;

    m_has_effectLst = true;
    if (!m_effectLst)
    {
        m_effectLst = new CT_EffectList();
    }
    return m_effectLst;
}

const CT_EffectList& CT_ShapeProperties::get_effectLst() const
{
    if (m_effectLst)
    {
        return *m_effectLst;
    }
    return CT_EffectList::default_instance();
}

bool CT_ShapeProperties::has_effectDag() const
{
    return m_has_effectDag;
}

CT_EffectContainer* CT_ShapeProperties::mutable_effectDag()
{

    m_has_effectLst = false;

    if (m_effectLst)
    {
        delete m_effectLst;
        m_effectLst = NULL;
    }
    ;

    m_has_effectDag = true;
    if (!m_effectDag)
    {
        m_effectDag = new CT_EffectContainer();
    }
    return m_effectDag;
}

const CT_EffectContainer& CT_ShapeProperties::get_effectDag() const
{
    if (m_effectDag)
    {
        return *m_effectDag;
    }
    return CT_EffectContainer::default_instance();
}

bool CT_ShapeProperties::has_scene3d() const
{
    return m_has_scene3d;
}

CT_Scene3D* CT_ShapeProperties::mutable_scene3d()
{
    m_has_scene3d = true;
    if (!m_scene3d)
    {
        m_scene3d = new CT_Scene3D();
    }
    return m_scene3d;
}

const CT_Scene3D& CT_ShapeProperties::get_scene3d() const
{
    if (m_scene3d)
    {
        return *m_scene3d;
    }
    return CT_Scene3D::default_instance();
}

bool CT_ShapeProperties::has_sp3d() const
{
    return m_has_sp3d;
}

CT_Shape3D* CT_ShapeProperties::mutable_sp3d()
{
    m_has_sp3d = true;
    if (!m_sp3d)
    {
        m_sp3d = new CT_Shape3D();
    }
    return m_sp3d;
}

const CT_Shape3D& CT_ShapeProperties::get_sp3d() const
{
    if (m_sp3d)
    {
        return *m_sp3d;
    }
    return CT_Shape3D::default_instance();
}

bool CT_ShapeProperties::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_ShapeProperties::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_ShapeProperties::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_ShapeProperties::clear()
{
    m_has_bwMode_attr = false;

    if (m_bwMode_attr)
    {
        delete m_bwMode_attr;
        m_bwMode_attr = NULL;
    }


    m_has_xfrm = false;

    if (m_xfrm)
    {
        delete m_xfrm;
        m_xfrm = NULL;
    }


    m_has_custGeom = false;

    if (m_custGeom)
    {
        delete m_custGeom;
        m_custGeom = NULL;
    }


    m_has_prstGeom = false;

    if (m_prstGeom)
    {
        delete m_prstGeom;
        m_prstGeom = NULL;
    }


    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }


    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }


    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }


    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }


    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }


    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }


    m_has_ln = false;

    if (m_ln)
    {
        delete m_ln;
        m_ln = NULL;
    }


    m_has_effectLst = false;

    if (m_effectLst)
    {
        delete m_effectLst;
        m_effectLst = NULL;
    }


    m_has_effectDag = false;

    if (m_effectDag)
    {
        delete m_effectDag;
        m_effectDag = NULL;
    }


    m_has_scene3d = false;

    if (m_scene3d)
    {
        delete m_scene3d;
        m_scene3d = NULL;
    }


    m_has_sp3d = false;

    if (m_sp3d)
    {
        delete m_sp3d;
        m_sp3d = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_ShapeProperties::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_bwMode_attr)
    {
        m_bwMode_attr->toXmlAttr("bwMode", _outStream);
    }

    _outStream << ">";


    if (m_has_xfrm)
    {
        m_xfrm->toXmlElem("a:xfrm", "", _outStream);
    }

    {
        bool elemHasValueList[2] = {m_has_custGeom, m_has_prstGeom};
        int cnt = count(elemHasValueList, elemHasValueList + 2, true);
        assert(cnt == 0 || cnt == 1);
    }


    if (m_has_custGeom)
    {
        m_custGeom->toXmlElem("a:custGeom", "", _outStream);
    }


    if (m_has_prstGeom)
    {
        m_prstGeom->toXmlElem("a:prstGeom", "", _outStream);
    }

    {
        bool elemHasValueList[6] = {m_has_noFill, m_has_solidFill, m_has_gradFill, m_has_blipFill, m_has_pattFill, m_has_grpFill};
        int cnt = count(elemHasValueList, elemHasValueList + 6, true);
        assert(cnt == 0 || cnt == 1);
    }


    if (m_has_noFill)
    {
        m_noFill->toXmlElem("a:noFill", "", _outStream);
    }


    if (m_has_solidFill)
    {
        m_solidFill->toXmlElem("a:solidFill", "", _outStream);
    }


    if (m_has_gradFill)
    {
        m_gradFill->toXmlElem("a:gradFill", "", _outStream);
    }


    if (m_has_blipFill)
    {
        m_blipFill->toXmlElem("a:blipFill", "", _outStream);
    }


    if (m_has_pattFill)
    {
        m_pattFill->toXmlElem("a:pattFill", "", _outStream);
    }


    if (m_has_grpFill)
    {
        m_grpFill->toXmlElem("a:grpFill", "", _outStream);
    }


    if (m_has_ln)
    {
        m_ln->toXmlElem("a:ln", "", _outStream);
    }

    {
        bool elemHasValueList[2] = {m_has_effectLst, m_has_effectDag};
        int cnt = count(elemHasValueList, elemHasValueList + 2, true);
        assert(cnt == 0 || cnt == 1);
    }


    if (m_has_effectLst)
    {
        m_effectLst->toXmlElem("a:effectLst", "", _outStream);
    }


    if (m_has_effectDag)
    {
        m_effectDag->toXmlElem("a:effectDag", "", _outStream);
    }


    if (m_has_scene3d)
    {
        m_scene3d->toXmlElem("a:scene3d", "", _outStream);
    }


    if (m_has_sp3d)
    {
        m_sp3d->toXmlElem("a:sp3d", "", _outStream);
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_ShapeProperties& CT_ShapeProperties::default_instance()
{
    if (!CT_ShapeProperties::default_instance_)
    {
        CT_ShapeProperties::default_instance_ = new CT_ShapeProperties();
    }
    return *CT_ShapeProperties::default_instance_;
}

bool CT_ShapeProperties::has_bwMode_attr() const
{
    return m_has_bwMode_attr;
}

void CT_ShapeProperties::set_bwMode_attr(const ST_BlackWhiteMode& _bwMode_attr)
{
    m_has_bwMode_attr = true;
    m_bwMode_attr = new ST_BlackWhiteMode(_bwMode_attr);
}

const ST_BlackWhiteMode& CT_ShapeProperties::get_bwMode_attr() const
{
    if (m_bwMode_attr)
    {
        return *m_bwMode_attr;
    }
    return ST_BlackWhiteMode::default_instance();
}

CT_ShapeProperties* CT_ShapeProperties::default_instance_ = NULL;

// CT_GroupShapeProperties
CT_GroupShapeProperties::CT_GroupShapeProperties()
    :m_has_xfrm(false),
     m_xfrm(NULL),
     m_has_noFill(false),
     m_noFill(NULL),
     m_has_solidFill(false),
     m_solidFill(NULL),
     m_has_gradFill(false),
     m_gradFill(NULL),
     m_has_blipFill(false),
     m_blipFill(NULL),
     m_has_pattFill(false),
     m_pattFill(NULL),
     m_has_grpFill(false),
     m_grpFill(NULL),
     m_has_effectLst(false),
     m_effectLst(NULL),
     m_has_effectDag(false),
     m_effectDag(NULL),
     m_has_scene3d(false),
     m_scene3d(NULL),
     m_has_extLst(false),
     m_extLst(NULL),
     m_has_bwMode_attr(false),
     m_bwMode_attr(NULL)
{
}
CT_GroupShapeProperties::~CT_GroupShapeProperties()
{
    clear();
}
bool CT_GroupShapeProperties::has_xfrm() const
{
    return m_has_xfrm;
}

CT_GroupTransform2D* CT_GroupShapeProperties::mutable_xfrm()
{
    m_has_xfrm = true;
    if (!m_xfrm)
    {
        m_xfrm = new CT_GroupTransform2D();
    }
    return m_xfrm;
}

const CT_GroupTransform2D& CT_GroupShapeProperties::get_xfrm() const
{
    if (m_xfrm)
    {
        return *m_xfrm;
    }
    return CT_GroupTransform2D::default_instance();
}

bool CT_GroupShapeProperties::has_noFill() const
{
    return m_has_noFill;
}

CT_NoFillProperties* CT_GroupShapeProperties::mutable_noFill()
{

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_noFill = true;
    if (!m_noFill)
    {
        m_noFill = new CT_NoFillProperties();
    }
    return m_noFill;
}

const CT_NoFillProperties& CT_GroupShapeProperties::get_noFill() const
{
    if (m_noFill)
    {
        return *m_noFill;
    }
    return CT_NoFillProperties::default_instance();
}

bool CT_GroupShapeProperties::has_solidFill() const
{
    return m_has_solidFill;
}

CT_SolidColorFillProperties* CT_GroupShapeProperties::mutable_solidFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_solidFill = true;
    if (!m_solidFill)
    {
        m_solidFill = new CT_SolidColorFillProperties();
    }
    return m_solidFill;
}

const CT_SolidColorFillProperties& CT_GroupShapeProperties::get_solidFill() const
{
    if (m_solidFill)
    {
        return *m_solidFill;
    }
    return CT_SolidColorFillProperties::default_instance();
}

bool CT_GroupShapeProperties::has_gradFill() const
{
    return m_has_gradFill;
}

CT_GradientFillProperties* CT_GroupShapeProperties::mutable_gradFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_gradFill = true;
    if (!m_gradFill)
    {
        m_gradFill = new CT_GradientFillProperties();
    }
    return m_gradFill;
}

const CT_GradientFillProperties& CT_GroupShapeProperties::get_gradFill() const
{
    if (m_gradFill)
    {
        return *m_gradFill;
    }
    return CT_GradientFillProperties::default_instance();
}

bool CT_GroupShapeProperties::has_blipFill() const
{
    return m_has_blipFill;
}

CT_BlipFillProperties* CT_GroupShapeProperties::mutable_blipFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_blipFill = true;
    if (!m_blipFill)
    {
        m_blipFill = new CT_BlipFillProperties();
    }
    return m_blipFill;
}

const CT_BlipFillProperties& CT_GroupShapeProperties::get_blipFill() const
{
    if (m_blipFill)
    {
        return *m_blipFill;
    }
    return CT_BlipFillProperties::default_instance();
}

bool CT_GroupShapeProperties::has_pattFill() const
{
    return m_has_pattFill;
}

CT_PatternFillProperties* CT_GroupShapeProperties::mutable_pattFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_pattFill = true;
    if (!m_pattFill)
    {
        m_pattFill = new CT_PatternFillProperties();
    }
    return m_pattFill;
}

const CT_PatternFillProperties& CT_GroupShapeProperties::get_pattFill() const
{
    if (m_pattFill)
    {
        return *m_pattFill;
    }
    return CT_PatternFillProperties::default_instance();
}

bool CT_GroupShapeProperties::has_grpFill() const
{
    return m_has_grpFill;
}

CT_GroupFillProperties* CT_GroupShapeProperties::mutable_grpFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = true;
    if (!m_grpFill)
    {
        m_grpFill = new CT_GroupFillProperties();
    }
    return m_grpFill;
}

const CT_GroupFillProperties& CT_GroupShapeProperties::get_grpFill() const
{
    if (m_grpFill)
    {
        return *m_grpFill;
    }
    return CT_GroupFillProperties::default_instance();
}

bool CT_GroupShapeProperties::has_effectLst() const
{
    return m_has_effectLst;
}

CT_EffectList* CT_GroupShapeProperties::mutable_effectLst()
{

    m_has_effectDag = false;

    if (m_effectDag)
    {
        delete m_effectDag;
        m_effectDag = NULL;
    }
    ;

    m_has_effectLst = true;
    if (!m_effectLst)
    {
        m_effectLst = new CT_EffectList();
    }
    return m_effectLst;
}

const CT_EffectList& CT_GroupShapeProperties::get_effectLst() const
{
    if (m_effectLst)
    {
        return *m_effectLst;
    }
    return CT_EffectList::default_instance();
}

bool CT_GroupShapeProperties::has_effectDag() const
{
    return m_has_effectDag;
}

CT_EffectContainer* CT_GroupShapeProperties::mutable_effectDag()
{

    m_has_effectLst = false;

    if (m_effectLst)
    {
        delete m_effectLst;
        m_effectLst = NULL;
    }
    ;

    m_has_effectDag = true;
    if (!m_effectDag)
    {
        m_effectDag = new CT_EffectContainer();
    }
    return m_effectDag;
}

const CT_EffectContainer& CT_GroupShapeProperties::get_effectDag() const
{
    if (m_effectDag)
    {
        return *m_effectDag;
    }
    return CT_EffectContainer::default_instance();
}

bool CT_GroupShapeProperties::has_scene3d() const
{
    return m_has_scene3d;
}

CT_Scene3D* CT_GroupShapeProperties::mutable_scene3d()
{
    m_has_scene3d = true;
    if (!m_scene3d)
    {
        m_scene3d = new CT_Scene3D();
    }
    return m_scene3d;
}

const CT_Scene3D& CT_GroupShapeProperties::get_scene3d() const
{
    if (m_scene3d)
    {
        return *m_scene3d;
    }
    return CT_Scene3D::default_instance();
}

bool CT_GroupShapeProperties::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_GroupShapeProperties::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_GroupShapeProperties::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_GroupShapeProperties::clear()
{
    m_has_bwMode_attr = false;

    if (m_bwMode_attr)
    {
        delete m_bwMode_attr;
        m_bwMode_attr = NULL;
    }


    m_has_xfrm = false;

    if (m_xfrm)
    {
        delete m_xfrm;
        m_xfrm = NULL;
    }


    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }


    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }


    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }


    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }


    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }


    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }


    m_has_effectLst = false;

    if (m_effectLst)
    {
        delete m_effectLst;
        m_effectLst = NULL;
    }


    m_has_effectDag = false;

    if (m_effectDag)
    {
        delete m_effectDag;
        m_effectDag = NULL;
    }


    m_has_scene3d = false;

    if (m_scene3d)
    {
        delete m_scene3d;
        m_scene3d = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_GroupShapeProperties::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_bwMode_attr)
    {
        m_bwMode_attr->toXmlAttr("bwMode", _outStream);
    }

    _outStream << ">";


    if (m_has_xfrm)
    {
        m_xfrm->toXmlElem("a:xfrm", "", _outStream);
    }

    {
        bool elemHasValueList[6] = {m_has_noFill, m_has_solidFill, m_has_gradFill, m_has_blipFill, m_has_pattFill, m_has_grpFill};
        int cnt = count(elemHasValueList, elemHasValueList + 6, true);
        assert(cnt == 0 || cnt == 1);
    }


    if (m_has_noFill)
    {
        m_noFill->toXmlElem("a:noFill", "", _outStream);
    }


    if (m_has_solidFill)
    {
        m_solidFill->toXmlElem("a:solidFill", "", _outStream);
    }


    if (m_has_gradFill)
    {
        m_gradFill->toXmlElem("a:gradFill", "", _outStream);
    }


    if (m_has_blipFill)
    {
        m_blipFill->toXmlElem("a:blipFill", "", _outStream);
    }


    if (m_has_pattFill)
    {
        m_pattFill->toXmlElem("a:pattFill", "", _outStream);
    }


    if (m_has_grpFill)
    {
        m_grpFill->toXmlElem("a:grpFill", "", _outStream);
    }

    {
        bool elemHasValueList[2] = {m_has_effectLst, m_has_effectDag};
        int cnt = count(elemHasValueList, elemHasValueList + 2, true);
        assert(cnt == 0 || cnt == 1);
    }


    if (m_has_effectLst)
    {
        m_effectLst->toXmlElem("a:effectLst", "", _outStream);
    }


    if (m_has_effectDag)
    {
        m_effectDag->toXmlElem("a:effectDag", "", _outStream);
    }


    if (m_has_scene3d)
    {
        m_scene3d->toXmlElem("a:scene3d", "", _outStream);
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_GroupShapeProperties& CT_GroupShapeProperties::default_instance()
{
    if (!CT_GroupShapeProperties::default_instance_)
    {
        CT_GroupShapeProperties::default_instance_ = new CT_GroupShapeProperties();
    }
    return *CT_GroupShapeProperties::default_instance_;
}

bool CT_GroupShapeProperties::has_bwMode_attr() const
{
    return m_has_bwMode_attr;
}

void CT_GroupShapeProperties::set_bwMode_attr(const ST_BlackWhiteMode& _bwMode_attr)
{
    m_has_bwMode_attr = true;
    m_bwMode_attr = new ST_BlackWhiteMode(_bwMode_attr);
}

const ST_BlackWhiteMode& CT_GroupShapeProperties::get_bwMode_attr() const
{
    if (m_bwMode_attr)
    {
        return *m_bwMode_attr;
    }
    return ST_BlackWhiteMode::default_instance();
}

CT_GroupShapeProperties* CT_GroupShapeProperties::default_instance_ = NULL;

// CT_StyleMatrixReference
CT_StyleMatrixReference::CT_StyleMatrixReference()
    :m_has_scrgbClr(false),
     m_scrgbClr(NULL),
     m_has_srgbClr(false),
     m_srgbClr(NULL),
     m_has_hslClr(false),
     m_hslClr(NULL),
     m_has_sysClr(false),
     m_sysClr(NULL),
     m_has_schemeClr(false),
     m_schemeClr(NULL),
     m_has_prstClr(false),
     m_prstClr(NULL),
     m_has_idx_attr(false),
     m_idx_attr(NULL)
{
}
CT_StyleMatrixReference::~CT_StyleMatrixReference()
{
    clear();
}
bool CT_StyleMatrixReference::has_scrgbClr() const
{
    return m_has_scrgbClr;
}

CT_ScRgbColor* CT_StyleMatrixReference::mutable_scrgbClr()
{

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_scrgbClr = true;
    if (!m_scrgbClr)
    {
        m_scrgbClr = new CT_ScRgbColor();
    }
    return m_scrgbClr;
}

const CT_ScRgbColor& CT_StyleMatrixReference::get_scrgbClr() const
{
    if (m_scrgbClr)
    {
        return *m_scrgbClr;
    }
    return CT_ScRgbColor::default_instance();
}

bool CT_StyleMatrixReference::has_srgbClr() const
{
    return m_has_srgbClr;
}

CT_SRgbColor* CT_StyleMatrixReference::mutable_srgbClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_srgbClr = true;
    if (!m_srgbClr)
    {
        m_srgbClr = new CT_SRgbColor();
    }
    return m_srgbClr;
}

const CT_SRgbColor& CT_StyleMatrixReference::get_srgbClr() const
{
    if (m_srgbClr)
    {
        return *m_srgbClr;
    }
    return CT_SRgbColor::default_instance();
}

bool CT_StyleMatrixReference::has_hslClr() const
{
    return m_has_hslClr;
}

CT_HslColor* CT_StyleMatrixReference::mutable_hslClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_hslClr = true;
    if (!m_hslClr)
    {
        m_hslClr = new CT_HslColor();
    }
    return m_hslClr;
}

const CT_HslColor& CT_StyleMatrixReference::get_hslClr() const
{
    if (m_hslClr)
    {
        return *m_hslClr;
    }
    return CT_HslColor::default_instance();
}

bool CT_StyleMatrixReference::has_sysClr() const
{
    return m_has_sysClr;
}

CT_SystemColor* CT_StyleMatrixReference::mutable_sysClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_sysClr = true;
    if (!m_sysClr)
    {
        m_sysClr = new CT_SystemColor();
    }
    return m_sysClr;
}

const CT_SystemColor& CT_StyleMatrixReference::get_sysClr() const
{
    if (m_sysClr)
    {
        return *m_sysClr;
    }
    return CT_SystemColor::default_instance();
}

bool CT_StyleMatrixReference::has_schemeClr() const
{
    return m_has_schemeClr;
}

CT_SchemeColor* CT_StyleMatrixReference::mutable_schemeClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_schemeClr = true;
    if (!m_schemeClr)
    {
        m_schemeClr = new CT_SchemeColor();
    }
    return m_schemeClr;
}

const CT_SchemeColor& CT_StyleMatrixReference::get_schemeClr() const
{
    if (m_schemeClr)
    {
        return *m_schemeClr;
    }
    return CT_SchemeColor::default_instance();
}

bool CT_StyleMatrixReference::has_prstClr() const
{
    return m_has_prstClr;
}

CT_PresetColor* CT_StyleMatrixReference::mutable_prstClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = true;
    if (!m_prstClr)
    {
        m_prstClr = new CT_PresetColor();
    }
    return m_prstClr;
}

const CT_PresetColor& CT_StyleMatrixReference::get_prstClr() const
{
    if (m_prstClr)
    {
        return *m_prstClr;
    }
    return CT_PresetColor::default_instance();
}

void CT_StyleMatrixReference::clear()
{
    m_has_idx_attr = false;

    if (m_idx_attr)
    {
        delete m_idx_attr;
        m_idx_attr = NULL;
    }


    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }


    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }


    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }


    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }


    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }


    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }

}

void CT_StyleMatrixReference::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_idx_attr);
    if (m_has_idx_attr)
    {
        m_idx_attr->toXmlAttr("idx", _outStream);
    }

    _outStream << ">";

    {
        bool elemHasValueList[6] = {m_has_scrgbClr, m_has_srgbClr, m_has_hslClr, m_has_sysClr, m_has_schemeClr, m_has_prstClr};
        int cnt = count(elemHasValueList, elemHasValueList + 6, true);
        assert(cnt == 0 || cnt == 1);
    }


    if (m_has_scrgbClr)
    {
        m_scrgbClr->toXmlElem("a:scrgbClr", "", _outStream);
    }


    if (m_has_srgbClr)
    {
        m_srgbClr->toXmlElem("a:srgbClr", "", _outStream);
    }


    if (m_has_hslClr)
    {
        m_hslClr->toXmlElem("a:hslClr", "", _outStream);
    }


    if (m_has_sysClr)
    {
        m_sysClr->toXmlElem("a:sysClr", "", _outStream);
    }


    if (m_has_schemeClr)
    {
        m_schemeClr->toXmlElem("a:schemeClr", "", _outStream);
    }


    if (m_has_prstClr)
    {
        m_prstClr->toXmlElem("a:prstClr", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_StyleMatrixReference& CT_StyleMatrixReference::default_instance()
{
    if (!CT_StyleMatrixReference::default_instance_)
    {
        CT_StyleMatrixReference::default_instance_ = new CT_StyleMatrixReference();
    }
    return *CT_StyleMatrixReference::default_instance_;
}

bool CT_StyleMatrixReference::has_idx_attr() const
{
    return m_has_idx_attr;
}

void CT_StyleMatrixReference::set_idx_attr(const ST_StyleMatrixColumnIndex& _idx_attr)
{
    m_has_idx_attr = true;
    m_idx_attr = new ST_StyleMatrixColumnIndex(_idx_attr);
}

const ST_StyleMatrixColumnIndex& CT_StyleMatrixReference::get_idx_attr() const
{
    if (m_idx_attr)
    {
        return *m_idx_attr;
    }
    return ST_StyleMatrixColumnIndex::default_instance();
}

CT_StyleMatrixReference* CT_StyleMatrixReference::default_instance_ = NULL;

// CT_FontReference
CT_FontReference::CT_FontReference()
    :m_has_scrgbClr(false),
     m_scrgbClr(NULL),
     m_has_srgbClr(false),
     m_srgbClr(NULL),
     m_has_hslClr(false),
     m_hslClr(NULL),
     m_has_sysClr(false),
     m_sysClr(NULL),
     m_has_schemeClr(false),
     m_schemeClr(NULL),
     m_has_prstClr(false),
     m_prstClr(NULL),
     m_has_idx_attr(false),
     m_idx_attr(NULL)
{
}
CT_FontReference::~CT_FontReference()
{
    clear();
}
bool CT_FontReference::has_scrgbClr() const
{
    return m_has_scrgbClr;
}

CT_ScRgbColor* CT_FontReference::mutable_scrgbClr()
{

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_scrgbClr = true;
    if (!m_scrgbClr)
    {
        m_scrgbClr = new CT_ScRgbColor();
    }
    return m_scrgbClr;
}

const CT_ScRgbColor& CT_FontReference::get_scrgbClr() const
{
    if (m_scrgbClr)
    {
        return *m_scrgbClr;
    }
    return CT_ScRgbColor::default_instance();
}

bool CT_FontReference::has_srgbClr() const
{
    return m_has_srgbClr;
}

CT_SRgbColor* CT_FontReference::mutable_srgbClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_srgbClr = true;
    if (!m_srgbClr)
    {
        m_srgbClr = new CT_SRgbColor();
    }
    return m_srgbClr;
}

const CT_SRgbColor& CT_FontReference::get_srgbClr() const
{
    if (m_srgbClr)
    {
        return *m_srgbClr;
    }
    return CT_SRgbColor::default_instance();
}

bool CT_FontReference::has_hslClr() const
{
    return m_has_hslClr;
}

CT_HslColor* CT_FontReference::mutable_hslClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_hslClr = true;
    if (!m_hslClr)
    {
        m_hslClr = new CT_HslColor();
    }
    return m_hslClr;
}

const CT_HslColor& CT_FontReference::get_hslClr() const
{
    if (m_hslClr)
    {
        return *m_hslClr;
    }
    return CT_HslColor::default_instance();
}

bool CT_FontReference::has_sysClr() const
{
    return m_has_sysClr;
}

CT_SystemColor* CT_FontReference::mutable_sysClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_sysClr = true;
    if (!m_sysClr)
    {
        m_sysClr = new CT_SystemColor();
    }
    return m_sysClr;
}

const CT_SystemColor& CT_FontReference::get_sysClr() const
{
    if (m_sysClr)
    {
        return *m_sysClr;
    }
    return CT_SystemColor::default_instance();
}

bool CT_FontReference::has_schemeClr() const
{
    return m_has_schemeClr;
}

CT_SchemeColor* CT_FontReference::mutable_schemeClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_schemeClr = true;
    if (!m_schemeClr)
    {
        m_schemeClr = new CT_SchemeColor();
    }
    return m_schemeClr;
}

const CT_SchemeColor& CT_FontReference::get_schemeClr() const
{
    if (m_schemeClr)
    {
        return *m_schemeClr;
    }
    return CT_SchemeColor::default_instance();
}

bool CT_FontReference::has_prstClr() const
{
    return m_has_prstClr;
}

CT_PresetColor* CT_FontReference::mutable_prstClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = true;
    if (!m_prstClr)
    {
        m_prstClr = new CT_PresetColor();
    }
    return m_prstClr;
}

const CT_PresetColor& CT_FontReference::get_prstClr() const
{
    if (m_prstClr)
    {
        return *m_prstClr;
    }
    return CT_PresetColor::default_instance();
}

void CT_FontReference::clear()
{
    m_has_idx_attr = false;

    if (m_idx_attr)
    {
        delete m_idx_attr;
        m_idx_attr = NULL;
    }


    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }


    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }


    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }


    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }


    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }


    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }

}

void CT_FontReference::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_idx_attr);
    if (m_has_idx_attr)
    {
        m_idx_attr->toXmlAttr("idx", _outStream);
    }

    _outStream << ">";

    {
        bool elemHasValueList[6] = {m_has_scrgbClr, m_has_srgbClr, m_has_hslClr, m_has_sysClr, m_has_schemeClr, m_has_prstClr};
        int cnt = count(elemHasValueList, elemHasValueList + 6, true);
        assert(cnt == 0 || cnt == 1);
    }


    if (m_has_scrgbClr)
    {
        m_scrgbClr->toXmlElem("a:scrgbClr", "", _outStream);
    }


    if (m_has_srgbClr)
    {
        m_srgbClr->toXmlElem("a:srgbClr", "", _outStream);
    }


    if (m_has_hslClr)
    {
        m_hslClr->toXmlElem("a:hslClr", "", _outStream);
    }


    if (m_has_sysClr)
    {
        m_sysClr->toXmlElem("a:sysClr", "", _outStream);
    }


    if (m_has_schemeClr)
    {
        m_schemeClr->toXmlElem("a:schemeClr", "", _outStream);
    }


    if (m_has_prstClr)
    {
        m_prstClr->toXmlElem("a:prstClr", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_FontReference& CT_FontReference::default_instance()
{
    if (!CT_FontReference::default_instance_)
    {
        CT_FontReference::default_instance_ = new CT_FontReference();
    }
    return *CT_FontReference::default_instance_;
}

bool CT_FontReference::has_idx_attr() const
{
    return m_has_idx_attr;
}

void CT_FontReference::set_idx_attr(const ST_FontCollectionIndex& _idx_attr)
{
    m_has_idx_attr = true;
    m_idx_attr = new ST_FontCollectionIndex(_idx_attr);
}

const ST_FontCollectionIndex& CT_FontReference::get_idx_attr() const
{
    if (m_idx_attr)
    {
        return *m_idx_attr;
    }
    return ST_FontCollectionIndex::default_instance();
}

CT_FontReference* CT_FontReference::default_instance_ = NULL;

// CT_ShapeStyle
CT_ShapeStyle::CT_ShapeStyle()
    :m_has_lnRef(false),
     m_lnRef(NULL),
     m_has_fillRef(false),
     m_fillRef(NULL),
     m_has_effectRef(false),
     m_effectRef(NULL),
     m_has_fontRef(false),
     m_fontRef(NULL)
{
}
CT_ShapeStyle::~CT_ShapeStyle()
{
    clear();
}
bool CT_ShapeStyle::has_lnRef() const
{
    return m_has_lnRef;
}

CT_StyleMatrixReference* CT_ShapeStyle::mutable_lnRef()
{
    m_has_lnRef = true;
    if (!m_lnRef)
    {
        m_lnRef = new CT_StyleMatrixReference();
    }
    return m_lnRef;
}

const CT_StyleMatrixReference& CT_ShapeStyle::get_lnRef() const
{
    if (m_lnRef)
    {
        return *m_lnRef;
    }
    return CT_StyleMatrixReference::default_instance();
}

bool CT_ShapeStyle::has_fillRef() const
{
    return m_has_fillRef;
}

CT_StyleMatrixReference* CT_ShapeStyle::mutable_fillRef()
{
    m_has_fillRef = true;
    if (!m_fillRef)
    {
        m_fillRef = new CT_StyleMatrixReference();
    }
    return m_fillRef;
}

const CT_StyleMatrixReference& CT_ShapeStyle::get_fillRef() const
{
    if (m_fillRef)
    {
        return *m_fillRef;
    }
    return CT_StyleMatrixReference::default_instance();
}

bool CT_ShapeStyle::has_effectRef() const
{
    return m_has_effectRef;
}

CT_StyleMatrixReference* CT_ShapeStyle::mutable_effectRef()
{
    m_has_effectRef = true;
    if (!m_effectRef)
    {
        m_effectRef = new CT_StyleMatrixReference();
    }
    return m_effectRef;
}

const CT_StyleMatrixReference& CT_ShapeStyle::get_effectRef() const
{
    if (m_effectRef)
    {
        return *m_effectRef;
    }
    return CT_StyleMatrixReference::default_instance();
}

bool CT_ShapeStyle::has_fontRef() const
{
    return m_has_fontRef;
}

CT_FontReference* CT_ShapeStyle::mutable_fontRef()
{
    m_has_fontRef = true;
    if (!m_fontRef)
    {
        m_fontRef = new CT_FontReference();
    }
    return m_fontRef;
}

const CT_FontReference& CT_ShapeStyle::get_fontRef() const
{
    if (m_fontRef)
    {
        return *m_fontRef;
    }
    return CT_FontReference::default_instance();
}

void CT_ShapeStyle::clear()
{
    m_has_lnRef = false;

    if (m_lnRef)
    {
        delete m_lnRef;
        m_lnRef = NULL;
    }


    m_has_fillRef = false;

    if (m_fillRef)
    {
        delete m_fillRef;
        m_fillRef = NULL;
    }


    m_has_effectRef = false;

    if (m_effectRef)
    {
        delete m_effectRef;
        m_effectRef = NULL;
    }


    m_has_fontRef = false;

    if (m_fontRef)
    {
        delete m_fontRef;
        m_fontRef = NULL;
    }

}

void CT_ShapeStyle::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    assert(m_has_lnRef);


    assert(m_has_fillRef);


    assert(m_has_effectRef);


    assert(m_has_fontRef);


    if (m_has_lnRef)
    {
        m_lnRef->toXmlElem("a:lnRef", "", _outStream);
    }


    if (m_has_fillRef)
    {
        m_fillRef->toXmlElem("a:fillRef", "", _outStream);
    }


    if (m_has_effectRef)
    {
        m_effectRef->toXmlElem("a:effectRef", "", _outStream);
    }


    if (m_has_fontRef)
    {
        m_fontRef->toXmlElem("a:fontRef", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_ShapeStyle& CT_ShapeStyle::default_instance()
{
    if (!CT_ShapeStyle::default_instance_)
    {
        CT_ShapeStyle::default_instance_ = new CT_ShapeStyle();
    }
    return *CT_ShapeStyle::default_instance_;
}

CT_ShapeStyle* CT_ShapeStyle::default_instance_ = NULL;

// CT_DefaultShapeDefinition
CT_DefaultShapeDefinition::CT_DefaultShapeDefinition()
    :m_has_spPr(false),
     m_spPr(NULL),
     m_has_bodyPr(false),
     m_bodyPr(NULL),
     m_has_lstStyle(false),
     m_lstStyle(NULL),
     m_has_style(false),
     m_style(NULL),
     m_has_extLst(false),
     m_extLst(NULL)
{
}
CT_DefaultShapeDefinition::~CT_DefaultShapeDefinition()
{
    clear();
}
bool CT_DefaultShapeDefinition::has_spPr() const
{
    return m_has_spPr;
}

CT_ShapeProperties* CT_DefaultShapeDefinition::mutable_spPr()
{
    m_has_spPr = true;
    if (!m_spPr)
    {
        m_spPr = new CT_ShapeProperties();
    }
    return m_spPr;
}

const CT_ShapeProperties& CT_DefaultShapeDefinition::get_spPr() const
{
    if (m_spPr)
    {
        return *m_spPr;
    }
    return CT_ShapeProperties::default_instance();
}

bool CT_DefaultShapeDefinition::has_bodyPr() const
{
    return m_has_bodyPr;
}

CT_TextBodyProperties* CT_DefaultShapeDefinition::mutable_bodyPr()
{
    m_has_bodyPr = true;
    if (!m_bodyPr)
    {
        m_bodyPr = new CT_TextBodyProperties();
    }
    return m_bodyPr;
}

const CT_TextBodyProperties& CT_DefaultShapeDefinition::get_bodyPr() const
{
    if (m_bodyPr)
    {
        return *m_bodyPr;
    }
    return CT_TextBodyProperties::default_instance();
}

bool CT_DefaultShapeDefinition::has_lstStyle() const
{
    return m_has_lstStyle;
}

CT_TextListStyle* CT_DefaultShapeDefinition::mutable_lstStyle()
{
    m_has_lstStyle = true;
    if (!m_lstStyle)
    {
        m_lstStyle = new CT_TextListStyle();
    }
    return m_lstStyle;
}

const CT_TextListStyle& CT_DefaultShapeDefinition::get_lstStyle() const
{
    if (m_lstStyle)
    {
        return *m_lstStyle;
    }
    return CT_TextListStyle::default_instance();
}

bool CT_DefaultShapeDefinition::has_style() const
{
    return m_has_style;
}

CT_ShapeStyle* CT_DefaultShapeDefinition::mutable_style()
{
    m_has_style = true;
    if (!m_style)
    {
        m_style = new CT_ShapeStyle();
    }
    return m_style;
}

const CT_ShapeStyle& CT_DefaultShapeDefinition::get_style() const
{
    if (m_style)
    {
        return *m_style;
    }
    return CT_ShapeStyle::default_instance();
}

bool CT_DefaultShapeDefinition::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_DefaultShapeDefinition::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_DefaultShapeDefinition::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_DefaultShapeDefinition::clear()
{
    m_has_spPr = false;

    if (m_spPr)
    {
        delete m_spPr;
        m_spPr = NULL;
    }


    m_has_bodyPr = false;

    if (m_bodyPr)
    {
        delete m_bodyPr;
        m_bodyPr = NULL;
    }


    m_has_lstStyle = false;

    if (m_lstStyle)
    {
        delete m_lstStyle;
        m_lstStyle = NULL;
    }


    m_has_style = false;

    if (m_style)
    {
        delete m_style;
        m_style = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_DefaultShapeDefinition::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    assert(m_has_spPr);


    assert(m_has_bodyPr);


    assert(m_has_lstStyle);


    if (m_has_spPr)
    {
        m_spPr->toXmlElem("a:spPr", "", _outStream);
    }


    if (m_has_bodyPr)
    {
        m_bodyPr->toXmlElem("a:bodyPr", "", _outStream);
    }


    if (m_has_lstStyle)
    {
        m_lstStyle->toXmlElem("a:lstStyle", "", _outStream);
    }


    if (m_has_style)
    {
        m_style->toXmlElem("a:style", "", _outStream);
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_DefaultShapeDefinition& CT_DefaultShapeDefinition::default_instance()
{
    if (!CT_DefaultShapeDefinition::default_instance_)
    {
        CT_DefaultShapeDefinition::default_instance_ = new CT_DefaultShapeDefinition();
    }
    return *CT_DefaultShapeDefinition::default_instance_;
}

CT_DefaultShapeDefinition* CT_DefaultShapeDefinition::default_instance_ = NULL;

// CT_ObjectStyleDefaults
CT_ObjectStyleDefaults::CT_ObjectStyleDefaults()
    :m_has_spDef(false),
     m_spDef(NULL),
     m_has_lnDef(false),
     m_lnDef(NULL),
     m_has_txDef(false),
     m_txDef(NULL),
     m_has_extLst(false),
     m_extLst(NULL)
{
}
CT_ObjectStyleDefaults::~CT_ObjectStyleDefaults()
{
    clear();
}
bool CT_ObjectStyleDefaults::has_spDef() const
{
    return m_has_spDef;
}

CT_DefaultShapeDefinition* CT_ObjectStyleDefaults::mutable_spDef()
{
    m_has_spDef = true;
    if (!m_spDef)
    {
        m_spDef = new CT_DefaultShapeDefinition();
    }
    return m_spDef;
}

const CT_DefaultShapeDefinition& CT_ObjectStyleDefaults::get_spDef() const
{
    if (m_spDef)
    {
        return *m_spDef;
    }
    return CT_DefaultShapeDefinition::default_instance();
}

bool CT_ObjectStyleDefaults::has_lnDef() const
{
    return m_has_lnDef;
}

CT_DefaultShapeDefinition* CT_ObjectStyleDefaults::mutable_lnDef()
{
    m_has_lnDef = true;
    if (!m_lnDef)
    {
        m_lnDef = new CT_DefaultShapeDefinition();
    }
    return m_lnDef;
}

const CT_DefaultShapeDefinition& CT_ObjectStyleDefaults::get_lnDef() const
{
    if (m_lnDef)
    {
        return *m_lnDef;
    }
    return CT_DefaultShapeDefinition::default_instance();
}

bool CT_ObjectStyleDefaults::has_txDef() const
{
    return m_has_txDef;
}

CT_DefaultShapeDefinition* CT_ObjectStyleDefaults::mutable_txDef()
{
    m_has_txDef = true;
    if (!m_txDef)
    {
        m_txDef = new CT_DefaultShapeDefinition();
    }
    return m_txDef;
}

const CT_DefaultShapeDefinition& CT_ObjectStyleDefaults::get_txDef() const
{
    if (m_txDef)
    {
        return *m_txDef;
    }
    return CT_DefaultShapeDefinition::default_instance();
}

bool CT_ObjectStyleDefaults::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_ObjectStyleDefaults::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_ObjectStyleDefaults::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_ObjectStyleDefaults::clear()
{
    m_has_spDef = false;

    if (m_spDef)
    {
        delete m_spDef;
        m_spDef = NULL;
    }


    m_has_lnDef = false;

    if (m_lnDef)
    {
        delete m_lnDef;
        m_lnDef = NULL;
    }


    m_has_txDef = false;

    if (m_txDef)
    {
        delete m_txDef;
        m_txDef = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_ObjectStyleDefaults::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";


    if (m_has_spDef)
    {
        m_spDef->toXmlElem("a:spDef", "", _outStream);
    }


    if (m_has_lnDef)
    {
        m_lnDef->toXmlElem("a:lnDef", "", _outStream);
    }


    if (m_has_txDef)
    {
        m_txDef->toXmlElem("a:txDef", "", _outStream);
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_ObjectStyleDefaults& CT_ObjectStyleDefaults::default_instance()
{
    if (!CT_ObjectStyleDefaults::default_instance_)
    {
        CT_ObjectStyleDefaults::default_instance_ = new CT_ObjectStyleDefaults();
    }
    return *CT_ObjectStyleDefaults::default_instance_;
}

CT_ObjectStyleDefaults* CT_ObjectStyleDefaults::default_instance_ = NULL;

// CT_EmptyElement
CT_EmptyElement::CT_EmptyElement()

{
}
CT_EmptyElement::~CT_EmptyElement()
{
    clear();
}
void CT_EmptyElement::clear()
{    }

void CT_EmptyElement::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_EmptyElement& CT_EmptyElement::default_instance()
{
    if (!CT_EmptyElement::default_instance_)
    {
        CT_EmptyElement::default_instance_ = new CT_EmptyElement();
    }
    return *CT_EmptyElement::default_instance_;
}

CT_EmptyElement* CT_EmptyElement::default_instance_ = NULL;

// CT_ColorMapping
CT_ColorMapping::CT_ColorMapping()
    :m_has_extLst(false),
     m_extLst(NULL),
     m_has_bg1_attr(false),
     m_bg1_attr(NULL),
     m_has_tx1_attr(false),
     m_tx1_attr(NULL),
     m_has_bg2_attr(false),
     m_bg2_attr(NULL),
     m_has_tx2_attr(false),
     m_tx2_attr(NULL),
     m_has_accent1_attr(false),
     m_accent1_attr(NULL),
     m_has_accent2_attr(false),
     m_accent2_attr(NULL),
     m_has_accent3_attr(false),
     m_accent3_attr(NULL),
     m_has_accent4_attr(false),
     m_accent4_attr(NULL),
     m_has_accent5_attr(false),
     m_accent5_attr(NULL),
     m_has_accent6_attr(false),
     m_accent6_attr(NULL),
     m_has_hlink_attr(false),
     m_hlink_attr(NULL),
     m_has_folHlink_attr(false),
     m_folHlink_attr(NULL)
{
}
CT_ColorMapping::~CT_ColorMapping()
{
    clear();
}
bool CT_ColorMapping::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_ColorMapping::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_ColorMapping::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_ColorMapping::clear()
{
    m_has_bg1_attr = false;

    if (m_bg1_attr)
    {
        delete m_bg1_attr;
        m_bg1_attr = NULL;
    }


    m_has_tx1_attr = false;

    if (m_tx1_attr)
    {
        delete m_tx1_attr;
        m_tx1_attr = NULL;
    }


    m_has_bg2_attr = false;

    if (m_bg2_attr)
    {
        delete m_bg2_attr;
        m_bg2_attr = NULL;
    }


    m_has_tx2_attr = false;

    if (m_tx2_attr)
    {
        delete m_tx2_attr;
        m_tx2_attr = NULL;
    }


    m_has_accent1_attr = false;

    if (m_accent1_attr)
    {
        delete m_accent1_attr;
        m_accent1_attr = NULL;
    }


    m_has_accent2_attr = false;

    if (m_accent2_attr)
    {
        delete m_accent2_attr;
        m_accent2_attr = NULL;
    }


    m_has_accent3_attr = false;

    if (m_accent3_attr)
    {
        delete m_accent3_attr;
        m_accent3_attr = NULL;
    }


    m_has_accent4_attr = false;

    if (m_accent4_attr)
    {
        delete m_accent4_attr;
        m_accent4_attr = NULL;
    }


    m_has_accent5_attr = false;

    if (m_accent5_attr)
    {
        delete m_accent5_attr;
        m_accent5_attr = NULL;
    }


    m_has_accent6_attr = false;

    if (m_accent6_attr)
    {
        delete m_accent6_attr;
        m_accent6_attr = NULL;
    }


    m_has_hlink_attr = false;

    if (m_hlink_attr)
    {
        delete m_hlink_attr;
        m_hlink_attr = NULL;
    }


    m_has_folHlink_attr = false;

    if (m_folHlink_attr)
    {
        delete m_folHlink_attr;
        m_folHlink_attr = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_ColorMapping::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_bg1_attr);
    if (m_has_bg1_attr)
    {
        m_bg1_attr->toXmlAttr("bg1", _outStream);
    }


    assert(m_has_tx1_attr);
    if (m_has_tx1_attr)
    {
        m_tx1_attr->toXmlAttr("tx1", _outStream);
    }


    assert(m_has_bg2_attr);
    if (m_has_bg2_attr)
    {
        m_bg2_attr->toXmlAttr("bg2", _outStream);
    }


    assert(m_has_tx2_attr);
    if (m_has_tx2_attr)
    {
        m_tx2_attr->toXmlAttr("tx2", _outStream);
    }


    assert(m_has_accent1_attr);
    if (m_has_accent1_attr)
    {
        m_accent1_attr->toXmlAttr("accent1", _outStream);
    }


    assert(m_has_accent2_attr);
    if (m_has_accent2_attr)
    {
        m_accent2_attr->toXmlAttr("accent2", _outStream);
    }


    assert(m_has_accent3_attr);
    if (m_has_accent3_attr)
    {
        m_accent3_attr->toXmlAttr("accent3", _outStream);
    }


    assert(m_has_accent4_attr);
    if (m_has_accent4_attr)
    {
        m_accent4_attr->toXmlAttr("accent4", _outStream);
    }


    assert(m_has_accent5_attr);
    if (m_has_accent5_attr)
    {
        m_accent5_attr->toXmlAttr("accent5", _outStream);
    }


    assert(m_has_accent6_attr);
    if (m_has_accent6_attr)
    {
        m_accent6_attr->toXmlAttr("accent6", _outStream);
    }


    assert(m_has_hlink_attr);
    if (m_has_hlink_attr)
    {
        m_hlink_attr->toXmlAttr("hlink", _outStream);
    }


    assert(m_has_folHlink_attr);
    if (m_has_folHlink_attr)
    {
        m_folHlink_attr->toXmlAttr("folHlink", _outStream);
    }

    _outStream << ">";


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_ColorMapping& CT_ColorMapping::default_instance()
{
    if (!CT_ColorMapping::default_instance_)
    {
        CT_ColorMapping::default_instance_ = new CT_ColorMapping();
    }
    return *CT_ColorMapping::default_instance_;
}

bool CT_ColorMapping::has_bg1_attr() const
{
    return m_has_bg1_attr;
}

void CT_ColorMapping::set_bg1_attr(const ST_ColorSchemeIndex& _bg1_attr)
{
    m_has_bg1_attr = true;
    m_bg1_attr = new ST_ColorSchemeIndex(_bg1_attr);
}

const ST_ColorSchemeIndex& CT_ColorMapping::get_bg1_attr() const
{
    if (m_bg1_attr)
    {
        return *m_bg1_attr;
    }
    return ST_ColorSchemeIndex::default_instance();
}

bool CT_ColorMapping::has_tx1_attr() const
{
    return m_has_tx1_attr;
}

void CT_ColorMapping::set_tx1_attr(const ST_ColorSchemeIndex& _tx1_attr)
{
    m_has_tx1_attr = true;
    m_tx1_attr = new ST_ColorSchemeIndex(_tx1_attr);
}

const ST_ColorSchemeIndex& CT_ColorMapping::get_tx1_attr() const
{
    if (m_tx1_attr)
    {
        return *m_tx1_attr;
    }
    return ST_ColorSchemeIndex::default_instance();
}

bool CT_ColorMapping::has_bg2_attr() const
{
    return m_has_bg2_attr;
}

void CT_ColorMapping::set_bg2_attr(const ST_ColorSchemeIndex& _bg2_attr)
{
    m_has_bg2_attr = true;
    m_bg2_attr = new ST_ColorSchemeIndex(_bg2_attr);
}

const ST_ColorSchemeIndex& CT_ColorMapping::get_bg2_attr() const
{
    if (m_bg2_attr)
    {
        return *m_bg2_attr;
    }
    return ST_ColorSchemeIndex::default_instance();
}

bool CT_ColorMapping::has_tx2_attr() const
{
    return m_has_tx2_attr;
}

void CT_ColorMapping::set_tx2_attr(const ST_ColorSchemeIndex& _tx2_attr)
{
    m_has_tx2_attr = true;
    m_tx2_attr = new ST_ColorSchemeIndex(_tx2_attr);
}

const ST_ColorSchemeIndex& CT_ColorMapping::get_tx2_attr() const
{
    if (m_tx2_attr)
    {
        return *m_tx2_attr;
    }
    return ST_ColorSchemeIndex::default_instance();
}

bool CT_ColorMapping::has_accent1_attr() const
{
    return m_has_accent1_attr;
}

void CT_ColorMapping::set_accent1_attr(const ST_ColorSchemeIndex& _accent1_attr)
{
    m_has_accent1_attr = true;
    m_accent1_attr = new ST_ColorSchemeIndex(_accent1_attr);
}

const ST_ColorSchemeIndex& CT_ColorMapping::get_accent1_attr() const
{
    if (m_accent1_attr)
    {
        return *m_accent1_attr;
    }
    return ST_ColorSchemeIndex::default_instance();
}

bool CT_ColorMapping::has_accent2_attr() const
{
    return m_has_accent2_attr;
}

void CT_ColorMapping::set_accent2_attr(const ST_ColorSchemeIndex& _accent2_attr)
{
    m_has_accent2_attr = true;
    m_accent2_attr = new ST_ColorSchemeIndex(_accent2_attr);
}

const ST_ColorSchemeIndex& CT_ColorMapping::get_accent2_attr() const
{
    if (m_accent2_attr)
    {
        return *m_accent2_attr;
    }
    return ST_ColorSchemeIndex::default_instance();
}

bool CT_ColorMapping::has_accent3_attr() const
{
    return m_has_accent3_attr;
}

void CT_ColorMapping::set_accent3_attr(const ST_ColorSchemeIndex& _accent3_attr)
{
    m_has_accent3_attr = true;
    m_accent3_attr = new ST_ColorSchemeIndex(_accent3_attr);
}

const ST_ColorSchemeIndex& CT_ColorMapping::get_accent3_attr() const
{
    if (m_accent3_attr)
    {
        return *m_accent3_attr;
    }
    return ST_ColorSchemeIndex::default_instance();
}

bool CT_ColorMapping::has_accent4_attr() const
{
    return m_has_accent4_attr;
}

void CT_ColorMapping::set_accent4_attr(const ST_ColorSchemeIndex& _accent4_attr)
{
    m_has_accent4_attr = true;
    m_accent4_attr = new ST_ColorSchemeIndex(_accent4_attr);
}

const ST_ColorSchemeIndex& CT_ColorMapping::get_accent4_attr() const
{
    if (m_accent4_attr)
    {
        return *m_accent4_attr;
    }
    return ST_ColorSchemeIndex::default_instance();
}

bool CT_ColorMapping::has_accent5_attr() const
{
    return m_has_accent5_attr;
}

void CT_ColorMapping::set_accent5_attr(const ST_ColorSchemeIndex& _accent5_attr)
{
    m_has_accent5_attr = true;
    m_accent5_attr = new ST_ColorSchemeIndex(_accent5_attr);
}

const ST_ColorSchemeIndex& CT_ColorMapping::get_accent5_attr() const
{
    if (m_accent5_attr)
    {
        return *m_accent5_attr;
    }
    return ST_ColorSchemeIndex::default_instance();
}

bool CT_ColorMapping::has_accent6_attr() const
{
    return m_has_accent6_attr;
}

void CT_ColorMapping::set_accent6_attr(const ST_ColorSchemeIndex& _accent6_attr)
{
    m_has_accent6_attr = true;
    m_accent6_attr = new ST_ColorSchemeIndex(_accent6_attr);
}

const ST_ColorSchemeIndex& CT_ColorMapping::get_accent6_attr() const
{
    if (m_accent6_attr)
    {
        return *m_accent6_attr;
    }
    return ST_ColorSchemeIndex::default_instance();
}

bool CT_ColorMapping::has_hlink_attr() const
{
    return m_has_hlink_attr;
}

void CT_ColorMapping::set_hlink_attr(const ST_ColorSchemeIndex& _hlink_attr)
{
    m_has_hlink_attr = true;
    m_hlink_attr = new ST_ColorSchemeIndex(_hlink_attr);
}

const ST_ColorSchemeIndex& CT_ColorMapping::get_hlink_attr() const
{
    if (m_hlink_attr)
    {
        return *m_hlink_attr;
    }
    return ST_ColorSchemeIndex::default_instance();
}

bool CT_ColorMapping::has_folHlink_attr() const
{
    return m_has_folHlink_attr;
}

void CT_ColorMapping::set_folHlink_attr(const ST_ColorSchemeIndex& _folHlink_attr)
{
    m_has_folHlink_attr = true;
    m_folHlink_attr = new ST_ColorSchemeIndex(_folHlink_attr);
}

const ST_ColorSchemeIndex& CT_ColorMapping::get_folHlink_attr() const
{
    if (m_folHlink_attr)
    {
        return *m_folHlink_attr;
    }
    return ST_ColorSchemeIndex::default_instance();
}

CT_ColorMapping* CT_ColorMapping::default_instance_ = NULL;

// CT_ColorMappingOverride
CT_ColorMappingOverride::CT_ColorMappingOverride()
    :m_has_masterClrMapping(false),
     m_masterClrMapping(NULL),
     m_has_overrideClrMapping(false),
     m_overrideClrMapping(NULL)
{
}
CT_ColorMappingOverride::~CT_ColorMappingOverride()
{
    clear();
}
bool CT_ColorMappingOverride::has_masterClrMapping() const
{
    return m_has_masterClrMapping;
}

CT_EmptyElement* CT_ColorMappingOverride::mutable_masterClrMapping()
{

    m_has_overrideClrMapping = false;

    if (m_overrideClrMapping)
    {
        delete m_overrideClrMapping;
        m_overrideClrMapping = NULL;
    }
    ;

    m_has_masterClrMapping = true;
    if (!m_masterClrMapping)
    {
        m_masterClrMapping = new CT_EmptyElement();
    }
    return m_masterClrMapping;
}

const CT_EmptyElement& CT_ColorMappingOverride::get_masterClrMapping() const
{
    if (m_masterClrMapping)
    {
        return *m_masterClrMapping;
    }
    return CT_EmptyElement::default_instance();
}

bool CT_ColorMappingOverride::has_overrideClrMapping() const
{
    return m_has_overrideClrMapping;
}

CT_ColorMapping* CT_ColorMappingOverride::mutable_overrideClrMapping()
{

    m_has_masterClrMapping = false;

    if (m_masterClrMapping)
    {
        delete m_masterClrMapping;
        m_masterClrMapping = NULL;
    }
    ;

    m_has_overrideClrMapping = true;
    if (!m_overrideClrMapping)
    {
        m_overrideClrMapping = new CT_ColorMapping();
    }
    return m_overrideClrMapping;
}

const CT_ColorMapping& CT_ColorMappingOverride::get_overrideClrMapping() const
{
    if (m_overrideClrMapping)
    {
        return *m_overrideClrMapping;
    }
    return CT_ColorMapping::default_instance();
}

void CT_ColorMappingOverride::clear()
{
    m_has_masterClrMapping = false;

    if (m_masterClrMapping)
    {
        delete m_masterClrMapping;
        m_masterClrMapping = NULL;
    }


    m_has_overrideClrMapping = false;

    if (m_overrideClrMapping)
    {
        delete m_overrideClrMapping;
        m_overrideClrMapping = NULL;
    }

}

void CT_ColorMappingOverride::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    {
        bool elemHasValueList[2] = {m_has_masterClrMapping, m_has_overrideClrMapping};
        int cnt = count(elemHasValueList, elemHasValueList + 2, true);
        assert(cnt == 1);
    }


    if (m_has_masterClrMapping)
    {
        m_masterClrMapping->toXmlElem("a:masterClrMapping", "", _outStream);
    }


    if (m_has_overrideClrMapping)
    {
        m_overrideClrMapping->toXmlElem("a:overrideClrMapping", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_ColorMappingOverride& CT_ColorMappingOverride::default_instance()
{
    if (!CT_ColorMappingOverride::default_instance_)
    {
        CT_ColorMappingOverride::default_instance_ = new CT_ColorMappingOverride();
    }
    return *CT_ColorMappingOverride::default_instance_;
}

CT_ColorMappingOverride* CT_ColorMappingOverride::default_instance_ = NULL;

// CT_ColorSchemeAndMapping
CT_ColorSchemeAndMapping::CT_ColorSchemeAndMapping()
    :m_has_clrScheme(false),
     m_clrScheme(NULL),
     m_has_clrMap(false),
     m_clrMap(NULL)
{
}
CT_ColorSchemeAndMapping::~CT_ColorSchemeAndMapping()
{
    clear();
}
bool CT_ColorSchemeAndMapping::has_clrScheme() const
{
    return m_has_clrScheme;
}

CT_ColorScheme* CT_ColorSchemeAndMapping::mutable_clrScheme()
{
    m_has_clrScheme = true;
    if (!m_clrScheme)
    {
        m_clrScheme = new CT_ColorScheme();
    }
    return m_clrScheme;
}

const CT_ColorScheme& CT_ColorSchemeAndMapping::get_clrScheme() const
{
    if (m_clrScheme)
    {
        return *m_clrScheme;
    }
    return CT_ColorScheme::default_instance();
}

bool CT_ColorSchemeAndMapping::has_clrMap() const
{
    return m_has_clrMap;
}

CT_ColorMapping* CT_ColorSchemeAndMapping::mutable_clrMap()
{
    m_has_clrMap = true;
    if (!m_clrMap)
    {
        m_clrMap = new CT_ColorMapping();
    }
    return m_clrMap;
}

const CT_ColorMapping& CT_ColorSchemeAndMapping::get_clrMap() const
{
    if (m_clrMap)
    {
        return *m_clrMap;
    }
    return CT_ColorMapping::default_instance();
}

void CT_ColorSchemeAndMapping::clear()
{
    m_has_clrScheme = false;

    if (m_clrScheme)
    {
        delete m_clrScheme;
        m_clrScheme = NULL;
    }


    m_has_clrMap = false;

    if (m_clrMap)
    {
        delete m_clrMap;
        m_clrMap = NULL;
    }

}

void CT_ColorSchemeAndMapping::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    assert(m_has_clrScheme);


    if (m_has_clrScheme)
    {
        m_clrScheme->toXmlElem("a:clrScheme", "", _outStream);
    }


    if (m_has_clrMap)
    {
        m_clrMap->toXmlElem("a:clrMap", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_ColorSchemeAndMapping& CT_ColorSchemeAndMapping::default_instance()
{
    if (!CT_ColorSchemeAndMapping::default_instance_)
    {
        CT_ColorSchemeAndMapping::default_instance_ = new CT_ColorSchemeAndMapping();
    }
    return *CT_ColorSchemeAndMapping::default_instance_;
}

CT_ColorSchemeAndMapping* CT_ColorSchemeAndMapping::default_instance_ = NULL;

// CT_ColorSchemeList
CT_ColorSchemeList::CT_ColorSchemeList()

{
}
CT_ColorSchemeList::~CT_ColorSchemeList()
{
    clear();
}
CT_ColorSchemeAndMapping* CT_ColorSchemeList::add_extraClrScheme()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_ColorSchemeAndMapping* pNewChild = pChildGroup->mutable_extraClrScheme();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

void CT_ColorSchemeList::clear()
{
    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }
}

void CT_ColorSchemeList::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_extraClrScheme())
            {
                (*iter)->get_extraClrScheme().toXmlElem("a:extraClrScheme", "", _outStream);
            }


        }
    }

    _outStream << "</" << _elemName << ">";
}

const CT_ColorSchemeList& CT_ColorSchemeList::default_instance()
{
    if (!CT_ColorSchemeList::default_instance_)
    {
        CT_ColorSchemeList::default_instance_ = new CT_ColorSchemeList();
    }
    return *CT_ColorSchemeList::default_instance_;
}


// CT_ColorSchemeList::ChildGroup_1
CT_ColorSchemeList::ChildGroup_1::ChildGroup_1()
    :m_has_extraClrScheme(false),
     m_extraClrScheme(NULL)
{
}
bool CT_ColorSchemeList::ChildGroup_1::has_extraClrScheme() const
{
    return m_has_extraClrScheme;
}

CT_ColorSchemeAndMapping* CT_ColorSchemeList::ChildGroup_1::mutable_extraClrScheme()
{

    m_has_extraClrScheme = true;
    if (!m_extraClrScheme)
    {
        m_extraClrScheme = new CT_ColorSchemeAndMapping();
    }
    return m_extraClrScheme;
}

const CT_ColorSchemeAndMapping& CT_ColorSchemeList::ChildGroup_1::get_extraClrScheme() const
{
    if (m_extraClrScheme)
    {
        return *m_extraClrScheme;
    }
    return CT_ColorSchemeAndMapping::default_instance();
}

CT_ColorSchemeList* CT_ColorSchemeList::default_instance_ = NULL;

// CT_OfficeStyleSheet
CT_OfficeStyleSheet::CT_OfficeStyleSheet()
    :m_has_themeElements(false),
     m_themeElements(NULL),
     m_has_objectDefaults(false),
     m_objectDefaults(NULL),
     m_has_extraClrSchemeLst(false),
     m_extraClrSchemeLst(NULL),
     m_has_custClrLst(false),
     m_custClrLst(NULL),
     m_has_extLst(false),
     m_extLst(NULL),
     m_has_name_attr(false),
     m_name_attr("")
{
}
CT_OfficeStyleSheet::~CT_OfficeStyleSheet()
{
    clear();
}
bool CT_OfficeStyleSheet::has_themeElements() const
{
    return m_has_themeElements;
}

CT_BaseStyles* CT_OfficeStyleSheet::mutable_themeElements()
{
    m_has_themeElements = true;
    if (!m_themeElements)
    {
        m_themeElements = new CT_BaseStyles();
    }
    return m_themeElements;
}

const CT_BaseStyles& CT_OfficeStyleSheet::get_themeElements() const
{
    if (m_themeElements)
    {
        return *m_themeElements;
    }
    return CT_BaseStyles::default_instance();
}

bool CT_OfficeStyleSheet::has_objectDefaults() const
{
    return m_has_objectDefaults;
}

CT_ObjectStyleDefaults* CT_OfficeStyleSheet::mutable_objectDefaults()
{
    m_has_objectDefaults = true;
    if (!m_objectDefaults)
    {
        m_objectDefaults = new CT_ObjectStyleDefaults();
    }
    return m_objectDefaults;
}

const CT_ObjectStyleDefaults& CT_OfficeStyleSheet::get_objectDefaults() const
{
    if (m_objectDefaults)
    {
        return *m_objectDefaults;
    }
    return CT_ObjectStyleDefaults::default_instance();
}

bool CT_OfficeStyleSheet::has_extraClrSchemeLst() const
{
    return m_has_extraClrSchemeLst;
}

CT_ColorSchemeList* CT_OfficeStyleSheet::mutable_extraClrSchemeLst()
{
    m_has_extraClrSchemeLst = true;
    if (!m_extraClrSchemeLst)
    {
        m_extraClrSchemeLst = new CT_ColorSchemeList();
    }
    return m_extraClrSchemeLst;
}

const CT_ColorSchemeList& CT_OfficeStyleSheet::get_extraClrSchemeLst() const
{
    if (m_extraClrSchemeLst)
    {
        return *m_extraClrSchemeLst;
    }
    return CT_ColorSchemeList::default_instance();
}

bool CT_OfficeStyleSheet::has_custClrLst() const
{
    return m_has_custClrLst;
}

CT_CustomColorList* CT_OfficeStyleSheet::mutable_custClrLst()
{
    m_has_custClrLst = true;
    if (!m_custClrLst)
    {
        m_custClrLst = new CT_CustomColorList();
    }
    return m_custClrLst;
}

const CT_CustomColorList& CT_OfficeStyleSheet::get_custClrLst() const
{
    if (m_custClrLst)
    {
        return *m_custClrLst;
    }
    return CT_CustomColorList::default_instance();
}

bool CT_OfficeStyleSheet::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_OfficeStyleSheet::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_OfficeStyleSheet::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_OfficeStyleSheet::clear()
{
    m_has_name_attr = false;
    m_name_attr.clear();

    m_has_themeElements = false;

    if (m_themeElements)
    {
        delete m_themeElements;
        m_themeElements = NULL;
    }


    m_has_objectDefaults = false;

    if (m_objectDefaults)
    {
        delete m_objectDefaults;
        m_objectDefaults = NULL;
    }


    m_has_extraClrSchemeLst = false;

    if (m_extraClrSchemeLst)
    {
        delete m_extraClrSchemeLst;
        m_extraClrSchemeLst = NULL;
    }


    m_has_custClrLst = false;

    if (m_custClrLst)
    {
        delete m_custClrLst;
        m_custClrLst = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_OfficeStyleSheet::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_name_attr)
    {
        _outStream << " " << "name" << "=\"" << m_name_attr << "\"";
    }

    _outStream << ">";

    assert(m_has_themeElements);


    if (m_has_themeElements)
    {
        m_themeElements->toXmlElem("a:themeElements", "", _outStream);
    }


    if (m_has_objectDefaults)
    {
        m_objectDefaults->toXmlElem("a:objectDefaults", "", _outStream);
    }


    if (m_has_extraClrSchemeLst)
    {
        m_extraClrSchemeLst->toXmlElem("a:extraClrSchemeLst", "", _outStream);
    }


    if (m_has_custClrLst)
    {
        m_custClrLst->toXmlElem("a:custClrLst", "", _outStream);
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_OfficeStyleSheet& CT_OfficeStyleSheet::default_instance()
{
    if (!CT_OfficeStyleSheet::default_instance_)
    {
        CT_OfficeStyleSheet::default_instance_ = new CT_OfficeStyleSheet();
    }
    return *CT_OfficeStyleSheet::default_instance_;
}

bool CT_OfficeStyleSheet::has_name_attr() const
{
    return m_has_name_attr;
}

void CT_OfficeStyleSheet::set_name_attr(const XSD::string_& _name_attr)
{
    m_has_name_attr = true;
    m_name_attr = _name_attr;
}

const XSD::string_& CT_OfficeStyleSheet::get_name_attr() const
{
    return m_name_attr;
}

CT_OfficeStyleSheet* CT_OfficeStyleSheet::default_instance_ = NULL;

// CT_BaseStylesOverride
CT_BaseStylesOverride::CT_BaseStylesOverride()
    :m_has_clrScheme(false),
     m_clrScheme(NULL),
     m_has_fontScheme(false),
     m_fontScheme(NULL),
     m_has_fmtScheme(false),
     m_fmtScheme(NULL)
{
}
CT_BaseStylesOverride::~CT_BaseStylesOverride()
{
    clear();
}
bool CT_BaseStylesOverride::has_clrScheme() const
{
    return m_has_clrScheme;
}

CT_ColorScheme* CT_BaseStylesOverride::mutable_clrScheme()
{
    m_has_clrScheme = true;
    if (!m_clrScheme)
    {
        m_clrScheme = new CT_ColorScheme();
    }
    return m_clrScheme;
}

const CT_ColorScheme& CT_BaseStylesOverride::get_clrScheme() const
{
    if (m_clrScheme)
    {
        return *m_clrScheme;
    }
    return CT_ColorScheme::default_instance();
}

bool CT_BaseStylesOverride::has_fontScheme() const
{
    return m_has_fontScheme;
}

CT_FontScheme* CT_BaseStylesOverride::mutable_fontScheme()
{
    m_has_fontScheme = true;
    if (!m_fontScheme)
    {
        m_fontScheme = new CT_FontScheme();
    }
    return m_fontScheme;
}

const CT_FontScheme& CT_BaseStylesOverride::get_fontScheme() const
{
    if (m_fontScheme)
    {
        return *m_fontScheme;
    }
    return CT_FontScheme::default_instance();
}

bool CT_BaseStylesOverride::has_fmtScheme() const
{
    return m_has_fmtScheme;
}

CT_StyleMatrix* CT_BaseStylesOverride::mutable_fmtScheme()
{
    m_has_fmtScheme = true;
    if (!m_fmtScheme)
    {
        m_fmtScheme = new CT_StyleMatrix();
    }
    return m_fmtScheme;
}

const CT_StyleMatrix& CT_BaseStylesOverride::get_fmtScheme() const
{
    if (m_fmtScheme)
    {
        return *m_fmtScheme;
    }
    return CT_StyleMatrix::default_instance();
}

void CT_BaseStylesOverride::clear()
{
    m_has_clrScheme = false;

    if (m_clrScheme)
    {
        delete m_clrScheme;
        m_clrScheme = NULL;
    }


    m_has_fontScheme = false;

    if (m_fontScheme)
    {
        delete m_fontScheme;
        m_fontScheme = NULL;
    }


    m_has_fmtScheme = false;

    if (m_fmtScheme)
    {
        delete m_fmtScheme;
        m_fmtScheme = NULL;
    }

}

void CT_BaseStylesOverride::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";


    if (m_has_clrScheme)
    {
        m_clrScheme->toXmlElem("a:clrScheme", "", _outStream);
    }


    if (m_has_fontScheme)
    {
        m_fontScheme->toXmlElem("a:fontScheme", "", _outStream);
    }


    if (m_has_fmtScheme)
    {
        m_fmtScheme->toXmlElem("a:fmtScheme", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_BaseStylesOverride& CT_BaseStylesOverride::default_instance()
{
    if (!CT_BaseStylesOverride::default_instance_)
    {
        CT_BaseStylesOverride::default_instance_ = new CT_BaseStylesOverride();
    }
    return *CT_BaseStylesOverride::default_instance_;
}

CT_BaseStylesOverride* CT_BaseStylesOverride::default_instance_ = NULL;

// CT_ClipboardStyleSheet
CT_ClipboardStyleSheet::CT_ClipboardStyleSheet()
    :m_has_themeElements(false),
     m_themeElements(NULL),
     m_has_clrMap(false),
     m_clrMap(NULL)
{
}
CT_ClipboardStyleSheet::~CT_ClipboardStyleSheet()
{
    clear();
}
bool CT_ClipboardStyleSheet::has_themeElements() const
{
    return m_has_themeElements;
}

CT_BaseStyles* CT_ClipboardStyleSheet::mutable_themeElements()
{
    m_has_themeElements = true;
    if (!m_themeElements)
    {
        m_themeElements = new CT_BaseStyles();
    }
    return m_themeElements;
}

const CT_BaseStyles& CT_ClipboardStyleSheet::get_themeElements() const
{
    if (m_themeElements)
    {
        return *m_themeElements;
    }
    return CT_BaseStyles::default_instance();
}

bool CT_ClipboardStyleSheet::has_clrMap() const
{
    return m_has_clrMap;
}

CT_ColorMapping* CT_ClipboardStyleSheet::mutable_clrMap()
{
    m_has_clrMap = true;
    if (!m_clrMap)
    {
        m_clrMap = new CT_ColorMapping();
    }
    return m_clrMap;
}

const CT_ColorMapping& CT_ClipboardStyleSheet::get_clrMap() const
{
    if (m_clrMap)
    {
        return *m_clrMap;
    }
    return CT_ColorMapping::default_instance();
}

void CT_ClipboardStyleSheet::clear()
{
    m_has_themeElements = false;

    if (m_themeElements)
    {
        delete m_themeElements;
        m_themeElements = NULL;
    }


    m_has_clrMap = false;

    if (m_clrMap)
    {
        delete m_clrMap;
        m_clrMap = NULL;
    }

}

void CT_ClipboardStyleSheet::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    assert(m_has_themeElements);


    assert(m_has_clrMap);


    if (m_has_themeElements)
    {
        m_themeElements->toXmlElem("a:themeElements", "", _outStream);
    }


    if (m_has_clrMap)
    {
        m_clrMap->toXmlElem("a:clrMap", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_ClipboardStyleSheet& CT_ClipboardStyleSheet::default_instance()
{
    if (!CT_ClipboardStyleSheet::default_instance_)
    {
        CT_ClipboardStyleSheet::default_instance_ = new CT_ClipboardStyleSheet();
    }
    return *CT_ClipboardStyleSheet::default_instance_;
}

CT_ClipboardStyleSheet* CT_ClipboardStyleSheet::default_instance_ = NULL;

// CT_TableCellProperties
CT_TableCellProperties::CT_TableCellProperties()
    :m_has_lnL(false),
     m_lnL(NULL),
     m_has_lnR(false),
     m_lnR(NULL),
     m_has_lnT(false),
     m_lnT(NULL),
     m_has_lnB(false),
     m_lnB(NULL),
     m_has_lnTlToBr(false),
     m_lnTlToBr(NULL),
     m_has_lnBlToTr(false),
     m_lnBlToTr(NULL),
     m_has_cell3D(false),
     m_cell3D(NULL),
     m_has_noFill(false),
     m_noFill(NULL),
     m_has_solidFill(false),
     m_solidFill(NULL),
     m_has_gradFill(false),
     m_gradFill(NULL),
     m_has_blipFill(false),
     m_blipFill(NULL),
     m_has_pattFill(false),
     m_pattFill(NULL),
     m_has_grpFill(false),
     m_grpFill(NULL),
     m_has_headers(false),
     m_headers(NULL),
     m_has_extLst(false),
     m_extLst(NULL),
     m_has_marL_attr(false),
     m_marL_attr(NULL),
     m_has_marR_attr(false),
     m_marR_attr(NULL),
     m_has_marT_attr(false),
     m_marT_attr(NULL),
     m_has_marB_attr(false),
     m_marB_attr(NULL),
     m_has_vert_attr(false),
     m_vert_attr(NULL),
     m_has_anchor_attr(false),
     m_anchor_attr(NULL),
     m_has_anchorCtr_attr(false),
     m_anchorCtr_attr(false),
     m_has_horzOverflow_attr(false),
     m_horzOverflow_attr(NULL)
{
}
CT_TableCellProperties::~CT_TableCellProperties()
{
    clear();
}
bool CT_TableCellProperties::has_lnL() const
{
    return m_has_lnL;
}

CT_LineProperties* CT_TableCellProperties::mutable_lnL()
{
    m_has_lnL = true;
    if (!m_lnL)
    {
        m_lnL = new CT_LineProperties();
    }
    return m_lnL;
}

const CT_LineProperties& CT_TableCellProperties::get_lnL() const
{
    if (m_lnL)
    {
        return *m_lnL;
    }
    return CT_LineProperties::default_instance();
}

bool CT_TableCellProperties::has_lnR() const
{
    return m_has_lnR;
}

CT_LineProperties* CT_TableCellProperties::mutable_lnR()
{
    m_has_lnR = true;
    if (!m_lnR)
    {
        m_lnR = new CT_LineProperties();
    }
    return m_lnR;
}

const CT_LineProperties& CT_TableCellProperties::get_lnR() const
{
    if (m_lnR)
    {
        return *m_lnR;
    }
    return CT_LineProperties::default_instance();
}

bool CT_TableCellProperties::has_lnT() const
{
    return m_has_lnT;
}

CT_LineProperties* CT_TableCellProperties::mutable_lnT()
{
    m_has_lnT = true;
    if (!m_lnT)
    {
        m_lnT = new CT_LineProperties();
    }
    return m_lnT;
}

const CT_LineProperties& CT_TableCellProperties::get_lnT() const
{
    if (m_lnT)
    {
        return *m_lnT;
    }
    return CT_LineProperties::default_instance();
}

bool CT_TableCellProperties::has_lnB() const
{
    return m_has_lnB;
}

CT_LineProperties* CT_TableCellProperties::mutable_lnB()
{
    m_has_lnB = true;
    if (!m_lnB)
    {
        m_lnB = new CT_LineProperties();
    }
    return m_lnB;
}

const CT_LineProperties& CT_TableCellProperties::get_lnB() const
{
    if (m_lnB)
    {
        return *m_lnB;
    }
    return CT_LineProperties::default_instance();
}

bool CT_TableCellProperties::has_lnTlToBr() const
{
    return m_has_lnTlToBr;
}

CT_LineProperties* CT_TableCellProperties::mutable_lnTlToBr()
{
    m_has_lnTlToBr = true;
    if (!m_lnTlToBr)
    {
        m_lnTlToBr = new CT_LineProperties();
    }
    return m_lnTlToBr;
}

const CT_LineProperties& CT_TableCellProperties::get_lnTlToBr() const
{
    if (m_lnTlToBr)
    {
        return *m_lnTlToBr;
    }
    return CT_LineProperties::default_instance();
}

bool CT_TableCellProperties::has_lnBlToTr() const
{
    return m_has_lnBlToTr;
}

CT_LineProperties* CT_TableCellProperties::mutable_lnBlToTr()
{
    m_has_lnBlToTr = true;
    if (!m_lnBlToTr)
    {
        m_lnBlToTr = new CT_LineProperties();
    }
    return m_lnBlToTr;
}

const CT_LineProperties& CT_TableCellProperties::get_lnBlToTr() const
{
    if (m_lnBlToTr)
    {
        return *m_lnBlToTr;
    }
    return CT_LineProperties::default_instance();
}

bool CT_TableCellProperties::has_cell3D() const
{
    return m_has_cell3D;
}

CT_Cell3D* CT_TableCellProperties::mutable_cell3D()
{
    m_has_cell3D = true;
    if (!m_cell3D)
    {
        m_cell3D = new CT_Cell3D();
    }
    return m_cell3D;
}

const CT_Cell3D& CT_TableCellProperties::get_cell3D() const
{
    if (m_cell3D)
    {
        return *m_cell3D;
    }
    return CT_Cell3D::default_instance();
}

bool CT_TableCellProperties::has_noFill() const
{
    return m_has_noFill;
}

CT_NoFillProperties* CT_TableCellProperties::mutable_noFill()
{

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_noFill = true;
    if (!m_noFill)
    {
        m_noFill = new CT_NoFillProperties();
    }
    return m_noFill;
}

const CT_NoFillProperties& CT_TableCellProperties::get_noFill() const
{
    if (m_noFill)
    {
        return *m_noFill;
    }
    return CT_NoFillProperties::default_instance();
}

bool CT_TableCellProperties::has_solidFill() const
{
    return m_has_solidFill;
}

CT_SolidColorFillProperties* CT_TableCellProperties::mutable_solidFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_solidFill = true;
    if (!m_solidFill)
    {
        m_solidFill = new CT_SolidColorFillProperties();
    }
    return m_solidFill;
}

const CT_SolidColorFillProperties& CT_TableCellProperties::get_solidFill() const
{
    if (m_solidFill)
    {
        return *m_solidFill;
    }
    return CT_SolidColorFillProperties::default_instance();
}

bool CT_TableCellProperties::has_gradFill() const
{
    return m_has_gradFill;
}

CT_GradientFillProperties* CT_TableCellProperties::mutable_gradFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_gradFill = true;
    if (!m_gradFill)
    {
        m_gradFill = new CT_GradientFillProperties();
    }
    return m_gradFill;
}

const CT_GradientFillProperties& CT_TableCellProperties::get_gradFill() const
{
    if (m_gradFill)
    {
        return *m_gradFill;
    }
    return CT_GradientFillProperties::default_instance();
}

bool CT_TableCellProperties::has_blipFill() const
{
    return m_has_blipFill;
}

CT_BlipFillProperties* CT_TableCellProperties::mutable_blipFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_blipFill = true;
    if (!m_blipFill)
    {
        m_blipFill = new CT_BlipFillProperties();
    }
    return m_blipFill;
}

const CT_BlipFillProperties& CT_TableCellProperties::get_blipFill() const
{
    if (m_blipFill)
    {
        return *m_blipFill;
    }
    return CT_BlipFillProperties::default_instance();
}

bool CT_TableCellProperties::has_pattFill() const
{
    return m_has_pattFill;
}

CT_PatternFillProperties* CT_TableCellProperties::mutable_pattFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_pattFill = true;
    if (!m_pattFill)
    {
        m_pattFill = new CT_PatternFillProperties();
    }
    return m_pattFill;
}

const CT_PatternFillProperties& CT_TableCellProperties::get_pattFill() const
{
    if (m_pattFill)
    {
        return *m_pattFill;
    }
    return CT_PatternFillProperties::default_instance();
}

bool CT_TableCellProperties::has_grpFill() const
{
    return m_has_grpFill;
}

CT_GroupFillProperties* CT_TableCellProperties::mutable_grpFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = true;
    if (!m_grpFill)
    {
        m_grpFill = new CT_GroupFillProperties();
    }
    return m_grpFill;
}

const CT_GroupFillProperties& CT_TableCellProperties::get_grpFill() const
{
    if (m_grpFill)
    {
        return *m_grpFill;
    }
    return CT_GroupFillProperties::default_instance();
}

bool CT_TableCellProperties::has_headers() const
{
    return m_has_headers;
}

CT_Headers* CT_TableCellProperties::mutable_headers()
{
    m_has_headers = true;
    if (!m_headers)
    {
        m_headers = new CT_Headers();
    }
    return m_headers;
}

const CT_Headers& CT_TableCellProperties::get_headers() const
{
    if (m_headers)
    {
        return *m_headers;
    }
    return CT_Headers::default_instance();
}

bool CT_TableCellProperties::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_TableCellProperties::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_TableCellProperties::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_TableCellProperties::clear()
{
    m_has_marL_attr = false;

    if (m_marL_attr)
    {
        delete m_marL_attr;
        m_marL_attr = NULL;
    }


    m_has_marR_attr = false;

    if (m_marR_attr)
    {
        delete m_marR_attr;
        m_marR_attr = NULL;
    }


    m_has_marT_attr = false;

    if (m_marT_attr)
    {
        delete m_marT_attr;
        m_marT_attr = NULL;
    }


    m_has_marB_attr = false;

    if (m_marB_attr)
    {
        delete m_marB_attr;
        m_marB_attr = NULL;
    }


    m_has_vert_attr = false;

    if (m_vert_attr)
    {
        delete m_vert_attr;
        m_vert_attr = NULL;
    }


    m_has_anchor_attr = false;

    if (m_anchor_attr)
    {
        delete m_anchor_attr;
        m_anchor_attr = NULL;
    }


    m_has_anchorCtr_attr = false;
    m_anchorCtr_attr = false;

    m_has_horzOverflow_attr = false;

    if (m_horzOverflow_attr)
    {
        delete m_horzOverflow_attr;
        m_horzOverflow_attr = NULL;
    }


    m_has_lnL = false;

    if (m_lnL)
    {
        delete m_lnL;
        m_lnL = NULL;
    }


    m_has_lnR = false;

    if (m_lnR)
    {
        delete m_lnR;
        m_lnR = NULL;
    }


    m_has_lnT = false;

    if (m_lnT)
    {
        delete m_lnT;
        m_lnT = NULL;
    }


    m_has_lnB = false;

    if (m_lnB)
    {
        delete m_lnB;
        m_lnB = NULL;
    }


    m_has_lnTlToBr = false;

    if (m_lnTlToBr)
    {
        delete m_lnTlToBr;
        m_lnTlToBr = NULL;
    }


    m_has_lnBlToTr = false;

    if (m_lnBlToTr)
    {
        delete m_lnBlToTr;
        m_lnBlToTr = NULL;
    }


    m_has_cell3D = false;

    if (m_cell3D)
    {
        delete m_cell3D;
        m_cell3D = NULL;
    }


    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }


    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }


    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }


    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }


    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }


    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }


    m_has_headers = false;

    if (m_headers)
    {
        delete m_headers;
        m_headers = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_TableCellProperties::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_marL_attr)
    {
        m_marL_attr->toXmlAttr("marL", _outStream);
    }



    if (m_has_marR_attr)
    {
        m_marR_attr->toXmlAttr("marR", _outStream);
    }



    if (m_has_marT_attr)
    {
        m_marT_attr->toXmlAttr("marT", _outStream);
    }



    if (m_has_marB_attr)
    {
        m_marB_attr->toXmlAttr("marB", _outStream);
    }



    if (m_has_vert_attr)
    {
        m_vert_attr->toXmlAttr("vert", _outStream);
    }



    if (m_has_anchor_attr)
    {
        m_anchor_attr->toXmlAttr("anchor", _outStream);
    }



    if (m_has_anchorCtr_attr)
    {
        _outStream << " " << "anchorCtr" << "=\"" << XSD::XMLBooleanStr(m_anchorCtr_attr) << "\"";
    }



    if (m_has_horzOverflow_attr)
    {
        m_horzOverflow_attr->toXmlAttr("horzOverflow", _outStream);
    }

    _outStream << ">";


    if (m_has_lnL)
    {
        m_lnL->toXmlElem("a:lnL", "", _outStream);
    }


    if (m_has_lnR)
    {
        m_lnR->toXmlElem("a:lnR", "", _outStream);
    }


    if (m_has_lnT)
    {
        m_lnT->toXmlElem("a:lnT", "", _outStream);
    }


    if (m_has_lnB)
    {
        m_lnB->toXmlElem("a:lnB", "", _outStream);
    }


    if (m_has_lnTlToBr)
    {
        m_lnTlToBr->toXmlElem("a:lnTlToBr", "", _outStream);
    }


    if (m_has_lnBlToTr)
    {
        m_lnBlToTr->toXmlElem("a:lnBlToTr", "", _outStream);
    }


    if (m_has_cell3D)
    {
        m_cell3D->toXmlElem("a:cell3D", "", _outStream);
    }

    {
        bool elemHasValueList[6] = {m_has_noFill, m_has_solidFill, m_has_gradFill, m_has_blipFill, m_has_pattFill, m_has_grpFill};
        int cnt = count(elemHasValueList, elemHasValueList + 6, true);
        assert(cnt == 0 || cnt == 1);
    }


    if (m_has_noFill)
    {
        m_noFill->toXmlElem("a:noFill", "", _outStream);
    }


    if (m_has_solidFill)
    {
        m_solidFill->toXmlElem("a:solidFill", "", _outStream);
    }


    if (m_has_gradFill)
    {
        m_gradFill->toXmlElem("a:gradFill", "", _outStream);
    }


    if (m_has_blipFill)
    {
        m_blipFill->toXmlElem("a:blipFill", "", _outStream);
    }


    if (m_has_pattFill)
    {
        m_pattFill->toXmlElem("a:pattFill", "", _outStream);
    }


    if (m_has_grpFill)
    {
        m_grpFill->toXmlElem("a:grpFill", "", _outStream);
    }


    if (m_has_headers)
    {
        m_headers->toXmlElem("a:headers", "", _outStream);
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_TableCellProperties& CT_TableCellProperties::default_instance()
{
    if (!CT_TableCellProperties::default_instance_)
    {
        CT_TableCellProperties::default_instance_ = new CT_TableCellProperties();
    }
    return *CT_TableCellProperties::default_instance_;
}

bool CT_TableCellProperties::has_marL_attr() const
{
    return m_has_marL_attr;
}

void CT_TableCellProperties::set_marL_attr(const ST_Coordinate32& _marL_attr)
{
    m_has_marL_attr = true;
    m_marL_attr = new ST_Coordinate32(_marL_attr);
}

const ST_Coordinate32& CT_TableCellProperties::get_marL_attr() const
{
    if (m_marL_attr)
    {
        return *m_marL_attr;
    }
    return ST_Coordinate32::default_instance();
}

bool CT_TableCellProperties::has_marR_attr() const
{
    return m_has_marR_attr;
}

void CT_TableCellProperties::set_marR_attr(const ST_Coordinate32& _marR_attr)
{
    m_has_marR_attr = true;
    m_marR_attr = new ST_Coordinate32(_marR_attr);
}

const ST_Coordinate32& CT_TableCellProperties::get_marR_attr() const
{
    if (m_marR_attr)
    {
        return *m_marR_attr;
    }
    return ST_Coordinate32::default_instance();
}

bool CT_TableCellProperties::has_marT_attr() const
{
    return m_has_marT_attr;
}

void CT_TableCellProperties::set_marT_attr(const ST_Coordinate32& _marT_attr)
{
    m_has_marT_attr = true;
    m_marT_attr = new ST_Coordinate32(_marT_attr);
}

const ST_Coordinate32& CT_TableCellProperties::get_marT_attr() const
{
    if (m_marT_attr)
    {
        return *m_marT_attr;
    }
    return ST_Coordinate32::default_instance();
}

bool CT_TableCellProperties::has_marB_attr() const
{
    return m_has_marB_attr;
}

void CT_TableCellProperties::set_marB_attr(const ST_Coordinate32& _marB_attr)
{
    m_has_marB_attr = true;
    m_marB_attr = new ST_Coordinate32(_marB_attr);
}

const ST_Coordinate32& CT_TableCellProperties::get_marB_attr() const
{
    if (m_marB_attr)
    {
        return *m_marB_attr;
    }
    return ST_Coordinate32::default_instance();
}

bool CT_TableCellProperties::has_vert_attr() const
{
    return m_has_vert_attr;
}

void CT_TableCellProperties::set_vert_attr(const ST_TextVerticalType& _vert_attr)
{
    m_has_vert_attr = true;
    m_vert_attr = new ST_TextVerticalType(_vert_attr);
}

const ST_TextVerticalType& CT_TableCellProperties::get_vert_attr() const
{
    if (m_vert_attr)
    {
        return *m_vert_attr;
    }
    return ST_TextVerticalType::default_instance();
}

bool CT_TableCellProperties::has_anchor_attr() const
{
    return m_has_anchor_attr;
}

void CT_TableCellProperties::set_anchor_attr(const ST_TextAnchoringType& _anchor_attr)
{
    m_has_anchor_attr = true;
    m_anchor_attr = new ST_TextAnchoringType(_anchor_attr);
}

const ST_TextAnchoringType& CT_TableCellProperties::get_anchor_attr() const
{
    if (m_anchor_attr)
    {
        return *m_anchor_attr;
    }
    return ST_TextAnchoringType::default_instance();
}

bool CT_TableCellProperties::has_anchorCtr_attr() const
{
    return m_has_anchorCtr_attr;
}

void CT_TableCellProperties::set_anchorCtr_attr(const XSD::boolean_& _anchorCtr_attr)
{
    m_has_anchorCtr_attr = true;
    m_anchorCtr_attr = _anchorCtr_attr;
}

const XSD::boolean_& CT_TableCellProperties::get_anchorCtr_attr() const
{
    return m_anchorCtr_attr;
}

bool CT_TableCellProperties::has_horzOverflow_attr() const
{
    return m_has_horzOverflow_attr;
}

void CT_TableCellProperties::set_horzOverflow_attr(const ST_TextHorzOverflowType& _horzOverflow_attr)
{
    m_has_horzOverflow_attr = true;
    m_horzOverflow_attr = new ST_TextHorzOverflowType(_horzOverflow_attr);
}

const ST_TextHorzOverflowType& CT_TableCellProperties::get_horzOverflow_attr() const
{
    if (m_horzOverflow_attr)
    {
        return *m_horzOverflow_attr;
    }
    return ST_TextHorzOverflowType::default_instance();
}

CT_TableCellProperties* CT_TableCellProperties::default_instance_ = NULL;

// CT_Headers
CT_Headers::CT_Headers()

{
}
CT_Headers::~CT_Headers()
{
    clear();
}
void CT_Headers::add_header(const XSD::string_& _header)
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    pChildGroup->set_header(_header);
    m_childGroupList_1.push_back(pChildGroup);
}

void CT_Headers::clear()
{
    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }
}

void CT_Headers::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_header())
            {
                _outStream << "<a:header>" << (*iter)->get_header() << "</a:header>";
            }


        }
    }

    _outStream << "</" << _elemName << ">";
}

const CT_Headers& CT_Headers::default_instance()
{
    if (!CT_Headers::default_instance_)
    {
        CT_Headers::default_instance_ = new CT_Headers();
    }
    return *CT_Headers::default_instance_;
}


// CT_Headers::ChildGroup_1
CT_Headers::ChildGroup_1::ChildGroup_1()
    :m_has_header(false),
     m_header("")
{
}
bool CT_Headers::ChildGroup_1::has_header() const
{
    return m_has_header;
}

void CT_Headers::ChildGroup_1::set_header(const XSD::string_& _header)
{

    m_has_header = true;
    m_header = _header;
}

const XSD::string_& CT_Headers::ChildGroup_1::get_header() const
{
    return m_header;
}

CT_Headers* CT_Headers::default_instance_ = NULL;

// CT_TableCol
CT_TableCol::CT_TableCol()
    :m_has_extLst(false),
     m_extLst(NULL),
     m_has_w_attr(false),
     m_w_attr(NULL)
{
}
CT_TableCol::~CT_TableCol()
{
    clear();
}
bool CT_TableCol::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_TableCol::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_TableCol::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_TableCol::clear()
{
    m_has_w_attr = false;

    if (m_w_attr)
    {
        delete m_w_attr;
        m_w_attr = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_TableCol::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_w_attr);
    if (m_has_w_attr)
    {
        m_w_attr->toXmlAttr("w", _outStream);
    }

    _outStream << ">";


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_TableCol& CT_TableCol::default_instance()
{
    if (!CT_TableCol::default_instance_)
    {
        CT_TableCol::default_instance_ = new CT_TableCol();
    }
    return *CT_TableCol::default_instance_;
}

bool CT_TableCol::has_w_attr() const
{
    return m_has_w_attr;
}

void CT_TableCol::set_w_attr(const ST_Coordinate& _w_attr)
{
    m_has_w_attr = true;
    m_w_attr = new ST_Coordinate(_w_attr);
}

const ST_Coordinate& CT_TableCol::get_w_attr() const
{
    if (m_w_attr)
    {
        return *m_w_attr;
    }
    return ST_Coordinate::default_instance();
}

CT_TableCol* CT_TableCol::default_instance_ = NULL;

// CT_TableGrid
CT_TableGrid::CT_TableGrid()

{
}
CT_TableGrid::~CT_TableGrid()
{
    clear();
}
CT_TableCol* CT_TableGrid::add_gridCol()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_TableCol* pNewChild = pChildGroup->mutable_gridCol();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

void CT_TableGrid::clear()
{
    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }
}

void CT_TableGrid::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_gridCol())
            {
                (*iter)->get_gridCol().toXmlElem("a:gridCol", "", _outStream);
            }


        }
    }

    _outStream << "</" << _elemName << ">";
}

const CT_TableGrid& CT_TableGrid::default_instance()
{
    if (!CT_TableGrid::default_instance_)
    {
        CT_TableGrid::default_instance_ = new CT_TableGrid();
    }
    return *CT_TableGrid::default_instance_;
}


// CT_TableGrid::ChildGroup_1
CT_TableGrid::ChildGroup_1::ChildGroup_1()
    :m_has_gridCol(false),
     m_gridCol(NULL)
{
}
bool CT_TableGrid::ChildGroup_1::has_gridCol() const
{
    return m_has_gridCol;
}

CT_TableCol* CT_TableGrid::ChildGroup_1::mutable_gridCol()
{

    m_has_gridCol = true;
    if (!m_gridCol)
    {
        m_gridCol = new CT_TableCol();
    }
    return m_gridCol;
}

const CT_TableCol& CT_TableGrid::ChildGroup_1::get_gridCol() const
{
    if (m_gridCol)
    {
        return *m_gridCol;
    }
    return CT_TableCol::default_instance();
}

CT_TableGrid* CT_TableGrid::default_instance_ = NULL;

// CT_TableCell
CT_TableCell::CT_TableCell()
    :m_has_txBody(false),
     m_txBody(NULL),
     m_has_tcPr(false),
     m_tcPr(NULL),
     m_has_extLst(false),
     m_extLst(NULL),
     m_has_rowSpan_attr(false),
     m_rowSpan_attr(0),
     m_has_gridSpan_attr(false),
     m_gridSpan_attr(0),
     m_has_hMerge_attr(false),
     m_hMerge_attr(false),
     m_has_vMerge_attr(false),
     m_vMerge_attr(false),
     m_has_id_attr(false),
     m_id_attr("")
{
}
CT_TableCell::~CT_TableCell()
{
    clear();
}
bool CT_TableCell::has_txBody() const
{
    return m_has_txBody;
}

CT_TextBody* CT_TableCell::mutable_txBody()
{
    m_has_txBody = true;
    if (!m_txBody)
    {
        m_txBody = new CT_TextBody();
    }
    return m_txBody;
}

const CT_TextBody& CT_TableCell::get_txBody() const
{
    if (m_txBody)
    {
        return *m_txBody;
    }
    return CT_TextBody::default_instance();
}

bool CT_TableCell::has_tcPr() const
{
    return m_has_tcPr;
}

CT_TableCellProperties* CT_TableCell::mutable_tcPr()
{
    m_has_tcPr = true;
    if (!m_tcPr)
    {
        m_tcPr = new CT_TableCellProperties();
    }
    return m_tcPr;
}

const CT_TableCellProperties& CT_TableCell::get_tcPr() const
{
    if (m_tcPr)
    {
        return *m_tcPr;
    }
    return CT_TableCellProperties::default_instance();
}

bool CT_TableCell::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_TableCell::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_TableCell::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_TableCell::clear()
{
    m_has_rowSpan_attr = false;
    m_rowSpan_attr = 0;

    m_has_gridSpan_attr = false;
    m_gridSpan_attr = 0;

    m_has_hMerge_attr = false;
    m_hMerge_attr = false;

    m_has_vMerge_attr = false;
    m_vMerge_attr = false;

    m_has_id_attr = false;
    m_id_attr.clear();

    m_has_txBody = false;

    if (m_txBody)
    {
        delete m_txBody;
        m_txBody = NULL;
    }


    m_has_tcPr = false;

    if (m_tcPr)
    {
        delete m_tcPr;
        m_tcPr = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_TableCell::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_rowSpan_attr)
    {
        _outStream << " " << "rowSpan" << "=\"" << m_rowSpan_attr << "\"";
    }



    if (m_has_gridSpan_attr)
    {
        _outStream << " " << "gridSpan" << "=\"" << m_gridSpan_attr << "\"";
    }



    if (m_has_hMerge_attr)
    {
        _outStream << " " << "hMerge" << "=\"" << XSD::XMLBooleanStr(m_hMerge_attr) << "\"";
    }



    if (m_has_vMerge_attr)
    {
        _outStream << " " << "vMerge" << "=\"" << XSD::XMLBooleanStr(m_vMerge_attr) << "\"";
    }



    if (m_has_id_attr)
    {
        _outStream << " " << "id" << "=\"" << m_id_attr << "\"";
    }

    _outStream << ">";


    if (m_has_txBody)
    {
        m_txBody->toXmlElem("a:txBody", "", _outStream);
    }


    if (m_has_tcPr)
    {
        m_tcPr->toXmlElem("a:tcPr", "", _outStream);
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_TableCell& CT_TableCell::default_instance()
{
    if (!CT_TableCell::default_instance_)
    {
        CT_TableCell::default_instance_ = new CT_TableCell();
    }
    return *CT_TableCell::default_instance_;
}

bool CT_TableCell::has_rowSpan_attr() const
{
    return m_has_rowSpan_attr;
}

void CT_TableCell::set_rowSpan_attr(const XSD::int_& _rowSpan_attr)
{
    m_has_rowSpan_attr = true;
    m_rowSpan_attr = _rowSpan_attr;
}

const XSD::int_& CT_TableCell::get_rowSpan_attr() const
{
    return m_rowSpan_attr;
}

bool CT_TableCell::has_gridSpan_attr() const
{
    return m_has_gridSpan_attr;
}

void CT_TableCell::set_gridSpan_attr(const XSD::int_& _gridSpan_attr)
{
    m_has_gridSpan_attr = true;
    m_gridSpan_attr = _gridSpan_attr;
}

const XSD::int_& CT_TableCell::get_gridSpan_attr() const
{
    return m_gridSpan_attr;
}

bool CT_TableCell::has_hMerge_attr() const
{
    return m_has_hMerge_attr;
}

void CT_TableCell::set_hMerge_attr(const XSD::boolean_& _hMerge_attr)
{
    m_has_hMerge_attr = true;
    m_hMerge_attr = _hMerge_attr;
}

const XSD::boolean_& CT_TableCell::get_hMerge_attr() const
{
    return m_hMerge_attr;
}

bool CT_TableCell::has_vMerge_attr() const
{
    return m_has_vMerge_attr;
}

void CT_TableCell::set_vMerge_attr(const XSD::boolean_& _vMerge_attr)
{
    m_has_vMerge_attr = true;
    m_vMerge_attr = _vMerge_attr;
}

const XSD::boolean_& CT_TableCell::get_vMerge_attr() const
{
    return m_vMerge_attr;
}

bool CT_TableCell::has_id_attr() const
{
    return m_has_id_attr;
}

void CT_TableCell::set_id_attr(const XSD::string_& _id_attr)
{
    m_has_id_attr = true;
    m_id_attr = _id_attr;
}

const XSD::string_& CT_TableCell::get_id_attr() const
{
    return m_id_attr;
}

CT_TableCell* CT_TableCell::default_instance_ = NULL;

// CT_TableRow
CT_TableRow::CT_TableRow()
    :m_has_extLst(false),
     m_extLst(NULL),
     m_has_h_attr(false),
     m_h_attr(NULL)
{
}
CT_TableRow::~CT_TableRow()
{
    clear();
}
CT_TableCell* CT_TableRow::add_tc()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_TableCell* pNewChild = pChildGroup->mutable_tc();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

bool CT_TableRow::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_TableRow::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_TableRow::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_TableRow::clear()
{
    m_has_h_attr = false;

    if (m_h_attr)
    {
        delete m_h_attr;
        m_h_attr = NULL;
    }


    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }

    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_TableRow::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_h_attr);
    if (m_has_h_attr)
    {
        m_h_attr->toXmlAttr("h", _outStream);
    }

    _outStream << ">";

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_tc())
            {
                (*iter)->get_tc().toXmlElem("a:tc", "", _outStream);
            }


        }
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_TableRow& CT_TableRow::default_instance()
{
    if (!CT_TableRow::default_instance_)
    {
        CT_TableRow::default_instance_ = new CT_TableRow();
    }
    return *CT_TableRow::default_instance_;
}

bool CT_TableRow::has_h_attr() const
{
    return m_has_h_attr;
}

void CT_TableRow::set_h_attr(const ST_Coordinate& _h_attr)
{
    m_has_h_attr = true;
    m_h_attr = new ST_Coordinate(_h_attr);
}

const ST_Coordinate& CT_TableRow::get_h_attr() const
{
    if (m_h_attr)
    {
        return *m_h_attr;
    }
    return ST_Coordinate::default_instance();
}


// CT_TableRow::ChildGroup_1
CT_TableRow::ChildGroup_1::ChildGroup_1()
    :m_has_tc(false),
     m_tc(NULL)
{
}
bool CT_TableRow::ChildGroup_1::has_tc() const
{
    return m_has_tc;
}

CT_TableCell* CT_TableRow::ChildGroup_1::mutable_tc()
{

    m_has_tc = true;
    if (!m_tc)
    {
        m_tc = new CT_TableCell();
    }
    return m_tc;
}

const CT_TableCell& CT_TableRow::ChildGroup_1::get_tc() const
{
    if (m_tc)
    {
        return *m_tc;
    }
    return CT_TableCell::default_instance();
}

CT_TableRow* CT_TableRow::default_instance_ = NULL;

// CT_TableProperties
CT_TableProperties::CT_TableProperties()
    :m_has_noFill(false),
     m_noFill(NULL),
     m_has_solidFill(false),
     m_solidFill(NULL),
     m_has_gradFill(false),
     m_gradFill(NULL),
     m_has_blipFill(false),
     m_blipFill(NULL),
     m_has_pattFill(false),
     m_pattFill(NULL),
     m_has_grpFill(false),
     m_grpFill(NULL),
     m_has_effectLst(false),
     m_effectLst(NULL),
     m_has_effectDag(false),
     m_effectDag(NULL),
     m_has_tableStyle(false),
     m_tableStyle(NULL),
     m_has_tableStyleId(false),
     m_tableStyleId(NULL),
     m_has_extLst(false),
     m_extLst(NULL),
     m_has_rtl_attr(false),
     m_rtl_attr(false),
     m_has_firstRow_attr(false),
     m_firstRow_attr(false),
     m_has_firstCol_attr(false),
     m_firstCol_attr(false),
     m_has_lastRow_attr(false),
     m_lastRow_attr(false),
     m_has_lastCol_attr(false),
     m_lastCol_attr(false),
     m_has_bandRow_attr(false),
     m_bandRow_attr(false),
     m_has_bandCol_attr(false),
     m_bandCol_attr(false)
{
}
CT_TableProperties::~CT_TableProperties()
{
    clear();
}
bool CT_TableProperties::has_noFill() const
{
    return m_has_noFill;
}

CT_NoFillProperties* CT_TableProperties::mutable_noFill()
{

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_noFill = true;
    if (!m_noFill)
    {
        m_noFill = new CT_NoFillProperties();
    }
    return m_noFill;
}

const CT_NoFillProperties& CT_TableProperties::get_noFill() const
{
    if (m_noFill)
    {
        return *m_noFill;
    }
    return CT_NoFillProperties::default_instance();
}

bool CT_TableProperties::has_solidFill() const
{
    return m_has_solidFill;
}

CT_SolidColorFillProperties* CT_TableProperties::mutable_solidFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_solidFill = true;
    if (!m_solidFill)
    {
        m_solidFill = new CT_SolidColorFillProperties();
    }
    return m_solidFill;
}

const CT_SolidColorFillProperties& CT_TableProperties::get_solidFill() const
{
    if (m_solidFill)
    {
        return *m_solidFill;
    }
    return CT_SolidColorFillProperties::default_instance();
}

bool CT_TableProperties::has_gradFill() const
{
    return m_has_gradFill;
}

CT_GradientFillProperties* CT_TableProperties::mutable_gradFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_gradFill = true;
    if (!m_gradFill)
    {
        m_gradFill = new CT_GradientFillProperties();
    }
    return m_gradFill;
}

const CT_GradientFillProperties& CT_TableProperties::get_gradFill() const
{
    if (m_gradFill)
    {
        return *m_gradFill;
    }
    return CT_GradientFillProperties::default_instance();
}

bool CT_TableProperties::has_blipFill() const
{
    return m_has_blipFill;
}

CT_BlipFillProperties* CT_TableProperties::mutable_blipFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_blipFill = true;
    if (!m_blipFill)
    {
        m_blipFill = new CT_BlipFillProperties();
    }
    return m_blipFill;
}

const CT_BlipFillProperties& CT_TableProperties::get_blipFill() const
{
    if (m_blipFill)
    {
        return *m_blipFill;
    }
    return CT_BlipFillProperties::default_instance();
}

bool CT_TableProperties::has_pattFill() const
{
    return m_has_pattFill;
}

CT_PatternFillProperties* CT_TableProperties::mutable_pattFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_pattFill = true;
    if (!m_pattFill)
    {
        m_pattFill = new CT_PatternFillProperties();
    }
    return m_pattFill;
}

const CT_PatternFillProperties& CT_TableProperties::get_pattFill() const
{
    if (m_pattFill)
    {
        return *m_pattFill;
    }
    return CT_PatternFillProperties::default_instance();
}

bool CT_TableProperties::has_grpFill() const
{
    return m_has_grpFill;
}

CT_GroupFillProperties* CT_TableProperties::mutable_grpFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = true;
    if (!m_grpFill)
    {
        m_grpFill = new CT_GroupFillProperties();
    }
    return m_grpFill;
}

const CT_GroupFillProperties& CT_TableProperties::get_grpFill() const
{
    if (m_grpFill)
    {
        return *m_grpFill;
    }
    return CT_GroupFillProperties::default_instance();
}

bool CT_TableProperties::has_effectLst() const
{
    return m_has_effectLst;
}

CT_EffectList* CT_TableProperties::mutable_effectLst()
{

    m_has_effectDag = false;

    if (m_effectDag)
    {
        delete m_effectDag;
        m_effectDag = NULL;
    }
    ;

    m_has_tableStyle = false;

    if (m_tableStyle)
    {
        delete m_tableStyle;
        m_tableStyle = NULL;
    }
    ;

    m_has_tableStyleId = false;

    if (m_tableStyleId)
    {
        delete m_tableStyleId;
        m_tableStyleId = NULL;
    }
    ;

    m_has_effectLst = true;
    if (!m_effectLst)
    {
        m_effectLst = new CT_EffectList();
    }
    return m_effectLst;
}

const CT_EffectList& CT_TableProperties::get_effectLst() const
{
    if (m_effectLst)
    {
        return *m_effectLst;
    }
    return CT_EffectList::default_instance();
}

bool CT_TableProperties::has_effectDag() const
{
    return m_has_effectDag;
}

CT_EffectContainer* CT_TableProperties::mutable_effectDag()
{

    m_has_effectLst = false;

    if (m_effectLst)
    {
        delete m_effectLst;
        m_effectLst = NULL;
    }
    ;

    m_has_tableStyle = false;

    if (m_tableStyle)
    {
        delete m_tableStyle;
        m_tableStyle = NULL;
    }
    ;

    m_has_tableStyleId = false;

    if (m_tableStyleId)
    {
        delete m_tableStyleId;
        m_tableStyleId = NULL;
    }
    ;

    m_has_effectDag = true;
    if (!m_effectDag)
    {
        m_effectDag = new CT_EffectContainer();
    }
    return m_effectDag;
}

const CT_EffectContainer& CT_TableProperties::get_effectDag() const
{
    if (m_effectDag)
    {
        return *m_effectDag;
    }
    return CT_EffectContainer::default_instance();
}

bool CT_TableProperties::has_tableStyle() const
{
    return m_has_tableStyle;
}

CT_TableStyle* CT_TableProperties::mutable_tableStyle()
{

    m_has_effectLst = false;

    if (m_effectLst)
    {
        delete m_effectLst;
        m_effectLst = NULL;
    }
    ;

    m_has_effectDag = false;

    if (m_effectDag)
    {
        delete m_effectDag;
        m_effectDag = NULL;
    }
    ;

    m_has_tableStyleId = false;

    if (m_tableStyleId)
    {
        delete m_tableStyleId;
        m_tableStyleId = NULL;
    }
    ;

    m_has_tableStyle = true;
    if (!m_tableStyle)
    {
        m_tableStyle = new CT_TableStyle();
    }
    return m_tableStyle;
}

const CT_TableStyle& CT_TableProperties::get_tableStyle() const
{
    if (m_tableStyle)
    {
        return *m_tableStyle;
    }
    return CT_TableStyle::default_instance();
}

bool CT_TableProperties::has_tableStyleId() const
{
    return m_has_tableStyleId;
}

ns_s::ST_Guid* CT_TableProperties::mutable_tableStyleId()
{

    m_has_effectLst = false;

    if (m_effectLst)
    {
        delete m_effectLst;
        m_effectLst = NULL;
    }
    ;

    m_has_effectDag = false;

    if (m_effectDag)
    {
        delete m_effectDag;
        m_effectDag = NULL;
    }
    ;

    m_has_tableStyle = false;

    if (m_tableStyle)
    {
        delete m_tableStyle;
        m_tableStyle = NULL;
    }
    ;

    m_has_tableStyleId = true;
    if (!m_tableStyleId)
    {
        m_tableStyleId = new ns_s::ST_Guid();
    }
    return m_tableStyleId;
}

const ns_s::ST_Guid& CT_TableProperties::get_tableStyleId() const
{
    if (m_tableStyleId)
    {
        return *m_tableStyleId;
    }
    return ns_s::ST_Guid::default_instance();
}

bool CT_TableProperties::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_TableProperties::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_TableProperties::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_TableProperties::clear()
{
    m_has_rtl_attr = false;
    m_rtl_attr = false;

    m_has_firstRow_attr = false;
    m_firstRow_attr = false;

    m_has_firstCol_attr = false;
    m_firstCol_attr = false;

    m_has_lastRow_attr = false;
    m_lastRow_attr = false;

    m_has_lastCol_attr = false;
    m_lastCol_attr = false;

    m_has_bandRow_attr = false;
    m_bandRow_attr = false;

    m_has_bandCol_attr = false;
    m_bandCol_attr = false;

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }


    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }


    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }


    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }


    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }


    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }


    m_has_effectLst = false;

    if (m_effectLst)
    {
        delete m_effectLst;
        m_effectLst = NULL;
    }


    m_has_effectDag = false;

    if (m_effectDag)
    {
        delete m_effectDag;
        m_effectDag = NULL;
    }


    m_has_tableStyle = false;

    if (m_tableStyle)
    {
        delete m_tableStyle;
        m_tableStyle = NULL;
    }


    m_has_tableStyleId = false;

    if (m_tableStyleId)
    {
        delete m_tableStyleId;
        m_tableStyleId = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_TableProperties::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_rtl_attr)
    {
        _outStream << " " << "rtl" << "=\"" << XSD::XMLBooleanStr(m_rtl_attr) << "\"";
    }



    if (m_has_firstRow_attr)
    {
        _outStream << " " << "firstRow" << "=\"" << XSD::XMLBooleanStr(m_firstRow_attr) << "\"";
    }



    if (m_has_firstCol_attr)
    {
        _outStream << " " << "firstCol" << "=\"" << XSD::XMLBooleanStr(m_firstCol_attr) << "\"";
    }



    if (m_has_lastRow_attr)
    {
        _outStream << " " << "lastRow" << "=\"" << XSD::XMLBooleanStr(m_lastRow_attr) << "\"";
    }



    if (m_has_lastCol_attr)
    {
        _outStream << " " << "lastCol" << "=\"" << XSD::XMLBooleanStr(m_lastCol_attr) << "\"";
    }



    if (m_has_bandRow_attr)
    {
        _outStream << " " << "bandRow" << "=\"" << XSD::XMLBooleanStr(m_bandRow_attr) << "\"";
    }



    if (m_has_bandCol_attr)
    {
        _outStream << " " << "bandCol" << "=\"" << XSD::XMLBooleanStr(m_bandCol_attr) << "\"";
    }

    _outStream << ">";

    {
        bool elemHasValueList[6] = {m_has_noFill, m_has_solidFill, m_has_gradFill, m_has_blipFill, m_has_pattFill, m_has_grpFill};
        int cnt = count(elemHasValueList, elemHasValueList + 6, true);
        assert(cnt == 0 || cnt == 1);
    }


    if (m_has_noFill)
    {
        m_noFill->toXmlElem("a:noFill", "", _outStream);
    }


    if (m_has_solidFill)
    {
        m_solidFill->toXmlElem("a:solidFill", "", _outStream);
    }


    if (m_has_gradFill)
    {
        m_gradFill->toXmlElem("a:gradFill", "", _outStream);
    }


    if (m_has_blipFill)
    {
        m_blipFill->toXmlElem("a:blipFill", "", _outStream);
    }


    if (m_has_pattFill)
    {
        m_pattFill->toXmlElem("a:pattFill", "", _outStream);
    }


    if (m_has_grpFill)
    {
        m_grpFill->toXmlElem("a:grpFill", "", _outStream);
    }

    {
        bool elemHasValueList[4] = {m_has_effectLst, m_has_effectDag, m_has_tableStyle, m_has_tableStyleId};
        int cnt = count(elemHasValueList, elemHasValueList + 4, true);
        assert(cnt == 0 || cnt == 1);
    }


    if (m_has_effectLst)
    {
        m_effectLst->toXmlElem("a:effectLst", "", _outStream);
    }


    if (m_has_effectDag)
    {
        m_effectDag->toXmlElem("a:effectDag", "", _outStream);
    }


    if (m_has_tableStyle)
    {
        m_tableStyle->toXmlElem("a:tableStyle", "", _outStream);
    }


    if (m_has_tableStyleId)
    {
        _outStream << "<a:tableStyleId>" << m_tableStyleId->toString() << "</a:tableStyleId>";
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_TableProperties& CT_TableProperties::default_instance()
{
    if (!CT_TableProperties::default_instance_)
    {
        CT_TableProperties::default_instance_ = new CT_TableProperties();
    }
    return *CT_TableProperties::default_instance_;
}

bool CT_TableProperties::has_rtl_attr() const
{
    return m_has_rtl_attr;
}

void CT_TableProperties::set_rtl_attr(const XSD::boolean_& _rtl_attr)
{
    m_has_rtl_attr = true;
    m_rtl_attr = _rtl_attr;
}

const XSD::boolean_& CT_TableProperties::get_rtl_attr() const
{
    return m_rtl_attr;
}

bool CT_TableProperties::has_firstRow_attr() const
{
    return m_has_firstRow_attr;
}

void CT_TableProperties::set_firstRow_attr(const XSD::boolean_& _firstRow_attr)
{
    m_has_firstRow_attr = true;
    m_firstRow_attr = _firstRow_attr;
}

const XSD::boolean_& CT_TableProperties::get_firstRow_attr() const
{
    return m_firstRow_attr;
}

bool CT_TableProperties::has_firstCol_attr() const
{
    return m_has_firstCol_attr;
}

void CT_TableProperties::set_firstCol_attr(const XSD::boolean_& _firstCol_attr)
{
    m_has_firstCol_attr = true;
    m_firstCol_attr = _firstCol_attr;
}

const XSD::boolean_& CT_TableProperties::get_firstCol_attr() const
{
    return m_firstCol_attr;
}

bool CT_TableProperties::has_lastRow_attr() const
{
    return m_has_lastRow_attr;
}

void CT_TableProperties::set_lastRow_attr(const XSD::boolean_& _lastRow_attr)
{
    m_has_lastRow_attr = true;
    m_lastRow_attr = _lastRow_attr;
}

const XSD::boolean_& CT_TableProperties::get_lastRow_attr() const
{
    return m_lastRow_attr;
}

bool CT_TableProperties::has_lastCol_attr() const
{
    return m_has_lastCol_attr;
}

void CT_TableProperties::set_lastCol_attr(const XSD::boolean_& _lastCol_attr)
{
    m_has_lastCol_attr = true;
    m_lastCol_attr = _lastCol_attr;
}

const XSD::boolean_& CT_TableProperties::get_lastCol_attr() const
{
    return m_lastCol_attr;
}

bool CT_TableProperties::has_bandRow_attr() const
{
    return m_has_bandRow_attr;
}

void CT_TableProperties::set_bandRow_attr(const XSD::boolean_& _bandRow_attr)
{
    m_has_bandRow_attr = true;
    m_bandRow_attr = _bandRow_attr;
}

const XSD::boolean_& CT_TableProperties::get_bandRow_attr() const
{
    return m_bandRow_attr;
}

bool CT_TableProperties::has_bandCol_attr() const
{
    return m_has_bandCol_attr;
}

void CT_TableProperties::set_bandCol_attr(const XSD::boolean_& _bandCol_attr)
{
    m_has_bandCol_attr = true;
    m_bandCol_attr = _bandCol_attr;
}

const XSD::boolean_& CT_TableProperties::get_bandCol_attr() const
{
    return m_bandCol_attr;
}

CT_TableProperties* CT_TableProperties::default_instance_ = NULL;

// CT_Table
CT_Table::CT_Table()
    :m_has_tblPr(false),
     m_tblPr(NULL),
     m_has_tblGrid(false),
     m_tblGrid(NULL)
{
}
CT_Table::~CT_Table()
{
    clear();
}
bool CT_Table::has_tblPr() const
{
    return m_has_tblPr;
}

CT_TableProperties* CT_Table::mutable_tblPr()
{
    m_has_tblPr = true;
    if (!m_tblPr)
    {
        m_tblPr = new CT_TableProperties();
    }
    return m_tblPr;
}

const CT_TableProperties& CT_Table::get_tblPr() const
{
    if (m_tblPr)
    {
        return *m_tblPr;
    }
    return CT_TableProperties::default_instance();
}

bool CT_Table::has_tblGrid() const
{
    return m_has_tblGrid;
}

CT_TableGrid* CT_Table::mutable_tblGrid()
{
    m_has_tblGrid = true;
    if (!m_tblGrid)
    {
        m_tblGrid = new CT_TableGrid();
    }
    return m_tblGrid;
}

const CT_TableGrid& CT_Table::get_tblGrid() const
{
    if (m_tblGrid)
    {
        return *m_tblGrid;
    }
    return CT_TableGrid::default_instance();
}

CT_TableRow* CT_Table::add_tr()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_TableRow* pNewChild = pChildGroup->mutable_tr();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

void CT_Table::clear()
{
    m_has_tblPr = false;

    if (m_tblPr)
    {
        delete m_tblPr;
        m_tblPr = NULL;
    }


    m_has_tblGrid = false;

    if (m_tblGrid)
    {
        delete m_tblGrid;
        m_tblGrid = NULL;
    }


    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }
}

void CT_Table::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    assert(m_has_tblGrid);


    if (m_has_tblPr)
    {
        m_tblPr->toXmlElem("a:tblPr", "", _outStream);
    }


    if (m_has_tblGrid)
    {
        m_tblGrid->toXmlElem("a:tblGrid", "", _outStream);
    }

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_tr())
            {
                (*iter)->get_tr().toXmlElem("a:tr", "", _outStream);
            }


        }
    }

    _outStream << "</" << _elemName << ">";
}

const CT_Table& CT_Table::default_instance()
{
    if (!CT_Table::default_instance_)
    {
        CT_Table::default_instance_ = new CT_Table();
    }
    return *CT_Table::default_instance_;
}


// CT_Table::ChildGroup_1
CT_Table::ChildGroup_1::ChildGroup_1()
    :m_has_tr(false),
     m_tr(NULL)
{
}
bool CT_Table::ChildGroup_1::has_tr() const
{
    return m_has_tr;
}

CT_TableRow* CT_Table::ChildGroup_1::mutable_tr()
{

    m_has_tr = true;
    if (!m_tr)
    {
        m_tr = new CT_TableRow();
    }
    return m_tr;
}

const CT_TableRow& CT_Table::ChildGroup_1::get_tr() const
{
    if (m_tr)
    {
        return *m_tr;
    }
    return CT_TableRow::default_instance();
}

CT_Table* CT_Table::default_instance_ = NULL;

// CT_Cell3D
CT_Cell3D::CT_Cell3D()
    :m_has_bevel(false),
     m_bevel(NULL),
     m_has_lightRig(false),
     m_lightRig(NULL),
     m_has_extLst(false),
     m_extLst(NULL),
     m_has_prstMaterial_attr(false),
     m_prstMaterial_attr(NULL)
{
}
CT_Cell3D::~CT_Cell3D()
{
    clear();
}
bool CT_Cell3D::has_bevel() const
{
    return m_has_bevel;
}

CT_Bevel* CT_Cell3D::mutable_bevel()
{
    m_has_bevel = true;
    if (!m_bevel)
    {
        m_bevel = new CT_Bevel();
    }
    return m_bevel;
}

const CT_Bevel& CT_Cell3D::get_bevel() const
{
    if (m_bevel)
    {
        return *m_bevel;
    }
    return CT_Bevel::default_instance();
}

bool CT_Cell3D::has_lightRig() const
{
    return m_has_lightRig;
}

CT_LightRig* CT_Cell3D::mutable_lightRig()
{
    m_has_lightRig = true;
    if (!m_lightRig)
    {
        m_lightRig = new CT_LightRig();
    }
    return m_lightRig;
}

const CT_LightRig& CT_Cell3D::get_lightRig() const
{
    if (m_lightRig)
    {
        return *m_lightRig;
    }
    return CT_LightRig::default_instance();
}

bool CT_Cell3D::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_Cell3D::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_Cell3D::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_Cell3D::clear()
{
    m_has_prstMaterial_attr = false;

    if (m_prstMaterial_attr)
    {
        delete m_prstMaterial_attr;
        m_prstMaterial_attr = NULL;
    }


    m_has_bevel = false;

    if (m_bevel)
    {
        delete m_bevel;
        m_bevel = NULL;
    }


    m_has_lightRig = false;

    if (m_lightRig)
    {
        delete m_lightRig;
        m_lightRig = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_Cell3D::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_prstMaterial_attr)
    {
        m_prstMaterial_attr->toXmlAttr("prstMaterial", _outStream);
    }

    _outStream << ">";

    assert(m_has_bevel);


    if (m_has_bevel)
    {
        m_bevel->toXmlElem("a:bevel", "", _outStream);
    }


    if (m_has_lightRig)
    {
        m_lightRig->toXmlElem("a:lightRig", "", _outStream);
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_Cell3D& CT_Cell3D::default_instance()
{
    if (!CT_Cell3D::default_instance_)
    {
        CT_Cell3D::default_instance_ = new CT_Cell3D();
    }
    return *CT_Cell3D::default_instance_;
}

bool CT_Cell3D::has_prstMaterial_attr() const
{
    return m_has_prstMaterial_attr;
}

void CT_Cell3D::set_prstMaterial_attr(const ST_PresetMaterialType& _prstMaterial_attr)
{
    m_has_prstMaterial_attr = true;
    m_prstMaterial_attr = new ST_PresetMaterialType(_prstMaterial_attr);
}

const ST_PresetMaterialType& CT_Cell3D::get_prstMaterial_attr() const
{
    if (m_prstMaterial_attr)
    {
        return *m_prstMaterial_attr;
    }
    return ST_PresetMaterialType::default_instance();
}

CT_Cell3D* CT_Cell3D::default_instance_ = NULL;

// CT_ThemeableLineStyle
CT_ThemeableLineStyle::CT_ThemeableLineStyle()
    :m_has_ln(false),
     m_ln(NULL),
     m_has_lnRef(false),
     m_lnRef(NULL)
{
}
CT_ThemeableLineStyle::~CT_ThemeableLineStyle()
{
    clear();
}
bool CT_ThemeableLineStyle::has_ln() const
{
    return m_has_ln;
}

CT_LineProperties* CT_ThemeableLineStyle::mutable_ln()
{

    m_has_lnRef = false;

    if (m_lnRef)
    {
        delete m_lnRef;
        m_lnRef = NULL;
    }
    ;

    m_has_ln = true;
    if (!m_ln)
    {
        m_ln = new CT_LineProperties();
    }
    return m_ln;
}

const CT_LineProperties& CT_ThemeableLineStyle::get_ln() const
{
    if (m_ln)
    {
        return *m_ln;
    }
    return CT_LineProperties::default_instance();
}

bool CT_ThemeableLineStyle::has_lnRef() const
{
    return m_has_lnRef;
}

CT_StyleMatrixReference* CT_ThemeableLineStyle::mutable_lnRef()
{

    m_has_ln = false;

    if (m_ln)
    {
        delete m_ln;
        m_ln = NULL;
    }
    ;

    m_has_lnRef = true;
    if (!m_lnRef)
    {
        m_lnRef = new CT_StyleMatrixReference();
    }
    return m_lnRef;
}

const CT_StyleMatrixReference& CT_ThemeableLineStyle::get_lnRef() const
{
    if (m_lnRef)
    {
        return *m_lnRef;
    }
    return CT_StyleMatrixReference::default_instance();
}

void CT_ThemeableLineStyle::clear()
{
    m_has_ln = false;

    if (m_ln)
    {
        delete m_ln;
        m_ln = NULL;
    }


    m_has_lnRef = false;

    if (m_lnRef)
    {
        delete m_lnRef;
        m_lnRef = NULL;
    }

}

void CT_ThemeableLineStyle::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    {
        bool elemHasValueList[2] = {m_has_ln, m_has_lnRef};
        int cnt = count(elemHasValueList, elemHasValueList + 2, true);
        assert(cnt == 1);
    }


    if (m_has_ln)
    {
        m_ln->toXmlElem("a:ln", "", _outStream);
    }


    if (m_has_lnRef)
    {
        m_lnRef->toXmlElem("a:lnRef", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_ThemeableLineStyle& CT_ThemeableLineStyle::default_instance()
{
    if (!CT_ThemeableLineStyle::default_instance_)
    {
        CT_ThemeableLineStyle::default_instance_ = new CT_ThemeableLineStyle();
    }
    return *CT_ThemeableLineStyle::default_instance_;
}

CT_ThemeableLineStyle* CT_ThemeableLineStyle::default_instance_ = NULL;

// CT_TableStyleTextStyle
CT_TableStyleTextStyle::CT_TableStyleTextStyle()
    :m_has_font(false),
     m_font(NULL),
     m_has_fontRef(false),
     m_fontRef(NULL),
     m_has_scrgbClr(false),
     m_scrgbClr(NULL),
     m_has_srgbClr(false),
     m_srgbClr(NULL),
     m_has_hslClr(false),
     m_hslClr(NULL),
     m_has_sysClr(false),
     m_sysClr(NULL),
     m_has_schemeClr(false),
     m_schemeClr(NULL),
     m_has_prstClr(false),
     m_prstClr(NULL),
     m_has_extLst(false),
     m_extLst(NULL),
     m_has_b_attr(false),
     m_b_attr(NULL),
     m_has_i_attr(false),
     m_i_attr(NULL)
{
}
CT_TableStyleTextStyle::~CT_TableStyleTextStyle()
{
    clear();
}
bool CT_TableStyleTextStyle::has_font() const
{
    return m_has_font;
}

CT_FontCollection* CT_TableStyleTextStyle::mutable_font()
{

    m_has_fontRef = false;

    if (m_fontRef)
    {
        delete m_fontRef;
        m_fontRef = NULL;
    }
    ;

    m_has_font = true;
    if (!m_font)
    {
        m_font = new CT_FontCollection();
    }
    return m_font;
}

const CT_FontCollection& CT_TableStyleTextStyle::get_font() const
{
    if (m_font)
    {
        return *m_font;
    }
    return CT_FontCollection::default_instance();
}

bool CT_TableStyleTextStyle::has_fontRef() const
{
    return m_has_fontRef;
}

CT_FontReference* CT_TableStyleTextStyle::mutable_fontRef()
{

    m_has_font = false;

    if (m_font)
    {
        delete m_font;
        m_font = NULL;
    }
    ;

    m_has_fontRef = true;
    if (!m_fontRef)
    {
        m_fontRef = new CT_FontReference();
    }
    return m_fontRef;
}

const CT_FontReference& CT_TableStyleTextStyle::get_fontRef() const
{
    if (m_fontRef)
    {
        return *m_fontRef;
    }
    return CT_FontReference::default_instance();
}

bool CT_TableStyleTextStyle::has_scrgbClr() const
{
    return m_has_scrgbClr;
}

CT_ScRgbColor* CT_TableStyleTextStyle::mutable_scrgbClr()
{

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_scrgbClr = true;
    if (!m_scrgbClr)
    {
        m_scrgbClr = new CT_ScRgbColor();
    }
    return m_scrgbClr;
}

const CT_ScRgbColor& CT_TableStyleTextStyle::get_scrgbClr() const
{
    if (m_scrgbClr)
    {
        return *m_scrgbClr;
    }
    return CT_ScRgbColor::default_instance();
}

bool CT_TableStyleTextStyle::has_srgbClr() const
{
    return m_has_srgbClr;
}

CT_SRgbColor* CT_TableStyleTextStyle::mutable_srgbClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_srgbClr = true;
    if (!m_srgbClr)
    {
        m_srgbClr = new CT_SRgbColor();
    }
    return m_srgbClr;
}

const CT_SRgbColor& CT_TableStyleTextStyle::get_srgbClr() const
{
    if (m_srgbClr)
    {
        return *m_srgbClr;
    }
    return CT_SRgbColor::default_instance();
}

bool CT_TableStyleTextStyle::has_hslClr() const
{
    return m_has_hslClr;
}

CT_HslColor* CT_TableStyleTextStyle::mutable_hslClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_hslClr = true;
    if (!m_hslClr)
    {
        m_hslClr = new CT_HslColor();
    }
    return m_hslClr;
}

const CT_HslColor& CT_TableStyleTextStyle::get_hslClr() const
{
    if (m_hslClr)
    {
        return *m_hslClr;
    }
    return CT_HslColor::default_instance();
}

bool CT_TableStyleTextStyle::has_sysClr() const
{
    return m_has_sysClr;
}

CT_SystemColor* CT_TableStyleTextStyle::mutable_sysClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_sysClr = true;
    if (!m_sysClr)
    {
        m_sysClr = new CT_SystemColor();
    }
    return m_sysClr;
}

const CT_SystemColor& CT_TableStyleTextStyle::get_sysClr() const
{
    if (m_sysClr)
    {
        return *m_sysClr;
    }
    return CT_SystemColor::default_instance();
}

bool CT_TableStyleTextStyle::has_schemeClr() const
{
    return m_has_schemeClr;
}

CT_SchemeColor* CT_TableStyleTextStyle::mutable_schemeClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }
    ;

    m_has_schemeClr = true;
    if (!m_schemeClr)
    {
        m_schemeClr = new CT_SchemeColor();
    }
    return m_schemeClr;
}

const CT_SchemeColor& CT_TableStyleTextStyle::get_schemeClr() const
{
    if (m_schemeClr)
    {
        return *m_schemeClr;
    }
    return CT_SchemeColor::default_instance();
}

bool CT_TableStyleTextStyle::has_prstClr() const
{
    return m_has_prstClr;
}

CT_PresetColor* CT_TableStyleTextStyle::mutable_prstClr()
{

    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }
    ;

    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }
    ;

    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }
    ;

    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }
    ;

    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }
    ;

    m_has_prstClr = true;
    if (!m_prstClr)
    {
        m_prstClr = new CT_PresetColor();
    }
    return m_prstClr;
}

const CT_PresetColor& CT_TableStyleTextStyle::get_prstClr() const
{
    if (m_prstClr)
    {
        return *m_prstClr;
    }
    return CT_PresetColor::default_instance();
}

bool CT_TableStyleTextStyle::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_TableStyleTextStyle::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_TableStyleTextStyle::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_TableStyleTextStyle::clear()
{
    m_has_b_attr = false;

    if (m_b_attr)
    {
        delete m_b_attr;
        m_b_attr = NULL;
    }


    m_has_i_attr = false;

    if (m_i_attr)
    {
        delete m_i_attr;
        m_i_attr = NULL;
    }


    m_has_font = false;

    if (m_font)
    {
        delete m_font;
        m_font = NULL;
    }


    m_has_fontRef = false;

    if (m_fontRef)
    {
        delete m_fontRef;
        m_fontRef = NULL;
    }


    m_has_scrgbClr = false;

    if (m_scrgbClr)
    {
        delete m_scrgbClr;
        m_scrgbClr = NULL;
    }


    m_has_srgbClr = false;

    if (m_srgbClr)
    {
        delete m_srgbClr;
        m_srgbClr = NULL;
    }


    m_has_hslClr = false;

    if (m_hslClr)
    {
        delete m_hslClr;
        m_hslClr = NULL;
    }


    m_has_sysClr = false;

    if (m_sysClr)
    {
        delete m_sysClr;
        m_sysClr = NULL;
    }


    m_has_schemeClr = false;

    if (m_schemeClr)
    {
        delete m_schemeClr;
        m_schemeClr = NULL;
    }


    m_has_prstClr = false;

    if (m_prstClr)
    {
        delete m_prstClr;
        m_prstClr = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_TableStyleTextStyle::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_b_attr)
    {
        m_b_attr->toXmlAttr("b", _outStream);
    }



    if (m_has_i_attr)
    {
        m_i_attr->toXmlAttr("i", _outStream);
    }

    _outStream << ">";

    {
        bool elemHasValueList[2] = {m_has_font, m_has_fontRef};
        int cnt = count(elemHasValueList, elemHasValueList + 2, true);
        assert(cnt == 0 || cnt == 1);
    }


    if (m_has_font)
    {
        m_font->toXmlElem("a:font", "", _outStream);
    }


    if (m_has_fontRef)
    {
        m_fontRef->toXmlElem("a:fontRef", "", _outStream);
    }

    {
        bool elemHasValueList[6] = {m_has_scrgbClr, m_has_srgbClr, m_has_hslClr, m_has_sysClr, m_has_schemeClr, m_has_prstClr};
        int cnt = count(elemHasValueList, elemHasValueList + 6, true);
        assert(cnt == 0 || cnt == 1);
    }


    if (m_has_scrgbClr)
    {
        m_scrgbClr->toXmlElem("a:scrgbClr", "", _outStream);
    }


    if (m_has_srgbClr)
    {
        m_srgbClr->toXmlElem("a:srgbClr", "", _outStream);
    }


    if (m_has_hslClr)
    {
        m_hslClr->toXmlElem("a:hslClr", "", _outStream);
    }


    if (m_has_sysClr)
    {
        m_sysClr->toXmlElem("a:sysClr", "", _outStream);
    }


    if (m_has_schemeClr)
    {
        m_schemeClr->toXmlElem("a:schemeClr", "", _outStream);
    }


    if (m_has_prstClr)
    {
        m_prstClr->toXmlElem("a:prstClr", "", _outStream);
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_TableStyleTextStyle& CT_TableStyleTextStyle::default_instance()
{
    if (!CT_TableStyleTextStyle::default_instance_)
    {
        CT_TableStyleTextStyle::default_instance_ = new CT_TableStyleTextStyle();
    }
    return *CT_TableStyleTextStyle::default_instance_;
}

bool CT_TableStyleTextStyle::has_b_attr() const
{
    return m_has_b_attr;
}

void CT_TableStyleTextStyle::set_b_attr(const ST_OnOffStyleType& _b_attr)
{
    m_has_b_attr = true;
    m_b_attr = new ST_OnOffStyleType(_b_attr);
}

const ST_OnOffStyleType& CT_TableStyleTextStyle::get_b_attr() const
{
    if (m_b_attr)
    {
        return *m_b_attr;
    }
    return ST_OnOffStyleType::default_instance();
}

bool CT_TableStyleTextStyle::has_i_attr() const
{
    return m_has_i_attr;
}

void CT_TableStyleTextStyle::set_i_attr(const ST_OnOffStyleType& _i_attr)
{
    m_has_i_attr = true;
    m_i_attr = new ST_OnOffStyleType(_i_attr);
}

const ST_OnOffStyleType& CT_TableStyleTextStyle::get_i_attr() const
{
    if (m_i_attr)
    {
        return *m_i_attr;
    }
    return ST_OnOffStyleType::default_instance();
}

CT_TableStyleTextStyle* CT_TableStyleTextStyle::default_instance_ = NULL;

// CT_TableCellBorderStyle
CT_TableCellBorderStyle::CT_TableCellBorderStyle()
    :m_has_left(false),
     m_left(NULL),
     m_has_right(false),
     m_right(NULL),
     m_has_top(false),
     m_top(NULL),
     m_has_bottom(false),
     m_bottom(NULL),
     m_has_insideH(false),
     m_insideH(NULL),
     m_has_insideV(false),
     m_insideV(NULL),
     m_has_tl2br(false),
     m_tl2br(NULL),
     m_has_tr2bl(false),
     m_tr2bl(NULL),
     m_has_extLst(false),
     m_extLst(NULL)
{
}
CT_TableCellBorderStyle::~CT_TableCellBorderStyle()
{
    clear();
}
bool CT_TableCellBorderStyle::has_left() const
{
    return m_has_left;
}

CT_ThemeableLineStyle* CT_TableCellBorderStyle::mutable_left()
{
    m_has_left = true;
    if (!m_left)
    {
        m_left = new CT_ThemeableLineStyle();
    }
    return m_left;
}

const CT_ThemeableLineStyle& CT_TableCellBorderStyle::get_left() const
{
    if (m_left)
    {
        return *m_left;
    }
    return CT_ThemeableLineStyle::default_instance();
}

bool CT_TableCellBorderStyle::has_right() const
{
    return m_has_right;
}

CT_ThemeableLineStyle* CT_TableCellBorderStyle::mutable_right()
{
    m_has_right = true;
    if (!m_right)
    {
        m_right = new CT_ThemeableLineStyle();
    }
    return m_right;
}

const CT_ThemeableLineStyle& CT_TableCellBorderStyle::get_right() const
{
    if (m_right)
    {
        return *m_right;
    }
    return CT_ThemeableLineStyle::default_instance();
}

bool CT_TableCellBorderStyle::has_top() const
{
    return m_has_top;
}

CT_ThemeableLineStyle* CT_TableCellBorderStyle::mutable_top()
{
    m_has_top = true;
    if (!m_top)
    {
        m_top = new CT_ThemeableLineStyle();
    }
    return m_top;
}

const CT_ThemeableLineStyle& CT_TableCellBorderStyle::get_top() const
{
    if (m_top)
    {
        return *m_top;
    }
    return CT_ThemeableLineStyle::default_instance();
}

bool CT_TableCellBorderStyle::has_bottom() const
{
    return m_has_bottom;
}

CT_ThemeableLineStyle* CT_TableCellBorderStyle::mutable_bottom()
{
    m_has_bottom = true;
    if (!m_bottom)
    {
        m_bottom = new CT_ThemeableLineStyle();
    }
    return m_bottom;
}

const CT_ThemeableLineStyle& CT_TableCellBorderStyle::get_bottom() const
{
    if (m_bottom)
    {
        return *m_bottom;
    }
    return CT_ThemeableLineStyle::default_instance();
}

bool CT_TableCellBorderStyle::has_insideH() const
{
    return m_has_insideH;
}

CT_ThemeableLineStyle* CT_TableCellBorderStyle::mutable_insideH()
{
    m_has_insideH = true;
    if (!m_insideH)
    {
        m_insideH = new CT_ThemeableLineStyle();
    }
    return m_insideH;
}

const CT_ThemeableLineStyle& CT_TableCellBorderStyle::get_insideH() const
{
    if (m_insideH)
    {
        return *m_insideH;
    }
    return CT_ThemeableLineStyle::default_instance();
}

bool CT_TableCellBorderStyle::has_insideV() const
{
    return m_has_insideV;
}

CT_ThemeableLineStyle* CT_TableCellBorderStyle::mutable_insideV()
{
    m_has_insideV = true;
    if (!m_insideV)
    {
        m_insideV = new CT_ThemeableLineStyle();
    }
    return m_insideV;
}

const CT_ThemeableLineStyle& CT_TableCellBorderStyle::get_insideV() const
{
    if (m_insideV)
    {
        return *m_insideV;
    }
    return CT_ThemeableLineStyle::default_instance();
}

bool CT_TableCellBorderStyle::has_tl2br() const
{
    return m_has_tl2br;
}

CT_ThemeableLineStyle* CT_TableCellBorderStyle::mutable_tl2br()
{
    m_has_tl2br = true;
    if (!m_tl2br)
    {
        m_tl2br = new CT_ThemeableLineStyle();
    }
    return m_tl2br;
}

const CT_ThemeableLineStyle& CT_TableCellBorderStyle::get_tl2br() const
{
    if (m_tl2br)
    {
        return *m_tl2br;
    }
    return CT_ThemeableLineStyle::default_instance();
}

bool CT_TableCellBorderStyle::has_tr2bl() const
{
    return m_has_tr2bl;
}

CT_ThemeableLineStyle* CT_TableCellBorderStyle::mutable_tr2bl()
{
    m_has_tr2bl = true;
    if (!m_tr2bl)
    {
        m_tr2bl = new CT_ThemeableLineStyle();
    }
    return m_tr2bl;
}

const CT_ThemeableLineStyle& CT_TableCellBorderStyle::get_tr2bl() const
{
    if (m_tr2bl)
    {
        return *m_tr2bl;
    }
    return CT_ThemeableLineStyle::default_instance();
}

bool CT_TableCellBorderStyle::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_TableCellBorderStyle::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_TableCellBorderStyle::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_TableCellBorderStyle::clear()
{
    m_has_left = false;

    if (m_left)
    {
        delete m_left;
        m_left = NULL;
    }


    m_has_right = false;

    if (m_right)
    {
        delete m_right;
        m_right = NULL;
    }


    m_has_top = false;

    if (m_top)
    {
        delete m_top;
        m_top = NULL;
    }


    m_has_bottom = false;

    if (m_bottom)
    {
        delete m_bottom;
        m_bottom = NULL;
    }


    m_has_insideH = false;

    if (m_insideH)
    {
        delete m_insideH;
        m_insideH = NULL;
    }


    m_has_insideV = false;

    if (m_insideV)
    {
        delete m_insideV;
        m_insideV = NULL;
    }


    m_has_tl2br = false;

    if (m_tl2br)
    {
        delete m_tl2br;
        m_tl2br = NULL;
    }


    m_has_tr2bl = false;

    if (m_tr2bl)
    {
        delete m_tr2bl;
        m_tr2bl = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_TableCellBorderStyle::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";


    if (m_has_left)
    {
        m_left->toXmlElem("a:left", "", _outStream);
    }


    if (m_has_right)
    {
        m_right->toXmlElem("a:right", "", _outStream);
    }


    if (m_has_top)
    {
        m_top->toXmlElem("a:top", "", _outStream);
    }


    if (m_has_bottom)
    {
        m_bottom->toXmlElem("a:bottom", "", _outStream);
    }


    if (m_has_insideH)
    {
        m_insideH->toXmlElem("a:insideH", "", _outStream);
    }


    if (m_has_insideV)
    {
        m_insideV->toXmlElem("a:insideV", "", _outStream);
    }


    if (m_has_tl2br)
    {
        m_tl2br->toXmlElem("a:tl2br", "", _outStream);
    }


    if (m_has_tr2bl)
    {
        m_tr2bl->toXmlElem("a:tr2bl", "", _outStream);
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_TableCellBorderStyle& CT_TableCellBorderStyle::default_instance()
{
    if (!CT_TableCellBorderStyle::default_instance_)
    {
        CT_TableCellBorderStyle::default_instance_ = new CT_TableCellBorderStyle();
    }
    return *CT_TableCellBorderStyle::default_instance_;
}

CT_TableCellBorderStyle* CT_TableCellBorderStyle::default_instance_ = NULL;

// CT_TableBackgroundStyle
CT_TableBackgroundStyle::CT_TableBackgroundStyle()
    :m_has_fill(false),
     m_fill(NULL),
     m_has_fillRef(false),
     m_fillRef(NULL),
     m_has_effect(false),
     m_effect(NULL),
     m_has_effectRef(false),
     m_effectRef(NULL)
{
}
CT_TableBackgroundStyle::~CT_TableBackgroundStyle()
{
    clear();
}
bool CT_TableBackgroundStyle::has_fill() const
{
    return m_has_fill;
}

CT_FillProperties* CT_TableBackgroundStyle::mutable_fill()
{

    m_has_fillRef = false;

    if (m_fillRef)
    {
        delete m_fillRef;
        m_fillRef = NULL;
    }
    ;

    m_has_fill = true;
    if (!m_fill)
    {
        m_fill = new CT_FillProperties();
    }
    return m_fill;
}

const CT_FillProperties& CT_TableBackgroundStyle::get_fill() const
{
    if (m_fill)
    {
        return *m_fill;
    }
    return CT_FillProperties::default_instance();
}

bool CT_TableBackgroundStyle::has_fillRef() const
{
    return m_has_fillRef;
}

CT_StyleMatrixReference* CT_TableBackgroundStyle::mutable_fillRef()
{

    m_has_fill = false;

    if (m_fill)
    {
        delete m_fill;
        m_fill = NULL;
    }
    ;

    m_has_fillRef = true;
    if (!m_fillRef)
    {
        m_fillRef = new CT_StyleMatrixReference();
    }
    return m_fillRef;
}

const CT_StyleMatrixReference& CT_TableBackgroundStyle::get_fillRef() const
{
    if (m_fillRef)
    {
        return *m_fillRef;
    }
    return CT_StyleMatrixReference::default_instance();
}

bool CT_TableBackgroundStyle::has_effect() const
{
    return m_has_effect;
}

CT_EffectProperties* CT_TableBackgroundStyle::mutable_effect()
{

    m_has_effectRef = false;

    if (m_effectRef)
    {
        delete m_effectRef;
        m_effectRef = NULL;
    }
    ;

    m_has_effect = true;
    if (!m_effect)
    {
        m_effect = new CT_EffectProperties();
    }
    return m_effect;
}

const CT_EffectProperties& CT_TableBackgroundStyle::get_effect() const
{
    if (m_effect)
    {
        return *m_effect;
    }
    return CT_EffectProperties::default_instance();
}

bool CT_TableBackgroundStyle::has_effectRef() const
{
    return m_has_effectRef;
}

CT_StyleMatrixReference* CT_TableBackgroundStyle::mutable_effectRef()
{

    m_has_effect = false;

    if (m_effect)
    {
        delete m_effect;
        m_effect = NULL;
    }
    ;

    m_has_effectRef = true;
    if (!m_effectRef)
    {
        m_effectRef = new CT_StyleMatrixReference();
    }
    return m_effectRef;
}

const CT_StyleMatrixReference& CT_TableBackgroundStyle::get_effectRef() const
{
    if (m_effectRef)
    {
        return *m_effectRef;
    }
    return CT_StyleMatrixReference::default_instance();
}

void CT_TableBackgroundStyle::clear()
{
    m_has_fill = false;

    if (m_fill)
    {
        delete m_fill;
        m_fill = NULL;
    }


    m_has_fillRef = false;

    if (m_fillRef)
    {
        delete m_fillRef;
        m_fillRef = NULL;
    }


    m_has_effect = false;

    if (m_effect)
    {
        delete m_effect;
        m_effect = NULL;
    }


    m_has_effectRef = false;

    if (m_effectRef)
    {
        delete m_effectRef;
        m_effectRef = NULL;
    }

}

void CT_TableBackgroundStyle::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    {
        bool elemHasValueList[2] = {m_has_fill, m_has_fillRef};
        int cnt = count(elemHasValueList, elemHasValueList + 2, true);
        assert(cnt == 0 || cnt == 1);
    }


    if (m_has_fill)
    {
        m_fill->toXmlElem("a:fill", "", _outStream);
    }


    if (m_has_fillRef)
    {
        m_fillRef->toXmlElem("a:fillRef", "", _outStream);
    }

    {
        bool elemHasValueList[2] = {m_has_effect, m_has_effectRef};
        int cnt = count(elemHasValueList, elemHasValueList + 2, true);
        assert(cnt == 0 || cnt == 1);
    }


    if (m_has_effect)
    {
        m_effect->toXmlElem("a:effect", "", _outStream);
    }


    if (m_has_effectRef)
    {
        m_effectRef->toXmlElem("a:effectRef", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_TableBackgroundStyle& CT_TableBackgroundStyle::default_instance()
{
    if (!CT_TableBackgroundStyle::default_instance_)
    {
        CT_TableBackgroundStyle::default_instance_ = new CT_TableBackgroundStyle();
    }
    return *CT_TableBackgroundStyle::default_instance_;
}

CT_TableBackgroundStyle* CT_TableBackgroundStyle::default_instance_ = NULL;

// CT_TableStyleCellStyle
CT_TableStyleCellStyle::CT_TableStyleCellStyle()
    :m_has_tcBdr(false),
     m_tcBdr(NULL),
     m_has_fill(false),
     m_fill(NULL),
     m_has_fillRef(false),
     m_fillRef(NULL),
     m_has_cell3D(false),
     m_cell3D(NULL)
{
}
CT_TableStyleCellStyle::~CT_TableStyleCellStyle()
{
    clear();
}
bool CT_TableStyleCellStyle::has_tcBdr() const
{
    return m_has_tcBdr;
}

CT_TableCellBorderStyle* CT_TableStyleCellStyle::mutable_tcBdr()
{
    m_has_tcBdr = true;
    if (!m_tcBdr)
    {
        m_tcBdr = new CT_TableCellBorderStyle();
    }
    return m_tcBdr;
}

const CT_TableCellBorderStyle& CT_TableStyleCellStyle::get_tcBdr() const
{
    if (m_tcBdr)
    {
        return *m_tcBdr;
    }
    return CT_TableCellBorderStyle::default_instance();
}

bool CT_TableStyleCellStyle::has_fill() const
{
    return m_has_fill;
}

CT_FillProperties* CT_TableStyleCellStyle::mutable_fill()
{

    m_has_fillRef = false;

    if (m_fillRef)
    {
        delete m_fillRef;
        m_fillRef = NULL;
    }
    ;

    m_has_fill = true;
    if (!m_fill)
    {
        m_fill = new CT_FillProperties();
    }
    return m_fill;
}

const CT_FillProperties& CT_TableStyleCellStyle::get_fill() const
{
    if (m_fill)
    {
        return *m_fill;
    }
    return CT_FillProperties::default_instance();
}

bool CT_TableStyleCellStyle::has_fillRef() const
{
    return m_has_fillRef;
}

CT_StyleMatrixReference* CT_TableStyleCellStyle::mutable_fillRef()
{

    m_has_fill = false;

    if (m_fill)
    {
        delete m_fill;
        m_fill = NULL;
    }
    ;

    m_has_fillRef = true;
    if (!m_fillRef)
    {
        m_fillRef = new CT_StyleMatrixReference();
    }
    return m_fillRef;
}

const CT_StyleMatrixReference& CT_TableStyleCellStyle::get_fillRef() const
{
    if (m_fillRef)
    {
        return *m_fillRef;
    }
    return CT_StyleMatrixReference::default_instance();
}

bool CT_TableStyleCellStyle::has_cell3D() const
{
    return m_has_cell3D;
}

CT_Cell3D* CT_TableStyleCellStyle::mutable_cell3D()
{
    m_has_cell3D = true;
    if (!m_cell3D)
    {
        m_cell3D = new CT_Cell3D();
    }
    return m_cell3D;
}

const CT_Cell3D& CT_TableStyleCellStyle::get_cell3D() const
{
    if (m_cell3D)
    {
        return *m_cell3D;
    }
    return CT_Cell3D::default_instance();
}

void CT_TableStyleCellStyle::clear()
{
    m_has_tcBdr = false;

    if (m_tcBdr)
    {
        delete m_tcBdr;
        m_tcBdr = NULL;
    }


    m_has_fill = false;

    if (m_fill)
    {
        delete m_fill;
        m_fill = NULL;
    }


    m_has_fillRef = false;

    if (m_fillRef)
    {
        delete m_fillRef;
        m_fillRef = NULL;
    }


    m_has_cell3D = false;

    if (m_cell3D)
    {
        delete m_cell3D;
        m_cell3D = NULL;
    }

}

void CT_TableStyleCellStyle::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";


    if (m_has_tcBdr)
    {
        m_tcBdr->toXmlElem("a:tcBdr", "", _outStream);
    }

    {
        bool elemHasValueList[2] = {m_has_fill, m_has_fillRef};
        int cnt = count(elemHasValueList, elemHasValueList + 2, true);
        assert(cnt == 0 || cnt == 1);
    }


    if (m_has_fill)
    {
        m_fill->toXmlElem("a:fill", "", _outStream);
    }


    if (m_has_fillRef)
    {
        m_fillRef->toXmlElem("a:fillRef", "", _outStream);
    }


    if (m_has_cell3D)
    {
        m_cell3D->toXmlElem("a:cell3D", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_TableStyleCellStyle& CT_TableStyleCellStyle::default_instance()
{
    if (!CT_TableStyleCellStyle::default_instance_)
    {
        CT_TableStyleCellStyle::default_instance_ = new CT_TableStyleCellStyle();
    }
    return *CT_TableStyleCellStyle::default_instance_;
}

CT_TableStyleCellStyle* CT_TableStyleCellStyle::default_instance_ = NULL;

// CT_TablePartStyle
CT_TablePartStyle::CT_TablePartStyle()
    :m_has_tcTxStyle(false),
     m_tcTxStyle(NULL),
     m_has_tcStyle(false),
     m_tcStyle(NULL)
{
}
CT_TablePartStyle::~CT_TablePartStyle()
{
    clear();
}
bool CT_TablePartStyle::has_tcTxStyle() const
{
    return m_has_tcTxStyle;
}

CT_TableStyleTextStyle* CT_TablePartStyle::mutable_tcTxStyle()
{
    m_has_tcTxStyle = true;
    if (!m_tcTxStyle)
    {
        m_tcTxStyle = new CT_TableStyleTextStyle();
    }
    return m_tcTxStyle;
}

const CT_TableStyleTextStyle& CT_TablePartStyle::get_tcTxStyle() const
{
    if (m_tcTxStyle)
    {
        return *m_tcTxStyle;
    }
    return CT_TableStyleTextStyle::default_instance();
}

bool CT_TablePartStyle::has_tcStyle() const
{
    return m_has_tcStyle;
}

CT_TableStyleCellStyle* CT_TablePartStyle::mutable_tcStyle()
{
    m_has_tcStyle = true;
    if (!m_tcStyle)
    {
        m_tcStyle = new CT_TableStyleCellStyle();
    }
    return m_tcStyle;
}

const CT_TableStyleCellStyle& CT_TablePartStyle::get_tcStyle() const
{
    if (m_tcStyle)
    {
        return *m_tcStyle;
    }
    return CT_TableStyleCellStyle::default_instance();
}

void CT_TablePartStyle::clear()
{
    m_has_tcTxStyle = false;

    if (m_tcTxStyle)
    {
        delete m_tcTxStyle;
        m_tcTxStyle = NULL;
    }


    m_has_tcStyle = false;

    if (m_tcStyle)
    {
        delete m_tcStyle;
        m_tcStyle = NULL;
    }

}

void CT_TablePartStyle::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";


    if (m_has_tcTxStyle)
    {
        m_tcTxStyle->toXmlElem("a:tcTxStyle", "", _outStream);
    }


    if (m_has_tcStyle)
    {
        m_tcStyle->toXmlElem("a:tcStyle", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_TablePartStyle& CT_TablePartStyle::default_instance()
{
    if (!CT_TablePartStyle::default_instance_)
    {
        CT_TablePartStyle::default_instance_ = new CT_TablePartStyle();
    }
    return *CT_TablePartStyle::default_instance_;
}

CT_TablePartStyle* CT_TablePartStyle::default_instance_ = NULL;

// CT_TableStyle
CT_TableStyle::CT_TableStyle()
    :m_has_tblBg(false),
     m_tblBg(NULL),
     m_has_wholeTbl(false),
     m_wholeTbl(NULL),
     m_has_band1H(false),
     m_band1H(NULL),
     m_has_band2H(false),
     m_band2H(NULL),
     m_has_band1V(false),
     m_band1V(NULL),
     m_has_band2V(false),
     m_band2V(NULL),
     m_has_lastCol(false),
     m_lastCol(NULL),
     m_has_firstCol(false),
     m_firstCol(NULL),
     m_has_lastRow(false),
     m_lastRow(NULL),
     m_has_seCell(false),
     m_seCell(NULL),
     m_has_swCell(false),
     m_swCell(NULL),
     m_has_firstRow(false),
     m_firstRow(NULL),
     m_has_neCell(false),
     m_neCell(NULL),
     m_has_nwCell(false),
     m_nwCell(NULL),
     m_has_extLst(false),
     m_extLst(NULL),
     m_has_styleId_attr(false),
     m_styleId_attr(NULL),
     m_has_styleName_attr(false),
     m_styleName_attr("")
{
}
CT_TableStyle::~CT_TableStyle()
{
    clear();
}
bool CT_TableStyle::has_tblBg() const
{
    return m_has_tblBg;
}

CT_TableBackgroundStyle* CT_TableStyle::mutable_tblBg()
{
    m_has_tblBg = true;
    if (!m_tblBg)
    {
        m_tblBg = new CT_TableBackgroundStyle();
    }
    return m_tblBg;
}

const CT_TableBackgroundStyle& CT_TableStyle::get_tblBg() const
{
    if (m_tblBg)
    {
        return *m_tblBg;
    }
    return CT_TableBackgroundStyle::default_instance();
}

bool CT_TableStyle::has_wholeTbl() const
{
    return m_has_wholeTbl;
}

CT_TablePartStyle* CT_TableStyle::mutable_wholeTbl()
{
    m_has_wholeTbl = true;
    if (!m_wholeTbl)
    {
        m_wholeTbl = new CT_TablePartStyle();
    }
    return m_wholeTbl;
}

const CT_TablePartStyle& CT_TableStyle::get_wholeTbl() const
{
    if (m_wholeTbl)
    {
        return *m_wholeTbl;
    }
    return CT_TablePartStyle::default_instance();
}

bool CT_TableStyle::has_band1H() const
{
    return m_has_band1H;
}

CT_TablePartStyle* CT_TableStyle::mutable_band1H()
{
    m_has_band1H = true;
    if (!m_band1H)
    {
        m_band1H = new CT_TablePartStyle();
    }
    return m_band1H;
}

const CT_TablePartStyle& CT_TableStyle::get_band1H() const
{
    if (m_band1H)
    {
        return *m_band1H;
    }
    return CT_TablePartStyle::default_instance();
}

bool CT_TableStyle::has_band2H() const
{
    return m_has_band2H;
}

CT_TablePartStyle* CT_TableStyle::mutable_band2H()
{
    m_has_band2H = true;
    if (!m_band2H)
    {
        m_band2H = new CT_TablePartStyle();
    }
    return m_band2H;
}

const CT_TablePartStyle& CT_TableStyle::get_band2H() const
{
    if (m_band2H)
    {
        return *m_band2H;
    }
    return CT_TablePartStyle::default_instance();
}

bool CT_TableStyle::has_band1V() const
{
    return m_has_band1V;
}

CT_TablePartStyle* CT_TableStyle::mutable_band1V()
{
    m_has_band1V = true;
    if (!m_band1V)
    {
        m_band1V = new CT_TablePartStyle();
    }
    return m_band1V;
}

const CT_TablePartStyle& CT_TableStyle::get_band1V() const
{
    if (m_band1V)
    {
        return *m_band1V;
    }
    return CT_TablePartStyle::default_instance();
}

bool CT_TableStyle::has_band2V() const
{
    return m_has_band2V;
}

CT_TablePartStyle* CT_TableStyle::mutable_band2V()
{
    m_has_band2V = true;
    if (!m_band2V)
    {
        m_band2V = new CT_TablePartStyle();
    }
    return m_band2V;
}

const CT_TablePartStyle& CT_TableStyle::get_band2V() const
{
    if (m_band2V)
    {
        return *m_band2V;
    }
    return CT_TablePartStyle::default_instance();
}

bool CT_TableStyle::has_lastCol() const
{
    return m_has_lastCol;
}

CT_TablePartStyle* CT_TableStyle::mutable_lastCol()
{
    m_has_lastCol = true;
    if (!m_lastCol)
    {
        m_lastCol = new CT_TablePartStyle();
    }
    return m_lastCol;
}

const CT_TablePartStyle& CT_TableStyle::get_lastCol() const
{
    if (m_lastCol)
    {
        return *m_lastCol;
    }
    return CT_TablePartStyle::default_instance();
}

bool CT_TableStyle::has_firstCol() const
{
    return m_has_firstCol;
}

CT_TablePartStyle* CT_TableStyle::mutable_firstCol()
{
    m_has_firstCol = true;
    if (!m_firstCol)
    {
        m_firstCol = new CT_TablePartStyle();
    }
    return m_firstCol;
}

const CT_TablePartStyle& CT_TableStyle::get_firstCol() const
{
    if (m_firstCol)
    {
        return *m_firstCol;
    }
    return CT_TablePartStyle::default_instance();
}

bool CT_TableStyle::has_lastRow() const
{
    return m_has_lastRow;
}

CT_TablePartStyle* CT_TableStyle::mutable_lastRow()
{
    m_has_lastRow = true;
    if (!m_lastRow)
    {
        m_lastRow = new CT_TablePartStyle();
    }
    return m_lastRow;
}

const CT_TablePartStyle& CT_TableStyle::get_lastRow() const
{
    if (m_lastRow)
    {
        return *m_lastRow;
    }
    return CT_TablePartStyle::default_instance();
}

bool CT_TableStyle::has_seCell() const
{
    return m_has_seCell;
}

CT_TablePartStyle* CT_TableStyle::mutable_seCell()
{
    m_has_seCell = true;
    if (!m_seCell)
    {
        m_seCell = new CT_TablePartStyle();
    }
    return m_seCell;
}

const CT_TablePartStyle& CT_TableStyle::get_seCell() const
{
    if (m_seCell)
    {
        return *m_seCell;
    }
    return CT_TablePartStyle::default_instance();
}

bool CT_TableStyle::has_swCell() const
{
    return m_has_swCell;
}

CT_TablePartStyle* CT_TableStyle::mutable_swCell()
{
    m_has_swCell = true;
    if (!m_swCell)
    {
        m_swCell = new CT_TablePartStyle();
    }
    return m_swCell;
}

const CT_TablePartStyle& CT_TableStyle::get_swCell() const
{
    if (m_swCell)
    {
        return *m_swCell;
    }
    return CT_TablePartStyle::default_instance();
}

bool CT_TableStyle::has_firstRow() const
{
    return m_has_firstRow;
}

CT_TablePartStyle* CT_TableStyle::mutable_firstRow()
{
    m_has_firstRow = true;
    if (!m_firstRow)
    {
        m_firstRow = new CT_TablePartStyle();
    }
    return m_firstRow;
}

const CT_TablePartStyle& CT_TableStyle::get_firstRow() const
{
    if (m_firstRow)
    {
        return *m_firstRow;
    }
    return CT_TablePartStyle::default_instance();
}

bool CT_TableStyle::has_neCell() const
{
    return m_has_neCell;
}

CT_TablePartStyle* CT_TableStyle::mutable_neCell()
{
    m_has_neCell = true;
    if (!m_neCell)
    {
        m_neCell = new CT_TablePartStyle();
    }
    return m_neCell;
}

const CT_TablePartStyle& CT_TableStyle::get_neCell() const
{
    if (m_neCell)
    {
        return *m_neCell;
    }
    return CT_TablePartStyle::default_instance();
}

bool CT_TableStyle::has_nwCell() const
{
    return m_has_nwCell;
}

CT_TablePartStyle* CT_TableStyle::mutable_nwCell()
{
    m_has_nwCell = true;
    if (!m_nwCell)
    {
        m_nwCell = new CT_TablePartStyle();
    }
    return m_nwCell;
}

const CT_TablePartStyle& CT_TableStyle::get_nwCell() const
{
    if (m_nwCell)
    {
        return *m_nwCell;
    }
    return CT_TablePartStyle::default_instance();
}

bool CT_TableStyle::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_TableStyle::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_TableStyle::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_TableStyle::clear()
{
    m_has_styleId_attr = false;

    if (m_styleId_attr)
    {
        delete m_styleId_attr;
        m_styleId_attr = NULL;
    }


    m_has_styleName_attr = false;
    m_styleName_attr.clear();

    m_has_tblBg = false;

    if (m_tblBg)
    {
        delete m_tblBg;
        m_tblBg = NULL;
    }


    m_has_wholeTbl = false;

    if (m_wholeTbl)
    {
        delete m_wholeTbl;
        m_wholeTbl = NULL;
    }


    m_has_band1H = false;

    if (m_band1H)
    {
        delete m_band1H;
        m_band1H = NULL;
    }


    m_has_band2H = false;

    if (m_band2H)
    {
        delete m_band2H;
        m_band2H = NULL;
    }


    m_has_band1V = false;

    if (m_band1V)
    {
        delete m_band1V;
        m_band1V = NULL;
    }


    m_has_band2V = false;

    if (m_band2V)
    {
        delete m_band2V;
        m_band2V = NULL;
    }


    m_has_lastCol = false;

    if (m_lastCol)
    {
        delete m_lastCol;
        m_lastCol = NULL;
    }


    m_has_firstCol = false;

    if (m_firstCol)
    {
        delete m_firstCol;
        m_firstCol = NULL;
    }


    m_has_lastRow = false;

    if (m_lastRow)
    {
        delete m_lastRow;
        m_lastRow = NULL;
    }


    m_has_seCell = false;

    if (m_seCell)
    {
        delete m_seCell;
        m_seCell = NULL;
    }


    m_has_swCell = false;

    if (m_swCell)
    {
        delete m_swCell;
        m_swCell = NULL;
    }


    m_has_firstRow = false;

    if (m_firstRow)
    {
        delete m_firstRow;
        m_firstRow = NULL;
    }


    m_has_neCell = false;

    if (m_neCell)
    {
        delete m_neCell;
        m_neCell = NULL;
    }


    m_has_nwCell = false;

    if (m_nwCell)
    {
        delete m_nwCell;
        m_nwCell = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_TableStyle::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_styleId_attr);
    if (m_has_styleId_attr)
    {
        m_styleId_attr->toXmlAttr("styleId", _outStream);
    }


    assert(m_has_styleName_attr);
    if (m_has_styleName_attr)
    {
        _outStream << " " << "styleName" << "=\"" << m_styleName_attr << "\"";
    }

    _outStream << ">";


    if (m_has_tblBg)
    {
        m_tblBg->toXmlElem("a:tblBg", "", _outStream);
    }


    if (m_has_wholeTbl)
    {
        m_wholeTbl->toXmlElem("a:wholeTbl", "", _outStream);
    }


    if (m_has_band1H)
    {
        m_band1H->toXmlElem("a:band1H", "", _outStream);
    }


    if (m_has_band2H)
    {
        m_band2H->toXmlElem("a:band2H", "", _outStream);
    }


    if (m_has_band1V)
    {
        m_band1V->toXmlElem("a:band1V", "", _outStream);
    }


    if (m_has_band2V)
    {
        m_band2V->toXmlElem("a:band2V", "", _outStream);
    }


    if (m_has_lastCol)
    {
        m_lastCol->toXmlElem("a:lastCol", "", _outStream);
    }


    if (m_has_firstCol)
    {
        m_firstCol->toXmlElem("a:firstCol", "", _outStream);
    }


    if (m_has_lastRow)
    {
        m_lastRow->toXmlElem("a:lastRow", "", _outStream);
    }


    if (m_has_seCell)
    {
        m_seCell->toXmlElem("a:seCell", "", _outStream);
    }


    if (m_has_swCell)
    {
        m_swCell->toXmlElem("a:swCell", "", _outStream);
    }


    if (m_has_firstRow)
    {
        m_firstRow->toXmlElem("a:firstRow", "", _outStream);
    }


    if (m_has_neCell)
    {
        m_neCell->toXmlElem("a:neCell", "", _outStream);
    }


    if (m_has_nwCell)
    {
        m_nwCell->toXmlElem("a:nwCell", "", _outStream);
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_TableStyle& CT_TableStyle::default_instance()
{
    if (!CT_TableStyle::default_instance_)
    {
        CT_TableStyle::default_instance_ = new CT_TableStyle();
    }
    return *CT_TableStyle::default_instance_;
}

bool CT_TableStyle::has_styleId_attr() const
{
    return m_has_styleId_attr;
}

void CT_TableStyle::set_styleId_attr(const ns_s::ST_Guid& _styleId_attr)
{
    m_has_styleId_attr = true;
    m_styleId_attr = new ns_s::ST_Guid(_styleId_attr);
}

const ns_s::ST_Guid& CT_TableStyle::get_styleId_attr() const
{
    if (m_styleId_attr)
    {
        return *m_styleId_attr;
    }
    return ns_s::ST_Guid::default_instance();
}

bool CT_TableStyle::has_styleName_attr() const
{
    return m_has_styleName_attr;
}

void CT_TableStyle::set_styleName_attr(const XSD::string_& _styleName_attr)
{
    m_has_styleName_attr = true;
    m_styleName_attr = _styleName_attr;
}

const XSD::string_& CT_TableStyle::get_styleName_attr() const
{
    return m_styleName_attr;
}

CT_TableStyle* CT_TableStyle::default_instance_ = NULL;

// CT_TableStyleList
CT_TableStyleList::CT_TableStyleList()
    :m_has_def_attr(false),
     m_def_attr(NULL)
{
}
CT_TableStyleList::~CT_TableStyleList()
{
    clear();
}
CT_TableStyle* CT_TableStyleList::add_tblStyle()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_TableStyle* pNewChild = pChildGroup->mutable_tblStyle();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

void CT_TableStyleList::clear()
{
    m_has_def_attr = false;

    if (m_def_attr)
    {
        delete m_def_attr;
        m_def_attr = NULL;
    }


    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }
}

void CT_TableStyleList::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_def_attr);
    if (m_has_def_attr)
    {
        m_def_attr->toXmlAttr("def", _outStream);
    }

    _outStream << ">";

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_tblStyle())
            {
                (*iter)->get_tblStyle().toXmlElem("a:tblStyle", "", _outStream);
            }


        }
    }

    _outStream << "</" << _elemName << ">";
}

const CT_TableStyleList& CT_TableStyleList::default_instance()
{
    if (!CT_TableStyleList::default_instance_)
    {
        CT_TableStyleList::default_instance_ = new CT_TableStyleList();
    }
    return *CT_TableStyleList::default_instance_;
}

bool CT_TableStyleList::has_def_attr() const
{
    return m_has_def_attr;
}

void CT_TableStyleList::set_def_attr(const ns_s::ST_Guid& _def_attr)
{
    m_has_def_attr = true;
    m_def_attr = new ns_s::ST_Guid(_def_attr);
}

const ns_s::ST_Guid& CT_TableStyleList::get_def_attr() const
{
    if (m_def_attr)
    {
        return *m_def_attr;
    }
    return ns_s::ST_Guid::default_instance();
}


// CT_TableStyleList::ChildGroup_1
CT_TableStyleList::ChildGroup_1::ChildGroup_1()
    :m_has_tblStyle(false),
     m_tblStyle(NULL)
{
}
bool CT_TableStyleList::ChildGroup_1::has_tblStyle() const
{
    return m_has_tblStyle;
}

CT_TableStyle* CT_TableStyleList::ChildGroup_1::mutable_tblStyle()
{

    m_has_tblStyle = true;
    if (!m_tblStyle)
    {
        m_tblStyle = new CT_TableStyle();
    }
    return m_tblStyle;
}

const CT_TableStyle& CT_TableStyleList::ChildGroup_1::get_tblStyle() const
{
    if (m_tblStyle)
    {
        return *m_tblStyle;
    }
    return CT_TableStyle::default_instance();
}

CT_TableStyleList* CT_TableStyleList::default_instance_ = NULL;

// CT_TextParagraph
CT_TextParagraph::CT_TextParagraph()
    :m_has_pPr(false),
     m_pPr(NULL),
     m_has_endParaRPr(false),
     m_endParaRPr(NULL)
{
}
CT_TextParagraph::~CT_TextParagraph()
{
    clear();
}
bool CT_TextParagraph::has_pPr() const
{
    return m_has_pPr;
}

CT_TextParagraphProperties* CT_TextParagraph::mutable_pPr()
{
    m_has_pPr = true;
    if (!m_pPr)
    {
        m_pPr = new CT_TextParagraphProperties();
    }
    return m_pPr;
}

const CT_TextParagraphProperties& CT_TextParagraph::get_pPr() const
{
    if (m_pPr)
    {
        return *m_pPr;
    }
    return CT_TextParagraphProperties::default_instance();
}

CT_RegularTextRun* CT_TextParagraph::add_r()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_RegularTextRun* pNewChild = pChildGroup->mutable_r();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_TextLineBreak* CT_TextParagraph::add_br()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_TextLineBreak* pNewChild = pChildGroup->mutable_br();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_TextField* CT_TextParagraph::add_fld()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_TextField* pNewChild = pChildGroup->mutable_fld();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

bool CT_TextParagraph::has_endParaRPr() const
{
    return m_has_endParaRPr;
}

CT_TextCharacterProperties* CT_TextParagraph::mutable_endParaRPr()
{
    m_has_endParaRPr = true;
    if (!m_endParaRPr)
    {
        m_endParaRPr = new CT_TextCharacterProperties();
    }
    return m_endParaRPr;
}

const CT_TextCharacterProperties& CT_TextParagraph::get_endParaRPr() const
{
    if (m_endParaRPr)
    {
        return *m_endParaRPr;
    }
    return CT_TextCharacterProperties::default_instance();
}

void CT_TextParagraph::clear()
{
    m_has_pPr = false;

    if (m_pPr)
    {
        delete m_pPr;
        m_pPr = NULL;
    }


    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }

    m_has_endParaRPr = false;

    if (m_endParaRPr)
    {
        delete m_endParaRPr;
        m_endParaRPr = NULL;
    }

}

void CT_TextParagraph::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";


    if (m_has_pPr)
    {
        m_pPr->toXmlElem("a:pPr", "", _outStream);
    }

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_r())
            {
                (*iter)->get_r().toXmlElem("a:r", "", _outStream);
            }


            else if ((*iter)->has_br())
            {
                (*iter)->get_br().toXmlElem("a:br", "", _outStream);
            }


            else if ((*iter)->has_fld())
            {
                (*iter)->get_fld().toXmlElem("a:fld", "", _outStream);
            }


        }
    }


    if (m_has_endParaRPr)
    {
        m_endParaRPr->toXmlElem("a:endParaRPr", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_TextParagraph& CT_TextParagraph::default_instance()
{
    if (!CT_TextParagraph::default_instance_)
    {
        CT_TextParagraph::default_instance_ = new CT_TextParagraph();
    }
    return *CT_TextParagraph::default_instance_;
}


// CT_TextParagraph::ChildGroup_1
CT_TextParagraph::ChildGroup_1::ChildGroup_1()
    :m_has_r(false),
     m_r(NULL),
     m_has_br(false),
     m_br(NULL),
     m_has_fld(false),
     m_fld(NULL)
{
}
bool CT_TextParagraph::ChildGroup_1::has_r() const
{
    return m_has_r;
}

CT_RegularTextRun* CT_TextParagraph::ChildGroup_1::mutable_r()
{

    m_has_br = false;

    if (m_br)
    {
        delete m_br;
        m_br = NULL;
    }
    ;

    m_has_fld = false;

    if (m_fld)
    {
        delete m_fld;
        m_fld = NULL;
    }
    ;

    m_has_r = true;
    if (!m_r)
    {
        m_r = new CT_RegularTextRun();
    }
    return m_r;
}

const CT_RegularTextRun& CT_TextParagraph::ChildGroup_1::get_r() const
{
    if (m_r)
    {
        return *m_r;
    }
    return CT_RegularTextRun::default_instance();
}

bool CT_TextParagraph::ChildGroup_1::has_br() const
{
    return m_has_br;
}

CT_TextLineBreak* CT_TextParagraph::ChildGroup_1::mutable_br()
{

    m_has_r = false;

    if (m_r)
    {
        delete m_r;
        m_r = NULL;
    }
    ;

    m_has_fld = false;

    if (m_fld)
    {
        delete m_fld;
        m_fld = NULL;
    }
    ;

    m_has_br = true;
    if (!m_br)
    {
        m_br = new CT_TextLineBreak();
    }
    return m_br;
}

const CT_TextLineBreak& CT_TextParagraph::ChildGroup_1::get_br() const
{
    if (m_br)
    {
        return *m_br;
    }
    return CT_TextLineBreak::default_instance();
}

bool CT_TextParagraph::ChildGroup_1::has_fld() const
{
    return m_has_fld;
}

CT_TextField* CT_TextParagraph::ChildGroup_1::mutable_fld()
{

    m_has_r = false;

    if (m_r)
    {
        delete m_r;
        m_r = NULL;
    }
    ;

    m_has_br = false;

    if (m_br)
    {
        delete m_br;
        m_br = NULL;
    }
    ;

    m_has_fld = true;
    if (!m_fld)
    {
        m_fld = new CT_TextField();
    }
    return m_fld;
}

const CT_TextField& CT_TextParagraph::ChildGroup_1::get_fld() const
{
    if (m_fld)
    {
        return *m_fld;
    }
    return CT_TextField::default_instance();
}

CT_TextParagraph* CT_TextParagraph::default_instance_ = NULL;

// CT_TextListStyle
CT_TextListStyle::CT_TextListStyle()
    :m_has_defPPr(false),
     m_defPPr(NULL),
     m_has_lvl1pPr(false),
     m_lvl1pPr(NULL),
     m_has_lvl2pPr(false),
     m_lvl2pPr(NULL),
     m_has_lvl3pPr(false),
     m_lvl3pPr(NULL),
     m_has_lvl4pPr(false),
     m_lvl4pPr(NULL),
     m_has_lvl5pPr(false),
     m_lvl5pPr(NULL),
     m_has_lvl6pPr(false),
     m_lvl6pPr(NULL),
     m_has_lvl7pPr(false),
     m_lvl7pPr(NULL),
     m_has_lvl8pPr(false),
     m_lvl8pPr(NULL),
     m_has_lvl9pPr(false),
     m_lvl9pPr(NULL),
     m_has_extLst(false),
     m_extLst(NULL)
{
}
CT_TextListStyle::~CT_TextListStyle()
{
    clear();
}
bool CT_TextListStyle::has_defPPr() const
{
    return m_has_defPPr;
}

CT_TextParagraphProperties* CT_TextListStyle::mutable_defPPr()
{
    m_has_defPPr = true;
    if (!m_defPPr)
    {
        m_defPPr = new CT_TextParagraphProperties();
    }
    return m_defPPr;
}

const CT_TextParagraphProperties& CT_TextListStyle::get_defPPr() const
{
    if (m_defPPr)
    {
        return *m_defPPr;
    }
    return CT_TextParagraphProperties::default_instance();
}

bool CT_TextListStyle::has_lvl1pPr() const
{
    return m_has_lvl1pPr;
}

CT_TextParagraphProperties* CT_TextListStyle::mutable_lvl1pPr()
{
    m_has_lvl1pPr = true;
    if (!m_lvl1pPr)
    {
        m_lvl1pPr = new CT_TextParagraphProperties();
    }
    return m_lvl1pPr;
}

const CT_TextParagraphProperties& CT_TextListStyle::get_lvl1pPr() const
{
    if (m_lvl1pPr)
    {
        return *m_lvl1pPr;
    }
    return CT_TextParagraphProperties::default_instance();
}

bool CT_TextListStyle::has_lvl2pPr() const
{
    return m_has_lvl2pPr;
}

CT_TextParagraphProperties* CT_TextListStyle::mutable_lvl2pPr()
{
    m_has_lvl2pPr = true;
    if (!m_lvl2pPr)
    {
        m_lvl2pPr = new CT_TextParagraphProperties();
    }
    return m_lvl2pPr;
}

const CT_TextParagraphProperties& CT_TextListStyle::get_lvl2pPr() const
{
    if (m_lvl2pPr)
    {
        return *m_lvl2pPr;
    }
    return CT_TextParagraphProperties::default_instance();
}

bool CT_TextListStyle::has_lvl3pPr() const
{
    return m_has_lvl3pPr;
}

CT_TextParagraphProperties* CT_TextListStyle::mutable_lvl3pPr()
{
    m_has_lvl3pPr = true;
    if (!m_lvl3pPr)
    {
        m_lvl3pPr = new CT_TextParagraphProperties();
    }
    return m_lvl3pPr;
}

const CT_TextParagraphProperties& CT_TextListStyle::get_lvl3pPr() const
{
    if (m_lvl3pPr)
    {
        return *m_lvl3pPr;
    }
    return CT_TextParagraphProperties::default_instance();
}

bool CT_TextListStyle::has_lvl4pPr() const
{
    return m_has_lvl4pPr;
}

CT_TextParagraphProperties* CT_TextListStyle::mutable_lvl4pPr()
{
    m_has_lvl4pPr = true;
    if (!m_lvl4pPr)
    {
        m_lvl4pPr = new CT_TextParagraphProperties();
    }
    return m_lvl4pPr;
}

const CT_TextParagraphProperties& CT_TextListStyle::get_lvl4pPr() const
{
    if (m_lvl4pPr)
    {
        return *m_lvl4pPr;
    }
    return CT_TextParagraphProperties::default_instance();
}

bool CT_TextListStyle::has_lvl5pPr() const
{
    return m_has_lvl5pPr;
}

CT_TextParagraphProperties* CT_TextListStyle::mutable_lvl5pPr()
{
    m_has_lvl5pPr = true;
    if (!m_lvl5pPr)
    {
        m_lvl5pPr = new CT_TextParagraphProperties();
    }
    return m_lvl5pPr;
}

const CT_TextParagraphProperties& CT_TextListStyle::get_lvl5pPr() const
{
    if (m_lvl5pPr)
    {
        return *m_lvl5pPr;
    }
    return CT_TextParagraphProperties::default_instance();
}

bool CT_TextListStyle::has_lvl6pPr() const
{
    return m_has_lvl6pPr;
}

CT_TextParagraphProperties* CT_TextListStyle::mutable_lvl6pPr()
{
    m_has_lvl6pPr = true;
    if (!m_lvl6pPr)
    {
        m_lvl6pPr = new CT_TextParagraphProperties();
    }
    return m_lvl6pPr;
}

const CT_TextParagraphProperties& CT_TextListStyle::get_lvl6pPr() const
{
    if (m_lvl6pPr)
    {
        return *m_lvl6pPr;
    }
    return CT_TextParagraphProperties::default_instance();
}

bool CT_TextListStyle::has_lvl7pPr() const
{
    return m_has_lvl7pPr;
}

CT_TextParagraphProperties* CT_TextListStyle::mutable_lvl7pPr()
{
    m_has_lvl7pPr = true;
    if (!m_lvl7pPr)
    {
        m_lvl7pPr = new CT_TextParagraphProperties();
    }
    return m_lvl7pPr;
}

const CT_TextParagraphProperties& CT_TextListStyle::get_lvl7pPr() const
{
    if (m_lvl7pPr)
    {
        return *m_lvl7pPr;
    }
    return CT_TextParagraphProperties::default_instance();
}

bool CT_TextListStyle::has_lvl8pPr() const
{
    return m_has_lvl8pPr;
}

CT_TextParagraphProperties* CT_TextListStyle::mutable_lvl8pPr()
{
    m_has_lvl8pPr = true;
    if (!m_lvl8pPr)
    {
        m_lvl8pPr = new CT_TextParagraphProperties();
    }
    return m_lvl8pPr;
}

const CT_TextParagraphProperties& CT_TextListStyle::get_lvl8pPr() const
{
    if (m_lvl8pPr)
    {
        return *m_lvl8pPr;
    }
    return CT_TextParagraphProperties::default_instance();
}

bool CT_TextListStyle::has_lvl9pPr() const
{
    return m_has_lvl9pPr;
}

CT_TextParagraphProperties* CT_TextListStyle::mutable_lvl9pPr()
{
    m_has_lvl9pPr = true;
    if (!m_lvl9pPr)
    {
        m_lvl9pPr = new CT_TextParagraphProperties();
    }
    return m_lvl9pPr;
}

const CT_TextParagraphProperties& CT_TextListStyle::get_lvl9pPr() const
{
    if (m_lvl9pPr)
    {
        return *m_lvl9pPr;
    }
    return CT_TextParagraphProperties::default_instance();
}

bool CT_TextListStyle::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_TextListStyle::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_TextListStyle::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_TextListStyle::clear()
{
    m_has_defPPr = false;

    if (m_defPPr)
    {
        delete m_defPPr;
        m_defPPr = NULL;
    }


    m_has_lvl1pPr = false;

    if (m_lvl1pPr)
    {
        delete m_lvl1pPr;
        m_lvl1pPr = NULL;
    }


    m_has_lvl2pPr = false;

    if (m_lvl2pPr)
    {
        delete m_lvl2pPr;
        m_lvl2pPr = NULL;
    }


    m_has_lvl3pPr = false;

    if (m_lvl3pPr)
    {
        delete m_lvl3pPr;
        m_lvl3pPr = NULL;
    }


    m_has_lvl4pPr = false;

    if (m_lvl4pPr)
    {
        delete m_lvl4pPr;
        m_lvl4pPr = NULL;
    }


    m_has_lvl5pPr = false;

    if (m_lvl5pPr)
    {
        delete m_lvl5pPr;
        m_lvl5pPr = NULL;
    }


    m_has_lvl6pPr = false;

    if (m_lvl6pPr)
    {
        delete m_lvl6pPr;
        m_lvl6pPr = NULL;
    }


    m_has_lvl7pPr = false;

    if (m_lvl7pPr)
    {
        delete m_lvl7pPr;
        m_lvl7pPr = NULL;
    }


    m_has_lvl8pPr = false;

    if (m_lvl8pPr)
    {
        delete m_lvl8pPr;
        m_lvl8pPr = NULL;
    }


    m_has_lvl9pPr = false;

    if (m_lvl9pPr)
    {
        delete m_lvl9pPr;
        m_lvl9pPr = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_TextListStyle::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";


    if (m_has_defPPr)
    {
        m_defPPr->toXmlElem("a:defPPr", "", _outStream);
    }


    if (m_has_lvl1pPr)
    {
        m_lvl1pPr->toXmlElem("a:lvl1pPr", "", _outStream);
    }


    if (m_has_lvl2pPr)
    {
        m_lvl2pPr->toXmlElem("a:lvl2pPr", "", _outStream);
    }


    if (m_has_lvl3pPr)
    {
        m_lvl3pPr->toXmlElem("a:lvl3pPr", "", _outStream);
    }


    if (m_has_lvl4pPr)
    {
        m_lvl4pPr->toXmlElem("a:lvl4pPr", "", _outStream);
    }


    if (m_has_lvl5pPr)
    {
        m_lvl5pPr->toXmlElem("a:lvl5pPr", "", _outStream);
    }


    if (m_has_lvl6pPr)
    {
        m_lvl6pPr->toXmlElem("a:lvl6pPr", "", _outStream);
    }


    if (m_has_lvl7pPr)
    {
        m_lvl7pPr->toXmlElem("a:lvl7pPr", "", _outStream);
    }


    if (m_has_lvl8pPr)
    {
        m_lvl8pPr->toXmlElem("a:lvl8pPr", "", _outStream);
    }


    if (m_has_lvl9pPr)
    {
        m_lvl9pPr->toXmlElem("a:lvl9pPr", "", _outStream);
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_TextListStyle& CT_TextListStyle::default_instance()
{
    if (!CT_TextListStyle::default_instance_)
    {
        CT_TextListStyle::default_instance_ = new CT_TextListStyle();
    }
    return *CT_TextListStyle::default_instance_;
}

CT_TextListStyle* CT_TextListStyle::default_instance_ = NULL;

// CT_TextNormalAutofit
CT_TextNormalAutofit::CT_TextNormalAutofit()
    :m_has_fontScale_attr(false),
     m_fontScale_attr(NULL),
     m_has_lnSpcReduction_attr(false),
     m_lnSpcReduction_attr(NULL)
{
}
CT_TextNormalAutofit::~CT_TextNormalAutofit()
{
    clear();
}
void CT_TextNormalAutofit::clear()
{
    m_has_fontScale_attr = false;

    if (m_fontScale_attr)
    {
        delete m_fontScale_attr;
        m_fontScale_attr = NULL;
    }


    m_has_lnSpcReduction_attr = false;

    if (m_lnSpcReduction_attr)
    {
        delete m_lnSpcReduction_attr;
        m_lnSpcReduction_attr = NULL;
    }

}

void CT_TextNormalAutofit::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_fontScale_attr)
    {
        m_fontScale_attr->toXmlAttr("fontScale", _outStream);
    }



    if (m_has_lnSpcReduction_attr)
    {
        m_lnSpcReduction_attr->toXmlAttr("lnSpcReduction", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_TextNormalAutofit& CT_TextNormalAutofit::default_instance()
{
    if (!CT_TextNormalAutofit::default_instance_)
    {
        CT_TextNormalAutofit::default_instance_ = new CT_TextNormalAutofit();
    }
    return *CT_TextNormalAutofit::default_instance_;
}

bool CT_TextNormalAutofit::has_fontScale_attr() const
{
    return m_has_fontScale_attr;
}

void CT_TextNormalAutofit::set_fontScale_attr(const ST_TextFontScalePercentOrPercentString& _fontScale_attr)
{
    m_has_fontScale_attr = true;
    m_fontScale_attr = new ST_TextFontScalePercentOrPercentString(_fontScale_attr);
}

const ST_TextFontScalePercentOrPercentString& CT_TextNormalAutofit::get_fontScale_attr() const
{
    if (m_fontScale_attr)
    {
        return *m_fontScale_attr;
    }
    return ST_TextFontScalePercentOrPercentString::default_instance();
}

bool CT_TextNormalAutofit::has_lnSpcReduction_attr() const
{
    return m_has_lnSpcReduction_attr;
}

void CT_TextNormalAutofit::set_lnSpcReduction_attr(const ST_TextSpacingPercentOrPercentString& _lnSpcReduction_attr)
{
    m_has_lnSpcReduction_attr = true;
    m_lnSpcReduction_attr = new ST_TextSpacingPercentOrPercentString(_lnSpcReduction_attr);
}

const ST_TextSpacingPercentOrPercentString& CT_TextNormalAutofit::get_lnSpcReduction_attr() const
{
    if (m_lnSpcReduction_attr)
    {
        return *m_lnSpcReduction_attr;
    }
    return ST_TextSpacingPercentOrPercentString::default_instance();
}

CT_TextNormalAutofit* CT_TextNormalAutofit::default_instance_ = NULL;

// CT_TextShapeAutofit
CT_TextShapeAutofit::CT_TextShapeAutofit()

{
}
CT_TextShapeAutofit::~CT_TextShapeAutofit()
{
    clear();
}
void CT_TextShapeAutofit::clear()
{    }

void CT_TextShapeAutofit::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_TextShapeAutofit& CT_TextShapeAutofit::default_instance()
{
    if (!CT_TextShapeAutofit::default_instance_)
    {
        CT_TextShapeAutofit::default_instance_ = new CT_TextShapeAutofit();
    }
    return *CT_TextShapeAutofit::default_instance_;
}

CT_TextShapeAutofit* CT_TextShapeAutofit::default_instance_ = NULL;

// CT_TextNoAutofit
CT_TextNoAutofit::CT_TextNoAutofit()

{
}
CT_TextNoAutofit::~CT_TextNoAutofit()
{
    clear();
}
void CT_TextNoAutofit::clear()
{    }

void CT_TextNoAutofit::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_TextNoAutofit& CT_TextNoAutofit::default_instance()
{
    if (!CT_TextNoAutofit::default_instance_)
    {
        CT_TextNoAutofit::default_instance_ = new CT_TextNoAutofit();
    }
    return *CT_TextNoAutofit::default_instance_;
}

CT_TextNoAutofit* CT_TextNoAutofit::default_instance_ = NULL;

// CT_TextBodyProperties
CT_TextBodyProperties::CT_TextBodyProperties()
    :m_has_prstTxWarp(false),
     m_prstTxWarp(NULL),
     m_has_noAutofit(false),
     m_noAutofit(NULL),
     m_has_normAutofit(false),
     m_normAutofit(NULL),
     m_has_spAutoFit(false),
     m_spAutoFit(NULL),
     m_has_scene3d(false),
     m_scene3d(NULL),
     m_has_sp3d(false),
     m_sp3d(NULL),
     m_has_flatTx(false),
     m_flatTx(NULL),
     m_has_extLst(false),
     m_extLst(NULL),
     m_has_rot_attr(false),
     m_rot_attr(NULL),
     m_has_spcFirstLastPara_attr(false),
     m_spcFirstLastPara_attr(false),
     m_has_vertOverflow_attr(false),
     m_vertOverflow_attr(NULL),
     m_has_horzOverflow_attr(false),
     m_horzOverflow_attr(NULL),
     m_has_vert_attr(false),
     m_vert_attr(NULL),
     m_has_wrap_attr(false),
     m_wrap_attr(NULL),
     m_has_lIns_attr(false),
     m_lIns_attr(NULL),
     m_has_tIns_attr(false),
     m_tIns_attr(NULL),
     m_has_rIns_attr(false),
     m_rIns_attr(NULL),
     m_has_bIns_attr(false),
     m_bIns_attr(NULL),
     m_has_numCol_attr(false),
     m_numCol_attr(NULL),
     m_has_spcCol_attr(false),
     m_spcCol_attr(NULL),
     m_has_rtlCol_attr(false),
     m_rtlCol_attr(false),
     m_has_fromWordArt_attr(false),
     m_fromWordArt_attr(false),
     m_has_anchor_attr(false),
     m_anchor_attr(NULL),
     m_has_anchorCtr_attr(false),
     m_anchorCtr_attr(false),
     m_has_forceAA_attr(false),
     m_forceAA_attr(false),
     m_has_upright_attr(false),
     m_upright_attr(false),
     m_has_compatLnSpc_attr(false),
     m_compatLnSpc_attr(false)
{
}
CT_TextBodyProperties::~CT_TextBodyProperties()
{
    clear();
}
bool CT_TextBodyProperties::has_prstTxWarp() const
{
    return m_has_prstTxWarp;
}

CT_PresetTextShape* CT_TextBodyProperties::mutable_prstTxWarp()
{
    m_has_prstTxWarp = true;
    if (!m_prstTxWarp)
    {
        m_prstTxWarp = new CT_PresetTextShape();
    }
    return m_prstTxWarp;
}

const CT_PresetTextShape& CT_TextBodyProperties::get_prstTxWarp() const
{
    if (m_prstTxWarp)
    {
        return *m_prstTxWarp;
    }
    return CT_PresetTextShape::default_instance();
}

bool CT_TextBodyProperties::has_noAutofit() const
{
    return m_has_noAutofit;
}

CT_TextNoAutofit* CT_TextBodyProperties::mutable_noAutofit()
{

    m_has_normAutofit = false;

    if (m_normAutofit)
    {
        delete m_normAutofit;
        m_normAutofit = NULL;
    }
    ;

    m_has_spAutoFit = false;

    if (m_spAutoFit)
    {
        delete m_spAutoFit;
        m_spAutoFit = NULL;
    }
    ;

    m_has_noAutofit = true;
    if (!m_noAutofit)
    {
        m_noAutofit = new CT_TextNoAutofit();
    }
    return m_noAutofit;
}

const CT_TextNoAutofit& CT_TextBodyProperties::get_noAutofit() const
{
    if (m_noAutofit)
    {
        return *m_noAutofit;
    }
    return CT_TextNoAutofit::default_instance();
}

bool CT_TextBodyProperties::has_normAutofit() const
{
    return m_has_normAutofit;
}

CT_TextNormalAutofit* CT_TextBodyProperties::mutable_normAutofit()
{

    m_has_noAutofit = false;

    if (m_noAutofit)
    {
        delete m_noAutofit;
        m_noAutofit = NULL;
    }
    ;

    m_has_spAutoFit = false;

    if (m_spAutoFit)
    {
        delete m_spAutoFit;
        m_spAutoFit = NULL;
    }
    ;

    m_has_normAutofit = true;
    if (!m_normAutofit)
    {
        m_normAutofit = new CT_TextNormalAutofit();
    }
    return m_normAutofit;
}

const CT_TextNormalAutofit& CT_TextBodyProperties::get_normAutofit() const
{
    if (m_normAutofit)
    {
        return *m_normAutofit;
    }
    return CT_TextNormalAutofit::default_instance();
}

bool CT_TextBodyProperties::has_spAutoFit() const
{
    return m_has_spAutoFit;
}

CT_TextShapeAutofit* CT_TextBodyProperties::mutable_spAutoFit()
{

    m_has_noAutofit = false;

    if (m_noAutofit)
    {
        delete m_noAutofit;
        m_noAutofit = NULL;
    }
    ;

    m_has_normAutofit = false;

    if (m_normAutofit)
    {
        delete m_normAutofit;
        m_normAutofit = NULL;
    }
    ;

    m_has_spAutoFit = true;
    if (!m_spAutoFit)
    {
        m_spAutoFit = new CT_TextShapeAutofit();
    }
    return m_spAutoFit;
}

const CT_TextShapeAutofit& CT_TextBodyProperties::get_spAutoFit() const
{
    if (m_spAutoFit)
    {
        return *m_spAutoFit;
    }
    return CT_TextShapeAutofit::default_instance();
}

bool CT_TextBodyProperties::has_scene3d() const
{
    return m_has_scene3d;
}

CT_Scene3D* CT_TextBodyProperties::mutable_scene3d()
{
    m_has_scene3d = true;
    if (!m_scene3d)
    {
        m_scene3d = new CT_Scene3D();
    }
    return m_scene3d;
}

const CT_Scene3D& CT_TextBodyProperties::get_scene3d() const
{
    if (m_scene3d)
    {
        return *m_scene3d;
    }
    return CT_Scene3D::default_instance();
}

bool CT_TextBodyProperties::has_sp3d() const
{
    return m_has_sp3d;
}

CT_Shape3D* CT_TextBodyProperties::mutable_sp3d()
{

    m_has_flatTx = false;

    if (m_flatTx)
    {
        delete m_flatTx;
        m_flatTx = NULL;
    }
    ;

    m_has_sp3d = true;
    if (!m_sp3d)
    {
        m_sp3d = new CT_Shape3D();
    }
    return m_sp3d;
}

const CT_Shape3D& CT_TextBodyProperties::get_sp3d() const
{
    if (m_sp3d)
    {
        return *m_sp3d;
    }
    return CT_Shape3D::default_instance();
}

bool CT_TextBodyProperties::has_flatTx() const
{
    return m_has_flatTx;
}

CT_FlatText* CT_TextBodyProperties::mutable_flatTx()
{

    m_has_sp3d = false;

    if (m_sp3d)
    {
        delete m_sp3d;
        m_sp3d = NULL;
    }
    ;

    m_has_flatTx = true;
    if (!m_flatTx)
    {
        m_flatTx = new CT_FlatText();
    }
    return m_flatTx;
}

const CT_FlatText& CT_TextBodyProperties::get_flatTx() const
{
    if (m_flatTx)
    {
        return *m_flatTx;
    }
    return CT_FlatText::default_instance();
}

bool CT_TextBodyProperties::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_TextBodyProperties::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_TextBodyProperties::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_TextBodyProperties::clear()
{
    m_has_rot_attr = false;

    if (m_rot_attr)
    {
        delete m_rot_attr;
        m_rot_attr = NULL;
    }


    m_has_spcFirstLastPara_attr = false;
    m_spcFirstLastPara_attr = false;

    m_has_vertOverflow_attr = false;

    if (m_vertOverflow_attr)
    {
        delete m_vertOverflow_attr;
        m_vertOverflow_attr = NULL;
    }


    m_has_horzOverflow_attr = false;

    if (m_horzOverflow_attr)
    {
        delete m_horzOverflow_attr;
        m_horzOverflow_attr = NULL;
    }


    m_has_vert_attr = false;

    if (m_vert_attr)
    {
        delete m_vert_attr;
        m_vert_attr = NULL;
    }


    m_has_wrap_attr = false;

    if (m_wrap_attr)
    {
        delete m_wrap_attr;
        m_wrap_attr = NULL;
    }


    m_has_lIns_attr = false;

    if (m_lIns_attr)
    {
        delete m_lIns_attr;
        m_lIns_attr = NULL;
    }


    m_has_tIns_attr = false;

    if (m_tIns_attr)
    {
        delete m_tIns_attr;
        m_tIns_attr = NULL;
    }


    m_has_rIns_attr = false;

    if (m_rIns_attr)
    {
        delete m_rIns_attr;
        m_rIns_attr = NULL;
    }


    m_has_bIns_attr = false;

    if (m_bIns_attr)
    {
        delete m_bIns_attr;
        m_bIns_attr = NULL;
    }


    m_has_numCol_attr = false;

    if (m_numCol_attr)
    {
        delete m_numCol_attr;
        m_numCol_attr = NULL;
    }


    m_has_spcCol_attr = false;

    if (m_spcCol_attr)
    {
        delete m_spcCol_attr;
        m_spcCol_attr = NULL;
    }


    m_has_rtlCol_attr = false;
    m_rtlCol_attr = false;

    m_has_fromWordArt_attr = false;
    m_fromWordArt_attr = false;

    m_has_anchor_attr = false;

    if (m_anchor_attr)
    {
        delete m_anchor_attr;
        m_anchor_attr = NULL;
    }


    m_has_anchorCtr_attr = false;
    m_anchorCtr_attr = false;

    m_has_forceAA_attr = false;
    m_forceAA_attr = false;

    m_has_upright_attr = false;
    m_upright_attr = false;

    m_has_compatLnSpc_attr = false;
    m_compatLnSpc_attr = false;

    m_has_prstTxWarp = false;

    if (m_prstTxWarp)
    {
        delete m_prstTxWarp;
        m_prstTxWarp = NULL;
    }


    m_has_noAutofit = false;

    if (m_noAutofit)
    {
        delete m_noAutofit;
        m_noAutofit = NULL;
    }


    m_has_normAutofit = false;

    if (m_normAutofit)
    {
        delete m_normAutofit;
        m_normAutofit = NULL;
    }


    m_has_spAutoFit = false;

    if (m_spAutoFit)
    {
        delete m_spAutoFit;
        m_spAutoFit = NULL;
    }


    m_has_scene3d = false;

    if (m_scene3d)
    {
        delete m_scene3d;
        m_scene3d = NULL;
    }


    m_has_sp3d = false;

    if (m_sp3d)
    {
        delete m_sp3d;
        m_sp3d = NULL;
    }


    m_has_flatTx = false;

    if (m_flatTx)
    {
        delete m_flatTx;
        m_flatTx = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_TextBodyProperties::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_rot_attr)
    {
        m_rot_attr->toXmlAttr("rot", _outStream);
    }



    if (m_has_spcFirstLastPara_attr)
    {
        _outStream << " " << "spcFirstLastPara" << "=\"" << XSD::XMLBooleanStr(m_spcFirstLastPara_attr) << "\"";
    }



    if (m_has_vertOverflow_attr)
    {
        m_vertOverflow_attr->toXmlAttr("vertOverflow", _outStream);
    }



    if (m_has_horzOverflow_attr)
    {
        m_horzOverflow_attr->toXmlAttr("horzOverflow", _outStream);
    }



    if (m_has_vert_attr)
    {
        m_vert_attr->toXmlAttr("vert", _outStream);
    }



    if (m_has_wrap_attr)
    {
        m_wrap_attr->toXmlAttr("wrap", _outStream);
    }



    if (m_has_lIns_attr)
    {
        m_lIns_attr->toXmlAttr("lIns", _outStream);
    }



    if (m_has_tIns_attr)
    {
        m_tIns_attr->toXmlAttr("tIns", _outStream);
    }



    if (m_has_rIns_attr)
    {
        m_rIns_attr->toXmlAttr("rIns", _outStream);
    }



    if (m_has_bIns_attr)
    {
        m_bIns_attr->toXmlAttr("bIns", _outStream);
    }



    if (m_has_numCol_attr)
    {
        m_numCol_attr->toXmlAttr("numCol", _outStream);
    }



    if (m_has_spcCol_attr)
    {
        m_spcCol_attr->toXmlAttr("spcCol", _outStream);
    }



    if (m_has_rtlCol_attr)
    {
        _outStream << " " << "rtlCol" << "=\"" << XSD::XMLBooleanStr(m_rtlCol_attr) << "\"";
    }



    if (m_has_fromWordArt_attr)
    {
        _outStream << " " << "fromWordArt" << "=\"" << XSD::XMLBooleanStr(m_fromWordArt_attr) << "\"";
    }



    if (m_has_anchor_attr)
    {
        m_anchor_attr->toXmlAttr("anchor", _outStream);
    }



    if (m_has_anchorCtr_attr)
    {
        _outStream << " " << "anchorCtr" << "=\"" << XSD::XMLBooleanStr(m_anchorCtr_attr) << "\"";
    }



    if (m_has_forceAA_attr)
    {
        _outStream << " " << "forceAA" << "=\"" << XSD::XMLBooleanStr(m_forceAA_attr) << "\"";
    }



    if (m_has_upright_attr)
    {
        _outStream << " " << "upright" << "=\"" << XSD::XMLBooleanStr(m_upright_attr) << "\"";
    }



    if (m_has_compatLnSpc_attr)
    {
        _outStream << " " << "compatLnSpc" << "=\"" << XSD::XMLBooleanStr(m_compatLnSpc_attr) << "\"";
    }

    _outStream << ">";


    if (m_has_prstTxWarp)
    {
        m_prstTxWarp->toXmlElem("a:prstTxWarp", "", _outStream);
    }

    {
        bool elemHasValueList[3] = {m_has_noAutofit, m_has_normAutofit, m_has_spAutoFit};
        int cnt = count(elemHasValueList, elemHasValueList + 3, true);
        assert(cnt == 0 || cnt == 1);
    }


    if (m_has_noAutofit)
    {
        m_noAutofit->toXmlElem("a:noAutofit", "", _outStream);
    }


    if (m_has_normAutofit)
    {
        m_normAutofit->toXmlElem("a:normAutofit", "", _outStream);
    }


    if (m_has_spAutoFit)
    {
        m_spAutoFit->toXmlElem("a:spAutoFit", "", _outStream);
    }


    if (m_has_scene3d)
    {
        m_scene3d->toXmlElem("a:scene3d", "", _outStream);
    }

    {
        bool elemHasValueList[2] = {m_has_sp3d, m_has_flatTx};
        int cnt = count(elemHasValueList, elemHasValueList + 2, true);
        assert(cnt == 0 || cnt == 1);
    }


    if (m_has_sp3d)
    {
        m_sp3d->toXmlElem("a:sp3d", "", _outStream);
    }


    if (m_has_flatTx)
    {
        m_flatTx->toXmlElem("a:flatTx", "", _outStream);
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_TextBodyProperties& CT_TextBodyProperties::default_instance()
{
    if (!CT_TextBodyProperties::default_instance_)
    {
        CT_TextBodyProperties::default_instance_ = new CT_TextBodyProperties();
    }
    return *CT_TextBodyProperties::default_instance_;
}

bool CT_TextBodyProperties::has_rot_attr() const
{
    return m_has_rot_attr;
}

void CT_TextBodyProperties::set_rot_attr(const ST_Angle& _rot_attr)
{
    m_has_rot_attr = true;
    m_rot_attr = new ST_Angle(_rot_attr);
}

const ST_Angle& CT_TextBodyProperties::get_rot_attr() const
{
    if (m_rot_attr)
    {
        return *m_rot_attr;
    }
    return ST_Angle::default_instance();
}

bool CT_TextBodyProperties::has_spcFirstLastPara_attr() const
{
    return m_has_spcFirstLastPara_attr;
}

void CT_TextBodyProperties::set_spcFirstLastPara_attr(const XSD::boolean_& _spcFirstLastPara_attr)
{
    m_has_spcFirstLastPara_attr = true;
    m_spcFirstLastPara_attr = _spcFirstLastPara_attr;
}

const XSD::boolean_& CT_TextBodyProperties::get_spcFirstLastPara_attr() const
{
    return m_spcFirstLastPara_attr;
}

bool CT_TextBodyProperties::has_vertOverflow_attr() const
{
    return m_has_vertOverflow_attr;
}

void CT_TextBodyProperties::set_vertOverflow_attr(const ST_TextVertOverflowType& _vertOverflow_attr)
{
    m_has_vertOverflow_attr = true;
    m_vertOverflow_attr = new ST_TextVertOverflowType(_vertOverflow_attr);
}

const ST_TextVertOverflowType& CT_TextBodyProperties::get_vertOverflow_attr() const
{
    if (m_vertOverflow_attr)
    {
        return *m_vertOverflow_attr;
    }
    return ST_TextVertOverflowType::default_instance();
}

bool CT_TextBodyProperties::has_horzOverflow_attr() const
{
    return m_has_horzOverflow_attr;
}

void CT_TextBodyProperties::set_horzOverflow_attr(const ST_TextHorzOverflowType& _horzOverflow_attr)
{
    m_has_horzOverflow_attr = true;
    m_horzOverflow_attr = new ST_TextHorzOverflowType(_horzOverflow_attr);
}

const ST_TextHorzOverflowType& CT_TextBodyProperties::get_horzOverflow_attr() const
{
    if (m_horzOverflow_attr)
    {
        return *m_horzOverflow_attr;
    }
    return ST_TextHorzOverflowType::default_instance();
}

bool CT_TextBodyProperties::has_vert_attr() const
{
    return m_has_vert_attr;
}

void CT_TextBodyProperties::set_vert_attr(const ST_TextVerticalType& _vert_attr)
{
    m_has_vert_attr = true;
    m_vert_attr = new ST_TextVerticalType(_vert_attr);
}

const ST_TextVerticalType& CT_TextBodyProperties::get_vert_attr() const
{
    if (m_vert_attr)
    {
        return *m_vert_attr;
    }
    return ST_TextVerticalType::default_instance();
}

bool CT_TextBodyProperties::has_wrap_attr() const
{
    return m_has_wrap_attr;
}

void CT_TextBodyProperties::set_wrap_attr(const ST_TextWrappingType& _wrap_attr)
{
    m_has_wrap_attr = true;
    m_wrap_attr = new ST_TextWrappingType(_wrap_attr);
}

const ST_TextWrappingType& CT_TextBodyProperties::get_wrap_attr() const
{
    if (m_wrap_attr)
    {
        return *m_wrap_attr;
    }
    return ST_TextWrappingType::default_instance();
}

bool CT_TextBodyProperties::has_lIns_attr() const
{
    return m_has_lIns_attr;
}

void CT_TextBodyProperties::set_lIns_attr(const ST_Coordinate32& _lIns_attr)
{
    m_has_lIns_attr = true;
    m_lIns_attr = new ST_Coordinate32(_lIns_attr);
}

const ST_Coordinate32& CT_TextBodyProperties::get_lIns_attr() const
{
    if (m_lIns_attr)
    {
        return *m_lIns_attr;
    }
    return ST_Coordinate32::default_instance();
}

bool CT_TextBodyProperties::has_tIns_attr() const
{
    return m_has_tIns_attr;
}

void CT_TextBodyProperties::set_tIns_attr(const ST_Coordinate32& _tIns_attr)
{
    m_has_tIns_attr = true;
    m_tIns_attr = new ST_Coordinate32(_tIns_attr);
}

const ST_Coordinate32& CT_TextBodyProperties::get_tIns_attr() const
{
    if (m_tIns_attr)
    {
        return *m_tIns_attr;
    }
    return ST_Coordinate32::default_instance();
}

bool CT_TextBodyProperties::has_rIns_attr() const
{
    return m_has_rIns_attr;
}

void CT_TextBodyProperties::set_rIns_attr(const ST_Coordinate32& _rIns_attr)
{
    m_has_rIns_attr = true;
    m_rIns_attr = new ST_Coordinate32(_rIns_attr);
}

const ST_Coordinate32& CT_TextBodyProperties::get_rIns_attr() const
{
    if (m_rIns_attr)
    {
        return *m_rIns_attr;
    }
    return ST_Coordinate32::default_instance();
}

bool CT_TextBodyProperties::has_bIns_attr() const
{
    return m_has_bIns_attr;
}

void CT_TextBodyProperties::set_bIns_attr(const ST_Coordinate32& _bIns_attr)
{
    m_has_bIns_attr = true;
    m_bIns_attr = new ST_Coordinate32(_bIns_attr);
}

const ST_Coordinate32& CT_TextBodyProperties::get_bIns_attr() const
{
    if (m_bIns_attr)
    {
        return *m_bIns_attr;
    }
    return ST_Coordinate32::default_instance();
}

bool CT_TextBodyProperties::has_numCol_attr() const
{
    return m_has_numCol_attr;
}

void CT_TextBodyProperties::set_numCol_attr(const ST_TextColumnCount& _numCol_attr)
{
    m_has_numCol_attr = true;
    m_numCol_attr = new ST_TextColumnCount(_numCol_attr);
}

const ST_TextColumnCount& CT_TextBodyProperties::get_numCol_attr() const
{
    if (m_numCol_attr)
    {
        return *m_numCol_attr;
    }
    return ST_TextColumnCount::default_instance();
}

bool CT_TextBodyProperties::has_spcCol_attr() const
{
    return m_has_spcCol_attr;
}

void CT_TextBodyProperties::set_spcCol_attr(const ST_PositiveCoordinate32& _spcCol_attr)
{
    m_has_spcCol_attr = true;
    m_spcCol_attr = new ST_PositiveCoordinate32(_spcCol_attr);
}

const ST_PositiveCoordinate32& CT_TextBodyProperties::get_spcCol_attr() const
{
    if (m_spcCol_attr)
    {
        return *m_spcCol_attr;
    }
    return ST_PositiveCoordinate32::default_instance();
}

bool CT_TextBodyProperties::has_rtlCol_attr() const
{
    return m_has_rtlCol_attr;
}

void CT_TextBodyProperties::set_rtlCol_attr(const XSD::boolean_& _rtlCol_attr)
{
    m_has_rtlCol_attr = true;
    m_rtlCol_attr = _rtlCol_attr;
}

const XSD::boolean_& CT_TextBodyProperties::get_rtlCol_attr() const
{
    return m_rtlCol_attr;
}

bool CT_TextBodyProperties::has_fromWordArt_attr() const
{
    return m_has_fromWordArt_attr;
}

void CT_TextBodyProperties::set_fromWordArt_attr(const XSD::boolean_& _fromWordArt_attr)
{
    m_has_fromWordArt_attr = true;
    m_fromWordArt_attr = _fromWordArt_attr;
}

const XSD::boolean_& CT_TextBodyProperties::get_fromWordArt_attr() const
{
    return m_fromWordArt_attr;
}

bool CT_TextBodyProperties::has_anchor_attr() const
{
    return m_has_anchor_attr;
}

void CT_TextBodyProperties::set_anchor_attr(const ST_TextAnchoringType& _anchor_attr)
{
    m_has_anchor_attr = true;
    m_anchor_attr = new ST_TextAnchoringType(_anchor_attr);
}

const ST_TextAnchoringType& CT_TextBodyProperties::get_anchor_attr() const
{
    if (m_anchor_attr)
    {
        return *m_anchor_attr;
    }
    return ST_TextAnchoringType::default_instance();
}

bool CT_TextBodyProperties::has_anchorCtr_attr() const
{
    return m_has_anchorCtr_attr;
}

void CT_TextBodyProperties::set_anchorCtr_attr(const XSD::boolean_& _anchorCtr_attr)
{
    m_has_anchorCtr_attr = true;
    m_anchorCtr_attr = _anchorCtr_attr;
}

const XSD::boolean_& CT_TextBodyProperties::get_anchorCtr_attr() const
{
    return m_anchorCtr_attr;
}

bool CT_TextBodyProperties::has_forceAA_attr() const
{
    return m_has_forceAA_attr;
}

void CT_TextBodyProperties::set_forceAA_attr(const XSD::boolean_& _forceAA_attr)
{
    m_has_forceAA_attr = true;
    m_forceAA_attr = _forceAA_attr;
}

const XSD::boolean_& CT_TextBodyProperties::get_forceAA_attr() const
{
    return m_forceAA_attr;
}

bool CT_TextBodyProperties::has_upright_attr() const
{
    return m_has_upright_attr;
}

void CT_TextBodyProperties::set_upright_attr(const XSD::boolean_& _upright_attr)
{
    m_has_upright_attr = true;
    m_upright_attr = _upright_attr;
}

const XSD::boolean_& CT_TextBodyProperties::get_upright_attr() const
{
    return m_upright_attr;
}

bool CT_TextBodyProperties::has_compatLnSpc_attr() const
{
    return m_has_compatLnSpc_attr;
}

void CT_TextBodyProperties::set_compatLnSpc_attr(const XSD::boolean_& _compatLnSpc_attr)
{
    m_has_compatLnSpc_attr = true;
    m_compatLnSpc_attr = _compatLnSpc_attr;
}

const XSD::boolean_& CT_TextBodyProperties::get_compatLnSpc_attr() const
{
    return m_compatLnSpc_attr;
}

CT_TextBodyProperties* CT_TextBodyProperties::default_instance_ = NULL;

// CT_TextBody
CT_TextBody::CT_TextBody()
    :m_has_bodyPr(false),
     m_bodyPr(NULL),
     m_has_lstStyle(false),
     m_lstStyle(NULL)
{
}
CT_TextBody::~CT_TextBody()
{
    clear();
}
bool CT_TextBody::has_bodyPr() const
{
    return m_has_bodyPr;
}

CT_TextBodyProperties* CT_TextBody::mutable_bodyPr()
{
    m_has_bodyPr = true;
    if (!m_bodyPr)
    {
        m_bodyPr = new CT_TextBodyProperties();
    }
    return m_bodyPr;
}

const CT_TextBodyProperties& CT_TextBody::get_bodyPr() const
{
    if (m_bodyPr)
    {
        return *m_bodyPr;
    }
    return CT_TextBodyProperties::default_instance();
}

bool CT_TextBody::has_lstStyle() const
{
    return m_has_lstStyle;
}

CT_TextListStyle* CT_TextBody::mutable_lstStyle()
{
    m_has_lstStyle = true;
    if (!m_lstStyle)
    {
        m_lstStyle = new CT_TextListStyle();
    }
    return m_lstStyle;
}

const CT_TextListStyle& CT_TextBody::get_lstStyle() const
{
    if (m_lstStyle)
    {
        return *m_lstStyle;
    }
    return CT_TextListStyle::default_instance();
}

CT_TextParagraph* CT_TextBody::add_p()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_TextParagraph* pNewChild = pChildGroup->mutable_p();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

void CT_TextBody::clear()
{
    m_has_bodyPr = false;

    if (m_bodyPr)
    {
        delete m_bodyPr;
        m_bodyPr = NULL;
    }


    m_has_lstStyle = false;

    if (m_lstStyle)
    {
        delete m_lstStyle;
        m_lstStyle = NULL;
    }


    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }
}

void CT_TextBody::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    assert(m_has_bodyPr);


    if (m_has_bodyPr)
    {
        m_bodyPr->toXmlElem("a:bodyPr", "", _outStream);
    }


    if (m_has_lstStyle)
    {
        m_lstStyle->toXmlElem("a:lstStyle", "", _outStream);
    }

    {
        int elemCnt = count_if(m_childGroupList_1.begin(), m_childGroupList_1.end(), mem_fun(&ChildGroup_1::has_p));
        assert(1 <= elemCnt);
    }

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_p())
            {
                (*iter)->get_p().toXmlElem("a:p", "", _outStream);
            }


        }
    }

    _outStream << "</" << _elemName << ">";
}

const CT_TextBody& CT_TextBody::default_instance()
{
    if (!CT_TextBody::default_instance_)
    {
        CT_TextBody::default_instance_ = new CT_TextBody();
    }
    return *CT_TextBody::default_instance_;
}


// CT_TextBody::ChildGroup_1
CT_TextBody::ChildGroup_1::ChildGroup_1()
    :m_has_p(false),
     m_p(NULL)
{
}
bool CT_TextBody::ChildGroup_1::has_p() const
{
    return m_has_p;
}

CT_TextParagraph* CT_TextBody::ChildGroup_1::mutable_p()
{

    m_has_p = true;
    if (!m_p)
    {
        m_p = new CT_TextParagraph();
    }
    return m_p;
}

const CT_TextParagraph& CT_TextBody::ChildGroup_1::get_p() const
{
    if (m_p)
    {
        return *m_p;
    }
    return CT_TextParagraph::default_instance();
}

CT_TextBody* CT_TextBody::default_instance_ = NULL;

// CT_TextBulletColorFollowText
CT_TextBulletColorFollowText::CT_TextBulletColorFollowText()

{
}
CT_TextBulletColorFollowText::~CT_TextBulletColorFollowText()
{
    clear();
}
void CT_TextBulletColorFollowText::clear()
{    }

void CT_TextBulletColorFollowText::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_TextBulletColorFollowText& CT_TextBulletColorFollowText::default_instance()
{
    if (!CT_TextBulletColorFollowText::default_instance_)
    {
        CT_TextBulletColorFollowText::default_instance_ = new CT_TextBulletColorFollowText();
    }
    return *CT_TextBulletColorFollowText::default_instance_;
}

CT_TextBulletColorFollowText* CT_TextBulletColorFollowText::default_instance_ = NULL;

// CT_TextBulletSizeFollowText
CT_TextBulletSizeFollowText::CT_TextBulletSizeFollowText()

{
}
CT_TextBulletSizeFollowText::~CT_TextBulletSizeFollowText()
{
    clear();
}
void CT_TextBulletSizeFollowText::clear()
{    }

void CT_TextBulletSizeFollowText::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_TextBulletSizeFollowText& CT_TextBulletSizeFollowText::default_instance()
{
    if (!CT_TextBulletSizeFollowText::default_instance_)
    {
        CT_TextBulletSizeFollowText::default_instance_ = new CT_TextBulletSizeFollowText();
    }
    return *CT_TextBulletSizeFollowText::default_instance_;
}

CT_TextBulletSizeFollowText* CT_TextBulletSizeFollowText::default_instance_ = NULL;

// CT_TextBulletSizePercent
CT_TextBulletSizePercent::CT_TextBulletSizePercent()
    :m_has_val_attr(false),
     m_val_attr(NULL)
{
}
CT_TextBulletSizePercent::~CT_TextBulletSizePercent()
{
    clear();
}
void CT_TextBulletSizePercent::clear()
{
    m_has_val_attr = false;

    if (m_val_attr)
    {
        delete m_val_attr;
        m_val_attr = NULL;
    }

}

void CT_TextBulletSizePercent::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_val_attr);
    if (m_has_val_attr)
    {
        m_val_attr->toXmlAttr("val", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_TextBulletSizePercent& CT_TextBulletSizePercent::default_instance()
{
    if (!CT_TextBulletSizePercent::default_instance_)
    {
        CT_TextBulletSizePercent::default_instance_ = new CT_TextBulletSizePercent();
    }
    return *CT_TextBulletSizePercent::default_instance_;
}

bool CT_TextBulletSizePercent::has_val_attr() const
{
    return m_has_val_attr;
}

void CT_TextBulletSizePercent::set_val_attr(const ST_TextBulletSizePercent& _val_attr)
{
    m_has_val_attr = true;
    m_val_attr = new ST_TextBulletSizePercent(_val_attr);
}

const ST_TextBulletSizePercent& CT_TextBulletSizePercent::get_val_attr() const
{
    if (m_val_attr)
    {
        return *m_val_attr;
    }
    return ST_TextBulletSizePercent::default_instance();
}

CT_TextBulletSizePercent* CT_TextBulletSizePercent::default_instance_ = NULL;

// CT_TextBulletSizePoint
CT_TextBulletSizePoint::CT_TextBulletSizePoint()
    :m_has_val_attr(false),
     m_val_attr(NULL)
{
}
CT_TextBulletSizePoint::~CT_TextBulletSizePoint()
{
    clear();
}
void CT_TextBulletSizePoint::clear()
{
    m_has_val_attr = false;

    if (m_val_attr)
    {
        delete m_val_attr;
        m_val_attr = NULL;
    }

}

void CT_TextBulletSizePoint::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_val_attr);
    if (m_has_val_attr)
    {
        m_val_attr->toXmlAttr("val", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_TextBulletSizePoint& CT_TextBulletSizePoint::default_instance()
{
    if (!CT_TextBulletSizePoint::default_instance_)
    {
        CT_TextBulletSizePoint::default_instance_ = new CT_TextBulletSizePoint();
    }
    return *CT_TextBulletSizePoint::default_instance_;
}

bool CT_TextBulletSizePoint::has_val_attr() const
{
    return m_has_val_attr;
}

void CT_TextBulletSizePoint::set_val_attr(const ST_TextFontSize& _val_attr)
{
    m_has_val_attr = true;
    m_val_attr = new ST_TextFontSize(_val_attr);
}

const ST_TextFontSize& CT_TextBulletSizePoint::get_val_attr() const
{
    if (m_val_attr)
    {
        return *m_val_attr;
    }
    return ST_TextFontSize::default_instance();
}

CT_TextBulletSizePoint* CT_TextBulletSizePoint::default_instance_ = NULL;

// CT_TextBulletTypefaceFollowText
CT_TextBulletTypefaceFollowText::CT_TextBulletTypefaceFollowText()

{
}
CT_TextBulletTypefaceFollowText::~CT_TextBulletTypefaceFollowText()
{
    clear();
}
void CT_TextBulletTypefaceFollowText::clear()
{    }

void CT_TextBulletTypefaceFollowText::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_TextBulletTypefaceFollowText& CT_TextBulletTypefaceFollowText::default_instance()
{
    if (!CT_TextBulletTypefaceFollowText::default_instance_)
    {
        CT_TextBulletTypefaceFollowText::default_instance_ = new CT_TextBulletTypefaceFollowText();
    }
    return *CT_TextBulletTypefaceFollowText::default_instance_;
}

CT_TextBulletTypefaceFollowText* CT_TextBulletTypefaceFollowText::default_instance_ = NULL;

// CT_TextAutonumberBullet
CT_TextAutonumberBullet::CT_TextAutonumberBullet()
    :m_has_type_attr(false),
     m_type_attr(NULL),
     m_has_startAt_attr(false),
     m_startAt_attr(NULL)
{
}
CT_TextAutonumberBullet::~CT_TextAutonumberBullet()
{
    clear();
}
void CT_TextAutonumberBullet::clear()
{
    m_has_type_attr = false;

    if (m_type_attr)
    {
        delete m_type_attr;
        m_type_attr = NULL;
    }


    m_has_startAt_attr = false;

    if (m_startAt_attr)
    {
        delete m_startAt_attr;
        m_startAt_attr = NULL;
    }

}

void CT_TextAutonumberBullet::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_type_attr);
    if (m_has_type_attr)
    {
        m_type_attr->toXmlAttr("type", _outStream);
    }



    if (m_has_startAt_attr)
    {
        m_startAt_attr->toXmlAttr("startAt", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_TextAutonumberBullet& CT_TextAutonumberBullet::default_instance()
{
    if (!CT_TextAutonumberBullet::default_instance_)
    {
        CT_TextAutonumberBullet::default_instance_ = new CT_TextAutonumberBullet();
    }
    return *CT_TextAutonumberBullet::default_instance_;
}

bool CT_TextAutonumberBullet::has_type_attr() const
{
    return m_has_type_attr;
}

void CT_TextAutonumberBullet::set_type_attr(const ST_TextAutonumberScheme& _type_attr)
{
    m_has_type_attr = true;
    m_type_attr = new ST_TextAutonumberScheme(_type_attr);
}

const ST_TextAutonumberScheme& CT_TextAutonumberBullet::get_type_attr() const
{
    if (m_type_attr)
    {
        return *m_type_attr;
    }
    return ST_TextAutonumberScheme::default_instance();
}

bool CT_TextAutonumberBullet::has_startAt_attr() const
{
    return m_has_startAt_attr;
}

void CT_TextAutonumberBullet::set_startAt_attr(const ST_TextBulletStartAtNum& _startAt_attr)
{
    m_has_startAt_attr = true;
    m_startAt_attr = new ST_TextBulletStartAtNum(_startAt_attr);
}

const ST_TextBulletStartAtNum& CT_TextAutonumberBullet::get_startAt_attr() const
{
    if (m_startAt_attr)
    {
        return *m_startAt_attr;
    }
    return ST_TextBulletStartAtNum::default_instance();
}

CT_TextAutonumberBullet* CT_TextAutonumberBullet::default_instance_ = NULL;

// CT_TextCharBullet
CT_TextCharBullet::CT_TextCharBullet()
    :m_has_char_attr(false),
     m_char_attr("")
{
}
CT_TextCharBullet::~CT_TextCharBullet()
{
    clear();
}
void CT_TextCharBullet::clear()
{
    m_has_char_attr = false;
    m_char_attr.clear();
}

void CT_TextCharBullet::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_char_attr);
    if (m_has_char_attr)
    {
        _outStream << " " << "char" << "=\"" << m_char_attr << "\"";
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_TextCharBullet& CT_TextCharBullet::default_instance()
{
    if (!CT_TextCharBullet::default_instance_)
    {
        CT_TextCharBullet::default_instance_ = new CT_TextCharBullet();
    }
    return *CT_TextCharBullet::default_instance_;
}

bool CT_TextCharBullet::has_char_attr() const
{
    return m_has_char_attr;
}

void CT_TextCharBullet::set_char_attr(const XSD::string_& _char_attr)
{
    m_has_char_attr = true;
    m_char_attr = _char_attr;
}

const XSD::string_& CT_TextCharBullet::get_char_attr() const
{
    return m_char_attr;
}

CT_TextCharBullet* CT_TextCharBullet::default_instance_ = NULL;

// CT_TextBlipBullet
CT_TextBlipBullet::CT_TextBlipBullet()
    :m_has_blip(false),
     m_blip(NULL)
{
}
CT_TextBlipBullet::~CT_TextBlipBullet()
{
    clear();
}
bool CT_TextBlipBullet::has_blip() const
{
    return m_has_blip;
}

CT_Blip* CT_TextBlipBullet::mutable_blip()
{
    m_has_blip = true;
    if (!m_blip)
    {
        m_blip = new CT_Blip();
    }
    return m_blip;
}

const CT_Blip& CT_TextBlipBullet::get_blip() const
{
    if (m_blip)
    {
        return *m_blip;
    }
    return CT_Blip::default_instance();
}

void CT_TextBlipBullet::clear()
{
    m_has_blip = false;

    if (m_blip)
    {
        delete m_blip;
        m_blip = NULL;
    }

}

void CT_TextBlipBullet::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    assert(m_has_blip);


    if (m_has_blip)
    {
        m_blip->toXmlElem("a:blip", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_TextBlipBullet& CT_TextBlipBullet::default_instance()
{
    if (!CT_TextBlipBullet::default_instance_)
    {
        CT_TextBlipBullet::default_instance_ = new CT_TextBlipBullet();
    }
    return *CT_TextBlipBullet::default_instance_;
}

CT_TextBlipBullet* CT_TextBlipBullet::default_instance_ = NULL;

// CT_TextNoBullet
CT_TextNoBullet::CT_TextNoBullet()

{
}
CT_TextNoBullet::~CT_TextNoBullet()
{
    clear();
}
void CT_TextNoBullet::clear()
{    }

void CT_TextNoBullet::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_TextNoBullet& CT_TextNoBullet::default_instance()
{
    if (!CT_TextNoBullet::default_instance_)
    {
        CT_TextNoBullet::default_instance_ = new CT_TextNoBullet();
    }
    return *CT_TextNoBullet::default_instance_;
}

CT_TextNoBullet* CT_TextNoBullet::default_instance_ = NULL;

// CT_TextFont
CT_TextFont::CT_TextFont()
    :m_has_typeface_attr(false),
     m_typeface_attr(NULL),
     m_has_panose_attr(false),
     m_panose_attr(NULL),
     m_has_pitchFamily_attr(false),
     m_pitchFamily_attr(NULL),
     m_has_charset_attr(false),
     m_charset_attr(0)
{
}
CT_TextFont::~CT_TextFont()
{
    clear();
}
void CT_TextFont::clear()
{
    m_has_typeface_attr = false;

    if (m_typeface_attr)
    {
        delete m_typeface_attr;
        m_typeface_attr = NULL;
    }


    m_has_panose_attr = false;

    if (m_panose_attr)
    {
        delete m_panose_attr;
        m_panose_attr = NULL;
    }


    m_has_pitchFamily_attr = false;

    if (m_pitchFamily_attr)
    {
        delete m_pitchFamily_attr;
        m_pitchFamily_attr = NULL;
    }


    m_has_charset_attr = false;
    m_charset_attr = 0;
}

void CT_TextFont::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_typeface_attr);
    if (m_has_typeface_attr)
    {
        m_typeface_attr->toXmlAttr("typeface", _outStream);
    }



    if (m_has_panose_attr)
    {
        m_panose_attr->toXmlAttr("panose", _outStream);
    }



    if (m_has_pitchFamily_attr)
    {
        m_pitchFamily_attr->toXmlAttr("pitchFamily", _outStream);
    }



    if (m_has_charset_attr)
    {
        _outStream << " " << "charset" << "=\"" << m_charset_attr << "\"";
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_TextFont& CT_TextFont::default_instance()
{
    if (!CT_TextFont::default_instance_)
    {
        CT_TextFont::default_instance_ = new CT_TextFont();
    }
    return *CT_TextFont::default_instance_;
}

bool CT_TextFont::has_typeface_attr() const
{
    return m_has_typeface_attr;
}

void CT_TextFont::set_typeface_attr(const ST_TextTypeface& _typeface_attr)
{
    m_has_typeface_attr = true;
    m_typeface_attr = new ST_TextTypeface(_typeface_attr);
}

const ST_TextTypeface& CT_TextFont::get_typeface_attr() const
{
    if (m_typeface_attr)
    {
        return *m_typeface_attr;
    }
    return ST_TextTypeface::default_instance();
}

bool CT_TextFont::has_panose_attr() const
{
    return m_has_panose_attr;
}

void CT_TextFont::set_panose_attr(const ns_s::ST_Panose& _panose_attr)
{
    m_has_panose_attr = true;
    m_panose_attr = new ns_s::ST_Panose(_panose_attr);
}

const ns_s::ST_Panose& CT_TextFont::get_panose_attr() const
{
    if (m_panose_attr)
    {
        return *m_panose_attr;
    }
    return ns_s::ST_Panose::default_instance();
}

bool CT_TextFont::has_pitchFamily_attr() const
{
    return m_has_pitchFamily_attr;
}

void CT_TextFont::set_pitchFamily_attr(const ST_PitchFamily& _pitchFamily_attr)
{
    m_has_pitchFamily_attr = true;
    m_pitchFamily_attr = new ST_PitchFamily(_pitchFamily_attr);
}

const ST_PitchFamily& CT_TextFont::get_pitchFamily_attr() const
{
    if (m_pitchFamily_attr)
    {
        return *m_pitchFamily_attr;
    }
    return ST_PitchFamily::default_instance();
}

bool CT_TextFont::has_charset_attr() const
{
    return m_has_charset_attr;
}

void CT_TextFont::set_charset_attr(const XSD::byte_& _charset_attr)
{
    m_has_charset_attr = true;
    m_charset_attr = _charset_attr;
}

const XSD::byte_& CT_TextFont::get_charset_attr() const
{
    return m_charset_attr;
}

CT_TextFont* CT_TextFont::default_instance_ = NULL;

// CT_TextUnderlineLineFollowText
CT_TextUnderlineLineFollowText::CT_TextUnderlineLineFollowText()

{
}
CT_TextUnderlineLineFollowText::~CT_TextUnderlineLineFollowText()
{
    clear();
}
void CT_TextUnderlineLineFollowText::clear()
{    }

void CT_TextUnderlineLineFollowText::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_TextUnderlineLineFollowText& CT_TextUnderlineLineFollowText::default_instance()
{
    if (!CT_TextUnderlineLineFollowText::default_instance_)
    {
        CT_TextUnderlineLineFollowText::default_instance_ = new CT_TextUnderlineLineFollowText();
    }
    return *CT_TextUnderlineLineFollowText::default_instance_;
}

CT_TextUnderlineLineFollowText* CT_TextUnderlineLineFollowText::default_instance_ = NULL;

// CT_TextUnderlineFillFollowText
CT_TextUnderlineFillFollowText::CT_TextUnderlineFillFollowText()

{
}
CT_TextUnderlineFillFollowText::~CT_TextUnderlineFillFollowText()
{
    clear();
}
void CT_TextUnderlineFillFollowText::clear()
{    }

void CT_TextUnderlineFillFollowText::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_TextUnderlineFillFollowText& CT_TextUnderlineFillFollowText::default_instance()
{
    if (!CT_TextUnderlineFillFollowText::default_instance_)
    {
        CT_TextUnderlineFillFollowText::default_instance_ = new CT_TextUnderlineFillFollowText();
    }
    return *CT_TextUnderlineFillFollowText::default_instance_;
}

CT_TextUnderlineFillFollowText* CT_TextUnderlineFillFollowText::default_instance_ = NULL;

// CT_TextUnderlineFillGroupWrapper
CT_TextUnderlineFillGroupWrapper::CT_TextUnderlineFillGroupWrapper()

{
}
CT_TextUnderlineFillGroupWrapper::~CT_TextUnderlineFillGroupWrapper()
{
    clear();
}
void CT_TextUnderlineFillGroupWrapper::clear()
{    }

void CT_TextUnderlineFillGroupWrapper::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_TextUnderlineFillGroupWrapper& CT_TextUnderlineFillGroupWrapper::default_instance()
{
    if (!CT_TextUnderlineFillGroupWrapper::default_instance_)
    {
        CT_TextUnderlineFillGroupWrapper::default_instance_ = new CT_TextUnderlineFillGroupWrapper();
    }
    return *CT_TextUnderlineFillGroupWrapper::default_instance_;
}

CT_TextUnderlineFillGroupWrapper* CT_TextUnderlineFillGroupWrapper::default_instance_ = NULL;

// CT_TextCharacterProperties
CT_TextCharacterProperties::CT_TextCharacterProperties()
    :m_has_ln(false),
     m_ln(NULL),
     m_has_noFill(false),
     m_noFill(NULL),
     m_has_solidFill(false),
     m_solidFill(NULL),
     m_has_gradFill(false),
     m_gradFill(NULL),
     m_has_blipFill(false),
     m_blipFill(NULL),
     m_has_pattFill(false),
     m_pattFill(NULL),
     m_has_grpFill(false),
     m_grpFill(NULL),
     m_has_effectLst(false),
     m_effectLst(NULL),
     m_has_effectDag(false),
     m_effectDag(NULL),
     m_has_highlight(false),
     m_highlight(NULL),
     m_has_uLnTx(false),
     m_uLnTx(NULL),
     m_has_uLn(false),
     m_uLn(NULL),
     m_has_uFillTx(false),
     m_uFillTx(NULL),
     m_has_uFill(false),
     m_uFill(NULL),
     m_has_latin(false),
     m_latin(NULL),
     m_has_ea(false),
     m_ea(NULL),
     m_has_cs(false),
     m_cs(NULL),
     m_has_sym(false),
     m_sym(NULL),
     m_has_hlinkClick(false),
     m_hlinkClick(NULL),
     m_has_hlinkMouseOver(false),
     m_hlinkMouseOver(NULL),
     m_has_rtl(false),
     m_rtl(NULL),
     m_has_extLst(false),
     m_extLst(NULL),
     m_has_kumimoji_attr(false),
     m_kumimoji_attr(false),
     m_has_lang_attr(false),
     m_lang_attr(NULL),
     m_has_altLang_attr(false),
     m_altLang_attr(NULL),
     m_has_sz_attr(false),
     m_sz_attr(NULL),
     m_has_b_attr(false),
     m_b_attr(false),
     m_has_i_attr(false),
     m_i_attr(false),
     m_has_u_attr(false),
     m_u_attr(NULL),
     m_has_strike_attr(false),
     m_strike_attr(NULL),
     m_has_kern_attr(false),
     m_kern_attr(NULL),
     m_has_cap_attr(false),
     m_cap_attr(NULL),
     m_has_spc_attr(false),
     m_spc_attr(NULL),
     m_has_normalizeH_attr(false),
     m_normalizeH_attr(false),
     m_has_baseline_attr(false),
     m_baseline_attr(NULL),
     m_has_noProof_attr(false),
     m_noProof_attr(false),
     m_has_dirty_attr(false),
     m_dirty_attr(false),
     m_has_err_attr(false),
     m_err_attr(false),
     m_has_smtClean_attr(false),
     m_smtClean_attr(false),
     m_has_smtId_attr(false),
     m_smtId_attr(0),
     m_has_bmk_attr(false),
     m_bmk_attr("")
{
}
CT_TextCharacterProperties::~CT_TextCharacterProperties()
{
    clear();
}
bool CT_TextCharacterProperties::has_ln() const
{
    return m_has_ln;
}

CT_LineProperties* CT_TextCharacterProperties::mutable_ln()
{
    m_has_ln = true;
    if (!m_ln)
    {
        m_ln = new CT_LineProperties();
    }
    return m_ln;
}

const CT_LineProperties& CT_TextCharacterProperties::get_ln() const
{
    if (m_ln)
    {
        return *m_ln;
    }
    return CT_LineProperties::default_instance();
}

bool CT_TextCharacterProperties::has_noFill() const
{
    return m_has_noFill;
}

CT_NoFillProperties* CT_TextCharacterProperties::mutable_noFill()
{

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_noFill = true;
    if (!m_noFill)
    {
        m_noFill = new CT_NoFillProperties();
    }
    return m_noFill;
}

const CT_NoFillProperties& CT_TextCharacterProperties::get_noFill() const
{
    if (m_noFill)
    {
        return *m_noFill;
    }
    return CT_NoFillProperties::default_instance();
}

bool CT_TextCharacterProperties::has_solidFill() const
{
    return m_has_solidFill;
}

CT_SolidColorFillProperties* CT_TextCharacterProperties::mutable_solidFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_solidFill = true;
    if (!m_solidFill)
    {
        m_solidFill = new CT_SolidColorFillProperties();
    }
    return m_solidFill;
}

const CT_SolidColorFillProperties& CT_TextCharacterProperties::get_solidFill() const
{
    if (m_solidFill)
    {
        return *m_solidFill;
    }
    return CT_SolidColorFillProperties::default_instance();
}

bool CT_TextCharacterProperties::has_gradFill() const
{
    return m_has_gradFill;
}

CT_GradientFillProperties* CT_TextCharacterProperties::mutable_gradFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_gradFill = true;
    if (!m_gradFill)
    {
        m_gradFill = new CT_GradientFillProperties();
    }
    return m_gradFill;
}

const CT_GradientFillProperties& CT_TextCharacterProperties::get_gradFill() const
{
    if (m_gradFill)
    {
        return *m_gradFill;
    }
    return CT_GradientFillProperties::default_instance();
}

bool CT_TextCharacterProperties::has_blipFill() const
{
    return m_has_blipFill;
}

CT_BlipFillProperties* CT_TextCharacterProperties::mutable_blipFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_blipFill = true;
    if (!m_blipFill)
    {
        m_blipFill = new CT_BlipFillProperties();
    }
    return m_blipFill;
}

const CT_BlipFillProperties& CT_TextCharacterProperties::get_blipFill() const
{
    if (m_blipFill)
    {
        return *m_blipFill;
    }
    return CT_BlipFillProperties::default_instance();
}

bool CT_TextCharacterProperties::has_pattFill() const
{
    return m_has_pattFill;
}

CT_PatternFillProperties* CT_TextCharacterProperties::mutable_pattFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_pattFill = true;
    if (!m_pattFill)
    {
        m_pattFill = new CT_PatternFillProperties();
    }
    return m_pattFill;
}

const CT_PatternFillProperties& CT_TextCharacterProperties::get_pattFill() const
{
    if (m_pattFill)
    {
        return *m_pattFill;
    }
    return CT_PatternFillProperties::default_instance();
}

bool CT_TextCharacterProperties::has_grpFill() const
{
    return m_has_grpFill;
}

CT_GroupFillProperties* CT_TextCharacterProperties::mutable_grpFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = true;
    if (!m_grpFill)
    {
        m_grpFill = new CT_GroupFillProperties();
    }
    return m_grpFill;
}

const CT_GroupFillProperties& CT_TextCharacterProperties::get_grpFill() const
{
    if (m_grpFill)
    {
        return *m_grpFill;
    }
    return CT_GroupFillProperties::default_instance();
}

bool CT_TextCharacterProperties::has_effectLst() const
{
    return m_has_effectLst;
}

CT_EffectList* CT_TextCharacterProperties::mutable_effectLst()
{

    m_has_effectDag = false;

    if (m_effectDag)
    {
        delete m_effectDag;
        m_effectDag = NULL;
    }
    ;

    m_has_effectLst = true;
    if (!m_effectLst)
    {
        m_effectLst = new CT_EffectList();
    }
    return m_effectLst;
}

const CT_EffectList& CT_TextCharacterProperties::get_effectLst() const
{
    if (m_effectLst)
    {
        return *m_effectLst;
    }
    return CT_EffectList::default_instance();
}

bool CT_TextCharacterProperties::has_effectDag() const
{
    return m_has_effectDag;
}

CT_EffectContainer* CT_TextCharacterProperties::mutable_effectDag()
{

    m_has_effectLst = false;

    if (m_effectLst)
    {
        delete m_effectLst;
        m_effectLst = NULL;
    }
    ;

    m_has_effectDag = true;
    if (!m_effectDag)
    {
        m_effectDag = new CT_EffectContainer();
    }
    return m_effectDag;
}

const CT_EffectContainer& CT_TextCharacterProperties::get_effectDag() const
{
    if (m_effectDag)
    {
        return *m_effectDag;
    }
    return CT_EffectContainer::default_instance();
}

bool CT_TextCharacterProperties::has_highlight() const
{
    return m_has_highlight;
}

CT_Color* CT_TextCharacterProperties::mutable_highlight()
{
    m_has_highlight = true;
    if (!m_highlight)
    {
        m_highlight = new CT_Color();
    }
    return m_highlight;
}

const CT_Color& CT_TextCharacterProperties::get_highlight() const
{
    if (m_highlight)
    {
        return *m_highlight;
    }
    return CT_Color::default_instance();
}

bool CT_TextCharacterProperties::has_uLnTx() const
{
    return m_has_uLnTx;
}

CT_TextUnderlineLineFollowText* CT_TextCharacterProperties::mutable_uLnTx()
{

    m_has_uLn = false;

    if (m_uLn)
    {
        delete m_uLn;
        m_uLn = NULL;
    }
    ;

    m_has_uLnTx = true;
    if (!m_uLnTx)
    {
        m_uLnTx = new CT_TextUnderlineLineFollowText();
    }
    return m_uLnTx;
}

const CT_TextUnderlineLineFollowText& CT_TextCharacterProperties::get_uLnTx() const
{
    if (m_uLnTx)
    {
        return *m_uLnTx;
    }
    return CT_TextUnderlineLineFollowText::default_instance();
}

bool CT_TextCharacterProperties::has_uLn() const
{
    return m_has_uLn;
}

CT_LineProperties* CT_TextCharacterProperties::mutable_uLn()
{

    m_has_uLnTx = false;

    if (m_uLnTx)
    {
        delete m_uLnTx;
        m_uLnTx = NULL;
    }
    ;

    m_has_uLn = true;
    if (!m_uLn)
    {
        m_uLn = new CT_LineProperties();
    }
    return m_uLn;
}

const CT_LineProperties& CT_TextCharacterProperties::get_uLn() const
{
    if (m_uLn)
    {
        return *m_uLn;
    }
    return CT_LineProperties::default_instance();
}

bool CT_TextCharacterProperties::has_uFillTx() const
{
    return m_has_uFillTx;
}

CT_TextUnderlineFillFollowText* CT_TextCharacterProperties::mutable_uFillTx()
{

    m_has_uFill = false;

    if (m_uFill)
    {
        delete m_uFill;
        m_uFill = NULL;
    }
    ;

    m_has_uFillTx = true;
    if (!m_uFillTx)
    {
        m_uFillTx = new CT_TextUnderlineFillFollowText();
    }
    return m_uFillTx;
}

const CT_TextUnderlineFillFollowText& CT_TextCharacterProperties::get_uFillTx() const
{
    if (m_uFillTx)
    {
        return *m_uFillTx;
    }
    return CT_TextUnderlineFillFollowText::default_instance();
}

bool CT_TextCharacterProperties::has_uFill() const
{
    return m_has_uFill;
}

CT_TextUnderlineFillGroupWrapper* CT_TextCharacterProperties::mutable_uFill()
{

    m_has_uFillTx = false;

    if (m_uFillTx)
    {
        delete m_uFillTx;
        m_uFillTx = NULL;
    }
    ;

    m_has_uFill = true;
    if (!m_uFill)
    {
        m_uFill = new CT_TextUnderlineFillGroupWrapper();
    }
    return m_uFill;
}

const CT_TextUnderlineFillGroupWrapper& CT_TextCharacterProperties::get_uFill() const
{
    if (m_uFill)
    {
        return *m_uFill;
    }
    return CT_TextUnderlineFillGroupWrapper::default_instance();
}

bool CT_TextCharacterProperties::has_latin() const
{
    return m_has_latin;
}

CT_TextFont* CT_TextCharacterProperties::mutable_latin()
{
    m_has_latin = true;
    if (!m_latin)
    {
        m_latin = new CT_TextFont();
    }
    return m_latin;
}

const CT_TextFont& CT_TextCharacterProperties::get_latin() const
{
    if (m_latin)
    {
        return *m_latin;
    }
    return CT_TextFont::default_instance();
}

bool CT_TextCharacterProperties::has_ea() const
{
    return m_has_ea;
}

CT_TextFont* CT_TextCharacterProperties::mutable_ea()
{
    m_has_ea = true;
    if (!m_ea)
    {
        m_ea = new CT_TextFont();
    }
    return m_ea;
}

const CT_TextFont& CT_TextCharacterProperties::get_ea() const
{
    if (m_ea)
    {
        return *m_ea;
    }
    return CT_TextFont::default_instance();
}

bool CT_TextCharacterProperties::has_cs() const
{
    return m_has_cs;
}

CT_TextFont* CT_TextCharacterProperties::mutable_cs()
{
    m_has_cs = true;
    if (!m_cs)
    {
        m_cs = new CT_TextFont();
    }
    return m_cs;
}

const CT_TextFont& CT_TextCharacterProperties::get_cs() const
{
    if (m_cs)
    {
        return *m_cs;
    }
    return CT_TextFont::default_instance();
}

bool CT_TextCharacterProperties::has_sym() const
{
    return m_has_sym;
}

CT_TextFont* CT_TextCharacterProperties::mutable_sym()
{
    m_has_sym = true;
    if (!m_sym)
    {
        m_sym = new CT_TextFont();
    }
    return m_sym;
}

const CT_TextFont& CT_TextCharacterProperties::get_sym() const
{
    if (m_sym)
    {
        return *m_sym;
    }
    return CT_TextFont::default_instance();
}

bool CT_TextCharacterProperties::has_hlinkClick() const
{
    return m_has_hlinkClick;
}

CT_Hyperlink* CT_TextCharacterProperties::mutable_hlinkClick()
{
    m_has_hlinkClick = true;
    if (!m_hlinkClick)
    {
        m_hlinkClick = new CT_Hyperlink();
    }
    return m_hlinkClick;
}

const CT_Hyperlink& CT_TextCharacterProperties::get_hlinkClick() const
{
    if (m_hlinkClick)
    {
        return *m_hlinkClick;
    }
    return CT_Hyperlink::default_instance();
}

bool CT_TextCharacterProperties::has_hlinkMouseOver() const
{
    return m_has_hlinkMouseOver;
}

CT_Hyperlink* CT_TextCharacterProperties::mutable_hlinkMouseOver()
{
    m_has_hlinkMouseOver = true;
    if (!m_hlinkMouseOver)
    {
        m_hlinkMouseOver = new CT_Hyperlink();
    }
    return m_hlinkMouseOver;
}

const CT_Hyperlink& CT_TextCharacterProperties::get_hlinkMouseOver() const
{
    if (m_hlinkMouseOver)
    {
        return *m_hlinkMouseOver;
    }
    return CT_Hyperlink::default_instance();
}

bool CT_TextCharacterProperties::has_rtl() const
{
    return m_has_rtl;
}

CT_Boolean* CT_TextCharacterProperties::mutable_rtl()
{
    m_has_rtl = true;
    if (!m_rtl)
    {
        m_rtl = new CT_Boolean();
    }
    return m_rtl;
}

const CT_Boolean& CT_TextCharacterProperties::get_rtl() const
{
    if (m_rtl)
    {
        return *m_rtl;
    }
    return CT_Boolean::default_instance();
}

bool CT_TextCharacterProperties::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_TextCharacterProperties::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_TextCharacterProperties::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_TextCharacterProperties::clear()
{
    m_has_kumimoji_attr = false;
    m_kumimoji_attr = false;

    m_has_lang_attr = false;

    if (m_lang_attr)
    {
        delete m_lang_attr;
        m_lang_attr = NULL;
    }


    m_has_altLang_attr = false;

    if (m_altLang_attr)
    {
        delete m_altLang_attr;
        m_altLang_attr = NULL;
    }


    m_has_sz_attr = false;

    if (m_sz_attr)
    {
        delete m_sz_attr;
        m_sz_attr = NULL;
    }


    m_has_b_attr = false;
    m_b_attr = false;

    m_has_i_attr = false;
    m_i_attr = false;

    m_has_u_attr = false;

    if (m_u_attr)
    {
        delete m_u_attr;
        m_u_attr = NULL;
    }


    m_has_strike_attr = false;

    if (m_strike_attr)
    {
        delete m_strike_attr;
        m_strike_attr = NULL;
    }


    m_has_kern_attr = false;

    if (m_kern_attr)
    {
        delete m_kern_attr;
        m_kern_attr = NULL;
    }


    m_has_cap_attr = false;

    if (m_cap_attr)
    {
        delete m_cap_attr;
        m_cap_attr = NULL;
    }


    m_has_spc_attr = false;

    if (m_spc_attr)
    {
        delete m_spc_attr;
        m_spc_attr = NULL;
    }


    m_has_normalizeH_attr = false;
    m_normalizeH_attr = false;

    m_has_baseline_attr = false;

    if (m_baseline_attr)
    {
        delete m_baseline_attr;
        m_baseline_attr = NULL;
    }


    m_has_noProof_attr = false;
    m_noProof_attr = false;

    m_has_dirty_attr = false;
    m_dirty_attr = false;

    m_has_err_attr = false;
    m_err_attr = false;

    m_has_smtClean_attr = false;
    m_smtClean_attr = false;

    m_has_smtId_attr = false;
    m_smtId_attr = 0;

    m_has_bmk_attr = false;
    m_bmk_attr.clear();

    m_has_ln = false;

    if (m_ln)
    {
        delete m_ln;
        m_ln = NULL;
    }


    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }


    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }


    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }


    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }


    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }


    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }


    m_has_effectLst = false;

    if (m_effectLst)
    {
        delete m_effectLst;
        m_effectLst = NULL;
    }


    m_has_effectDag = false;

    if (m_effectDag)
    {
        delete m_effectDag;
        m_effectDag = NULL;
    }


    m_has_highlight = false;

    if (m_highlight)
    {
        delete m_highlight;
        m_highlight = NULL;
    }


    m_has_uLnTx = false;

    if (m_uLnTx)
    {
        delete m_uLnTx;
        m_uLnTx = NULL;
    }


    m_has_uLn = false;

    if (m_uLn)
    {
        delete m_uLn;
        m_uLn = NULL;
    }


    m_has_uFillTx = false;

    if (m_uFillTx)
    {
        delete m_uFillTx;
        m_uFillTx = NULL;
    }


    m_has_uFill = false;

    if (m_uFill)
    {
        delete m_uFill;
        m_uFill = NULL;
    }


    m_has_latin = false;

    if (m_latin)
    {
        delete m_latin;
        m_latin = NULL;
    }


    m_has_ea = false;

    if (m_ea)
    {
        delete m_ea;
        m_ea = NULL;
    }


    m_has_cs = false;

    if (m_cs)
    {
        delete m_cs;
        m_cs = NULL;
    }


    m_has_sym = false;

    if (m_sym)
    {
        delete m_sym;
        m_sym = NULL;
    }


    m_has_hlinkClick = false;

    if (m_hlinkClick)
    {
        delete m_hlinkClick;
        m_hlinkClick = NULL;
    }


    m_has_hlinkMouseOver = false;

    if (m_hlinkMouseOver)
    {
        delete m_hlinkMouseOver;
        m_hlinkMouseOver = NULL;
    }


    m_has_rtl = false;

    if (m_rtl)
    {
        delete m_rtl;
        m_rtl = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_TextCharacterProperties::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_kumimoji_attr)
    {
        _outStream << " " << "kumimoji" << "=\"" << XSD::XMLBooleanStr(m_kumimoji_attr) << "\"";
    }



    if (m_has_lang_attr)
    {
        m_lang_attr->toXmlAttr("lang", _outStream);
    }



    if (m_has_altLang_attr)
    {
        m_altLang_attr->toXmlAttr("altLang", _outStream);
    }



    if (m_has_sz_attr)
    {
        m_sz_attr->toXmlAttr("sz", _outStream);
    }



    if (m_has_b_attr)
    {
        _outStream << " " << "b" << "=\"" << XSD::XMLBooleanStr(m_b_attr) << "\"";
    }



    if (m_has_i_attr)
    {
        _outStream << " " << "i" << "=\"" << XSD::XMLBooleanStr(m_i_attr) << "\"";
    }



    if (m_has_u_attr)
    {
        m_u_attr->toXmlAttr("u", _outStream);
    }



    if (m_has_strike_attr)
    {
        m_strike_attr->toXmlAttr("strike", _outStream);
    }



    if (m_has_kern_attr)
    {
        m_kern_attr->toXmlAttr("kern", _outStream);
    }



    if (m_has_cap_attr)
    {
        m_cap_attr->toXmlAttr("cap", _outStream);
    }



    if (m_has_spc_attr)
    {
        m_spc_attr->toXmlAttr("spc", _outStream);
    }



    if (m_has_normalizeH_attr)
    {
        _outStream << " " << "normalizeH" << "=\"" << XSD::XMLBooleanStr(m_normalizeH_attr) << "\"";
    }



    if (m_has_baseline_attr)
    {
        m_baseline_attr->toXmlAttr("baseline", _outStream);
    }



    if (m_has_noProof_attr)
    {
        _outStream << " " << "noProof" << "=\"" << XSD::XMLBooleanStr(m_noProof_attr) << "\"";
    }



    if (m_has_dirty_attr)
    {
        _outStream << " " << "dirty" << "=\"" << XSD::XMLBooleanStr(m_dirty_attr) << "\"";
    }



    if (m_has_err_attr)
    {
        _outStream << " " << "err" << "=\"" << XSD::XMLBooleanStr(m_err_attr) << "\"";
    }



    if (m_has_smtClean_attr)
    {
        _outStream << " " << "smtClean" << "=\"" << XSD::XMLBooleanStr(m_smtClean_attr) << "\"";
    }



    if (m_has_smtId_attr)
    {
        _outStream << " " << "smtId" << "=\"" << m_smtId_attr << "\"";
    }



    if (m_has_bmk_attr)
    {
        _outStream << " " << "bmk" << "=\"" << m_bmk_attr << "\"";
    }

    _outStream << ">";


    if (m_has_ln)
    {
        m_ln->toXmlElem("a:ln", "", _outStream);
    }

    {
        bool elemHasValueList[6] = {m_has_noFill, m_has_solidFill, m_has_gradFill, m_has_blipFill, m_has_pattFill, m_has_grpFill};
        int cnt = count(elemHasValueList, elemHasValueList + 6, true);
        assert(cnt == 0 || cnt == 1);
    }


    if (m_has_noFill)
    {
        m_noFill->toXmlElem("a:noFill", "", _outStream);
    }


    if (m_has_solidFill)
    {
        m_solidFill->toXmlElem("a:solidFill", "", _outStream);
    }


    if (m_has_gradFill)
    {
        m_gradFill->toXmlElem("a:gradFill", "", _outStream);
    }


    if (m_has_blipFill)
    {
        m_blipFill->toXmlElem("a:blipFill", "", _outStream);
    }


    if (m_has_pattFill)
    {
        m_pattFill->toXmlElem("a:pattFill", "", _outStream);
    }


    if (m_has_grpFill)
    {
        m_grpFill->toXmlElem("a:grpFill", "", _outStream);
    }

    {
        bool elemHasValueList[2] = {m_has_effectLst, m_has_effectDag};
        int cnt = count(elemHasValueList, elemHasValueList + 2, true);
        assert(cnt == 0 || cnt == 1);
    }


    if (m_has_effectLst)
    {
        m_effectLst->toXmlElem("a:effectLst", "", _outStream);
    }


    if (m_has_effectDag)
    {
        m_effectDag->toXmlElem("a:effectDag", "", _outStream);
    }


    if (m_has_highlight)
    {
        m_highlight->toXmlElem("a:highlight", "", _outStream);
    }

    {
        bool elemHasValueList[2] = {m_has_uLnTx, m_has_uLn};
        int cnt = count(elemHasValueList, elemHasValueList + 2, true);
        assert(cnt == 0 || cnt == 1);
    }


    if (m_has_uLnTx)
    {
        m_uLnTx->toXmlElem("a:uLnTx", "", _outStream);
    }


    if (m_has_uLn)
    {
        m_uLn->toXmlElem("a:uLn", "", _outStream);
    }

    {
        bool elemHasValueList[2] = {m_has_uFillTx, m_has_uFill};
        int cnt = count(elemHasValueList, elemHasValueList + 2, true);
        assert(cnt == 0 || cnt == 1);
    }


    if (m_has_uFillTx)
    {
        m_uFillTx->toXmlElem("a:uFillTx", "", _outStream);
    }


    if (m_has_uFill)
    {
        m_uFill->toXmlElem("a:uFill", "", _outStream);
    }


    if (m_has_latin)
    {
        m_latin->toXmlElem("a:latin", "", _outStream);
    }


    if (m_has_ea)
    {
        m_ea->toXmlElem("a:ea", "", _outStream);
    }


    if (m_has_cs)
    {
        m_cs->toXmlElem("a:cs", "", _outStream);
    }


    if (m_has_sym)
    {
        m_sym->toXmlElem("a:sym", "", _outStream);
    }


    if (m_has_hlinkClick)
    {
        m_hlinkClick->toXmlElem("a:hlinkClick", "", _outStream);
    }


    if (m_has_hlinkMouseOver)
    {
        m_hlinkMouseOver->toXmlElem("a:hlinkMouseOver", "", _outStream);
    }


    if (m_has_rtl)
    {
        m_rtl->toXmlElem("a:rtl", "", _outStream);
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_TextCharacterProperties& CT_TextCharacterProperties::default_instance()
{
    if (!CT_TextCharacterProperties::default_instance_)
    {
        CT_TextCharacterProperties::default_instance_ = new CT_TextCharacterProperties();
    }
    return *CT_TextCharacterProperties::default_instance_;
}

bool CT_TextCharacterProperties::has_kumimoji_attr() const
{
    return m_has_kumimoji_attr;
}

void CT_TextCharacterProperties::set_kumimoji_attr(const XSD::boolean_& _kumimoji_attr)
{
    m_has_kumimoji_attr = true;
    m_kumimoji_attr = _kumimoji_attr;
}

const XSD::boolean_& CT_TextCharacterProperties::get_kumimoji_attr() const
{
    return m_kumimoji_attr;
}

bool CT_TextCharacterProperties::has_lang_attr() const
{
    return m_has_lang_attr;
}

void CT_TextCharacterProperties::set_lang_attr(const ns_s::ST_Lang& _lang_attr)
{
    m_has_lang_attr = true;
    m_lang_attr = new ns_s::ST_Lang(_lang_attr);
}

const ns_s::ST_Lang& CT_TextCharacterProperties::get_lang_attr() const
{
    if (m_lang_attr)
    {
        return *m_lang_attr;
    }
    return ns_s::ST_Lang::default_instance();
}

bool CT_TextCharacterProperties::has_altLang_attr() const
{
    return m_has_altLang_attr;
}

void CT_TextCharacterProperties::set_altLang_attr(const ns_s::ST_Lang& _altLang_attr)
{
    m_has_altLang_attr = true;
    m_altLang_attr = new ns_s::ST_Lang(_altLang_attr);
}

const ns_s::ST_Lang& CT_TextCharacterProperties::get_altLang_attr() const
{
    if (m_altLang_attr)
    {
        return *m_altLang_attr;
    }
    return ns_s::ST_Lang::default_instance();
}

bool CT_TextCharacterProperties::has_sz_attr() const
{
    return m_has_sz_attr;
}

void CT_TextCharacterProperties::set_sz_attr(const ST_TextFontSize& _sz_attr)
{
    m_has_sz_attr = true;
    m_sz_attr = new ST_TextFontSize(_sz_attr);
}

const ST_TextFontSize& CT_TextCharacterProperties::get_sz_attr() const
{
    if (m_sz_attr)
    {
        return *m_sz_attr;
    }
    return ST_TextFontSize::default_instance();
}

bool CT_TextCharacterProperties::has_b_attr() const
{
    return m_has_b_attr;
}

void CT_TextCharacterProperties::set_b_attr(const XSD::boolean_& _b_attr)
{
    m_has_b_attr = true;
    m_b_attr = _b_attr;
}

const XSD::boolean_& CT_TextCharacterProperties::get_b_attr() const
{
    return m_b_attr;
}

bool CT_TextCharacterProperties::has_i_attr() const
{
    return m_has_i_attr;
}

void CT_TextCharacterProperties::set_i_attr(const XSD::boolean_& _i_attr)
{
    m_has_i_attr = true;
    m_i_attr = _i_attr;
}

const XSD::boolean_& CT_TextCharacterProperties::get_i_attr() const
{
    return m_i_attr;
}

bool CT_TextCharacterProperties::has_u_attr() const
{
    return m_has_u_attr;
}

void CT_TextCharacterProperties::set_u_attr(const ST_TextUnderlineType& _u_attr)
{
    m_has_u_attr = true;
    m_u_attr = new ST_TextUnderlineType(_u_attr);
}

const ST_TextUnderlineType& CT_TextCharacterProperties::get_u_attr() const
{
    if (m_u_attr)
    {
        return *m_u_attr;
    }
    return ST_TextUnderlineType::default_instance();
}

bool CT_TextCharacterProperties::has_strike_attr() const
{
    return m_has_strike_attr;
}

void CT_TextCharacterProperties::set_strike_attr(const ST_TextStrikeType& _strike_attr)
{
    m_has_strike_attr = true;
    m_strike_attr = new ST_TextStrikeType(_strike_attr);
}

const ST_TextStrikeType& CT_TextCharacterProperties::get_strike_attr() const
{
    if (m_strike_attr)
    {
        return *m_strike_attr;
    }
    return ST_TextStrikeType::default_instance();
}

bool CT_TextCharacterProperties::has_kern_attr() const
{
    return m_has_kern_attr;
}

void CT_TextCharacterProperties::set_kern_attr(const ST_TextNonNegativePoint& _kern_attr)
{
    m_has_kern_attr = true;
    m_kern_attr = new ST_TextNonNegativePoint(_kern_attr);
}

const ST_TextNonNegativePoint& CT_TextCharacterProperties::get_kern_attr() const
{
    if (m_kern_attr)
    {
        return *m_kern_attr;
    }
    return ST_TextNonNegativePoint::default_instance();
}

bool CT_TextCharacterProperties::has_cap_attr() const
{
    return m_has_cap_attr;
}

void CT_TextCharacterProperties::set_cap_attr(const ST_TextCapsType& _cap_attr)
{
    m_has_cap_attr = true;
    m_cap_attr = new ST_TextCapsType(_cap_attr);
}

const ST_TextCapsType& CT_TextCharacterProperties::get_cap_attr() const
{
    if (m_cap_attr)
    {
        return *m_cap_attr;
    }
    return ST_TextCapsType::default_instance();
}

bool CT_TextCharacterProperties::has_spc_attr() const
{
    return m_has_spc_attr;
}

void CT_TextCharacterProperties::set_spc_attr(const ST_TextPoint& _spc_attr)
{
    m_has_spc_attr = true;
    m_spc_attr = new ST_TextPoint(_spc_attr);
}

const ST_TextPoint& CT_TextCharacterProperties::get_spc_attr() const
{
    if (m_spc_attr)
    {
        return *m_spc_attr;
    }
    return ST_TextPoint::default_instance();
}

bool CT_TextCharacterProperties::has_normalizeH_attr() const
{
    return m_has_normalizeH_attr;
}

void CT_TextCharacterProperties::set_normalizeH_attr(const XSD::boolean_& _normalizeH_attr)
{
    m_has_normalizeH_attr = true;
    m_normalizeH_attr = _normalizeH_attr;
}

const XSD::boolean_& CT_TextCharacterProperties::get_normalizeH_attr() const
{
    return m_normalizeH_attr;
}

bool CT_TextCharacterProperties::has_baseline_attr() const
{
    return m_has_baseline_attr;
}

void CT_TextCharacterProperties::set_baseline_attr(const ST_Percentage& _baseline_attr)
{
    m_has_baseline_attr = true;
    m_baseline_attr = new ST_Percentage(_baseline_attr);
}

const ST_Percentage& CT_TextCharacterProperties::get_baseline_attr() const
{
    if (m_baseline_attr)
    {
        return *m_baseline_attr;
    }
    return ST_Percentage::default_instance();
}

bool CT_TextCharacterProperties::has_noProof_attr() const
{
    return m_has_noProof_attr;
}

void CT_TextCharacterProperties::set_noProof_attr(const XSD::boolean_& _noProof_attr)
{
    m_has_noProof_attr = true;
    m_noProof_attr = _noProof_attr;
}

const XSD::boolean_& CT_TextCharacterProperties::get_noProof_attr() const
{
    return m_noProof_attr;
}

bool CT_TextCharacterProperties::has_dirty_attr() const
{
    return m_has_dirty_attr;
}

void CT_TextCharacterProperties::set_dirty_attr(const XSD::boolean_& _dirty_attr)
{
    m_has_dirty_attr = true;
    m_dirty_attr = _dirty_attr;
}

const XSD::boolean_& CT_TextCharacterProperties::get_dirty_attr() const
{
    return m_dirty_attr;
}

bool CT_TextCharacterProperties::has_err_attr() const
{
    return m_has_err_attr;
}

void CT_TextCharacterProperties::set_err_attr(const XSD::boolean_& _err_attr)
{
    m_has_err_attr = true;
    m_err_attr = _err_attr;
}

const XSD::boolean_& CT_TextCharacterProperties::get_err_attr() const
{
    return m_err_attr;
}

bool CT_TextCharacterProperties::has_smtClean_attr() const
{
    return m_has_smtClean_attr;
}

void CT_TextCharacterProperties::set_smtClean_attr(const XSD::boolean_& _smtClean_attr)
{
    m_has_smtClean_attr = true;
    m_smtClean_attr = _smtClean_attr;
}

const XSD::boolean_& CT_TextCharacterProperties::get_smtClean_attr() const
{
    return m_smtClean_attr;
}

bool CT_TextCharacterProperties::has_smtId_attr() const
{
    return m_has_smtId_attr;
}

void CT_TextCharacterProperties::set_smtId_attr(const XSD::unsignedInt_& _smtId_attr)
{
    m_has_smtId_attr = true;
    m_smtId_attr = _smtId_attr;
}

const XSD::unsignedInt_& CT_TextCharacterProperties::get_smtId_attr() const
{
    return m_smtId_attr;
}

bool CT_TextCharacterProperties::has_bmk_attr() const
{
    return m_has_bmk_attr;
}

void CT_TextCharacterProperties::set_bmk_attr(const XSD::string_& _bmk_attr)
{
    m_has_bmk_attr = true;
    m_bmk_attr = _bmk_attr;
}

const XSD::string_& CT_TextCharacterProperties::get_bmk_attr() const
{
    return m_bmk_attr;
}

CT_TextCharacterProperties* CT_TextCharacterProperties::default_instance_ = NULL;

// CT_Boolean
CT_Boolean::CT_Boolean()
    :m_has_val_attr(false),
     m_val_attr(NULL)
{
}
CT_Boolean::~CT_Boolean()
{
    clear();
}
void CT_Boolean::clear()
{
    m_has_val_attr = false;

    if (m_val_attr)
    {
        delete m_val_attr;
        m_val_attr = NULL;
    }

}

void CT_Boolean::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_val_attr)
    {
        m_val_attr->toXmlAttr("val", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_Boolean& CT_Boolean::default_instance()
{
    if (!CT_Boolean::default_instance_)
    {
        CT_Boolean::default_instance_ = new CT_Boolean();
    }
    return *CT_Boolean::default_instance_;
}

bool CT_Boolean::has_val_attr() const
{
    return m_has_val_attr;
}

void CT_Boolean::set_val_attr(const ns_s::ST_OnOff& _val_attr)
{
    m_has_val_attr = true;
    m_val_attr = new ns_s::ST_OnOff(_val_attr);
}

const ns_s::ST_OnOff& CT_Boolean::get_val_attr() const
{
    if (m_val_attr)
    {
        return *m_val_attr;
    }
    return ns_s::ST_OnOff::default_instance();
}

CT_Boolean* CT_Boolean::default_instance_ = NULL;

// CT_TextSpacingPercent
CT_TextSpacingPercent::CT_TextSpacingPercent()
    :m_has_val_attr(false),
     m_val_attr(NULL)
{
}
CT_TextSpacingPercent::~CT_TextSpacingPercent()
{
    clear();
}
void CT_TextSpacingPercent::clear()
{
    m_has_val_attr = false;

    if (m_val_attr)
    {
        delete m_val_attr;
        m_val_attr = NULL;
    }

}

void CT_TextSpacingPercent::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_val_attr);
    if (m_has_val_attr)
    {
        m_val_attr->toXmlAttr("val", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_TextSpacingPercent& CT_TextSpacingPercent::default_instance()
{
    if (!CT_TextSpacingPercent::default_instance_)
    {
        CT_TextSpacingPercent::default_instance_ = new CT_TextSpacingPercent();
    }
    return *CT_TextSpacingPercent::default_instance_;
}

bool CT_TextSpacingPercent::has_val_attr() const
{
    return m_has_val_attr;
}

void CT_TextSpacingPercent::set_val_attr(const ST_TextSpacingPercentOrPercentString& _val_attr)
{
    m_has_val_attr = true;
    m_val_attr = new ST_TextSpacingPercentOrPercentString(_val_attr);
}

const ST_TextSpacingPercentOrPercentString& CT_TextSpacingPercent::get_val_attr() const
{
    if (m_val_attr)
    {
        return *m_val_attr;
    }
    return ST_TextSpacingPercentOrPercentString::default_instance();
}

CT_TextSpacingPercent* CT_TextSpacingPercent::default_instance_ = NULL;

// CT_TextSpacingPoint
CT_TextSpacingPoint::CT_TextSpacingPoint()
    :m_has_val_attr(false),
     m_val_attr(NULL)
{
}
CT_TextSpacingPoint::~CT_TextSpacingPoint()
{
    clear();
}
void CT_TextSpacingPoint::clear()
{
    m_has_val_attr = false;

    if (m_val_attr)
    {
        delete m_val_attr;
        m_val_attr = NULL;
    }

}

void CT_TextSpacingPoint::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_val_attr);
    if (m_has_val_attr)
    {
        m_val_attr->toXmlAttr("val", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_TextSpacingPoint& CT_TextSpacingPoint::default_instance()
{
    if (!CT_TextSpacingPoint::default_instance_)
    {
        CT_TextSpacingPoint::default_instance_ = new CT_TextSpacingPoint();
    }
    return *CT_TextSpacingPoint::default_instance_;
}

bool CT_TextSpacingPoint::has_val_attr() const
{
    return m_has_val_attr;
}

void CT_TextSpacingPoint::set_val_attr(const ST_TextSpacingPoint& _val_attr)
{
    m_has_val_attr = true;
    m_val_attr = new ST_TextSpacingPoint(_val_attr);
}

const ST_TextSpacingPoint& CT_TextSpacingPoint::get_val_attr() const
{
    if (m_val_attr)
    {
        return *m_val_attr;
    }
    return ST_TextSpacingPoint::default_instance();
}

CT_TextSpacingPoint* CT_TextSpacingPoint::default_instance_ = NULL;

// CT_TextTabStop
CT_TextTabStop::CT_TextTabStop()
    :m_has_pos_attr(false),
     m_pos_attr(NULL),
     m_has_algn_attr(false),
     m_algn_attr(NULL)
{
}
CT_TextTabStop::~CT_TextTabStop()
{
    clear();
}
void CT_TextTabStop::clear()
{
    m_has_pos_attr = false;

    if (m_pos_attr)
    {
        delete m_pos_attr;
        m_pos_attr = NULL;
    }


    m_has_algn_attr = false;

    if (m_algn_attr)
    {
        delete m_algn_attr;
        m_algn_attr = NULL;
    }

}

void CT_TextTabStop::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_pos_attr)
    {
        m_pos_attr->toXmlAttr("pos", _outStream);
    }



    if (m_has_algn_attr)
    {
        m_algn_attr->toXmlAttr("algn", _outStream);
    }

    _outStream << ">";

    _outStream << "</" << _elemName << ">";
}

const CT_TextTabStop& CT_TextTabStop::default_instance()
{
    if (!CT_TextTabStop::default_instance_)
    {
        CT_TextTabStop::default_instance_ = new CT_TextTabStop();
    }
    return *CT_TextTabStop::default_instance_;
}

bool CT_TextTabStop::has_pos_attr() const
{
    return m_has_pos_attr;
}

void CT_TextTabStop::set_pos_attr(const ST_Coordinate32& _pos_attr)
{
    m_has_pos_attr = true;
    m_pos_attr = new ST_Coordinate32(_pos_attr);
}

const ST_Coordinate32& CT_TextTabStop::get_pos_attr() const
{
    if (m_pos_attr)
    {
        return *m_pos_attr;
    }
    return ST_Coordinate32::default_instance();
}

bool CT_TextTabStop::has_algn_attr() const
{
    return m_has_algn_attr;
}

void CT_TextTabStop::set_algn_attr(const ST_TextTabAlignType& _algn_attr)
{
    m_has_algn_attr = true;
    m_algn_attr = new ST_TextTabAlignType(_algn_attr);
}

const ST_TextTabAlignType& CT_TextTabStop::get_algn_attr() const
{
    if (m_algn_attr)
    {
        return *m_algn_attr;
    }
    return ST_TextTabAlignType::default_instance();
}

CT_TextTabStop* CT_TextTabStop::default_instance_ = NULL;

// CT_TextTabStopList
CT_TextTabStopList::CT_TextTabStopList()

{
}
CT_TextTabStopList::~CT_TextTabStopList()
{
    clear();
}
CT_TextTabStop* CT_TextTabStopList::add_tab()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_TextTabStop* pNewChild = pChildGroup->mutable_tab();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

void CT_TextTabStopList::clear()
{
    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }
}

void CT_TextTabStopList::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    {
        int elemCnt = count_if(m_childGroupList_1.begin(), m_childGroupList_1.end(), mem_fun(&ChildGroup_1::has_tab));
        assert(0 <= elemCnt && elemCnt <= 32);
    }

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_tab())
            {
                (*iter)->get_tab().toXmlElem("a:tab", "", _outStream);
            }


        }
    }

    _outStream << "</" << _elemName << ">";
}

const CT_TextTabStopList& CT_TextTabStopList::default_instance()
{
    if (!CT_TextTabStopList::default_instance_)
    {
        CT_TextTabStopList::default_instance_ = new CT_TextTabStopList();
    }
    return *CT_TextTabStopList::default_instance_;
}


// CT_TextTabStopList::ChildGroup_1
CT_TextTabStopList::ChildGroup_1::ChildGroup_1()
    :m_has_tab(false),
     m_tab(NULL)
{
}
bool CT_TextTabStopList::ChildGroup_1::has_tab() const
{
    return m_has_tab;
}

CT_TextTabStop* CT_TextTabStopList::ChildGroup_1::mutable_tab()
{

    m_has_tab = true;
    if (!m_tab)
    {
        m_tab = new CT_TextTabStop();
    }
    return m_tab;
}

const CT_TextTabStop& CT_TextTabStopList::ChildGroup_1::get_tab() const
{
    if (m_tab)
    {
        return *m_tab;
    }
    return CT_TextTabStop::default_instance();
}

CT_TextTabStopList* CT_TextTabStopList::default_instance_ = NULL;

// CT_TextLineBreak
CT_TextLineBreak::CT_TextLineBreak()
    :m_has_rPr(false),
     m_rPr(NULL)
{
}
CT_TextLineBreak::~CT_TextLineBreak()
{
    clear();
}
bool CT_TextLineBreak::has_rPr() const
{
    return m_has_rPr;
}

CT_TextCharacterProperties* CT_TextLineBreak::mutable_rPr()
{
    m_has_rPr = true;
    if (!m_rPr)
    {
        m_rPr = new CT_TextCharacterProperties();
    }
    return m_rPr;
}

const CT_TextCharacterProperties& CT_TextLineBreak::get_rPr() const
{
    if (m_rPr)
    {
        return *m_rPr;
    }
    return CT_TextCharacterProperties::default_instance();
}

void CT_TextLineBreak::clear()
{
    m_has_rPr = false;

    if (m_rPr)
    {
        delete m_rPr;
        m_rPr = NULL;
    }

}

void CT_TextLineBreak::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";


    if (m_has_rPr)
    {
        m_rPr->toXmlElem("a:rPr", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_TextLineBreak& CT_TextLineBreak::default_instance()
{
    if (!CT_TextLineBreak::default_instance_)
    {
        CT_TextLineBreak::default_instance_ = new CT_TextLineBreak();
    }
    return *CT_TextLineBreak::default_instance_;
}

CT_TextLineBreak* CT_TextLineBreak::default_instance_ = NULL;

// CT_TextSpacing
CT_TextSpacing::CT_TextSpacing()
    :m_has_spcPct(false),
     m_spcPct(NULL),
     m_has_spcPts(false),
     m_spcPts(NULL)
{
}
CT_TextSpacing::~CT_TextSpacing()
{
    clear();
}
bool CT_TextSpacing::has_spcPct() const
{
    return m_has_spcPct;
}

CT_TextSpacingPercent* CT_TextSpacing::mutable_spcPct()
{

    m_has_spcPts = false;

    if (m_spcPts)
    {
        delete m_spcPts;
        m_spcPts = NULL;
    }
    ;

    m_has_spcPct = true;
    if (!m_spcPct)
    {
        m_spcPct = new CT_TextSpacingPercent();
    }
    return m_spcPct;
}

const CT_TextSpacingPercent& CT_TextSpacing::get_spcPct() const
{
    if (m_spcPct)
    {
        return *m_spcPct;
    }
    return CT_TextSpacingPercent::default_instance();
}

bool CT_TextSpacing::has_spcPts() const
{
    return m_has_spcPts;
}

CT_TextSpacingPoint* CT_TextSpacing::mutable_spcPts()
{

    m_has_spcPct = false;

    if (m_spcPct)
    {
        delete m_spcPct;
        m_spcPct = NULL;
    }
    ;

    m_has_spcPts = true;
    if (!m_spcPts)
    {
        m_spcPts = new CT_TextSpacingPoint();
    }
    return m_spcPts;
}

const CT_TextSpacingPoint& CT_TextSpacing::get_spcPts() const
{
    if (m_spcPts)
    {
        return *m_spcPts;
    }
    return CT_TextSpacingPoint::default_instance();
}

void CT_TextSpacing::clear()
{
    m_has_spcPct = false;

    if (m_spcPct)
    {
        delete m_spcPct;
        m_spcPct = NULL;
    }


    m_has_spcPts = false;

    if (m_spcPts)
    {
        delete m_spcPts;
        m_spcPts = NULL;
    }

}

void CT_TextSpacing::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    {
        bool elemHasValueList[2] = {m_has_spcPct, m_has_spcPts};
        int cnt = count(elemHasValueList, elemHasValueList + 2, true);
        assert(cnt == 1);
    }


    if (m_has_spcPct)
    {
        m_spcPct->toXmlElem("a:spcPct", "", _outStream);
    }


    if (m_has_spcPts)
    {
        m_spcPts->toXmlElem("a:spcPts", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_TextSpacing& CT_TextSpacing::default_instance()
{
    if (!CT_TextSpacing::default_instance_)
    {
        CT_TextSpacing::default_instance_ = new CT_TextSpacing();
    }
    return *CT_TextSpacing::default_instance_;
}

CT_TextSpacing* CT_TextSpacing::default_instance_ = NULL;

// CT_TextParagraphProperties
CT_TextParagraphProperties::CT_TextParagraphProperties()
    :m_has_lnSpc(false),
     m_lnSpc(NULL),
     m_has_spcBef(false),
     m_spcBef(NULL),
     m_has_spcAft(false),
     m_spcAft(NULL),
     m_has_buClrTx(false),
     m_buClrTx(NULL),
     m_has_buClr(false),
     m_buClr(NULL),
     m_has_buSzTx(false),
     m_buSzTx(NULL),
     m_has_buSzPct(false),
     m_buSzPct(NULL),
     m_has_buSzPts(false),
     m_buSzPts(NULL),
     m_has_buFontTx(false),
     m_buFontTx(NULL),
     m_has_buFont(false),
     m_buFont(NULL),
     m_has_buNone(false),
     m_buNone(NULL),
     m_has_buAutoNum(false),
     m_buAutoNum(NULL),
     m_has_buChar(false),
     m_buChar(NULL),
     m_has_buBlip(false),
     m_buBlip(NULL),
     m_has_tabLst(false),
     m_tabLst(NULL),
     m_has_defRPr(false),
     m_defRPr(NULL),
     m_has_extLst(false),
     m_extLst(NULL),
     m_has_marL_attr(false),
     m_marL_attr(NULL),
     m_has_marR_attr(false),
     m_marR_attr(NULL),
     m_has_lvl_attr(false),
     m_lvl_attr(NULL),
     m_has_indent_attr(false),
     m_indent_attr(NULL),
     m_has_algn_attr(false),
     m_algn_attr(NULL),
     m_has_defTabSz_attr(false),
     m_defTabSz_attr(NULL),
     m_has_rtl_attr(false),
     m_rtl_attr(false),
     m_has_eaLnBrk_attr(false),
     m_eaLnBrk_attr(false),
     m_has_fontAlgn_attr(false),
     m_fontAlgn_attr(NULL),
     m_has_latinLnBrk_attr(false),
     m_latinLnBrk_attr(false),
     m_has_hangingPunct_attr(false),
     m_hangingPunct_attr(false)
{
}
CT_TextParagraphProperties::~CT_TextParagraphProperties()
{
    clear();
}
bool CT_TextParagraphProperties::has_lnSpc() const
{
    return m_has_lnSpc;
}

CT_TextSpacing* CT_TextParagraphProperties::mutable_lnSpc()
{
    m_has_lnSpc = true;
    if (!m_lnSpc)
    {
        m_lnSpc = new CT_TextSpacing();
    }
    return m_lnSpc;
}

const CT_TextSpacing& CT_TextParagraphProperties::get_lnSpc() const
{
    if (m_lnSpc)
    {
        return *m_lnSpc;
    }
    return CT_TextSpacing::default_instance();
}

bool CT_TextParagraphProperties::has_spcBef() const
{
    return m_has_spcBef;
}

CT_TextSpacing* CT_TextParagraphProperties::mutable_spcBef()
{
    m_has_spcBef = true;
    if (!m_spcBef)
    {
        m_spcBef = new CT_TextSpacing();
    }
    return m_spcBef;
}

const CT_TextSpacing& CT_TextParagraphProperties::get_spcBef() const
{
    if (m_spcBef)
    {
        return *m_spcBef;
    }
    return CT_TextSpacing::default_instance();
}

bool CT_TextParagraphProperties::has_spcAft() const
{
    return m_has_spcAft;
}

CT_TextSpacing* CT_TextParagraphProperties::mutable_spcAft()
{
    m_has_spcAft = true;
    if (!m_spcAft)
    {
        m_spcAft = new CT_TextSpacing();
    }
    return m_spcAft;
}

const CT_TextSpacing& CT_TextParagraphProperties::get_spcAft() const
{
    if (m_spcAft)
    {
        return *m_spcAft;
    }
    return CT_TextSpacing::default_instance();
}

bool CT_TextParagraphProperties::has_buClrTx() const
{
    return m_has_buClrTx;
}

CT_TextBulletColorFollowText* CT_TextParagraphProperties::mutable_buClrTx()
{

    m_has_buClr = false;

    if (m_buClr)
    {
        delete m_buClr;
        m_buClr = NULL;
    }
    ;

    m_has_buClrTx = true;
    if (!m_buClrTx)
    {
        m_buClrTx = new CT_TextBulletColorFollowText();
    }
    return m_buClrTx;
}

const CT_TextBulletColorFollowText& CT_TextParagraphProperties::get_buClrTx() const
{
    if (m_buClrTx)
    {
        return *m_buClrTx;
    }
    return CT_TextBulletColorFollowText::default_instance();
}

bool CT_TextParagraphProperties::has_buClr() const
{
    return m_has_buClr;
}

CT_Color* CT_TextParagraphProperties::mutable_buClr()
{

    m_has_buClrTx = false;

    if (m_buClrTx)
    {
        delete m_buClrTx;
        m_buClrTx = NULL;
    }
    ;

    m_has_buClr = true;
    if (!m_buClr)
    {
        m_buClr = new CT_Color();
    }
    return m_buClr;
}

const CT_Color& CT_TextParagraphProperties::get_buClr() const
{
    if (m_buClr)
    {
        return *m_buClr;
    }
    return CT_Color::default_instance();
}

bool CT_TextParagraphProperties::has_buSzTx() const
{
    return m_has_buSzTx;
}

CT_TextBulletSizeFollowText* CT_TextParagraphProperties::mutable_buSzTx()
{

    m_has_buSzPct = false;

    if (m_buSzPct)
    {
        delete m_buSzPct;
        m_buSzPct = NULL;
    }
    ;

    m_has_buSzPts = false;

    if (m_buSzPts)
    {
        delete m_buSzPts;
        m_buSzPts = NULL;
    }
    ;

    m_has_buSzTx = true;
    if (!m_buSzTx)
    {
        m_buSzTx = new CT_TextBulletSizeFollowText();
    }
    return m_buSzTx;
}

const CT_TextBulletSizeFollowText& CT_TextParagraphProperties::get_buSzTx() const
{
    if (m_buSzTx)
    {
        return *m_buSzTx;
    }
    return CT_TextBulletSizeFollowText::default_instance();
}

bool CT_TextParagraphProperties::has_buSzPct() const
{
    return m_has_buSzPct;
}

CT_TextBulletSizePercent* CT_TextParagraphProperties::mutable_buSzPct()
{

    m_has_buSzTx = false;

    if (m_buSzTx)
    {
        delete m_buSzTx;
        m_buSzTx = NULL;
    }
    ;

    m_has_buSzPts = false;

    if (m_buSzPts)
    {
        delete m_buSzPts;
        m_buSzPts = NULL;
    }
    ;

    m_has_buSzPct = true;
    if (!m_buSzPct)
    {
        m_buSzPct = new CT_TextBulletSizePercent();
    }
    return m_buSzPct;
}

const CT_TextBulletSizePercent& CT_TextParagraphProperties::get_buSzPct() const
{
    if (m_buSzPct)
    {
        return *m_buSzPct;
    }
    return CT_TextBulletSizePercent::default_instance();
}

bool CT_TextParagraphProperties::has_buSzPts() const
{
    return m_has_buSzPts;
}

CT_TextBulletSizePoint* CT_TextParagraphProperties::mutable_buSzPts()
{

    m_has_buSzTx = false;

    if (m_buSzTx)
    {
        delete m_buSzTx;
        m_buSzTx = NULL;
    }
    ;

    m_has_buSzPct = false;

    if (m_buSzPct)
    {
        delete m_buSzPct;
        m_buSzPct = NULL;
    }
    ;

    m_has_buSzPts = true;
    if (!m_buSzPts)
    {
        m_buSzPts = new CT_TextBulletSizePoint();
    }
    return m_buSzPts;
}

const CT_TextBulletSizePoint& CT_TextParagraphProperties::get_buSzPts() const
{
    if (m_buSzPts)
    {
        return *m_buSzPts;
    }
    return CT_TextBulletSizePoint::default_instance();
}

bool CT_TextParagraphProperties::has_buFontTx() const
{
    return m_has_buFontTx;
}

CT_TextBulletTypefaceFollowText* CT_TextParagraphProperties::mutable_buFontTx()
{

    m_has_buFont = false;

    if (m_buFont)
    {
        delete m_buFont;
        m_buFont = NULL;
    }
    ;

    m_has_buFontTx = true;
    if (!m_buFontTx)
    {
        m_buFontTx = new CT_TextBulletTypefaceFollowText();
    }
    return m_buFontTx;
}

const CT_TextBulletTypefaceFollowText& CT_TextParagraphProperties::get_buFontTx() const
{
    if (m_buFontTx)
    {
        return *m_buFontTx;
    }
    return CT_TextBulletTypefaceFollowText::default_instance();
}

bool CT_TextParagraphProperties::has_buFont() const
{
    return m_has_buFont;
}

CT_TextFont* CT_TextParagraphProperties::mutable_buFont()
{

    m_has_buFontTx = false;

    if (m_buFontTx)
    {
        delete m_buFontTx;
        m_buFontTx = NULL;
    }
    ;

    m_has_buFont = true;
    if (!m_buFont)
    {
        m_buFont = new CT_TextFont();
    }
    return m_buFont;
}

const CT_TextFont& CT_TextParagraphProperties::get_buFont() const
{
    if (m_buFont)
    {
        return *m_buFont;
    }
    return CT_TextFont::default_instance();
}

bool CT_TextParagraphProperties::has_buNone() const
{
    return m_has_buNone;
}

CT_TextNoBullet* CT_TextParagraphProperties::mutable_buNone()
{

    m_has_buAutoNum = false;

    if (m_buAutoNum)
    {
        delete m_buAutoNum;
        m_buAutoNum = NULL;
    }
    ;

    m_has_buChar = false;

    if (m_buChar)
    {
        delete m_buChar;
        m_buChar = NULL;
    }
    ;

    m_has_buBlip = false;

    if (m_buBlip)
    {
        delete m_buBlip;
        m_buBlip = NULL;
    }
    ;

    m_has_buNone = true;
    if (!m_buNone)
    {
        m_buNone = new CT_TextNoBullet();
    }
    return m_buNone;
}

const CT_TextNoBullet& CT_TextParagraphProperties::get_buNone() const
{
    if (m_buNone)
    {
        return *m_buNone;
    }
    return CT_TextNoBullet::default_instance();
}

bool CT_TextParagraphProperties::has_buAutoNum() const
{
    return m_has_buAutoNum;
}

CT_TextAutonumberBullet* CT_TextParagraphProperties::mutable_buAutoNum()
{

    m_has_buNone = false;

    if (m_buNone)
    {
        delete m_buNone;
        m_buNone = NULL;
    }
    ;

    m_has_buChar = false;

    if (m_buChar)
    {
        delete m_buChar;
        m_buChar = NULL;
    }
    ;

    m_has_buBlip = false;

    if (m_buBlip)
    {
        delete m_buBlip;
        m_buBlip = NULL;
    }
    ;

    m_has_buAutoNum = true;
    if (!m_buAutoNum)
    {
        m_buAutoNum = new CT_TextAutonumberBullet();
    }
    return m_buAutoNum;
}

const CT_TextAutonumberBullet& CT_TextParagraphProperties::get_buAutoNum() const
{
    if (m_buAutoNum)
    {
        return *m_buAutoNum;
    }
    return CT_TextAutonumberBullet::default_instance();
}

bool CT_TextParagraphProperties::has_buChar() const
{
    return m_has_buChar;
}

CT_TextCharBullet* CT_TextParagraphProperties::mutable_buChar()
{

    m_has_buNone = false;

    if (m_buNone)
    {
        delete m_buNone;
        m_buNone = NULL;
    }
    ;

    m_has_buAutoNum = false;

    if (m_buAutoNum)
    {
        delete m_buAutoNum;
        m_buAutoNum = NULL;
    }
    ;

    m_has_buBlip = false;

    if (m_buBlip)
    {
        delete m_buBlip;
        m_buBlip = NULL;
    }
    ;

    m_has_buChar = true;
    if (!m_buChar)
    {
        m_buChar = new CT_TextCharBullet();
    }
    return m_buChar;
}

const CT_TextCharBullet& CT_TextParagraphProperties::get_buChar() const
{
    if (m_buChar)
    {
        return *m_buChar;
    }
    return CT_TextCharBullet::default_instance();
}

bool CT_TextParagraphProperties::has_buBlip() const
{
    return m_has_buBlip;
}

CT_TextBlipBullet* CT_TextParagraphProperties::mutable_buBlip()
{

    m_has_buNone = false;

    if (m_buNone)
    {
        delete m_buNone;
        m_buNone = NULL;
    }
    ;

    m_has_buAutoNum = false;

    if (m_buAutoNum)
    {
        delete m_buAutoNum;
        m_buAutoNum = NULL;
    }
    ;

    m_has_buChar = false;

    if (m_buChar)
    {
        delete m_buChar;
        m_buChar = NULL;
    }
    ;

    m_has_buBlip = true;
    if (!m_buBlip)
    {
        m_buBlip = new CT_TextBlipBullet();
    }
    return m_buBlip;
}

const CT_TextBlipBullet& CT_TextParagraphProperties::get_buBlip() const
{
    if (m_buBlip)
    {
        return *m_buBlip;
    }
    return CT_TextBlipBullet::default_instance();
}

bool CT_TextParagraphProperties::has_tabLst() const
{
    return m_has_tabLst;
}

CT_TextTabStopList* CT_TextParagraphProperties::mutable_tabLst()
{
    m_has_tabLst = true;
    if (!m_tabLst)
    {
        m_tabLst = new CT_TextTabStopList();
    }
    return m_tabLst;
}

const CT_TextTabStopList& CT_TextParagraphProperties::get_tabLst() const
{
    if (m_tabLst)
    {
        return *m_tabLst;
    }
    return CT_TextTabStopList::default_instance();
}

bool CT_TextParagraphProperties::has_defRPr() const
{
    return m_has_defRPr;
}

CT_TextCharacterProperties* CT_TextParagraphProperties::mutable_defRPr()
{
    m_has_defRPr = true;
    if (!m_defRPr)
    {
        m_defRPr = new CT_TextCharacterProperties();
    }
    return m_defRPr;
}

const CT_TextCharacterProperties& CT_TextParagraphProperties::get_defRPr() const
{
    if (m_defRPr)
    {
        return *m_defRPr;
    }
    return CT_TextCharacterProperties::default_instance();
}

bool CT_TextParagraphProperties::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* CT_TextParagraphProperties::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& CT_TextParagraphProperties::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void CT_TextParagraphProperties::clear()
{
    m_has_marL_attr = false;

    if (m_marL_attr)
    {
        delete m_marL_attr;
        m_marL_attr = NULL;
    }


    m_has_marR_attr = false;

    if (m_marR_attr)
    {
        delete m_marR_attr;
        m_marR_attr = NULL;
    }


    m_has_lvl_attr = false;

    if (m_lvl_attr)
    {
        delete m_lvl_attr;
        m_lvl_attr = NULL;
    }


    m_has_indent_attr = false;

    if (m_indent_attr)
    {
        delete m_indent_attr;
        m_indent_attr = NULL;
    }


    m_has_algn_attr = false;

    if (m_algn_attr)
    {
        delete m_algn_attr;
        m_algn_attr = NULL;
    }


    m_has_defTabSz_attr = false;

    if (m_defTabSz_attr)
    {
        delete m_defTabSz_attr;
        m_defTabSz_attr = NULL;
    }


    m_has_rtl_attr = false;
    m_rtl_attr = false;

    m_has_eaLnBrk_attr = false;
    m_eaLnBrk_attr = false;

    m_has_fontAlgn_attr = false;

    if (m_fontAlgn_attr)
    {
        delete m_fontAlgn_attr;
        m_fontAlgn_attr = NULL;
    }


    m_has_latinLnBrk_attr = false;
    m_latinLnBrk_attr = false;

    m_has_hangingPunct_attr = false;
    m_hangingPunct_attr = false;

    m_has_lnSpc = false;

    if (m_lnSpc)
    {
        delete m_lnSpc;
        m_lnSpc = NULL;
    }


    m_has_spcBef = false;

    if (m_spcBef)
    {
        delete m_spcBef;
        m_spcBef = NULL;
    }


    m_has_spcAft = false;

    if (m_spcAft)
    {
        delete m_spcAft;
        m_spcAft = NULL;
    }


    m_has_buClrTx = false;

    if (m_buClrTx)
    {
        delete m_buClrTx;
        m_buClrTx = NULL;
    }


    m_has_buClr = false;

    if (m_buClr)
    {
        delete m_buClr;
        m_buClr = NULL;
    }


    m_has_buSzTx = false;

    if (m_buSzTx)
    {
        delete m_buSzTx;
        m_buSzTx = NULL;
    }


    m_has_buSzPct = false;

    if (m_buSzPct)
    {
        delete m_buSzPct;
        m_buSzPct = NULL;
    }


    m_has_buSzPts = false;

    if (m_buSzPts)
    {
        delete m_buSzPts;
        m_buSzPts = NULL;
    }


    m_has_buFontTx = false;

    if (m_buFontTx)
    {
        delete m_buFontTx;
        m_buFontTx = NULL;
    }


    m_has_buFont = false;

    if (m_buFont)
    {
        delete m_buFont;
        m_buFont = NULL;
    }


    m_has_buNone = false;

    if (m_buNone)
    {
        delete m_buNone;
        m_buNone = NULL;
    }


    m_has_buAutoNum = false;

    if (m_buAutoNum)
    {
        delete m_buAutoNum;
        m_buAutoNum = NULL;
    }


    m_has_buChar = false;

    if (m_buChar)
    {
        delete m_buChar;
        m_buChar = NULL;
    }


    m_has_buBlip = false;

    if (m_buBlip)
    {
        delete m_buBlip;
        m_buBlip = NULL;
    }


    m_has_tabLst = false;

    if (m_tabLst)
    {
        delete m_tabLst;
        m_tabLst = NULL;
    }


    m_has_defRPr = false;

    if (m_defRPr)
    {
        delete m_defRPr;
        m_defRPr = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void CT_TextParagraphProperties::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }


    if (m_has_marL_attr)
    {
        m_marL_attr->toXmlAttr("marL", _outStream);
    }



    if (m_has_marR_attr)
    {
        m_marR_attr->toXmlAttr("marR", _outStream);
    }



    if (m_has_lvl_attr)
    {
        m_lvl_attr->toXmlAttr("lvl", _outStream);
    }



    if (m_has_indent_attr)
    {
        m_indent_attr->toXmlAttr("indent", _outStream);
    }



    if (m_has_algn_attr)
    {
        m_algn_attr->toXmlAttr("algn", _outStream);
    }



    if (m_has_defTabSz_attr)
    {
        m_defTabSz_attr->toXmlAttr("defTabSz", _outStream);
    }



    if (m_has_rtl_attr)
    {
        _outStream << " " << "rtl" << "=\"" << XSD::XMLBooleanStr(m_rtl_attr) << "\"";
    }



    if (m_has_eaLnBrk_attr)
    {
        _outStream << " " << "eaLnBrk" << "=\"" << XSD::XMLBooleanStr(m_eaLnBrk_attr) << "\"";
    }



    if (m_has_fontAlgn_attr)
    {
        m_fontAlgn_attr->toXmlAttr("fontAlgn", _outStream);
    }



    if (m_has_latinLnBrk_attr)
    {
        _outStream << " " << "latinLnBrk" << "=\"" << XSD::XMLBooleanStr(m_latinLnBrk_attr) << "\"";
    }



    if (m_has_hangingPunct_attr)
    {
        _outStream << " " << "hangingPunct" << "=\"" << XSD::XMLBooleanStr(m_hangingPunct_attr) << "\"";
    }

    _outStream << ">";


    if (m_has_lnSpc)
    {
        m_lnSpc->toXmlElem("a:lnSpc", "", _outStream);
    }


    if (m_has_spcBef)
    {
        m_spcBef->toXmlElem("a:spcBef", "", _outStream);
    }


    if (m_has_spcAft)
    {
        m_spcAft->toXmlElem("a:spcAft", "", _outStream);
    }

    {
        bool elemHasValueList[2] = {m_has_buClrTx, m_has_buClr};
        int cnt = count(elemHasValueList, elemHasValueList + 2, true);
        assert(cnt == 0 || cnt == 1);
    }


    if (m_has_buClrTx)
    {
        m_buClrTx->toXmlElem("a:buClrTx", "", _outStream);
    }


    if (m_has_buClr)
    {
        m_buClr->toXmlElem("a:buClr", "", _outStream);
    }

    {
        bool elemHasValueList[3] = {m_has_buSzTx, m_has_buSzPct, m_has_buSzPts};
        int cnt = count(elemHasValueList, elemHasValueList + 3, true);
        assert(cnt == 0 || cnt == 1);
    }


    if (m_has_buSzTx)
    {
        m_buSzTx->toXmlElem("a:buSzTx", "", _outStream);
    }


    if (m_has_buSzPct)
    {
        m_buSzPct->toXmlElem("a:buSzPct", "", _outStream);
    }


    if (m_has_buSzPts)
    {
        m_buSzPts->toXmlElem("a:buSzPts", "", _outStream);
    }

    {
        bool elemHasValueList[2] = {m_has_buFontTx, m_has_buFont};
        int cnt = count(elemHasValueList, elemHasValueList + 2, true);
        assert(cnt == 0 || cnt == 1);
    }


    if (m_has_buFontTx)
    {
        m_buFontTx->toXmlElem("a:buFontTx", "", _outStream);
    }


    if (m_has_buFont)
    {
        m_buFont->toXmlElem("a:buFont", "", _outStream);
    }

    {
        bool elemHasValueList[4] = {m_has_buNone, m_has_buAutoNum, m_has_buChar, m_has_buBlip};
        int cnt = count(elemHasValueList, elemHasValueList + 4, true);
        assert(cnt == 0 || cnt == 1);
    }


    if (m_has_buNone)
    {
        m_buNone->toXmlElem("a:buNone", "", _outStream);
    }


    if (m_has_buAutoNum)
    {
        m_buAutoNum->toXmlElem("a:buAutoNum", "", _outStream);
    }


    if (m_has_buChar)
    {
        m_buChar->toXmlElem("a:buChar", "", _outStream);
    }


    if (m_has_buBlip)
    {
        m_buBlip->toXmlElem("a:buBlip", "", _outStream);
    }


    if (m_has_tabLst)
    {
        m_tabLst->toXmlElem("a:tabLst", "", _outStream);
    }


    if (m_has_defRPr)
    {
        m_defRPr->toXmlElem("a:defRPr", "", _outStream);
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_TextParagraphProperties& CT_TextParagraphProperties::default_instance()
{
    if (!CT_TextParagraphProperties::default_instance_)
    {
        CT_TextParagraphProperties::default_instance_ = new CT_TextParagraphProperties();
    }
    return *CT_TextParagraphProperties::default_instance_;
}

bool CT_TextParagraphProperties::has_marL_attr() const
{
    return m_has_marL_attr;
}

void CT_TextParagraphProperties::set_marL_attr(const ST_TextMargin& _marL_attr)
{
    m_has_marL_attr = true;
    m_marL_attr = new ST_TextMargin(_marL_attr);
}

const ST_TextMargin& CT_TextParagraphProperties::get_marL_attr() const
{
    if (m_marL_attr)
    {
        return *m_marL_attr;
    }
    return ST_TextMargin::default_instance();
}

bool CT_TextParagraphProperties::has_marR_attr() const
{
    return m_has_marR_attr;
}

void CT_TextParagraphProperties::set_marR_attr(const ST_TextMargin& _marR_attr)
{
    m_has_marR_attr = true;
    m_marR_attr = new ST_TextMargin(_marR_attr);
}

const ST_TextMargin& CT_TextParagraphProperties::get_marR_attr() const
{
    if (m_marR_attr)
    {
        return *m_marR_attr;
    }
    return ST_TextMargin::default_instance();
}

bool CT_TextParagraphProperties::has_lvl_attr() const
{
    return m_has_lvl_attr;
}

void CT_TextParagraphProperties::set_lvl_attr(const ST_TextIndentLevelType& _lvl_attr)
{
    m_has_lvl_attr = true;
    m_lvl_attr = new ST_TextIndentLevelType(_lvl_attr);
}

const ST_TextIndentLevelType& CT_TextParagraphProperties::get_lvl_attr() const
{
    if (m_lvl_attr)
    {
        return *m_lvl_attr;
    }
    return ST_TextIndentLevelType::default_instance();
}

bool CT_TextParagraphProperties::has_indent_attr() const
{
    return m_has_indent_attr;
}

void CT_TextParagraphProperties::set_indent_attr(const ST_TextIndent& _indent_attr)
{
    m_has_indent_attr = true;
    m_indent_attr = new ST_TextIndent(_indent_attr);
}

const ST_TextIndent& CT_TextParagraphProperties::get_indent_attr() const
{
    if (m_indent_attr)
    {
        return *m_indent_attr;
    }
    return ST_TextIndent::default_instance();
}

bool CT_TextParagraphProperties::has_algn_attr() const
{
    return m_has_algn_attr;
}

void CT_TextParagraphProperties::set_algn_attr(const ST_TextAlignType& _algn_attr)
{
    m_has_algn_attr = true;
    m_algn_attr = new ST_TextAlignType(_algn_attr);
}

const ST_TextAlignType& CT_TextParagraphProperties::get_algn_attr() const
{
    if (m_algn_attr)
    {
        return *m_algn_attr;
    }
    return ST_TextAlignType::default_instance();
}

bool CT_TextParagraphProperties::has_defTabSz_attr() const
{
    return m_has_defTabSz_attr;
}

void CT_TextParagraphProperties::set_defTabSz_attr(const ST_Coordinate32& _defTabSz_attr)
{
    m_has_defTabSz_attr = true;
    m_defTabSz_attr = new ST_Coordinate32(_defTabSz_attr);
}

const ST_Coordinate32& CT_TextParagraphProperties::get_defTabSz_attr() const
{
    if (m_defTabSz_attr)
    {
        return *m_defTabSz_attr;
    }
    return ST_Coordinate32::default_instance();
}

bool CT_TextParagraphProperties::has_rtl_attr() const
{
    return m_has_rtl_attr;
}

void CT_TextParagraphProperties::set_rtl_attr(const XSD::boolean_& _rtl_attr)
{
    m_has_rtl_attr = true;
    m_rtl_attr = _rtl_attr;
}

const XSD::boolean_& CT_TextParagraphProperties::get_rtl_attr() const
{
    return m_rtl_attr;
}

bool CT_TextParagraphProperties::has_eaLnBrk_attr() const
{
    return m_has_eaLnBrk_attr;
}

void CT_TextParagraphProperties::set_eaLnBrk_attr(const XSD::boolean_& _eaLnBrk_attr)
{
    m_has_eaLnBrk_attr = true;
    m_eaLnBrk_attr = _eaLnBrk_attr;
}

const XSD::boolean_& CT_TextParagraphProperties::get_eaLnBrk_attr() const
{
    return m_eaLnBrk_attr;
}

bool CT_TextParagraphProperties::has_fontAlgn_attr() const
{
    return m_has_fontAlgn_attr;
}

void CT_TextParagraphProperties::set_fontAlgn_attr(const ST_TextFontAlignType& _fontAlgn_attr)
{
    m_has_fontAlgn_attr = true;
    m_fontAlgn_attr = new ST_TextFontAlignType(_fontAlgn_attr);
}

const ST_TextFontAlignType& CT_TextParagraphProperties::get_fontAlgn_attr() const
{
    if (m_fontAlgn_attr)
    {
        return *m_fontAlgn_attr;
    }
    return ST_TextFontAlignType::default_instance();
}

bool CT_TextParagraphProperties::has_latinLnBrk_attr() const
{
    return m_has_latinLnBrk_attr;
}

void CT_TextParagraphProperties::set_latinLnBrk_attr(const XSD::boolean_& _latinLnBrk_attr)
{
    m_has_latinLnBrk_attr = true;
    m_latinLnBrk_attr = _latinLnBrk_attr;
}

const XSD::boolean_& CT_TextParagraphProperties::get_latinLnBrk_attr() const
{
    return m_latinLnBrk_attr;
}

bool CT_TextParagraphProperties::has_hangingPunct_attr() const
{
    return m_has_hangingPunct_attr;
}

void CT_TextParagraphProperties::set_hangingPunct_attr(const XSD::boolean_& _hangingPunct_attr)
{
    m_has_hangingPunct_attr = true;
    m_hangingPunct_attr = _hangingPunct_attr;
}

const XSD::boolean_& CT_TextParagraphProperties::get_hangingPunct_attr() const
{
    return m_hangingPunct_attr;
}

CT_TextParagraphProperties* CT_TextParagraphProperties::default_instance_ = NULL;

// CT_TextField
CT_TextField::CT_TextField()
    :m_has_rPr(false),
     m_rPr(NULL),
     m_has_pPr(false),
     m_pPr(NULL),
     m_has_t(false),
     m_t(""),
     m_has_id_attr(false),
     m_id_attr(NULL),
     m_has_type_attr(false),
     m_type_attr("")
{
}
CT_TextField::~CT_TextField()
{
    clear();
}
bool CT_TextField::has_rPr() const
{
    return m_has_rPr;
}

CT_TextCharacterProperties* CT_TextField::mutable_rPr()
{
    m_has_rPr = true;
    if (!m_rPr)
    {
        m_rPr = new CT_TextCharacterProperties();
    }
    return m_rPr;
}

const CT_TextCharacterProperties& CT_TextField::get_rPr() const
{
    if (m_rPr)
    {
        return *m_rPr;
    }
    return CT_TextCharacterProperties::default_instance();
}

bool CT_TextField::has_pPr() const
{
    return m_has_pPr;
}

CT_TextParagraphProperties* CT_TextField::mutable_pPr()
{
    m_has_pPr = true;
    if (!m_pPr)
    {
        m_pPr = new CT_TextParagraphProperties();
    }
    return m_pPr;
}

const CT_TextParagraphProperties& CT_TextField::get_pPr() const
{
    if (m_pPr)
    {
        return *m_pPr;
    }
    return CT_TextParagraphProperties::default_instance();
}

bool CT_TextField::has_t() const
{
    return m_has_t;
}

void CT_TextField::set_t(const XSD::string_& _t)
{
    m_has_t = true;
    m_t = _t;
}

const XSD::string_& CT_TextField::get_t() const
{
    return m_t;
}

void CT_TextField::clear()
{
    m_has_id_attr = false;

    if (m_id_attr)
    {
        delete m_id_attr;
        m_id_attr = NULL;
    }


    m_has_type_attr = false;
    m_type_attr.clear();

    m_has_rPr = false;

    if (m_rPr)
    {
        delete m_rPr;
        m_rPr = NULL;
    }


    m_has_pPr = false;

    if (m_pPr)
    {
        delete m_pPr;
        m_pPr = NULL;
    }


    m_has_t = false;
    m_t.clear();
}

void CT_TextField::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    assert(m_has_id_attr);
    if (m_has_id_attr)
    {
        m_id_attr->toXmlAttr("id", _outStream);
    }



    if (m_has_type_attr)
    {
        _outStream << " " << "type" << "=\"" << m_type_attr << "\"";
    }

    _outStream << ">";


    if (m_has_rPr)
    {
        m_rPr->toXmlElem("a:rPr", "", _outStream);
    }


    if (m_has_pPr)
    {
        m_pPr->toXmlElem("a:pPr", "", _outStream);
    }


    if (m_has_t)
    {
        _outStream << "<a:t>" << m_t << "</a:t>";
    }

    _outStream << "</" << _elemName << ">";
}

const CT_TextField& CT_TextField::default_instance()
{
    if (!CT_TextField::default_instance_)
    {
        CT_TextField::default_instance_ = new CT_TextField();
    }
    return *CT_TextField::default_instance_;
}

bool CT_TextField::has_id_attr() const
{
    return m_has_id_attr;
}

void CT_TextField::set_id_attr(const ns_s::ST_Guid& _id_attr)
{
    m_has_id_attr = true;
    m_id_attr = new ns_s::ST_Guid(_id_attr);
}

const ns_s::ST_Guid& CT_TextField::get_id_attr() const
{
    if (m_id_attr)
    {
        return *m_id_attr;
    }
    return ns_s::ST_Guid::default_instance();
}

bool CT_TextField::has_type_attr() const
{
    return m_has_type_attr;
}

void CT_TextField::set_type_attr(const XSD::string_& _type_attr)
{
    m_has_type_attr = true;
    m_type_attr = _type_attr;
}

const XSD::string_& CT_TextField::get_type_attr() const
{
    return m_type_attr;
}

CT_TextField* CT_TextField::default_instance_ = NULL;

// CT_RegularTextRun
CT_RegularTextRun::CT_RegularTextRun()
    :m_has_rPr(false),
     m_rPr(NULL),
     m_has_t(false),
     m_t("")
{
}
CT_RegularTextRun::~CT_RegularTextRun()
{
    clear();
}
bool CT_RegularTextRun::has_rPr() const
{
    return m_has_rPr;
}

CT_TextCharacterProperties* CT_RegularTextRun::mutable_rPr()
{
    m_has_rPr = true;
    if (!m_rPr)
    {
        m_rPr = new CT_TextCharacterProperties();
    }
    return m_rPr;
}

const CT_TextCharacterProperties& CT_RegularTextRun::get_rPr() const
{
    if (m_rPr)
    {
        return *m_rPr;
    }
    return CT_TextCharacterProperties::default_instance();
}

bool CT_RegularTextRun::has_t() const
{
    return m_has_t;
}

void CT_RegularTextRun::set_t(const XSD::string_& _t)
{
    m_has_t = true;
    m_t = _t;
}

const XSD::string_& CT_RegularTextRun::get_t() const
{
    return m_t;
}

void CT_RegularTextRun::clear()
{
    m_has_rPr = false;

    if (m_rPr)
    {
        delete m_rPr;
        m_rPr = NULL;
    }


    m_has_t = false;
    m_t.clear();
}

void CT_RegularTextRun::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    assert(m_has_t);


    if (m_has_rPr)
    {
        m_rPr->toXmlElem("a:rPr", "", _outStream);
    }


    if (m_has_t)
    {
        _outStream << "<a:t>" << m_t << "</a:t>";
    }

    _outStream << "</" << _elemName << ">";
}

const CT_RegularTextRun& CT_RegularTextRun::default_instance()
{
    if (!CT_RegularTextRun::default_instance_)
    {
        CT_RegularTextRun::default_instance_ = new CT_RegularTextRun();
    }
    return *CT_RegularTextRun::default_instance_;
}

CT_RegularTextRun* CT_RegularTextRun::default_instance_ = NULL;

// CT_BackgroundFormatting
CT_BackgroundFormatting::CT_BackgroundFormatting()
    :m_has_noFill(false),
     m_noFill(NULL),
     m_has_solidFill(false),
     m_solidFill(NULL),
     m_has_gradFill(false),
     m_gradFill(NULL),
     m_has_blipFill(false),
     m_blipFill(NULL),
     m_has_pattFill(false),
     m_pattFill(NULL),
     m_has_grpFill(false),
     m_grpFill(NULL),
     m_has_effectLst(false),
     m_effectLst(NULL),
     m_has_effectDag(false),
     m_effectDag(NULL)
{
}
CT_BackgroundFormatting::~CT_BackgroundFormatting()
{
    clear();
}
bool CT_BackgroundFormatting::has_noFill() const
{
    return m_has_noFill;
}

CT_NoFillProperties* CT_BackgroundFormatting::mutable_noFill()
{

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_noFill = true;
    if (!m_noFill)
    {
        m_noFill = new CT_NoFillProperties();
    }
    return m_noFill;
}

const CT_NoFillProperties& CT_BackgroundFormatting::get_noFill() const
{
    if (m_noFill)
    {
        return *m_noFill;
    }
    return CT_NoFillProperties::default_instance();
}

bool CT_BackgroundFormatting::has_solidFill() const
{
    return m_has_solidFill;
}

CT_SolidColorFillProperties* CT_BackgroundFormatting::mutable_solidFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_solidFill = true;
    if (!m_solidFill)
    {
        m_solidFill = new CT_SolidColorFillProperties();
    }
    return m_solidFill;
}

const CT_SolidColorFillProperties& CT_BackgroundFormatting::get_solidFill() const
{
    if (m_solidFill)
    {
        return *m_solidFill;
    }
    return CT_SolidColorFillProperties::default_instance();
}

bool CT_BackgroundFormatting::has_gradFill() const
{
    return m_has_gradFill;
}

CT_GradientFillProperties* CT_BackgroundFormatting::mutable_gradFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_gradFill = true;
    if (!m_gradFill)
    {
        m_gradFill = new CT_GradientFillProperties();
    }
    return m_gradFill;
}

const CT_GradientFillProperties& CT_BackgroundFormatting::get_gradFill() const
{
    if (m_gradFill)
    {
        return *m_gradFill;
    }
    return CT_GradientFillProperties::default_instance();
}

bool CT_BackgroundFormatting::has_blipFill() const
{
    return m_has_blipFill;
}

CT_BlipFillProperties* CT_BackgroundFormatting::mutable_blipFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_blipFill = true;
    if (!m_blipFill)
    {
        m_blipFill = new CT_BlipFillProperties();
    }
    return m_blipFill;
}

const CT_BlipFillProperties& CT_BackgroundFormatting::get_blipFill() const
{
    if (m_blipFill)
    {
        return *m_blipFill;
    }
    return CT_BlipFillProperties::default_instance();
}

bool CT_BackgroundFormatting::has_pattFill() const
{
    return m_has_pattFill;
}

CT_PatternFillProperties* CT_BackgroundFormatting::mutable_pattFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }
    ;

    m_has_pattFill = true;
    if (!m_pattFill)
    {
        m_pattFill = new CT_PatternFillProperties();
    }
    return m_pattFill;
}

const CT_PatternFillProperties& CT_BackgroundFormatting::get_pattFill() const
{
    if (m_pattFill)
    {
        return *m_pattFill;
    }
    return CT_PatternFillProperties::default_instance();
}

bool CT_BackgroundFormatting::has_grpFill() const
{
    return m_has_grpFill;
}

CT_GroupFillProperties* CT_BackgroundFormatting::mutable_grpFill()
{

    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }
    ;

    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }
    ;

    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }
    ;

    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }
    ;

    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }
    ;

    m_has_grpFill = true;
    if (!m_grpFill)
    {
        m_grpFill = new CT_GroupFillProperties();
    }
    return m_grpFill;
}

const CT_GroupFillProperties& CT_BackgroundFormatting::get_grpFill() const
{
    if (m_grpFill)
    {
        return *m_grpFill;
    }
    return CT_GroupFillProperties::default_instance();
}

bool CT_BackgroundFormatting::has_effectLst() const
{
    return m_has_effectLst;
}

CT_EffectList* CT_BackgroundFormatting::mutable_effectLst()
{

    m_has_effectDag = false;

    if (m_effectDag)
    {
        delete m_effectDag;
        m_effectDag = NULL;
    }
    ;

    m_has_effectLst = true;
    if (!m_effectLst)
    {
        m_effectLst = new CT_EffectList();
    }
    return m_effectLst;
}

const CT_EffectList& CT_BackgroundFormatting::get_effectLst() const
{
    if (m_effectLst)
    {
        return *m_effectLst;
    }
    return CT_EffectList::default_instance();
}

bool CT_BackgroundFormatting::has_effectDag() const
{
    return m_has_effectDag;
}

CT_EffectContainer* CT_BackgroundFormatting::mutable_effectDag()
{

    m_has_effectLst = false;

    if (m_effectLst)
    {
        delete m_effectLst;
        m_effectLst = NULL;
    }
    ;

    m_has_effectDag = true;
    if (!m_effectDag)
    {
        m_effectDag = new CT_EffectContainer();
    }
    return m_effectDag;
}

const CT_EffectContainer& CT_BackgroundFormatting::get_effectDag() const
{
    if (m_effectDag)
    {
        return *m_effectDag;
    }
    return CT_EffectContainer::default_instance();
}

void CT_BackgroundFormatting::clear()
{
    m_has_noFill = false;

    if (m_noFill)
    {
        delete m_noFill;
        m_noFill = NULL;
    }


    m_has_solidFill = false;

    if (m_solidFill)
    {
        delete m_solidFill;
        m_solidFill = NULL;
    }


    m_has_gradFill = false;

    if (m_gradFill)
    {
        delete m_gradFill;
        m_gradFill = NULL;
    }


    m_has_blipFill = false;

    if (m_blipFill)
    {
        delete m_blipFill;
        m_blipFill = NULL;
    }


    m_has_pattFill = false;

    if (m_pattFill)
    {
        delete m_pattFill;
        m_pattFill = NULL;
    }


    m_has_grpFill = false;

    if (m_grpFill)
    {
        delete m_grpFill;
        m_grpFill = NULL;
    }


    m_has_effectLst = false;

    if (m_effectLst)
    {
        delete m_effectLst;
        m_effectLst = NULL;
    }


    m_has_effectDag = false;

    if (m_effectDag)
    {
        delete m_effectDag;
        m_effectDag = NULL;
    }

}

void CT_BackgroundFormatting::toXmlElem(const std::string& _elemName, const std::string& _xmlNsStr, std::ostream& _outStream) const
{
    _outStream << "<" << _elemName;

    if (!_xmlNsStr.empty())
    {
        _outStream << _xmlNsStr;
    }

    _outStream << ">";

    {
        bool elemHasValueList[6] = {m_has_noFill, m_has_solidFill, m_has_gradFill, m_has_blipFill, m_has_pattFill, m_has_grpFill};
        int cnt = count(elemHasValueList, elemHasValueList + 6, true);
        assert(cnt == 0 || cnt == 1);
    }


    if (m_has_noFill)
    {
        m_noFill->toXmlElem("a:noFill", "", _outStream);
    }


    if (m_has_solidFill)
    {
        m_solidFill->toXmlElem("a:solidFill", "", _outStream);
    }


    if (m_has_gradFill)
    {
        m_gradFill->toXmlElem("a:gradFill", "", _outStream);
    }


    if (m_has_blipFill)
    {
        m_blipFill->toXmlElem("a:blipFill", "", _outStream);
    }


    if (m_has_pattFill)
    {
        m_pattFill->toXmlElem("a:pattFill", "", _outStream);
    }


    if (m_has_grpFill)
    {
        m_grpFill->toXmlElem("a:grpFill", "", _outStream);
    }

    {
        bool elemHasValueList[2] = {m_has_effectLst, m_has_effectDag};
        int cnt = count(elemHasValueList, elemHasValueList + 2, true);
        assert(cnt == 0 || cnt == 1);
    }


    if (m_has_effectLst)
    {
        m_effectLst->toXmlElem("a:effectLst", "", _outStream);
    }


    if (m_has_effectDag)
    {
        m_effectDag->toXmlElem("a:effectDag", "", _outStream);
    }

    _outStream << "</" << _elemName << ">";
}

const CT_BackgroundFormatting& CT_BackgroundFormatting::default_instance()
{
    if (!CT_BackgroundFormatting::default_instance_)
    {
        CT_BackgroundFormatting::default_instance_ = new CT_BackgroundFormatting();
    }
    return *CT_BackgroundFormatting::default_instance_;
}

CT_BackgroundFormatting* CT_BackgroundFormatting::default_instance_ = NULL;

// videoFile_element
videoFile_element::videoFile_element()
    :m_has_extLst(false),
     m_extLst(NULL),
     m_has_r_link_attr(false),
     m_r_link_attr(NULL),
     m_has_contentType_attr(false),
     m_contentType_attr("")
{
}
videoFile_element::~videoFile_element()
{
    clear();
}
bool videoFile_element::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* videoFile_element::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& videoFile_element::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void videoFile_element::clear()
{
    m_has_r_link_attr = false;

    if (m_r_link_attr)
    {
        delete m_r_link_attr;
        m_r_link_attr = NULL;
    }


    m_has_contentType_attr = false;
    m_contentType_attr.clear();

    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void videoFile_element::toXml(std::ostream& _outStream) const
{
    _outStream << "<a:videoFile";

    _outStream << " " << "xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\"";
    _outStream << " " << "xmlns:s=\"http://schemas.openxmlformats.org/officeDocument/2006/sharedTypes\"";
    _outStream << " " << "xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\"";

    assert(m_has_r_link_attr);
    if (m_has_r_link_attr)
    {
        m_r_link_attr->toXmlAttr("r:link", _outStream);
    }



    if (m_has_contentType_attr)
    {
        _outStream << " " << "contentType" << "=\"" << m_contentType_attr << "\"";
    }

    _outStream << ">";


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</a:videoFile>";
}

const videoFile_element& videoFile_element::default_instance()
{
    if (!videoFile_element::default_instance_)
    {
        videoFile_element::default_instance_ = new videoFile_element();
    }
    return *videoFile_element::default_instance_;
}

bool videoFile_element::has_r_link_attr() const
{
    return m_has_r_link_attr;
}

void videoFile_element::set_r_link_attr(const ns_r::ST_RelationshipId& _r_link_attr)
{
    m_has_r_link_attr = true;
    m_r_link_attr = new ns_r::ST_RelationshipId(_r_link_attr);
}

const ns_r::ST_RelationshipId& videoFile_element::get_r_link_attr() const
{
    if (m_r_link_attr)
    {
        return *m_r_link_attr;
    }
    return ns_r::ST_RelationshipId::default_instance();
}

bool videoFile_element::has_contentType_attr() const
{
    return m_has_contentType_attr;
}

void videoFile_element::set_contentType_attr(const XSD::string_& _contentType_attr)
{
    m_has_contentType_attr = true;
    m_contentType_attr = _contentType_attr;
}

const XSD::string_& videoFile_element::get_contentType_attr() const
{
    return m_contentType_attr;
}

videoFile_element* videoFile_element::default_instance_ = NULL;

// graphic_element
graphic_element::graphic_element()
    :m_has_graphicData(false),
     m_graphicData(NULL)
{
}
graphic_element::~graphic_element()
{
    clear();
}
bool graphic_element::has_graphicData() const
{
    return m_has_graphicData;
}

CT_GraphicalObjectData* graphic_element::mutable_graphicData()
{
    m_has_graphicData = true;
    if (!m_graphicData)
    {
        m_graphicData = new CT_GraphicalObjectData();
    }
    return m_graphicData;
}

const CT_GraphicalObjectData& graphic_element::get_graphicData() const
{
    if (m_graphicData)
    {
        return *m_graphicData;
    }
    return CT_GraphicalObjectData::default_instance();
}

void graphic_element::clear()
{
    m_has_graphicData = false;

    if (m_graphicData)
    {
        delete m_graphicData;
        m_graphicData = NULL;
    }

}

void graphic_element::toXml(std::ostream& _outStream) const
{
    _outStream << "<a:graphic";

    _outStream << " " << "xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\"";
    _outStream << " " << "xmlns:s=\"http://schemas.openxmlformats.org/officeDocument/2006/sharedTypes\"";
    _outStream << " " << "xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\"";

    _outStream << ">";

    assert(m_has_graphicData);


    if (m_has_graphicData)
    {
        m_graphicData->toXmlElem("a:graphicData", "", _outStream);
    }

    _outStream << "</a:graphic>";
}

const graphic_element& graphic_element::default_instance()
{
    if (!graphic_element::default_instance_)
    {
        graphic_element::default_instance_ = new graphic_element();
    }
    return *graphic_element::default_instance_;
}

graphic_element* graphic_element::default_instance_ = NULL;

// blip_element
blip_element::blip_element()
    :m_has_extLst(false),
     m_extLst(NULL),
     m_has_r_embed_attr(false),
     m_r_embed_attr(NULL),
     m_has_r_link_attr(false),
     m_r_link_attr(NULL),
     m_has_cstate_attr(false),
     m_cstate_attr(NULL)
{
}
blip_element::~blip_element()
{
    clear();
}
CT_AlphaBiLevelEffect* blip_element::add_alphaBiLevel()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_AlphaBiLevelEffect* pNewChild = pChildGroup->mutable_alphaBiLevel();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_AlphaCeilingEffect* blip_element::add_alphaCeiling()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_AlphaCeilingEffect* pNewChild = pChildGroup->mutable_alphaCeiling();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_AlphaFloorEffect* blip_element::add_alphaFloor()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_AlphaFloorEffect* pNewChild = pChildGroup->mutable_alphaFloor();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_AlphaInverseEffect* blip_element::add_alphaInv()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_AlphaInverseEffect* pNewChild = pChildGroup->mutable_alphaInv();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_AlphaModulateEffect* blip_element::add_alphaMod()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_AlphaModulateEffect* pNewChild = pChildGroup->mutable_alphaMod();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_AlphaModulateFixedEffect* blip_element::add_alphaModFix()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_AlphaModulateFixedEffect* pNewChild = pChildGroup->mutable_alphaModFix();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_AlphaReplaceEffect* blip_element::add_alphaRepl()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_AlphaReplaceEffect* pNewChild = pChildGroup->mutable_alphaRepl();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_BiLevelEffect* blip_element::add_biLevel()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_BiLevelEffect* pNewChild = pChildGroup->mutable_biLevel();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_BlurEffect* blip_element::add_blur()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_BlurEffect* pNewChild = pChildGroup->mutable_blur();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_ColorChangeEffect* blip_element::add_clrChange()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_ColorChangeEffect* pNewChild = pChildGroup->mutable_clrChange();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_ColorReplaceEffect* blip_element::add_clrRepl()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_ColorReplaceEffect* pNewChild = pChildGroup->mutable_clrRepl();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_DuotoneEffect* blip_element::add_duotone()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_DuotoneEffect* pNewChild = pChildGroup->mutable_duotone();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_FillOverlayEffect* blip_element::add_fillOverlay()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_FillOverlayEffect* pNewChild = pChildGroup->mutable_fillOverlay();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_GrayscaleEffect* blip_element::add_grayscl()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_GrayscaleEffect* pNewChild = pChildGroup->mutable_grayscl();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_HSLEffect* blip_element::add_hsl()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_HSLEffect* pNewChild = pChildGroup->mutable_hsl();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_LuminanceEffect* blip_element::add_lum()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_LuminanceEffect* pNewChild = pChildGroup->mutable_lum();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

CT_TintEffect* blip_element::add_tint()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_TintEffect* pNewChild = pChildGroup->mutable_tint();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

bool blip_element::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* blip_element::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& blip_element::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void blip_element::clear()
{
    m_has_r_embed_attr = false;

    if (m_r_embed_attr)
    {
        delete m_r_embed_attr;
        m_r_embed_attr = NULL;
    }


    m_has_r_link_attr = false;

    if (m_r_link_attr)
    {
        delete m_r_link_attr;
        m_r_link_attr = NULL;
    }


    m_has_cstate_attr = false;

    if (m_cstate_attr)
    {
        delete m_cstate_attr;
        m_cstate_attr = NULL;
    }


    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }

    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void blip_element::toXml(std::ostream& _outStream) const
{
    _outStream << "<a:blip";

    _outStream << " " << "xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\"";
    _outStream << " " << "xmlns:s=\"http://schemas.openxmlformats.org/officeDocument/2006/sharedTypes\"";
    _outStream << " " << "xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\"";


    if (m_has_r_embed_attr)
    {
        m_r_embed_attr->toXmlAttr("r:embed", _outStream);
    }



    if (m_has_r_link_attr)
    {
        m_r_link_attr->toXmlAttr("r:link", _outStream);
    }



    if (m_has_cstate_attr)
    {
        m_cstate_attr->toXmlAttr("cstate", _outStream);
    }

    _outStream << ">";

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_alphaBiLevel())
            {
                (*iter)->get_alphaBiLevel().toXmlElem("a:alphaBiLevel", "", _outStream);
            }


            else if ((*iter)->has_alphaCeiling())
            {
                (*iter)->get_alphaCeiling().toXmlElem("a:alphaCeiling", "", _outStream);
            }


            else if ((*iter)->has_alphaFloor())
            {
                (*iter)->get_alphaFloor().toXmlElem("a:alphaFloor", "", _outStream);
            }


            else if ((*iter)->has_alphaInv())
            {
                (*iter)->get_alphaInv().toXmlElem("a:alphaInv", "", _outStream);
            }


            else if ((*iter)->has_alphaMod())
            {
                (*iter)->get_alphaMod().toXmlElem("a:alphaMod", "", _outStream);
            }


            else if ((*iter)->has_alphaModFix())
            {
                (*iter)->get_alphaModFix().toXmlElem("a:alphaModFix", "", _outStream);
            }


            else if ((*iter)->has_alphaRepl())
            {
                (*iter)->get_alphaRepl().toXmlElem("a:alphaRepl", "", _outStream);
            }


            else if ((*iter)->has_biLevel())
            {
                (*iter)->get_biLevel().toXmlElem("a:biLevel", "", _outStream);
            }


            else if ((*iter)->has_blur())
            {
                (*iter)->get_blur().toXmlElem("a:blur", "", _outStream);
            }


            else if ((*iter)->has_clrChange())
            {
                (*iter)->get_clrChange().toXmlElem("a:clrChange", "", _outStream);
            }


            else if ((*iter)->has_clrRepl())
            {
                (*iter)->get_clrRepl().toXmlElem("a:clrRepl", "", _outStream);
            }


            else if ((*iter)->has_duotone())
            {
                (*iter)->get_duotone().toXmlElem("a:duotone", "", _outStream);
            }


            else if ((*iter)->has_fillOverlay())
            {
                (*iter)->get_fillOverlay().toXmlElem("a:fillOverlay", "", _outStream);
            }


            else if ((*iter)->has_grayscl())
            {
                (*iter)->get_grayscl().toXmlElem("a:grayscl", "", _outStream);
            }


            else if ((*iter)->has_hsl())
            {
                (*iter)->get_hsl().toXmlElem("a:hsl", "", _outStream);
            }


            else if ((*iter)->has_lum())
            {
                (*iter)->get_lum().toXmlElem("a:lum", "", _outStream);
            }


            else if ((*iter)->has_tint())
            {
                (*iter)->get_tint().toXmlElem("a:tint", "", _outStream);
            }


        }
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</a:blip>";
}

const blip_element& blip_element::default_instance()
{
    if (!blip_element::default_instance_)
    {
        blip_element::default_instance_ = new blip_element();
    }
    return *blip_element::default_instance_;
}

bool blip_element::has_r_embed_attr() const
{
    return m_has_r_embed_attr;
}

void blip_element::set_r_embed_attr(const ns_r::ST_RelationshipId& _r_embed_attr)
{
    m_has_r_embed_attr = true;
    m_r_embed_attr = new ns_r::ST_RelationshipId(_r_embed_attr);
}

const ns_r::ST_RelationshipId& blip_element::get_r_embed_attr() const
{
    if (m_r_embed_attr)
    {
        return *m_r_embed_attr;
    }
    return ns_r::ST_RelationshipId::default_instance();
}

bool blip_element::has_r_link_attr() const
{
    return m_has_r_link_attr;
}

void blip_element::set_r_link_attr(const ns_r::ST_RelationshipId& _r_link_attr)
{
    m_has_r_link_attr = true;
    m_r_link_attr = new ns_r::ST_RelationshipId(_r_link_attr);
}

const ns_r::ST_RelationshipId& blip_element::get_r_link_attr() const
{
    if (m_r_link_attr)
    {
        return *m_r_link_attr;
    }
    return ns_r::ST_RelationshipId::default_instance();
}

bool blip_element::has_cstate_attr() const
{
    return m_has_cstate_attr;
}

void blip_element::set_cstate_attr(const ST_BlipCompression& _cstate_attr)
{
    m_has_cstate_attr = true;
    m_cstate_attr = new ST_BlipCompression(_cstate_attr);
}

const ST_BlipCompression& blip_element::get_cstate_attr() const
{
    if (m_cstate_attr)
    {
        return *m_cstate_attr;
    }
    return ST_BlipCompression::default_instance();
}


// blip_element::ChildGroup_1
blip_element::ChildGroup_1::ChildGroup_1()
    :m_has_alphaBiLevel(false),
     m_alphaBiLevel(NULL),
     m_has_alphaCeiling(false),
     m_alphaCeiling(NULL),
     m_has_alphaFloor(false),
     m_alphaFloor(NULL),
     m_has_alphaInv(false),
     m_alphaInv(NULL),
     m_has_alphaMod(false),
     m_alphaMod(NULL),
     m_has_alphaModFix(false),
     m_alphaModFix(NULL),
     m_has_alphaRepl(false),
     m_alphaRepl(NULL),
     m_has_biLevel(false),
     m_biLevel(NULL),
     m_has_blur(false),
     m_blur(NULL),
     m_has_clrChange(false),
     m_clrChange(NULL),
     m_has_clrRepl(false),
     m_clrRepl(NULL),
     m_has_duotone(false),
     m_duotone(NULL),
     m_has_fillOverlay(false),
     m_fillOverlay(NULL),
     m_has_grayscl(false),
     m_grayscl(NULL),
     m_has_hsl(false),
     m_hsl(NULL),
     m_has_lum(false),
     m_lum(NULL),
     m_has_tint(false),
     m_tint(NULL)
{
}
bool blip_element::ChildGroup_1::has_alphaBiLevel() const
{
    return m_has_alphaBiLevel;
}

CT_AlphaBiLevelEffect* blip_element::ChildGroup_1::mutable_alphaBiLevel()
{

    m_has_alphaCeiling = false;

    if (m_alphaCeiling)
    {
        delete m_alphaCeiling;
        m_alphaCeiling = NULL;
    }
    ;

    m_has_alphaFloor = false;

    if (m_alphaFloor)
    {
        delete m_alphaFloor;
        m_alphaFloor = NULL;
    }
    ;

    m_has_alphaInv = false;

    if (m_alphaInv)
    {
        delete m_alphaInv;
        m_alphaInv = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_alphaModFix = false;

    if (m_alphaModFix)
    {
        delete m_alphaModFix;
        m_alphaModFix = NULL;
    }
    ;

    m_has_alphaRepl = false;

    if (m_alphaRepl)
    {
        delete m_alphaRepl;
        m_alphaRepl = NULL;
    }
    ;

    m_has_biLevel = false;

    if (m_biLevel)
    {
        delete m_biLevel;
        m_biLevel = NULL;
    }
    ;

    m_has_blur = false;

    if (m_blur)
    {
        delete m_blur;
        m_blur = NULL;
    }
    ;

    m_has_clrChange = false;

    if (m_clrChange)
    {
        delete m_clrChange;
        m_clrChange = NULL;
    }
    ;

    m_has_clrRepl = false;

    if (m_clrRepl)
    {
        delete m_clrRepl;
        m_clrRepl = NULL;
    }
    ;

    m_has_duotone = false;

    if (m_duotone)
    {
        delete m_duotone;
        m_duotone = NULL;
    }
    ;

    m_has_fillOverlay = false;

    if (m_fillOverlay)
    {
        delete m_fillOverlay;
        m_fillOverlay = NULL;
    }
    ;

    m_has_grayscl = false;

    if (m_grayscl)
    {
        delete m_grayscl;
        m_grayscl = NULL;
    }
    ;

    m_has_hsl = false;

    if (m_hsl)
    {
        delete m_hsl;
        m_hsl = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_alphaBiLevel = true;
    if (!m_alphaBiLevel)
    {
        m_alphaBiLevel = new CT_AlphaBiLevelEffect();
    }
    return m_alphaBiLevel;
}

const CT_AlphaBiLevelEffect& blip_element::ChildGroup_1::get_alphaBiLevel() const
{
    if (m_alphaBiLevel)
    {
        return *m_alphaBiLevel;
    }
    return CT_AlphaBiLevelEffect::default_instance();
}

bool blip_element::ChildGroup_1::has_alphaCeiling() const
{
    return m_has_alphaCeiling;
}

CT_AlphaCeilingEffect* blip_element::ChildGroup_1::mutable_alphaCeiling()
{

    m_has_alphaBiLevel = false;

    if (m_alphaBiLevel)
    {
        delete m_alphaBiLevel;
        m_alphaBiLevel = NULL;
    }
    ;

    m_has_alphaFloor = false;

    if (m_alphaFloor)
    {
        delete m_alphaFloor;
        m_alphaFloor = NULL;
    }
    ;

    m_has_alphaInv = false;

    if (m_alphaInv)
    {
        delete m_alphaInv;
        m_alphaInv = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_alphaModFix = false;

    if (m_alphaModFix)
    {
        delete m_alphaModFix;
        m_alphaModFix = NULL;
    }
    ;

    m_has_alphaRepl = false;

    if (m_alphaRepl)
    {
        delete m_alphaRepl;
        m_alphaRepl = NULL;
    }
    ;

    m_has_biLevel = false;

    if (m_biLevel)
    {
        delete m_biLevel;
        m_biLevel = NULL;
    }
    ;

    m_has_blur = false;

    if (m_blur)
    {
        delete m_blur;
        m_blur = NULL;
    }
    ;

    m_has_clrChange = false;

    if (m_clrChange)
    {
        delete m_clrChange;
        m_clrChange = NULL;
    }
    ;

    m_has_clrRepl = false;

    if (m_clrRepl)
    {
        delete m_clrRepl;
        m_clrRepl = NULL;
    }
    ;

    m_has_duotone = false;

    if (m_duotone)
    {
        delete m_duotone;
        m_duotone = NULL;
    }
    ;

    m_has_fillOverlay = false;

    if (m_fillOverlay)
    {
        delete m_fillOverlay;
        m_fillOverlay = NULL;
    }
    ;

    m_has_grayscl = false;

    if (m_grayscl)
    {
        delete m_grayscl;
        m_grayscl = NULL;
    }
    ;

    m_has_hsl = false;

    if (m_hsl)
    {
        delete m_hsl;
        m_hsl = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_alphaCeiling = true;
    if (!m_alphaCeiling)
    {
        m_alphaCeiling = new CT_AlphaCeilingEffect();
    }
    return m_alphaCeiling;
}

const CT_AlphaCeilingEffect& blip_element::ChildGroup_1::get_alphaCeiling() const
{
    if (m_alphaCeiling)
    {
        return *m_alphaCeiling;
    }
    return CT_AlphaCeilingEffect::default_instance();
}

bool blip_element::ChildGroup_1::has_alphaFloor() const
{
    return m_has_alphaFloor;
}

CT_AlphaFloorEffect* blip_element::ChildGroup_1::mutable_alphaFloor()
{

    m_has_alphaBiLevel = false;

    if (m_alphaBiLevel)
    {
        delete m_alphaBiLevel;
        m_alphaBiLevel = NULL;
    }
    ;

    m_has_alphaCeiling = false;

    if (m_alphaCeiling)
    {
        delete m_alphaCeiling;
        m_alphaCeiling = NULL;
    }
    ;

    m_has_alphaInv = false;

    if (m_alphaInv)
    {
        delete m_alphaInv;
        m_alphaInv = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_alphaModFix = false;

    if (m_alphaModFix)
    {
        delete m_alphaModFix;
        m_alphaModFix = NULL;
    }
    ;

    m_has_alphaRepl = false;

    if (m_alphaRepl)
    {
        delete m_alphaRepl;
        m_alphaRepl = NULL;
    }
    ;

    m_has_biLevel = false;

    if (m_biLevel)
    {
        delete m_biLevel;
        m_biLevel = NULL;
    }
    ;

    m_has_blur = false;

    if (m_blur)
    {
        delete m_blur;
        m_blur = NULL;
    }
    ;

    m_has_clrChange = false;

    if (m_clrChange)
    {
        delete m_clrChange;
        m_clrChange = NULL;
    }
    ;

    m_has_clrRepl = false;

    if (m_clrRepl)
    {
        delete m_clrRepl;
        m_clrRepl = NULL;
    }
    ;

    m_has_duotone = false;

    if (m_duotone)
    {
        delete m_duotone;
        m_duotone = NULL;
    }
    ;

    m_has_fillOverlay = false;

    if (m_fillOverlay)
    {
        delete m_fillOverlay;
        m_fillOverlay = NULL;
    }
    ;

    m_has_grayscl = false;

    if (m_grayscl)
    {
        delete m_grayscl;
        m_grayscl = NULL;
    }
    ;

    m_has_hsl = false;

    if (m_hsl)
    {
        delete m_hsl;
        m_hsl = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_alphaFloor = true;
    if (!m_alphaFloor)
    {
        m_alphaFloor = new CT_AlphaFloorEffect();
    }
    return m_alphaFloor;
}

const CT_AlphaFloorEffect& blip_element::ChildGroup_1::get_alphaFloor() const
{
    if (m_alphaFloor)
    {
        return *m_alphaFloor;
    }
    return CT_AlphaFloorEffect::default_instance();
}

bool blip_element::ChildGroup_1::has_alphaInv() const
{
    return m_has_alphaInv;
}

CT_AlphaInverseEffect* blip_element::ChildGroup_1::mutable_alphaInv()
{

    m_has_alphaBiLevel = false;

    if (m_alphaBiLevel)
    {
        delete m_alphaBiLevel;
        m_alphaBiLevel = NULL;
    }
    ;

    m_has_alphaCeiling = false;

    if (m_alphaCeiling)
    {
        delete m_alphaCeiling;
        m_alphaCeiling = NULL;
    }
    ;

    m_has_alphaFloor = false;

    if (m_alphaFloor)
    {
        delete m_alphaFloor;
        m_alphaFloor = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_alphaModFix = false;

    if (m_alphaModFix)
    {
        delete m_alphaModFix;
        m_alphaModFix = NULL;
    }
    ;

    m_has_alphaRepl = false;

    if (m_alphaRepl)
    {
        delete m_alphaRepl;
        m_alphaRepl = NULL;
    }
    ;

    m_has_biLevel = false;

    if (m_biLevel)
    {
        delete m_biLevel;
        m_biLevel = NULL;
    }
    ;

    m_has_blur = false;

    if (m_blur)
    {
        delete m_blur;
        m_blur = NULL;
    }
    ;

    m_has_clrChange = false;

    if (m_clrChange)
    {
        delete m_clrChange;
        m_clrChange = NULL;
    }
    ;

    m_has_clrRepl = false;

    if (m_clrRepl)
    {
        delete m_clrRepl;
        m_clrRepl = NULL;
    }
    ;

    m_has_duotone = false;

    if (m_duotone)
    {
        delete m_duotone;
        m_duotone = NULL;
    }
    ;

    m_has_fillOverlay = false;

    if (m_fillOverlay)
    {
        delete m_fillOverlay;
        m_fillOverlay = NULL;
    }
    ;

    m_has_grayscl = false;

    if (m_grayscl)
    {
        delete m_grayscl;
        m_grayscl = NULL;
    }
    ;

    m_has_hsl = false;

    if (m_hsl)
    {
        delete m_hsl;
        m_hsl = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_alphaInv = true;
    if (!m_alphaInv)
    {
        m_alphaInv = new CT_AlphaInverseEffect();
    }
    return m_alphaInv;
}

const CT_AlphaInverseEffect& blip_element::ChildGroup_1::get_alphaInv() const
{
    if (m_alphaInv)
    {
        return *m_alphaInv;
    }
    return CT_AlphaInverseEffect::default_instance();
}

bool blip_element::ChildGroup_1::has_alphaMod() const
{
    return m_has_alphaMod;
}

CT_AlphaModulateEffect* blip_element::ChildGroup_1::mutable_alphaMod()
{

    m_has_alphaBiLevel = false;

    if (m_alphaBiLevel)
    {
        delete m_alphaBiLevel;
        m_alphaBiLevel = NULL;
    }
    ;

    m_has_alphaCeiling = false;

    if (m_alphaCeiling)
    {
        delete m_alphaCeiling;
        m_alphaCeiling = NULL;
    }
    ;

    m_has_alphaFloor = false;

    if (m_alphaFloor)
    {
        delete m_alphaFloor;
        m_alphaFloor = NULL;
    }
    ;

    m_has_alphaInv = false;

    if (m_alphaInv)
    {
        delete m_alphaInv;
        m_alphaInv = NULL;
    }
    ;

    m_has_alphaModFix = false;

    if (m_alphaModFix)
    {
        delete m_alphaModFix;
        m_alphaModFix = NULL;
    }
    ;

    m_has_alphaRepl = false;

    if (m_alphaRepl)
    {
        delete m_alphaRepl;
        m_alphaRepl = NULL;
    }
    ;

    m_has_biLevel = false;

    if (m_biLevel)
    {
        delete m_biLevel;
        m_biLevel = NULL;
    }
    ;

    m_has_blur = false;

    if (m_blur)
    {
        delete m_blur;
        m_blur = NULL;
    }
    ;

    m_has_clrChange = false;

    if (m_clrChange)
    {
        delete m_clrChange;
        m_clrChange = NULL;
    }
    ;

    m_has_clrRepl = false;

    if (m_clrRepl)
    {
        delete m_clrRepl;
        m_clrRepl = NULL;
    }
    ;

    m_has_duotone = false;

    if (m_duotone)
    {
        delete m_duotone;
        m_duotone = NULL;
    }
    ;

    m_has_fillOverlay = false;

    if (m_fillOverlay)
    {
        delete m_fillOverlay;
        m_fillOverlay = NULL;
    }
    ;

    m_has_grayscl = false;

    if (m_grayscl)
    {
        delete m_grayscl;
        m_grayscl = NULL;
    }
    ;

    m_has_hsl = false;

    if (m_hsl)
    {
        delete m_hsl;
        m_hsl = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_alphaMod = true;
    if (!m_alphaMod)
    {
        m_alphaMod = new CT_AlphaModulateEffect();
    }
    return m_alphaMod;
}

const CT_AlphaModulateEffect& blip_element::ChildGroup_1::get_alphaMod() const
{
    if (m_alphaMod)
    {
        return *m_alphaMod;
    }
    return CT_AlphaModulateEffect::default_instance();
}

bool blip_element::ChildGroup_1::has_alphaModFix() const
{
    return m_has_alphaModFix;
}

CT_AlphaModulateFixedEffect* blip_element::ChildGroup_1::mutable_alphaModFix()
{

    m_has_alphaBiLevel = false;

    if (m_alphaBiLevel)
    {
        delete m_alphaBiLevel;
        m_alphaBiLevel = NULL;
    }
    ;

    m_has_alphaCeiling = false;

    if (m_alphaCeiling)
    {
        delete m_alphaCeiling;
        m_alphaCeiling = NULL;
    }
    ;

    m_has_alphaFloor = false;

    if (m_alphaFloor)
    {
        delete m_alphaFloor;
        m_alphaFloor = NULL;
    }
    ;

    m_has_alphaInv = false;

    if (m_alphaInv)
    {
        delete m_alphaInv;
        m_alphaInv = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_alphaRepl = false;

    if (m_alphaRepl)
    {
        delete m_alphaRepl;
        m_alphaRepl = NULL;
    }
    ;

    m_has_biLevel = false;

    if (m_biLevel)
    {
        delete m_biLevel;
        m_biLevel = NULL;
    }
    ;

    m_has_blur = false;

    if (m_blur)
    {
        delete m_blur;
        m_blur = NULL;
    }
    ;

    m_has_clrChange = false;

    if (m_clrChange)
    {
        delete m_clrChange;
        m_clrChange = NULL;
    }
    ;

    m_has_clrRepl = false;

    if (m_clrRepl)
    {
        delete m_clrRepl;
        m_clrRepl = NULL;
    }
    ;

    m_has_duotone = false;

    if (m_duotone)
    {
        delete m_duotone;
        m_duotone = NULL;
    }
    ;

    m_has_fillOverlay = false;

    if (m_fillOverlay)
    {
        delete m_fillOverlay;
        m_fillOverlay = NULL;
    }
    ;

    m_has_grayscl = false;

    if (m_grayscl)
    {
        delete m_grayscl;
        m_grayscl = NULL;
    }
    ;

    m_has_hsl = false;

    if (m_hsl)
    {
        delete m_hsl;
        m_hsl = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_alphaModFix = true;
    if (!m_alphaModFix)
    {
        m_alphaModFix = new CT_AlphaModulateFixedEffect();
    }
    return m_alphaModFix;
}

const CT_AlphaModulateFixedEffect& blip_element::ChildGroup_1::get_alphaModFix() const
{
    if (m_alphaModFix)
    {
        return *m_alphaModFix;
    }
    return CT_AlphaModulateFixedEffect::default_instance();
}

bool blip_element::ChildGroup_1::has_alphaRepl() const
{
    return m_has_alphaRepl;
}

CT_AlphaReplaceEffect* blip_element::ChildGroup_1::mutable_alphaRepl()
{

    m_has_alphaBiLevel = false;

    if (m_alphaBiLevel)
    {
        delete m_alphaBiLevel;
        m_alphaBiLevel = NULL;
    }
    ;

    m_has_alphaCeiling = false;

    if (m_alphaCeiling)
    {
        delete m_alphaCeiling;
        m_alphaCeiling = NULL;
    }
    ;

    m_has_alphaFloor = false;

    if (m_alphaFloor)
    {
        delete m_alphaFloor;
        m_alphaFloor = NULL;
    }
    ;

    m_has_alphaInv = false;

    if (m_alphaInv)
    {
        delete m_alphaInv;
        m_alphaInv = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_alphaModFix = false;

    if (m_alphaModFix)
    {
        delete m_alphaModFix;
        m_alphaModFix = NULL;
    }
    ;

    m_has_biLevel = false;

    if (m_biLevel)
    {
        delete m_biLevel;
        m_biLevel = NULL;
    }
    ;

    m_has_blur = false;

    if (m_blur)
    {
        delete m_blur;
        m_blur = NULL;
    }
    ;

    m_has_clrChange = false;

    if (m_clrChange)
    {
        delete m_clrChange;
        m_clrChange = NULL;
    }
    ;

    m_has_clrRepl = false;

    if (m_clrRepl)
    {
        delete m_clrRepl;
        m_clrRepl = NULL;
    }
    ;

    m_has_duotone = false;

    if (m_duotone)
    {
        delete m_duotone;
        m_duotone = NULL;
    }
    ;

    m_has_fillOverlay = false;

    if (m_fillOverlay)
    {
        delete m_fillOverlay;
        m_fillOverlay = NULL;
    }
    ;

    m_has_grayscl = false;

    if (m_grayscl)
    {
        delete m_grayscl;
        m_grayscl = NULL;
    }
    ;

    m_has_hsl = false;

    if (m_hsl)
    {
        delete m_hsl;
        m_hsl = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_alphaRepl = true;
    if (!m_alphaRepl)
    {
        m_alphaRepl = new CT_AlphaReplaceEffect();
    }
    return m_alphaRepl;
}

const CT_AlphaReplaceEffect& blip_element::ChildGroup_1::get_alphaRepl() const
{
    if (m_alphaRepl)
    {
        return *m_alphaRepl;
    }
    return CT_AlphaReplaceEffect::default_instance();
}

bool blip_element::ChildGroup_1::has_biLevel() const
{
    return m_has_biLevel;
}

CT_BiLevelEffect* blip_element::ChildGroup_1::mutable_biLevel()
{

    m_has_alphaBiLevel = false;

    if (m_alphaBiLevel)
    {
        delete m_alphaBiLevel;
        m_alphaBiLevel = NULL;
    }
    ;

    m_has_alphaCeiling = false;

    if (m_alphaCeiling)
    {
        delete m_alphaCeiling;
        m_alphaCeiling = NULL;
    }
    ;

    m_has_alphaFloor = false;

    if (m_alphaFloor)
    {
        delete m_alphaFloor;
        m_alphaFloor = NULL;
    }
    ;

    m_has_alphaInv = false;

    if (m_alphaInv)
    {
        delete m_alphaInv;
        m_alphaInv = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_alphaModFix = false;

    if (m_alphaModFix)
    {
        delete m_alphaModFix;
        m_alphaModFix = NULL;
    }
    ;

    m_has_alphaRepl = false;

    if (m_alphaRepl)
    {
        delete m_alphaRepl;
        m_alphaRepl = NULL;
    }
    ;

    m_has_blur = false;

    if (m_blur)
    {
        delete m_blur;
        m_blur = NULL;
    }
    ;

    m_has_clrChange = false;

    if (m_clrChange)
    {
        delete m_clrChange;
        m_clrChange = NULL;
    }
    ;

    m_has_clrRepl = false;

    if (m_clrRepl)
    {
        delete m_clrRepl;
        m_clrRepl = NULL;
    }
    ;

    m_has_duotone = false;

    if (m_duotone)
    {
        delete m_duotone;
        m_duotone = NULL;
    }
    ;

    m_has_fillOverlay = false;

    if (m_fillOverlay)
    {
        delete m_fillOverlay;
        m_fillOverlay = NULL;
    }
    ;

    m_has_grayscl = false;

    if (m_grayscl)
    {
        delete m_grayscl;
        m_grayscl = NULL;
    }
    ;

    m_has_hsl = false;

    if (m_hsl)
    {
        delete m_hsl;
        m_hsl = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_biLevel = true;
    if (!m_biLevel)
    {
        m_biLevel = new CT_BiLevelEffect();
    }
    return m_biLevel;
}

const CT_BiLevelEffect& blip_element::ChildGroup_1::get_biLevel() const
{
    if (m_biLevel)
    {
        return *m_biLevel;
    }
    return CT_BiLevelEffect::default_instance();
}

bool blip_element::ChildGroup_1::has_blur() const
{
    return m_has_blur;
}

CT_BlurEffect* blip_element::ChildGroup_1::mutable_blur()
{

    m_has_alphaBiLevel = false;

    if (m_alphaBiLevel)
    {
        delete m_alphaBiLevel;
        m_alphaBiLevel = NULL;
    }
    ;

    m_has_alphaCeiling = false;

    if (m_alphaCeiling)
    {
        delete m_alphaCeiling;
        m_alphaCeiling = NULL;
    }
    ;

    m_has_alphaFloor = false;

    if (m_alphaFloor)
    {
        delete m_alphaFloor;
        m_alphaFloor = NULL;
    }
    ;

    m_has_alphaInv = false;

    if (m_alphaInv)
    {
        delete m_alphaInv;
        m_alphaInv = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_alphaModFix = false;

    if (m_alphaModFix)
    {
        delete m_alphaModFix;
        m_alphaModFix = NULL;
    }
    ;

    m_has_alphaRepl = false;

    if (m_alphaRepl)
    {
        delete m_alphaRepl;
        m_alphaRepl = NULL;
    }
    ;

    m_has_biLevel = false;

    if (m_biLevel)
    {
        delete m_biLevel;
        m_biLevel = NULL;
    }
    ;

    m_has_clrChange = false;

    if (m_clrChange)
    {
        delete m_clrChange;
        m_clrChange = NULL;
    }
    ;

    m_has_clrRepl = false;

    if (m_clrRepl)
    {
        delete m_clrRepl;
        m_clrRepl = NULL;
    }
    ;

    m_has_duotone = false;

    if (m_duotone)
    {
        delete m_duotone;
        m_duotone = NULL;
    }
    ;

    m_has_fillOverlay = false;

    if (m_fillOverlay)
    {
        delete m_fillOverlay;
        m_fillOverlay = NULL;
    }
    ;

    m_has_grayscl = false;

    if (m_grayscl)
    {
        delete m_grayscl;
        m_grayscl = NULL;
    }
    ;

    m_has_hsl = false;

    if (m_hsl)
    {
        delete m_hsl;
        m_hsl = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_blur = true;
    if (!m_blur)
    {
        m_blur = new CT_BlurEffect();
    }
    return m_blur;
}

const CT_BlurEffect& blip_element::ChildGroup_1::get_blur() const
{
    if (m_blur)
    {
        return *m_blur;
    }
    return CT_BlurEffect::default_instance();
}

bool blip_element::ChildGroup_1::has_clrChange() const
{
    return m_has_clrChange;
}

CT_ColorChangeEffect* blip_element::ChildGroup_1::mutable_clrChange()
{

    m_has_alphaBiLevel = false;

    if (m_alphaBiLevel)
    {
        delete m_alphaBiLevel;
        m_alphaBiLevel = NULL;
    }
    ;

    m_has_alphaCeiling = false;

    if (m_alphaCeiling)
    {
        delete m_alphaCeiling;
        m_alphaCeiling = NULL;
    }
    ;

    m_has_alphaFloor = false;

    if (m_alphaFloor)
    {
        delete m_alphaFloor;
        m_alphaFloor = NULL;
    }
    ;

    m_has_alphaInv = false;

    if (m_alphaInv)
    {
        delete m_alphaInv;
        m_alphaInv = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_alphaModFix = false;

    if (m_alphaModFix)
    {
        delete m_alphaModFix;
        m_alphaModFix = NULL;
    }
    ;

    m_has_alphaRepl = false;

    if (m_alphaRepl)
    {
        delete m_alphaRepl;
        m_alphaRepl = NULL;
    }
    ;

    m_has_biLevel = false;

    if (m_biLevel)
    {
        delete m_biLevel;
        m_biLevel = NULL;
    }
    ;

    m_has_blur = false;

    if (m_blur)
    {
        delete m_blur;
        m_blur = NULL;
    }
    ;

    m_has_clrRepl = false;

    if (m_clrRepl)
    {
        delete m_clrRepl;
        m_clrRepl = NULL;
    }
    ;

    m_has_duotone = false;

    if (m_duotone)
    {
        delete m_duotone;
        m_duotone = NULL;
    }
    ;

    m_has_fillOverlay = false;

    if (m_fillOverlay)
    {
        delete m_fillOverlay;
        m_fillOverlay = NULL;
    }
    ;

    m_has_grayscl = false;

    if (m_grayscl)
    {
        delete m_grayscl;
        m_grayscl = NULL;
    }
    ;

    m_has_hsl = false;

    if (m_hsl)
    {
        delete m_hsl;
        m_hsl = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_clrChange = true;
    if (!m_clrChange)
    {
        m_clrChange = new CT_ColorChangeEffect();
    }
    return m_clrChange;
}

const CT_ColorChangeEffect& blip_element::ChildGroup_1::get_clrChange() const
{
    if (m_clrChange)
    {
        return *m_clrChange;
    }
    return CT_ColorChangeEffect::default_instance();
}

bool blip_element::ChildGroup_1::has_clrRepl() const
{
    return m_has_clrRepl;
}

CT_ColorReplaceEffect* blip_element::ChildGroup_1::mutable_clrRepl()
{

    m_has_alphaBiLevel = false;

    if (m_alphaBiLevel)
    {
        delete m_alphaBiLevel;
        m_alphaBiLevel = NULL;
    }
    ;

    m_has_alphaCeiling = false;

    if (m_alphaCeiling)
    {
        delete m_alphaCeiling;
        m_alphaCeiling = NULL;
    }
    ;

    m_has_alphaFloor = false;

    if (m_alphaFloor)
    {
        delete m_alphaFloor;
        m_alphaFloor = NULL;
    }
    ;

    m_has_alphaInv = false;

    if (m_alphaInv)
    {
        delete m_alphaInv;
        m_alphaInv = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_alphaModFix = false;

    if (m_alphaModFix)
    {
        delete m_alphaModFix;
        m_alphaModFix = NULL;
    }
    ;

    m_has_alphaRepl = false;

    if (m_alphaRepl)
    {
        delete m_alphaRepl;
        m_alphaRepl = NULL;
    }
    ;

    m_has_biLevel = false;

    if (m_biLevel)
    {
        delete m_biLevel;
        m_biLevel = NULL;
    }
    ;

    m_has_blur = false;

    if (m_blur)
    {
        delete m_blur;
        m_blur = NULL;
    }
    ;

    m_has_clrChange = false;

    if (m_clrChange)
    {
        delete m_clrChange;
        m_clrChange = NULL;
    }
    ;

    m_has_duotone = false;

    if (m_duotone)
    {
        delete m_duotone;
        m_duotone = NULL;
    }
    ;

    m_has_fillOverlay = false;

    if (m_fillOverlay)
    {
        delete m_fillOverlay;
        m_fillOverlay = NULL;
    }
    ;

    m_has_grayscl = false;

    if (m_grayscl)
    {
        delete m_grayscl;
        m_grayscl = NULL;
    }
    ;

    m_has_hsl = false;

    if (m_hsl)
    {
        delete m_hsl;
        m_hsl = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_clrRepl = true;
    if (!m_clrRepl)
    {
        m_clrRepl = new CT_ColorReplaceEffect();
    }
    return m_clrRepl;
}

const CT_ColorReplaceEffect& blip_element::ChildGroup_1::get_clrRepl() const
{
    if (m_clrRepl)
    {
        return *m_clrRepl;
    }
    return CT_ColorReplaceEffect::default_instance();
}

bool blip_element::ChildGroup_1::has_duotone() const
{
    return m_has_duotone;
}

CT_DuotoneEffect* blip_element::ChildGroup_1::mutable_duotone()
{

    m_has_alphaBiLevel = false;

    if (m_alphaBiLevel)
    {
        delete m_alphaBiLevel;
        m_alphaBiLevel = NULL;
    }
    ;

    m_has_alphaCeiling = false;

    if (m_alphaCeiling)
    {
        delete m_alphaCeiling;
        m_alphaCeiling = NULL;
    }
    ;

    m_has_alphaFloor = false;

    if (m_alphaFloor)
    {
        delete m_alphaFloor;
        m_alphaFloor = NULL;
    }
    ;

    m_has_alphaInv = false;

    if (m_alphaInv)
    {
        delete m_alphaInv;
        m_alphaInv = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_alphaModFix = false;

    if (m_alphaModFix)
    {
        delete m_alphaModFix;
        m_alphaModFix = NULL;
    }
    ;

    m_has_alphaRepl = false;

    if (m_alphaRepl)
    {
        delete m_alphaRepl;
        m_alphaRepl = NULL;
    }
    ;

    m_has_biLevel = false;

    if (m_biLevel)
    {
        delete m_biLevel;
        m_biLevel = NULL;
    }
    ;

    m_has_blur = false;

    if (m_blur)
    {
        delete m_blur;
        m_blur = NULL;
    }
    ;

    m_has_clrChange = false;

    if (m_clrChange)
    {
        delete m_clrChange;
        m_clrChange = NULL;
    }
    ;

    m_has_clrRepl = false;

    if (m_clrRepl)
    {
        delete m_clrRepl;
        m_clrRepl = NULL;
    }
    ;

    m_has_fillOverlay = false;

    if (m_fillOverlay)
    {
        delete m_fillOverlay;
        m_fillOverlay = NULL;
    }
    ;

    m_has_grayscl = false;

    if (m_grayscl)
    {
        delete m_grayscl;
        m_grayscl = NULL;
    }
    ;

    m_has_hsl = false;

    if (m_hsl)
    {
        delete m_hsl;
        m_hsl = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_duotone = true;
    if (!m_duotone)
    {
        m_duotone = new CT_DuotoneEffect();
    }
    return m_duotone;
}

const CT_DuotoneEffect& blip_element::ChildGroup_1::get_duotone() const
{
    if (m_duotone)
    {
        return *m_duotone;
    }
    return CT_DuotoneEffect::default_instance();
}

bool blip_element::ChildGroup_1::has_fillOverlay() const
{
    return m_has_fillOverlay;
}

CT_FillOverlayEffect* blip_element::ChildGroup_1::mutable_fillOverlay()
{

    m_has_alphaBiLevel = false;

    if (m_alphaBiLevel)
    {
        delete m_alphaBiLevel;
        m_alphaBiLevel = NULL;
    }
    ;

    m_has_alphaCeiling = false;

    if (m_alphaCeiling)
    {
        delete m_alphaCeiling;
        m_alphaCeiling = NULL;
    }
    ;

    m_has_alphaFloor = false;

    if (m_alphaFloor)
    {
        delete m_alphaFloor;
        m_alphaFloor = NULL;
    }
    ;

    m_has_alphaInv = false;

    if (m_alphaInv)
    {
        delete m_alphaInv;
        m_alphaInv = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_alphaModFix = false;

    if (m_alphaModFix)
    {
        delete m_alphaModFix;
        m_alphaModFix = NULL;
    }
    ;

    m_has_alphaRepl = false;

    if (m_alphaRepl)
    {
        delete m_alphaRepl;
        m_alphaRepl = NULL;
    }
    ;

    m_has_biLevel = false;

    if (m_biLevel)
    {
        delete m_biLevel;
        m_biLevel = NULL;
    }
    ;

    m_has_blur = false;

    if (m_blur)
    {
        delete m_blur;
        m_blur = NULL;
    }
    ;

    m_has_clrChange = false;

    if (m_clrChange)
    {
        delete m_clrChange;
        m_clrChange = NULL;
    }
    ;

    m_has_clrRepl = false;

    if (m_clrRepl)
    {
        delete m_clrRepl;
        m_clrRepl = NULL;
    }
    ;

    m_has_duotone = false;

    if (m_duotone)
    {
        delete m_duotone;
        m_duotone = NULL;
    }
    ;

    m_has_grayscl = false;

    if (m_grayscl)
    {
        delete m_grayscl;
        m_grayscl = NULL;
    }
    ;

    m_has_hsl = false;

    if (m_hsl)
    {
        delete m_hsl;
        m_hsl = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_fillOverlay = true;
    if (!m_fillOverlay)
    {
        m_fillOverlay = new CT_FillOverlayEffect();
    }
    return m_fillOverlay;
}

const CT_FillOverlayEffect& blip_element::ChildGroup_1::get_fillOverlay() const
{
    if (m_fillOverlay)
    {
        return *m_fillOverlay;
    }
    return CT_FillOverlayEffect::default_instance();
}

bool blip_element::ChildGroup_1::has_grayscl() const
{
    return m_has_grayscl;
}

CT_GrayscaleEffect* blip_element::ChildGroup_1::mutable_grayscl()
{

    m_has_alphaBiLevel = false;

    if (m_alphaBiLevel)
    {
        delete m_alphaBiLevel;
        m_alphaBiLevel = NULL;
    }
    ;

    m_has_alphaCeiling = false;

    if (m_alphaCeiling)
    {
        delete m_alphaCeiling;
        m_alphaCeiling = NULL;
    }
    ;

    m_has_alphaFloor = false;

    if (m_alphaFloor)
    {
        delete m_alphaFloor;
        m_alphaFloor = NULL;
    }
    ;

    m_has_alphaInv = false;

    if (m_alphaInv)
    {
        delete m_alphaInv;
        m_alphaInv = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_alphaModFix = false;

    if (m_alphaModFix)
    {
        delete m_alphaModFix;
        m_alphaModFix = NULL;
    }
    ;

    m_has_alphaRepl = false;

    if (m_alphaRepl)
    {
        delete m_alphaRepl;
        m_alphaRepl = NULL;
    }
    ;

    m_has_biLevel = false;

    if (m_biLevel)
    {
        delete m_biLevel;
        m_biLevel = NULL;
    }
    ;

    m_has_blur = false;

    if (m_blur)
    {
        delete m_blur;
        m_blur = NULL;
    }
    ;

    m_has_clrChange = false;

    if (m_clrChange)
    {
        delete m_clrChange;
        m_clrChange = NULL;
    }
    ;

    m_has_clrRepl = false;

    if (m_clrRepl)
    {
        delete m_clrRepl;
        m_clrRepl = NULL;
    }
    ;

    m_has_duotone = false;

    if (m_duotone)
    {
        delete m_duotone;
        m_duotone = NULL;
    }
    ;

    m_has_fillOverlay = false;

    if (m_fillOverlay)
    {
        delete m_fillOverlay;
        m_fillOverlay = NULL;
    }
    ;

    m_has_hsl = false;

    if (m_hsl)
    {
        delete m_hsl;
        m_hsl = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_grayscl = true;
    if (!m_grayscl)
    {
        m_grayscl = new CT_GrayscaleEffect();
    }
    return m_grayscl;
}

const CT_GrayscaleEffect& blip_element::ChildGroup_1::get_grayscl() const
{
    if (m_grayscl)
    {
        return *m_grayscl;
    }
    return CT_GrayscaleEffect::default_instance();
}

bool blip_element::ChildGroup_1::has_hsl() const
{
    return m_has_hsl;
}

CT_HSLEffect* blip_element::ChildGroup_1::mutable_hsl()
{

    m_has_alphaBiLevel = false;

    if (m_alphaBiLevel)
    {
        delete m_alphaBiLevel;
        m_alphaBiLevel = NULL;
    }
    ;

    m_has_alphaCeiling = false;

    if (m_alphaCeiling)
    {
        delete m_alphaCeiling;
        m_alphaCeiling = NULL;
    }
    ;

    m_has_alphaFloor = false;

    if (m_alphaFloor)
    {
        delete m_alphaFloor;
        m_alphaFloor = NULL;
    }
    ;

    m_has_alphaInv = false;

    if (m_alphaInv)
    {
        delete m_alphaInv;
        m_alphaInv = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_alphaModFix = false;

    if (m_alphaModFix)
    {
        delete m_alphaModFix;
        m_alphaModFix = NULL;
    }
    ;

    m_has_alphaRepl = false;

    if (m_alphaRepl)
    {
        delete m_alphaRepl;
        m_alphaRepl = NULL;
    }
    ;

    m_has_biLevel = false;

    if (m_biLevel)
    {
        delete m_biLevel;
        m_biLevel = NULL;
    }
    ;

    m_has_blur = false;

    if (m_blur)
    {
        delete m_blur;
        m_blur = NULL;
    }
    ;

    m_has_clrChange = false;

    if (m_clrChange)
    {
        delete m_clrChange;
        m_clrChange = NULL;
    }
    ;

    m_has_clrRepl = false;

    if (m_clrRepl)
    {
        delete m_clrRepl;
        m_clrRepl = NULL;
    }
    ;

    m_has_duotone = false;

    if (m_duotone)
    {
        delete m_duotone;
        m_duotone = NULL;
    }
    ;

    m_has_fillOverlay = false;

    if (m_fillOverlay)
    {
        delete m_fillOverlay;
        m_fillOverlay = NULL;
    }
    ;

    m_has_grayscl = false;

    if (m_grayscl)
    {
        delete m_grayscl;
        m_grayscl = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_hsl = true;
    if (!m_hsl)
    {
        m_hsl = new CT_HSLEffect();
    }
    return m_hsl;
}

const CT_HSLEffect& blip_element::ChildGroup_1::get_hsl() const
{
    if (m_hsl)
    {
        return *m_hsl;
    }
    return CT_HSLEffect::default_instance();
}

bool blip_element::ChildGroup_1::has_lum() const
{
    return m_has_lum;
}

CT_LuminanceEffect* blip_element::ChildGroup_1::mutable_lum()
{

    m_has_alphaBiLevel = false;

    if (m_alphaBiLevel)
    {
        delete m_alphaBiLevel;
        m_alphaBiLevel = NULL;
    }
    ;

    m_has_alphaCeiling = false;

    if (m_alphaCeiling)
    {
        delete m_alphaCeiling;
        m_alphaCeiling = NULL;
    }
    ;

    m_has_alphaFloor = false;

    if (m_alphaFloor)
    {
        delete m_alphaFloor;
        m_alphaFloor = NULL;
    }
    ;

    m_has_alphaInv = false;

    if (m_alphaInv)
    {
        delete m_alphaInv;
        m_alphaInv = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_alphaModFix = false;

    if (m_alphaModFix)
    {
        delete m_alphaModFix;
        m_alphaModFix = NULL;
    }
    ;

    m_has_alphaRepl = false;

    if (m_alphaRepl)
    {
        delete m_alphaRepl;
        m_alphaRepl = NULL;
    }
    ;

    m_has_biLevel = false;

    if (m_biLevel)
    {
        delete m_biLevel;
        m_biLevel = NULL;
    }
    ;

    m_has_blur = false;

    if (m_blur)
    {
        delete m_blur;
        m_blur = NULL;
    }
    ;

    m_has_clrChange = false;

    if (m_clrChange)
    {
        delete m_clrChange;
        m_clrChange = NULL;
    }
    ;

    m_has_clrRepl = false;

    if (m_clrRepl)
    {
        delete m_clrRepl;
        m_clrRepl = NULL;
    }
    ;

    m_has_duotone = false;

    if (m_duotone)
    {
        delete m_duotone;
        m_duotone = NULL;
    }
    ;

    m_has_fillOverlay = false;

    if (m_fillOverlay)
    {
        delete m_fillOverlay;
        m_fillOverlay = NULL;
    }
    ;

    m_has_grayscl = false;

    if (m_grayscl)
    {
        delete m_grayscl;
        m_grayscl = NULL;
    }
    ;

    m_has_hsl = false;

    if (m_hsl)
    {
        delete m_hsl;
        m_hsl = NULL;
    }
    ;

    m_has_tint = false;

    if (m_tint)
    {
        delete m_tint;
        m_tint = NULL;
    }
    ;

    m_has_lum = true;
    if (!m_lum)
    {
        m_lum = new CT_LuminanceEffect();
    }
    return m_lum;
}

const CT_LuminanceEffect& blip_element::ChildGroup_1::get_lum() const
{
    if (m_lum)
    {
        return *m_lum;
    }
    return CT_LuminanceEffect::default_instance();
}

bool blip_element::ChildGroup_1::has_tint() const
{
    return m_has_tint;
}

CT_TintEffect* blip_element::ChildGroup_1::mutable_tint()
{

    m_has_alphaBiLevel = false;

    if (m_alphaBiLevel)
    {
        delete m_alphaBiLevel;
        m_alphaBiLevel = NULL;
    }
    ;

    m_has_alphaCeiling = false;

    if (m_alphaCeiling)
    {
        delete m_alphaCeiling;
        m_alphaCeiling = NULL;
    }
    ;

    m_has_alphaFloor = false;

    if (m_alphaFloor)
    {
        delete m_alphaFloor;
        m_alphaFloor = NULL;
    }
    ;

    m_has_alphaInv = false;

    if (m_alphaInv)
    {
        delete m_alphaInv;
        m_alphaInv = NULL;
    }
    ;

    m_has_alphaMod = false;

    if (m_alphaMod)
    {
        delete m_alphaMod;
        m_alphaMod = NULL;
    }
    ;

    m_has_alphaModFix = false;

    if (m_alphaModFix)
    {
        delete m_alphaModFix;
        m_alphaModFix = NULL;
    }
    ;

    m_has_alphaRepl = false;

    if (m_alphaRepl)
    {
        delete m_alphaRepl;
        m_alphaRepl = NULL;
    }
    ;

    m_has_biLevel = false;

    if (m_biLevel)
    {
        delete m_biLevel;
        m_biLevel = NULL;
    }
    ;

    m_has_blur = false;

    if (m_blur)
    {
        delete m_blur;
        m_blur = NULL;
    }
    ;

    m_has_clrChange = false;

    if (m_clrChange)
    {
        delete m_clrChange;
        m_clrChange = NULL;
    }
    ;

    m_has_clrRepl = false;

    if (m_clrRepl)
    {
        delete m_clrRepl;
        m_clrRepl = NULL;
    }
    ;

    m_has_duotone = false;

    if (m_duotone)
    {
        delete m_duotone;
        m_duotone = NULL;
    }
    ;

    m_has_fillOverlay = false;

    if (m_fillOverlay)
    {
        delete m_fillOverlay;
        m_fillOverlay = NULL;
    }
    ;

    m_has_grayscl = false;

    if (m_grayscl)
    {
        delete m_grayscl;
        m_grayscl = NULL;
    }
    ;

    m_has_hsl = false;

    if (m_hsl)
    {
        delete m_hsl;
        m_hsl = NULL;
    }
    ;

    m_has_lum = false;

    if (m_lum)
    {
        delete m_lum;
        m_lum = NULL;
    }
    ;

    m_has_tint = true;
    if (!m_tint)
    {
        m_tint = new CT_TintEffect();
    }
    return m_tint;
}

const CT_TintEffect& blip_element::ChildGroup_1::get_tint() const
{
    if (m_tint)
    {
        return *m_tint;
    }
    return CT_TintEffect::default_instance();
}

blip_element* blip_element::default_instance_ = NULL;

// theme_element
theme_element::theme_element()
    :m_has_themeElements(false),
     m_themeElements(NULL),
     m_has_objectDefaults(false),
     m_objectDefaults(NULL),
     m_has_extraClrSchemeLst(false),
     m_extraClrSchemeLst(NULL),
     m_has_custClrLst(false),
     m_custClrLst(NULL),
     m_has_extLst(false),
     m_extLst(NULL),
     m_has_name_attr(false),
     m_name_attr("")
{
}
theme_element::~theme_element()
{
    clear();
}
bool theme_element::has_themeElements() const
{
    return m_has_themeElements;
}

CT_BaseStyles* theme_element::mutable_themeElements()
{
    m_has_themeElements = true;
    if (!m_themeElements)
    {
        m_themeElements = new CT_BaseStyles();
    }
    return m_themeElements;
}

const CT_BaseStyles& theme_element::get_themeElements() const
{
    if (m_themeElements)
    {
        return *m_themeElements;
    }
    return CT_BaseStyles::default_instance();
}

bool theme_element::has_objectDefaults() const
{
    return m_has_objectDefaults;
}

CT_ObjectStyleDefaults* theme_element::mutable_objectDefaults()
{
    m_has_objectDefaults = true;
    if (!m_objectDefaults)
    {
        m_objectDefaults = new CT_ObjectStyleDefaults();
    }
    return m_objectDefaults;
}

const CT_ObjectStyleDefaults& theme_element::get_objectDefaults() const
{
    if (m_objectDefaults)
    {
        return *m_objectDefaults;
    }
    return CT_ObjectStyleDefaults::default_instance();
}

bool theme_element::has_extraClrSchemeLst() const
{
    return m_has_extraClrSchemeLst;
}

CT_ColorSchemeList* theme_element::mutable_extraClrSchemeLst()
{
    m_has_extraClrSchemeLst = true;
    if (!m_extraClrSchemeLst)
    {
        m_extraClrSchemeLst = new CT_ColorSchemeList();
    }
    return m_extraClrSchemeLst;
}

const CT_ColorSchemeList& theme_element::get_extraClrSchemeLst() const
{
    if (m_extraClrSchemeLst)
    {
        return *m_extraClrSchemeLst;
    }
    return CT_ColorSchemeList::default_instance();
}

bool theme_element::has_custClrLst() const
{
    return m_has_custClrLst;
}

CT_CustomColorList* theme_element::mutable_custClrLst()
{
    m_has_custClrLst = true;
    if (!m_custClrLst)
    {
        m_custClrLst = new CT_CustomColorList();
    }
    return m_custClrLst;
}

const CT_CustomColorList& theme_element::get_custClrLst() const
{
    if (m_custClrLst)
    {
        return *m_custClrLst;
    }
    return CT_CustomColorList::default_instance();
}

bool theme_element::has_extLst() const
{
    return m_has_extLst;
}

CT_OfficeArtExtensionList* theme_element::mutable_extLst()
{
    m_has_extLst = true;
    if (!m_extLst)
    {
        m_extLst = new CT_OfficeArtExtensionList();
    }
    return m_extLst;
}

const CT_OfficeArtExtensionList& theme_element::get_extLst() const
{
    if (m_extLst)
    {
        return *m_extLst;
    }
    return CT_OfficeArtExtensionList::default_instance();
}

void theme_element::clear()
{
    m_has_name_attr = false;
    m_name_attr.clear();

    m_has_themeElements = false;

    if (m_themeElements)
    {
        delete m_themeElements;
        m_themeElements = NULL;
    }


    m_has_objectDefaults = false;

    if (m_objectDefaults)
    {
        delete m_objectDefaults;
        m_objectDefaults = NULL;
    }


    m_has_extraClrSchemeLst = false;

    if (m_extraClrSchemeLst)
    {
        delete m_extraClrSchemeLst;
        m_extraClrSchemeLst = NULL;
    }


    m_has_custClrLst = false;

    if (m_custClrLst)
    {
        delete m_custClrLst;
        m_custClrLst = NULL;
    }


    m_has_extLst = false;

    if (m_extLst)
    {
        delete m_extLst;
        m_extLst = NULL;
    }

}

void theme_element::toXml(std::ostream& _outStream) const
{
    _outStream << "<a:theme";

    _outStream << " " << "xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\"";
    _outStream << " " << "xmlns:s=\"http://schemas.openxmlformats.org/officeDocument/2006/sharedTypes\"";
    _outStream << " " << "xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\"";


    if (m_has_name_attr)
    {
        _outStream << " " << "name" << "=\"" << m_name_attr << "\"";
    }

    _outStream << ">";

    assert(m_has_themeElements);


    if (m_has_themeElements)
    {
        m_themeElements->toXmlElem("a:themeElements", "", _outStream);
    }


    if (m_has_objectDefaults)
    {
        m_objectDefaults->toXmlElem("a:objectDefaults", "", _outStream);
    }


    if (m_has_extraClrSchemeLst)
    {
        m_extraClrSchemeLst->toXmlElem("a:extraClrSchemeLst", "", _outStream);
    }


    if (m_has_custClrLst)
    {
        m_custClrLst->toXmlElem("a:custClrLst", "", _outStream);
    }


    if (m_has_extLst)
    {
        m_extLst->toXmlElem("a:extLst", "", _outStream);
    }

    _outStream << "</a:theme>";
}

const theme_element& theme_element::default_instance()
{
    if (!theme_element::default_instance_)
    {
        theme_element::default_instance_ = new theme_element();
    }
    return *theme_element::default_instance_;
}

bool theme_element::has_name_attr() const
{
    return m_has_name_attr;
}

void theme_element::set_name_attr(const XSD::string_& _name_attr)
{
    m_has_name_attr = true;
    m_name_attr = _name_attr;
}

const XSD::string_& theme_element::get_name_attr() const
{
    return m_name_attr;
}

theme_element* theme_element::default_instance_ = NULL;

// themeOverride_element
themeOverride_element::themeOverride_element()
    :m_has_clrScheme(false),
     m_clrScheme(NULL),
     m_has_fontScheme(false),
     m_fontScheme(NULL),
     m_has_fmtScheme(false),
     m_fmtScheme(NULL)
{
}
themeOverride_element::~themeOverride_element()
{
    clear();
}
bool themeOverride_element::has_clrScheme() const
{
    return m_has_clrScheme;
}

CT_ColorScheme* themeOverride_element::mutable_clrScheme()
{
    m_has_clrScheme = true;
    if (!m_clrScheme)
    {
        m_clrScheme = new CT_ColorScheme();
    }
    return m_clrScheme;
}

const CT_ColorScheme& themeOverride_element::get_clrScheme() const
{
    if (m_clrScheme)
    {
        return *m_clrScheme;
    }
    return CT_ColorScheme::default_instance();
}

bool themeOverride_element::has_fontScheme() const
{
    return m_has_fontScheme;
}

CT_FontScheme* themeOverride_element::mutable_fontScheme()
{
    m_has_fontScheme = true;
    if (!m_fontScheme)
    {
        m_fontScheme = new CT_FontScheme();
    }
    return m_fontScheme;
}

const CT_FontScheme& themeOverride_element::get_fontScheme() const
{
    if (m_fontScheme)
    {
        return *m_fontScheme;
    }
    return CT_FontScheme::default_instance();
}

bool themeOverride_element::has_fmtScheme() const
{
    return m_has_fmtScheme;
}

CT_StyleMatrix* themeOverride_element::mutable_fmtScheme()
{
    m_has_fmtScheme = true;
    if (!m_fmtScheme)
    {
        m_fmtScheme = new CT_StyleMatrix();
    }
    return m_fmtScheme;
}

const CT_StyleMatrix& themeOverride_element::get_fmtScheme() const
{
    if (m_fmtScheme)
    {
        return *m_fmtScheme;
    }
    return CT_StyleMatrix::default_instance();
}

void themeOverride_element::clear()
{
    m_has_clrScheme = false;

    if (m_clrScheme)
    {
        delete m_clrScheme;
        m_clrScheme = NULL;
    }


    m_has_fontScheme = false;

    if (m_fontScheme)
    {
        delete m_fontScheme;
        m_fontScheme = NULL;
    }


    m_has_fmtScheme = false;

    if (m_fmtScheme)
    {
        delete m_fmtScheme;
        m_fmtScheme = NULL;
    }

}

void themeOverride_element::toXml(std::ostream& _outStream) const
{
    _outStream << "<a:themeOverride";

    _outStream << " " << "xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\"";
    _outStream << " " << "xmlns:s=\"http://schemas.openxmlformats.org/officeDocument/2006/sharedTypes\"";
    _outStream << " " << "xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\"";

    _outStream << ">";


    if (m_has_clrScheme)
    {
        m_clrScheme->toXmlElem("a:clrScheme", "", _outStream);
    }


    if (m_has_fontScheme)
    {
        m_fontScheme->toXmlElem("a:fontScheme", "", _outStream);
    }


    if (m_has_fmtScheme)
    {
        m_fmtScheme->toXmlElem("a:fmtScheme", "", _outStream);
    }

    _outStream << "</a:themeOverride>";
}

const themeOverride_element& themeOverride_element::default_instance()
{
    if (!themeOverride_element::default_instance_)
    {
        themeOverride_element::default_instance_ = new themeOverride_element();
    }
    return *themeOverride_element::default_instance_;
}

themeOverride_element* themeOverride_element::default_instance_ = NULL;

// themeManager_element
themeManager_element::themeManager_element()

{
}
themeManager_element::~themeManager_element()
{
    clear();
}
void themeManager_element::clear()
{    }

void themeManager_element::toXml(std::ostream& _outStream) const
{
    _outStream << "<a:themeManager";

    _outStream << " " << "xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\"";
    _outStream << " " << "xmlns:s=\"http://schemas.openxmlformats.org/officeDocument/2006/sharedTypes\"";
    _outStream << " " << "xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\"";

    _outStream << ">";

    _outStream << "</a:themeManager>";
}

const themeManager_element& themeManager_element::default_instance()
{
    if (!themeManager_element::default_instance_)
    {
        themeManager_element::default_instance_ = new themeManager_element();
    }
    return *themeManager_element::default_instance_;
}

themeManager_element* themeManager_element::default_instance_ = NULL;

// tbl_element
tbl_element::tbl_element()
    :m_has_tblPr(false),
     m_tblPr(NULL),
     m_has_tblGrid(false),
     m_tblGrid(NULL)
{
}
tbl_element::~tbl_element()
{
    clear();
}
bool tbl_element::has_tblPr() const
{
    return m_has_tblPr;
}

CT_TableProperties* tbl_element::mutable_tblPr()
{
    m_has_tblPr = true;
    if (!m_tblPr)
    {
        m_tblPr = new CT_TableProperties();
    }
    return m_tblPr;
}

const CT_TableProperties& tbl_element::get_tblPr() const
{
    if (m_tblPr)
    {
        return *m_tblPr;
    }
    return CT_TableProperties::default_instance();
}

bool tbl_element::has_tblGrid() const
{
    return m_has_tblGrid;
}

CT_TableGrid* tbl_element::mutable_tblGrid()
{
    m_has_tblGrid = true;
    if (!m_tblGrid)
    {
        m_tblGrid = new CT_TableGrid();
    }
    return m_tblGrid;
}

const CT_TableGrid& tbl_element::get_tblGrid() const
{
    if (m_tblGrid)
    {
        return *m_tblGrid;
    }
    return CT_TableGrid::default_instance();
}

CT_TableRow* tbl_element::add_tr()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_TableRow* pNewChild = pChildGroup->mutable_tr();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

void tbl_element::clear()
{
    m_has_tblPr = false;

    if (m_tblPr)
    {
        delete m_tblPr;
        m_tblPr = NULL;
    }


    m_has_tblGrid = false;

    if (m_tblGrid)
    {
        delete m_tblGrid;
        m_tblGrid = NULL;
    }


    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }
}

void tbl_element::toXml(std::ostream& _outStream) const
{
    _outStream << "<a:tbl";

    _outStream << " " << "xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\"";
    _outStream << " " << "xmlns:s=\"http://schemas.openxmlformats.org/officeDocument/2006/sharedTypes\"";
    _outStream << " " << "xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\"";

    _outStream << ">";

    assert(m_has_tblGrid);


    if (m_has_tblPr)
    {
        m_tblPr->toXmlElem("a:tblPr", "", _outStream);
    }


    if (m_has_tblGrid)
    {
        m_tblGrid->toXmlElem("a:tblGrid", "", _outStream);
    }

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_tr())
            {
                (*iter)->get_tr().toXmlElem("a:tr", "", _outStream);
            }


        }
    }

    _outStream << "</a:tbl>";
}

const tbl_element& tbl_element::default_instance()
{
    if (!tbl_element::default_instance_)
    {
        tbl_element::default_instance_ = new tbl_element();
    }
    return *tbl_element::default_instance_;
}


// tbl_element::ChildGroup_1
tbl_element::ChildGroup_1::ChildGroup_1()
    :m_has_tr(false),
     m_tr(NULL)
{
}
bool tbl_element::ChildGroup_1::has_tr() const
{
    return m_has_tr;
}

CT_TableRow* tbl_element::ChildGroup_1::mutable_tr()
{

    m_has_tr = true;
    if (!m_tr)
    {
        m_tr = new CT_TableRow();
    }
    return m_tr;
}

const CT_TableRow& tbl_element::ChildGroup_1::get_tr() const
{
    if (m_tr)
    {
        return *m_tr;
    }
    return CT_TableRow::default_instance();
}

tbl_element* tbl_element::default_instance_ = NULL;

// tblStyleLst_element
tblStyleLst_element::tblStyleLst_element()
    :m_has_def_attr(false),
     m_def_attr(NULL)
{
}
tblStyleLst_element::~tblStyleLst_element()
{
    clear();
}
CT_TableStyle* tblStyleLst_element::add_tblStyle()
{
    ChildGroup_1 *pChildGroup = new ChildGroup_1();
    CT_TableStyle* pNewChild = pChildGroup->mutable_tblStyle();
    m_childGroupList_1.push_back(pChildGroup);
    return pNewChild;
}

void tblStyleLst_element::clear()
{
    m_has_def_attr = false;

    if (m_def_attr)
    {
        delete m_def_attr;
        m_def_attr = NULL;
    }


    {
        vector<ChildGroup_1*>::iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            delete *iter;
        }
        m_childGroupList_1.clear();
    }
}

void tblStyleLst_element::toXml(std::ostream& _outStream) const
{
    _outStream << "<a:tblStyleLst";

    _outStream << " " << "xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\"";
    _outStream << " " << "xmlns:s=\"http://schemas.openxmlformats.org/officeDocument/2006/sharedTypes\"";
    _outStream << " " << "xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\"";

    assert(m_has_def_attr);
    if (m_has_def_attr)
    {
        m_def_attr->toXmlAttr("def", _outStream);
    }

    _outStream << ">";

    {
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_tblStyle())
            {
                (*iter)->get_tblStyle().toXmlElem("a:tblStyle", "", _outStream);
            }


        }
    }

    _outStream << "</a:tblStyleLst>";
}

const tblStyleLst_element& tblStyleLst_element::default_instance()
{
    if (!tblStyleLst_element::default_instance_)
    {
        tblStyleLst_element::default_instance_ = new tblStyleLst_element();
    }
    return *tblStyleLst_element::default_instance_;
}

bool tblStyleLst_element::has_def_attr() const
{
    return m_has_def_attr;
}

void tblStyleLst_element::set_def_attr(const ns_s::ST_Guid& _def_attr)
{
    m_has_def_attr = true;
    m_def_attr = new ns_s::ST_Guid(_def_attr);
}

const ns_s::ST_Guid& tblStyleLst_element::get_def_attr() const
{
    if (m_def_attr)
    {
        return *m_def_attr;
    }
    return ns_s::ST_Guid::default_instance();
}


// tblStyleLst_element::ChildGroup_1
tblStyleLst_element::ChildGroup_1::ChildGroup_1()
    :m_has_tblStyle(false),
     m_tblStyle(NULL)
{
}
bool tblStyleLst_element::ChildGroup_1::has_tblStyle() const
{
    return m_has_tblStyle;
}

CT_TableStyle* tblStyleLst_element::ChildGroup_1::mutable_tblStyle()
{

    m_has_tblStyle = true;
    if (!m_tblStyle)
    {
        m_tblStyle = new CT_TableStyle();
    }
    return m_tblStyle;
}

const CT_TableStyle& tblStyleLst_element::ChildGroup_1::get_tblStyle() const
{
    if (m_tblStyle)
    {
        return *m_tblStyle;
    }
    return CT_TableStyle::default_instance();
}

tblStyleLst_element* tblStyleLst_element::default_instance_ = NULL;
}