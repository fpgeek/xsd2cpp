#include "sml_xsd.h"
#include <stdlib.h>
#include <sstream>
#include "shared-relationshipReference_xsd.h"
#include "shared-commonSimpleTypes_xsd.h"
#include "dml-spreadsheetDrawing_xsd.h"
namespace ns_s{
    class Element : public XSD::Element{
    public:

    private:

    }

    class Attribute : public XSD::Attribute{
    public:

    private:

    }

    class ST_FilterOperator : public XSD::SimpleType{
    public:
        ST_FilterOperator(){
            m_has_type = false

        }
        ST_FilterOperator(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_FilterOperator::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_FilterOperator& default_instance(){

    if (!ST_FilterOperator::default_instance_)
    {
        ST_FilterOperator::default_instance_ = new ST_FilterOperator();
    }
    return *ST_FilterOperator::default_instance_;

        }
        enum Type{
            _equal_ = 1,
            _lessThan_,
            _lessThanOrEqual_,
            _notEqual_,
            _greaterThanOrEqual_,
            _greaterThan_
        }

    private:
        static const string TypeStrList [];
        static ST_FilterOperator* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_DynamicFilterType : public XSD::SimpleType{
    public:
        ST_DynamicFilterType(){
            m_has_type = false

        }
        ST_DynamicFilterType(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_DynamicFilterType::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_DynamicFilterType& default_instance(){

    if (!ST_DynamicFilterType::default_instance_)
    {
        ST_DynamicFilterType::default_instance_ = new ST_DynamicFilterType();
    }
    return *ST_DynamicFilterType::default_instance_;

        }
        enum Type{
            _null_ = 1,
            _aboveAverage_,
            _belowAverage_,
            _tomorrow_,
            _today_,
            _yesterday_,
            _nextWeek_,
            _thisWeek_,
            _lastWeek_,
            _nextMonth_,
            _thisMonth_,
            _lastMonth_,
            _nextQuarter_,
            _thisQuarter_,
            _lastQuarter_,
            _nextYear_,
            _thisYear_,
            _lastYear_,
            _yearToDate_,
            _Q1_,
            _Q2_,
            _Q3_,
            _Q4_,
            _M1_,
            _M2_,
            _M3_,
            _M4_,
            _M5_,
            _M6_,
            _M7_,
            _M8_,
            _M9_,
            _M10_,
            _M11_,
            _M12_
        }

    private:
        static const string TypeStrList [];
        static ST_DynamicFilterType* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_IconSetType : public XSD::SimpleType{
    public:
        ST_IconSetType(){
            m_has_type = false

        }
        ST_IconSetType(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_IconSetType::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_IconSetType& default_instance(){

    if (!ST_IconSetType::default_instance_)
    {
        ST_IconSetType::default_instance_ = new ST_IconSetType();
    }
    return *ST_IconSetType::default_instance_;

        }
        enum Type{
            _3Arrows_ = 1,
            _3ArrowsGray_,
            _3Flags_,
            _3TrafficLights1_,
            _3TrafficLights2_,
            _3Signs_,
            _3Symbols_,
            _3Symbols2_,
            _4Arrows_,
            _4ArrowsGray_,
            _4RedToBlack_,
            _4Rating_,
            _4TrafficLights_,
            _5Arrows_,
            _5ArrowsGray_,
            _5Rating_,
            _5Quarters_
        }

    private:
        static const string TypeStrList [];
        static ST_IconSetType* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_SortBy : public XSD::SimpleType{
    public:
        ST_SortBy(){
            m_has_type = false

        }
        ST_SortBy(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_SortBy::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_SortBy& default_instance(){

    if (!ST_SortBy::default_instance_)
    {
        ST_SortBy::default_instance_ = new ST_SortBy();
    }
    return *ST_SortBy::default_instance_;

        }
        enum Type{
            _value_ = 1,
            _cellColor_,
            _fontColor_,
            _icon_
        }

    private:
        static const string TypeStrList [];
        static ST_SortBy* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_SortMethod : public XSD::SimpleType{
    public:
        ST_SortMethod(){
            m_has_type = false

        }
        ST_SortMethod(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_SortMethod::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_SortMethod& default_instance(){

    if (!ST_SortMethod::default_instance_)
    {
        ST_SortMethod::default_instance_ = new ST_SortMethod();
    }
    return *ST_SortMethod::default_instance_;

        }
        enum Type{
            _stroke_ = 1,
            _pinYin_,
            _none_
        }

    private:
        static const string TypeStrList [];
        static ST_SortMethod* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_DateTimeGrouping : public XSD::SimpleType{
    public:
        ST_DateTimeGrouping(){
            m_has_type = false

        }
        ST_DateTimeGrouping(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_DateTimeGrouping::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_DateTimeGrouping& default_instance(){

    if (!ST_DateTimeGrouping::default_instance_)
    {
        ST_DateTimeGrouping::default_instance_ = new ST_DateTimeGrouping();
    }
    return *ST_DateTimeGrouping::default_instance_;

        }
        enum Type{
            _year_ = 1,
            _month_,
            _day_,
            _hour_,
            _minute_,
            _second_
        }

    private:
        static const string TypeStrList [];
        static ST_DateTimeGrouping* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_CellRef : public XSD::SimpleType{
    public:
        ST_CellRef(){
            m_has_string = false
            m_string = 

        }
        ST_CellRef(const XSD::string& _string ){
            m_has_string = true
            m_string = _string

        }
        bool has_string(){

    return m_has_string;

        }
        void set_string(const string& _string ){

    m_has_string = true;
    m_string = _string;

        }
        const string& string(){

    return m_string;

        }
        void clear(){

    m_has_string = false;
    m_string.clear();;

        }
        void toXml(const string _attrName , ostream _outStream ){

    if (m_has_string)
    {
        _outStream << _attrName << \=\\ << m_string << \\\;;
    }

        }
        const ST_CellRef& default_instance(){

    if (!ST_CellRef::default_instance_)
    {
        ST_CellRef::default_instance_ = new ST_CellRef();
    }
    return *ST_CellRef::default_instance_;

        }

    private:
        static ST_CellRef* default_instance_ ;
        bool m_has_string ;
        string m_string ;

    }

    class ST_Ref : public XSD::SimpleType{
    public:
        ST_Ref(){
            m_has_string = false
            m_string = 

        }
        ST_Ref(const XSD::string& _string ){
            m_has_string = true
            m_string = _string

        }
        bool has_string(){

    return m_has_string;

        }
        void set_string(const string& _string ){

    m_has_string = true;
    m_string = _string;

        }
        const string& string(){

    return m_string;

        }
        void clear(){

    m_has_string = false;
    m_string.clear();;

        }
        void toXml(const string _attrName , ostream _outStream ){

    if (m_has_string)
    {
        _outStream << _attrName << \=\\ << m_string << \\\;;
    }

        }
        const ST_Ref& default_instance(){

    if (!ST_Ref::default_instance_)
    {
        ST_Ref::default_instance_ = new ST_Ref();
    }
    return *ST_Ref::default_instance_;

        }

    private:
        static ST_Ref* default_instance_ ;
        bool m_has_string ;
        string m_string ;

    }

    class ST_RefA : public XSD::SimpleType{
    public:
        ST_RefA(){
            m_has_string = false
            m_string = 

        }
        ST_RefA(const XSD::string& _string ){
            m_has_string = true
            m_string = _string

        }
        bool has_string(){

    return m_has_string;

        }
        void set_string(const string& _string ){

    m_has_string = true;
    m_string = _string;

        }
        const string& string(){

    return m_string;

        }
        void clear(){

    m_has_string = false;
    m_string.clear();;

        }
        void toXml(const string _attrName , ostream _outStream ){

    if (m_has_string)
    {
        _outStream << _attrName << \=\\ << m_string << \\\;;
    }

        }
        const ST_RefA& default_instance(){

    if (!ST_RefA::default_instance_)
    {
        ST_RefA::default_instance_ = new ST_RefA();
    }
    return *ST_RefA::default_instance_;

        }

    private:
        static ST_RefA* default_instance_ ;
        bool m_has_string ;
        string m_string ;

    }

    class ST_Sqref : public XSD::SimpleType{
    public:
        ST_Sqref(){
            m_has_ENTITIES = false
            m_ENTITIES = 

        }
        ST_Sqref(const XSD::ENTITIES& _ENTITIES ){
            m_has_ENTITIES = true
            m_ENTITIES = _ENTITIES

        }
        bool has_ENTITIES(){

    return m_has_ENTITIES;

        }
        void set_ENTITIES(const ENTITIES& _ENTITIES ){

    m_has_ENTITIES = true;
    m_ENTITIES = _ENTITIES;

        }
        const ENTITIES& ENTITIES(){

    return m_ENTITIES;

        }
        void clear(){

    m_has_ENTITIES = false;
    m_ENTITIES.clear();;

        }
        void toXml(const string _attrName , ostream _outStream ){

    if (m_has_ENTITIES)
    {
        _outStream << _attrName << \=\\ << m_ENTITIES << \\\;;
    }

        }
        const ST_Sqref& default_instance(){

    if (!ST_Sqref::default_instance_)
    {
        ST_Sqref::default_instance_ = new ST_Sqref();
    }
    return *ST_Sqref::default_instance_;

        }

    private:
        static ST_Sqref* default_instance_ ;
        bool m_has_ENTITIES ;
        ENTITIES m_ENTITIES ;

    }

    class ST_Formula : public ST_Xstring{
    public:
        ST_Formula(const ns_s::ST_Xstring& _ST_Xstring ){

        }

    private:

    }

    class ST_UnsignedIntHex : public XSD::SimpleType{
    public:
        ST_UnsignedIntHex(){
            m_has_hexBinary = false
            m_hexBinary = 0

        }
        ST_UnsignedIntHex(const XSD::hexBinary& _hexBinary ){
            m_has_hexBinary = true
            m_hexBinary = _hexBinary

        }
        bool has_hexBinary(){

    return m_has_hexBinary;

        }
        void set_hexBinary(const hexBinary& _hexBinary ){

    m_has_hexBinary = true;
    m_hexBinary = _hexBinary;

        }
        const hexBinary& hexBinary(){

    return m_hexBinary;

        }
        void clear(){

    m_has_hexBinary = false;
    m_hexBinary = 0;;

        }
        void toXml(const string _attrName , ostream _outStream ){

    if (m_has_hexBinary)
    {
        _outStream << _attrName << \=\\ << m_hexBinary << \\\;;
    }

        }
        const ST_UnsignedIntHex& default_instance(){

    if (!ST_UnsignedIntHex::default_instance_)
    {
        ST_UnsignedIntHex::default_instance_ = new ST_UnsignedIntHex();
    }
    return *ST_UnsignedIntHex::default_instance_;

        }

    private:
        static ST_UnsignedIntHex* default_instance_ ;
        bool m_has_hexBinary ;
        hexBinary m_hexBinary ;

    }

    class ST_UnsignedShortHex : public XSD::SimpleType{
    public:
        ST_UnsignedShortHex(){
            m_has_hexBinary = false
            m_hexBinary = 0

        }
        ST_UnsignedShortHex(const XSD::hexBinary& _hexBinary ){
            m_has_hexBinary = true
            m_hexBinary = _hexBinary

        }
        bool has_hexBinary(){

    return m_has_hexBinary;

        }
        void set_hexBinary(const hexBinary& _hexBinary ){

    m_has_hexBinary = true;
    m_hexBinary = _hexBinary;

        }
        const hexBinary& hexBinary(){

    return m_hexBinary;

        }
        void clear(){

    m_has_hexBinary = false;
    m_hexBinary = 0;;

        }
        void toXml(const string _attrName , ostream _outStream ){

    if (m_has_hexBinary)
    {
        _outStream << _attrName << \=\\ << m_hexBinary << \\\;;
    }

        }
        const ST_UnsignedShortHex& default_instance(){

    if (!ST_UnsignedShortHex::default_instance_)
    {
        ST_UnsignedShortHex::default_instance_ = new ST_UnsignedShortHex();
    }
    return *ST_UnsignedShortHex::default_instance_;

        }

    private:
        static ST_UnsignedShortHex* default_instance_ ;
        bool m_has_hexBinary ;
        hexBinary m_hexBinary ;

    }

    class ST_TextHAlign : public XSD::SimpleType{
    public:
        ST_TextHAlign(){
            m_has_type = false

        }
        ST_TextHAlign(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_TextHAlign::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_TextHAlign& default_instance(){

    if (!ST_TextHAlign::default_instance_)
    {
        ST_TextHAlign::default_instance_ = new ST_TextHAlign();
    }
    return *ST_TextHAlign::default_instance_;

        }
        enum Type{
            _left_ = 1,
            _center_,
            _right_,
            _justify_,
            _distributed_
        }

    private:
        static const string TypeStrList [];
        static ST_TextHAlign* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_TextVAlign : public XSD::SimpleType{
    public:
        ST_TextVAlign(){
            m_has_type = false

        }
        ST_TextVAlign(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_TextVAlign::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_TextVAlign& default_instance(){

    if (!ST_TextVAlign::default_instance_)
    {
        ST_TextVAlign::default_instance_ = new ST_TextVAlign();
    }
    return *ST_TextVAlign::default_instance_;

        }
        enum Type{
            _top_ = 1,
            _center_,
            _bottom_,
            _justify_,
            _distributed_
        }

    private:
        static const string TypeStrList [];
        static ST_TextVAlign* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_CredMethod : public XSD::SimpleType{
    public:
        ST_CredMethod(){
            m_has_type = false

        }
        ST_CredMethod(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_CredMethod::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_CredMethod& default_instance(){

    if (!ST_CredMethod::default_instance_)
    {
        ST_CredMethod::default_instance_ = new ST_CredMethod();
    }
    return *ST_CredMethod::default_instance_;

        }
        enum Type{
            _integrated_ = 1,
            _none_,
            _stored_,
            _prompt_
        }

    private:
        static const string TypeStrList [];
        static ST_CredMethod* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_HtmlFmt : public XSD::SimpleType{
    public:
        ST_HtmlFmt(){
            m_has_type = false

        }
        ST_HtmlFmt(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_HtmlFmt::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_HtmlFmt& default_instance(){

    if (!ST_HtmlFmt::default_instance_)
    {
        ST_HtmlFmt::default_instance_ = new ST_HtmlFmt();
    }
    return *ST_HtmlFmt::default_instance_;

        }
        enum Type{
            _none_ = 1,
            _rtf_,
            _all_
        }

    private:
        static const string TypeStrList [];
        static ST_HtmlFmt* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_ParameterType : public XSD::SimpleType{
    public:
        ST_ParameterType(){
            m_has_type = false

        }
        ST_ParameterType(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_ParameterType::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_ParameterType& default_instance(){

    if (!ST_ParameterType::default_instance_)
    {
        ST_ParameterType::default_instance_ = new ST_ParameterType();
    }
    return *ST_ParameterType::default_instance_;

        }
        enum Type{
            _prompt_ = 1,
            _value_,
            _cell_
        }

    private:
        static const string TypeStrList [];
        static ST_ParameterType* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_FileType : public XSD::SimpleType{
    public:
        ST_FileType(){
            m_has_type = false

        }
        ST_FileType(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_FileType::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_FileType& default_instance(){

    if (!ST_FileType::default_instance_)
    {
        ST_FileType::default_instance_ = new ST_FileType();
    }
    return *ST_FileType::default_instance_;

        }
        enum Type{
            _mac_ = 1,
            _win_,
            _dos_,
            _lin_,
            _other_
        }

    private:
        static const string TypeStrList [];
        static ST_FileType* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_Qualifier : public XSD::SimpleType{
    public:
        ST_Qualifier(){
            m_has_type = false

        }
        ST_Qualifier(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_Qualifier::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_Qualifier& default_instance(){

    if (!ST_Qualifier::default_instance_)
    {
        ST_Qualifier::default_instance_ = new ST_Qualifier();
    }
    return *ST_Qualifier::default_instance_;

        }
        enum Type{
            _doubleQuote_ = 1,
            _singleQuote_,
            _none_
        }

    private:
        static const string TypeStrList [];
        static ST_Qualifier* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_ExternalConnectionType : public XSD::SimpleType{
    public:
        ST_ExternalConnectionType(){
            m_has_type = false

        }
        ST_ExternalConnectionType(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_ExternalConnectionType::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_ExternalConnectionType& default_instance(){

    if (!ST_ExternalConnectionType::default_instance_)
    {
        ST_ExternalConnectionType::default_instance_ = new ST_ExternalConnectionType();
    }
    return *ST_ExternalConnectionType::default_instance_;

        }
        enum Type{
            _general_ = 1,
            _text_,
            _MDY_,
            _DMY_,
            _YMD_,
            _MYD_,
            _DYM_,
            _YDM_,
            _skip_,
            _EMD_
        }

    private:
        static const string TypeStrList [];
        static ST_ExternalConnectionType* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_SourceType : public XSD::SimpleType{
    public:
        ST_SourceType(){
            m_has_type = false

        }
        ST_SourceType(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_SourceType::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_SourceType& default_instance(){

    if (!ST_SourceType::default_instance_)
    {
        ST_SourceType::default_instance_ = new ST_SourceType();
    }
    return *ST_SourceType::default_instance_;

        }
        enum Type{
            _worksheet_ = 1,
            _external_,
            _consolidation_,
            _scenario_
        }

    private:
        static const string TypeStrList [];
        static ST_SourceType* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_GroupBy : public XSD::SimpleType{
    public:
        ST_GroupBy(){
            m_has_type = false

        }
        ST_GroupBy(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_GroupBy::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_GroupBy& default_instance(){

    if (!ST_GroupBy::default_instance_)
    {
        ST_GroupBy::default_instance_ = new ST_GroupBy();
    }
    return *ST_GroupBy::default_instance_;

        }
        enum Type{
            _range_ = 1,
            _seconds_,
            _minutes_,
            _hours_,
            _days_,
            _months_,
            _quarters_,
            _years_
        }

    private:
        static const string TypeStrList [];
        static ST_GroupBy* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_SortType : public XSD::SimpleType{
    public:
        ST_SortType(){
            m_has_type = false

        }
        ST_SortType(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_SortType::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_SortType& default_instance(){

    if (!ST_SortType::default_instance_)
    {
        ST_SortType::default_instance_ = new ST_SortType();
    }
    return *ST_SortType::default_instance_;

        }
        enum Type{
            _none_ = 1,
            _ascending_,
            _descending_,
            _ascendingAlpha_,
            _descendingAlpha_,
            _ascendingNatural_,
            _descendingNatural_
        }

    private:
        static const string TypeStrList [];
        static ST_SortType* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_Scope : public XSD::SimpleType{
    public:
        ST_Scope(){
            m_has_type = false

        }
        ST_Scope(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_Scope::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_Scope& default_instance(){

    if (!ST_Scope::default_instance_)
    {
        ST_Scope::default_instance_ = new ST_Scope();
    }
    return *ST_Scope::default_instance_;

        }
        enum Type{
            _selection_ = 1,
            _data_,
            _field_
        }

    private:
        static const string TypeStrList [];
        static ST_Scope* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_Type : public XSD::SimpleType{
    public:
        ST_Type(){
            m_has_type = false

        }
        ST_Type(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_Type::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_Type& default_instance(){

    if (!ST_Type::default_instance_)
    {
        ST_Type::default_instance_ = new ST_Type();
    }
    return *ST_Type::default_instance_;

        }
        enum Type{
            _none_ = 1,
            _all_,
            _row_,
            _column_
        }

    private:
        static const string TypeStrList [];
        static ST_Type* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_ShowDataAs : public XSD::SimpleType{
    public:
        ST_ShowDataAs(){
            m_has_type = false

        }
        ST_ShowDataAs(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_ShowDataAs::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_ShowDataAs& default_instance(){

    if (!ST_ShowDataAs::default_instance_)
    {
        ST_ShowDataAs::default_instance_ = new ST_ShowDataAs();
    }
    return *ST_ShowDataAs::default_instance_;

        }
        enum Type{
            _normal_ = 1,
            _difference_,
            _percent_,
            _percentDiff_,
            _runTotal_,
            _percentOfRow_,
            _percentOfCol_,
            _percentOfTotal_,
            _index_
        }

    private:
        static const string TypeStrList [];
        static ST_ShowDataAs* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_ItemType : public XSD::SimpleType{
    public:
        ST_ItemType(){
            m_has_type = false

        }
        ST_ItemType(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_ItemType::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_ItemType& default_instance(){

    if (!ST_ItemType::default_instance_)
    {
        ST_ItemType::default_instance_ = new ST_ItemType();
    }
    return *ST_ItemType::default_instance_;

        }
        enum Type{
            _data_ = 1,
            _default_,
            _sum_,
            _countA_,
            _avg_,
            _max_,
            _min_,
            _product_,
            _count_,
            _stdDev_,
            _stdDevP_,
            _var_,
            _varP_,
            _grand_,
            _blank_
        }

    private:
        static const string TypeStrList [];
        static ST_ItemType* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_FormatAction : public XSD::SimpleType{
    public:
        ST_FormatAction(){
            m_has_type = false

        }
        ST_FormatAction(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_FormatAction::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_FormatAction& default_instance(){

    if (!ST_FormatAction::default_instance_)
    {
        ST_FormatAction::default_instance_ = new ST_FormatAction();
    }
    return *ST_FormatAction::default_instance_;

        }
        enum Type{
            _blank_ = 1,
            _formatting_,
            _drill_,
            _formula_
        }

    private:
        static const string TypeStrList [];
        static ST_FormatAction* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_FieldSortType : public XSD::SimpleType{
    public:
        ST_FieldSortType(){
            m_has_type = false

        }
        ST_FieldSortType(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_FieldSortType::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_FieldSortType& default_instance(){

    if (!ST_FieldSortType::default_instance_)
    {
        ST_FieldSortType::default_instance_ = new ST_FieldSortType();
    }
    return *ST_FieldSortType::default_instance_;

        }
        enum Type{
            _manual_ = 1,
            _ascending_,
            _descending_
        }

    private:
        static const string TypeStrList [];
        static ST_FieldSortType* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_PivotFilterType : public XSD::SimpleType{
    public:
        ST_PivotFilterType(){
            m_has_type = false

        }
        ST_PivotFilterType(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_PivotFilterType::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_PivotFilterType& default_instance(){

    if (!ST_PivotFilterType::default_instance_)
    {
        ST_PivotFilterType::default_instance_ = new ST_PivotFilterType();
    }
    return *ST_PivotFilterType::default_instance_;

        }
        enum Type{
            _unknown_ = 1,
            _count_,
            _percent_,
            _sum_,
            _captionEqual_,
            _captionNotEqual_,
            _captionBeginsWith_,
            _captionNotBeginsWith_,
            _captionEndsWith_,
            _captionNotEndsWith_,
            _captionContains_,
            _captionNotContains_,
            _captionGreaterThan_,
            _captionGreaterThanOrEqual_,
            _captionLessThan_,
            _captionLessThanOrEqual_,
            _captionBetween_,
            _captionNotBetween_,
            _valueEqual_,
            _valueNotEqual_,
            _valueGreaterThan_,
            _valueGreaterThanOrEqual_,
            _valueLessThan_,
            _valueLessThanOrEqual_,
            _valueBetween_,
            _valueNotBetween_,
            _dateEqual_,
            _dateNotEqual_,
            _dateOlderThan_,
            _dateOlderThanOrEqual_,
            _dateNewerThan_,
            _dateNewerThanOrEqual_,
            _dateBetween_,
            _dateNotBetween_,
            _tomorrow_,
            _today_,
            _yesterday_,
            _nextWeek_,
            _thisWeek_,
            _lastWeek_,
            _nextMonth_,
            _thisMonth_,
            _lastMonth_,
            _nextQuarter_,
            _thisQuarter_,
            _lastQuarter_,
            _nextYear_,
            _thisYear_,
            _lastYear_,
            _yearToDate_,
            _Q1_,
            _Q2_,
            _Q3_,
            _Q4_,
            _M1_,
            _M2_,
            _M3_,
            _M4_,
            _M5_,
            _M6_,
            _M7_,
            _M8_,
            _M9_,
            _M10_,
            _M11_,
            _M12_
        }

    private:
        static const string TypeStrList [];
        static ST_PivotFilterType* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_PivotAreaType : public XSD::SimpleType{
    public:
        ST_PivotAreaType(){
            m_has_type = false

        }
        ST_PivotAreaType(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_PivotAreaType::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_PivotAreaType& default_instance(){

    if (!ST_PivotAreaType::default_instance_)
    {
        ST_PivotAreaType::default_instance_ = new ST_PivotAreaType();
    }
    return *ST_PivotAreaType::default_instance_;

        }
        enum Type{
            _none_ = 1,
            _normal_,
            _data_,
            _all_,
            _origin_,
            _button_,
            _topEnd_,
            _topRight_
        }

    private:
        static const string TypeStrList [];
        static ST_PivotAreaType* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_Axis : public XSD::SimpleType{
    public:
        ST_Axis(){
            m_has_type = false

        }
        ST_Axis(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_Axis::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_Axis& default_instance(){

    if (!ST_Axis::default_instance_)
    {
        ST_Axis::default_instance_ = new ST_Axis();
    }
    return *ST_Axis::default_instance_;

        }
        enum Type{
            _axisRow_ = 1,
            _axisCol_,
            _axisPage_,
            _axisValues_
        }

    private:
        static const string TypeStrList [];
        static ST_Axis* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_GrowShrinkType : public XSD::SimpleType{
    public:
        ST_GrowShrinkType(){
            m_has_type = false

        }
        ST_GrowShrinkType(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_GrowShrinkType::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_GrowShrinkType& default_instance(){

    if (!ST_GrowShrinkType::default_instance_)
    {
        ST_GrowShrinkType::default_instance_ = new ST_GrowShrinkType();
    }
    return *ST_GrowShrinkType::default_instance_;

        }
        enum Type{
            _insertDelete_ = 1,
            _insertClear_,
            _overwriteClear_
        }

    private:
        static const string TypeStrList [];
        static ST_GrowShrinkType* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_PhoneticType : public XSD::SimpleType{
    public:
        ST_PhoneticType(){
            m_has_type = false

        }
        ST_PhoneticType(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_PhoneticType::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_PhoneticType& default_instance(){

    if (!ST_PhoneticType::default_instance_)
    {
        ST_PhoneticType::default_instance_ = new ST_PhoneticType();
    }
    return *ST_PhoneticType::default_instance_;

        }
        enum Type{
            _halfwidthKatakana_ = 1,
            _fullwidthKatakana_,
            _Hiragana_,
            _noConversion_
        }

    private:
        static const string TypeStrList [];
        static ST_PhoneticType* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_PhoneticAlignment : public XSD::SimpleType{
    public:
        ST_PhoneticAlignment(){
            m_has_type = false

        }
        ST_PhoneticAlignment(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_PhoneticAlignment::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_PhoneticAlignment& default_instance(){

    if (!ST_PhoneticAlignment::default_instance_)
    {
        ST_PhoneticAlignment::default_instance_ = new ST_PhoneticAlignment();
    }
    return *ST_PhoneticAlignment::default_instance_;

        }
        enum Type{
            _noControl_ = 1,
            _left_,
            _center_,
            _distributed_
        }

    private:
        static const string TypeStrList [];
        static ST_PhoneticAlignment* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_rwColActionType : public XSD::SimpleType{
    public:
        ST_rwColActionType(){
            m_has_type = false

        }
        ST_rwColActionType(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_rwColActionType::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_rwColActionType& default_instance(){

    if (!ST_rwColActionType::default_instance_)
    {
        ST_rwColActionType::default_instance_ = new ST_rwColActionType();
    }
    return *ST_rwColActionType::default_instance_;

        }
        enum Type{
            _insertRow_ = 1,
            _deleteRow_,
            _insertCol_,
            _deleteCol_
        }

    private:
        static const string TypeStrList [];
        static ST_rwColActionType* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_RevisionAction : public XSD::SimpleType{
    public:
        ST_RevisionAction(){
            m_has_type = false

        }
        ST_RevisionAction(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_RevisionAction::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_RevisionAction& default_instance(){

    if (!ST_RevisionAction::default_instance_)
    {
        ST_RevisionAction::default_instance_ = new ST_RevisionAction();
    }
    return *ST_RevisionAction::default_instance_;

        }
        enum Type{
            _add_ = 1,
            _delete_
        }

    private:
        static const string TypeStrList [];
        static ST_RevisionAction* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_FormulaExpression : public XSD::SimpleType{
    public:
        ST_FormulaExpression(){
            m_has_type = false

        }
        ST_FormulaExpression(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_FormulaExpression::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_FormulaExpression& default_instance(){

    if (!ST_FormulaExpression::default_instance_)
    {
        ST_FormulaExpression::default_instance_ = new ST_FormulaExpression();
    }
    return *ST_FormulaExpression::default_instance_;

        }
        enum Type{
            _ref_ = 1,
            _refError_,
            _area_,
            _areaError_,
            _computedArea_
        }

    private:
        static const string TypeStrList [];
        static ST_FormulaExpression* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_CellSpan : public XSD::SimpleType{
    public:
        ST_CellSpan(){
            m_has_string = false
            m_string = 

        }
        ST_CellSpan(const XSD::string& _string ){
            m_has_string = true
            m_string = _string

        }
        bool has_string(){

    return m_has_string;

        }
        void set_string(const string& _string ){

    m_has_string = true;
    m_string = _string;

        }
        const string& string(){

    return m_string;

        }
        void clear(){

    m_has_string = false;
    m_string.clear();;

        }
        void toXml(const string _attrName , ostream _outStream ){

    if (m_has_string)
    {
        _outStream << _attrName << \=\\ << m_string << \\\;;
    }

        }
        const ST_CellSpan& default_instance(){

    if (!ST_CellSpan::default_instance_)
    {
        ST_CellSpan::default_instance_ = new ST_CellSpan();
    }
    return *ST_CellSpan::default_instance_;

        }

    private:
        static ST_CellSpan* default_instance_ ;
        bool m_has_string ;
        string m_string ;

    }

    class ST_CellSpans : public XSD::SimpleType{
    public:
        ST_CellSpans(){
            m_has_ENTITIES = false
            m_ENTITIES = 

        }
        ST_CellSpans(const XSD::ENTITIES& _ENTITIES ){
            m_has_ENTITIES = true
            m_ENTITIES = _ENTITIES

        }
        bool has_ENTITIES(){

    return m_has_ENTITIES;

        }
        void set_ENTITIES(const ENTITIES& _ENTITIES ){

    m_has_ENTITIES = true;
    m_ENTITIES = _ENTITIES;

        }
        const ENTITIES& ENTITIES(){

    return m_ENTITIES;

        }
        void clear(){

    m_has_ENTITIES = false;
    m_ENTITIES.clear();;

        }
        void toXml(const string _attrName , ostream _outStream ){

    if (m_has_ENTITIES)
    {
        _outStream << _attrName << \=\\ << m_ENTITIES << \\\;;
    }

        }
        const ST_CellSpans& default_instance(){

    if (!ST_CellSpans::default_instance_)
    {
        ST_CellSpans::default_instance_ = new ST_CellSpans();
    }
    return *ST_CellSpans::default_instance_;

        }

    private:
        static ST_CellSpans* default_instance_ ;
        bool m_has_ENTITIES ;
        ENTITIES m_ENTITIES ;

    }

    class ST_CellType : public XSD::SimpleType{
    public:
        ST_CellType(){
            m_has_type = false

        }
        ST_CellType(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_CellType::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_CellType& default_instance(){

    if (!ST_CellType::default_instance_)
    {
        ST_CellType::default_instance_ = new ST_CellType();
    }
    return *ST_CellType::default_instance_;

        }
        enum Type{
            _b_ = 1,
            _n_,
            _e_,
            _s_,
            _str_,
            _inlineStr_
        }

    private:
        static const string TypeStrList [];
        static ST_CellType* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_CellFormulaType : public XSD::SimpleType{
    public:
        ST_CellFormulaType(){
            m_has_type = false

        }
        ST_CellFormulaType(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_CellFormulaType::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_CellFormulaType& default_instance(){

    if (!ST_CellFormulaType::default_instance_)
    {
        ST_CellFormulaType::default_instance_ = new ST_CellFormulaType();
    }
    return *ST_CellFormulaType::default_instance_;

        }
        enum Type{
            _normal_ = 1,
            _array_,
            _dataTable_,
            _shared_
        }

    private:
        static const string TypeStrList [];
        static ST_CellFormulaType* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_Pane : public XSD::SimpleType{
    public:
        ST_Pane(){
            m_has_type = false

        }
        ST_Pane(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_Pane::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_Pane& default_instance(){

    if (!ST_Pane::default_instance_)
    {
        ST_Pane::default_instance_ = new ST_Pane();
    }
    return *ST_Pane::default_instance_;

        }
        enum Type{
            _bottomRight_ = 1,
            _topRight_,
            _bottomLeft_,
            _topLeft_
        }

    private:
        static const string TypeStrList [];
        static ST_Pane* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_SheetViewType : public XSD::SimpleType{
    public:
        ST_SheetViewType(){
            m_has_type = false

        }
        ST_SheetViewType(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_SheetViewType::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_SheetViewType& default_instance(){

    if (!ST_SheetViewType::default_instance_)
    {
        ST_SheetViewType::default_instance_ = new ST_SheetViewType();
    }
    return *ST_SheetViewType::default_instance_;

        }
        enum Type{
            _normal_ = 1,
            _pageBreakPreview_,
            _pageLayout_
        }

    private:
        static const string TypeStrList [];
        static ST_SheetViewType* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_DataConsolidateFunction : public XSD::SimpleType{
    public:
        ST_DataConsolidateFunction(){
            m_has_type = false

        }
        ST_DataConsolidateFunction(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_DataConsolidateFunction::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_DataConsolidateFunction& default_instance(){

    if (!ST_DataConsolidateFunction::default_instance_)
    {
        ST_DataConsolidateFunction::default_instance_ = new ST_DataConsolidateFunction();
    }
    return *ST_DataConsolidateFunction::default_instance_;

        }
        enum Type{
            _average_ = 1,
            _count_,
            _countNums_,
            _max_,
            _min_,
            _product_,
            _stdDev_,
            _stdDevp_,
            _sum_,
            _var_,
            _varp_
        }

    private:
        static const string TypeStrList [];
        static ST_DataConsolidateFunction* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_DataValidationType : public XSD::SimpleType{
    public:
        ST_DataValidationType(){
            m_has_type = false

        }
        ST_DataValidationType(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_DataValidationType::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_DataValidationType& default_instance(){

    if (!ST_DataValidationType::default_instance_)
    {
        ST_DataValidationType::default_instance_ = new ST_DataValidationType();
    }
    return *ST_DataValidationType::default_instance_;

        }
        enum Type{
            _none_ = 1,
            _whole_,
            _decimal_,
            _list_,
            _date_,
            _time_,
            _textLength_,
            _custom_
        }

    private:
        static const string TypeStrList [];
        static ST_DataValidationType* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_DataValidationOperator : public XSD::SimpleType{
    public:
        ST_DataValidationOperator(){
            m_has_type = false

        }
        ST_DataValidationOperator(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_DataValidationOperator::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_DataValidationOperator& default_instance(){

    if (!ST_DataValidationOperator::default_instance_)
    {
        ST_DataValidationOperator::default_instance_ = new ST_DataValidationOperator();
    }
    return *ST_DataValidationOperator::default_instance_;

        }
        enum Type{
            _between_ = 1,
            _notBetween_,
            _equal_,
            _notEqual_,
            _lessThan_,
            _lessThanOrEqual_,
            _greaterThan_,
            _greaterThanOrEqual_
        }

    private:
        static const string TypeStrList [];
        static ST_DataValidationOperator* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_DataValidationErrorStyle : public XSD::SimpleType{
    public:
        ST_DataValidationErrorStyle(){
            m_has_type = false

        }
        ST_DataValidationErrorStyle(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_DataValidationErrorStyle::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_DataValidationErrorStyle& default_instance(){

    if (!ST_DataValidationErrorStyle::default_instance_)
    {
        ST_DataValidationErrorStyle::default_instance_ = new ST_DataValidationErrorStyle();
    }
    return *ST_DataValidationErrorStyle::default_instance_;

        }
        enum Type{
            _stop_ = 1,
            _warning_,
            _information_
        }

    private:
        static const string TypeStrList [];
        static ST_DataValidationErrorStyle* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_DataValidationImeMode : public XSD::SimpleType{
    public:
        ST_DataValidationImeMode(){
            m_has_type = false

        }
        ST_DataValidationImeMode(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_DataValidationImeMode::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_DataValidationImeMode& default_instance(){

    if (!ST_DataValidationImeMode::default_instance_)
    {
        ST_DataValidationImeMode::default_instance_ = new ST_DataValidationImeMode();
    }
    return *ST_DataValidationImeMode::default_instance_;

        }
        enum Type{
            _noControl_ = 1,
            _off_,
            _on_,
            _disabled_,
            _hiragana_,
            _fullKatakana_,
            _halfKatakana_,
            _fullAlpha_,
            _halfAlpha_,
            _fullHangul_,
            _halfHangul_
        }

    private:
        static const string TypeStrList [];
        static ST_DataValidationImeMode* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_CfType : public XSD::SimpleType{
    public:
        ST_CfType(){
            m_has_type = false

        }
        ST_CfType(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_CfType::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_CfType& default_instance(){

    if (!ST_CfType::default_instance_)
    {
        ST_CfType::default_instance_ = new ST_CfType();
    }
    return *ST_CfType::default_instance_;

        }
        enum Type{
            _expression_ = 1,
            _cellIs_,
            _colorScale_,
            _dataBar_,
            _iconSet_,
            _top10_,
            _uniqueValues_,
            _duplicateValues_,
            _containsText_,
            _notContainsText_,
            _beginsWith_,
            _endsWith_,
            _containsBlanks_,
            _notContainsBlanks_,
            _containsErrors_,
            _notContainsErrors_,
            _timePeriod_,
            _aboveAverage_
        }

    private:
        static const string TypeStrList [];
        static ST_CfType* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_TimePeriod : public XSD::SimpleType{
    public:
        ST_TimePeriod(){
            m_has_type = false

        }
        ST_TimePeriod(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_TimePeriod::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_TimePeriod& default_instance(){

    if (!ST_TimePeriod::default_instance_)
    {
        ST_TimePeriod::default_instance_ = new ST_TimePeriod();
    }
    return *ST_TimePeriod::default_instance_;

        }
        enum Type{
            _today_ = 1,
            _yesterday_,
            _tomorrow_,
            _last7Days_,
            _thisMonth_,
            _lastMonth_,
            _nextMonth_,
            _thisWeek_,
            _lastWeek_,
            _nextWeek_
        }

    private:
        static const string TypeStrList [];
        static ST_TimePeriod* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_ConditionalFormattingOperator : public XSD::SimpleType{
    public:
        ST_ConditionalFormattingOperator(){
            m_has_type = false

        }
        ST_ConditionalFormattingOperator(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_ConditionalFormattingOperator::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_ConditionalFormattingOperator& default_instance(){

    if (!ST_ConditionalFormattingOperator::default_instance_)
    {
        ST_ConditionalFormattingOperator::default_instance_ = new ST_ConditionalFormattingOperator();
    }
    return *ST_ConditionalFormattingOperator::default_instance_;

        }
        enum Type{
            _lessThan_ = 1,
            _lessThanOrEqual_,
            _equal_,
            _notEqual_,
            _greaterThanOrEqual_,
            _greaterThan_,
            _between_,
            _notBetween_,
            _containsText_,
            _notContains_,
            _beginsWith_,
            _endsWith_
        }

    private:
        static const string TypeStrList [];
        static ST_ConditionalFormattingOperator* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_CfvoType : public XSD::SimpleType{
    public:
        ST_CfvoType(){
            m_has_type = false

        }
        ST_CfvoType(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_CfvoType::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_CfvoType& default_instance(){

    if (!ST_CfvoType::default_instance_)
    {
        ST_CfvoType::default_instance_ = new ST_CfvoType();
    }
    return *ST_CfvoType::default_instance_;

        }
        enum Type{
            _num_ = 1,
            _percent_,
            _max_,
            _min_,
            _formula_,
            _percentile_
        }

    private:
        static const string TypeStrList [];
        static ST_CfvoType* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_PageOrder : public XSD::SimpleType{
    public:
        ST_PageOrder(){
            m_has_type = false

        }
        ST_PageOrder(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_PageOrder::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_PageOrder& default_instance(){

    if (!ST_PageOrder::default_instance_)
    {
        ST_PageOrder::default_instance_ = new ST_PageOrder();
    }
    return *ST_PageOrder::default_instance_;

        }
        enum Type{
            _downThenOver_ = 1,
            _overThenDown_
        }

    private:
        static const string TypeStrList [];
        static ST_PageOrder* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_Orientation : public XSD::SimpleType{
    public:
        ST_Orientation(){
            m_has_type = false

        }
        ST_Orientation(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_Orientation::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_Orientation& default_instance(){

    if (!ST_Orientation::default_instance_)
    {
        ST_Orientation::default_instance_ = new ST_Orientation();
    }
    return *ST_Orientation::default_instance_;

        }
        enum Type{
            _default_ = 1,
            _portrait_,
            _landscape_
        }

    private:
        static const string TypeStrList [];
        static ST_Orientation* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_CellComments : public XSD::SimpleType{
    public:
        ST_CellComments(){
            m_has_type = false

        }
        ST_CellComments(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_CellComments::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_CellComments& default_instance(){

    if (!ST_CellComments::default_instance_)
    {
        ST_CellComments::default_instance_ = new ST_CellComments();
    }
    return *ST_CellComments::default_instance_;

        }
        enum Type{
            _none_ = 1,
            _asDisplayed_,
            _atEnd_
        }

    private:
        static const string TypeStrList [];
        static ST_CellComments* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_PrintError : public XSD::SimpleType{
    public:
        ST_PrintError(){
            m_has_type = false

        }
        ST_PrintError(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_PrintError::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_PrintError& default_instance(){

    if (!ST_PrintError::default_instance_)
    {
        ST_PrintError::default_instance_ = new ST_PrintError();
    }
    return *ST_PrintError::default_instance_;

        }
        enum Type{
            _displayed_ = 1,
            _blank_,
            _dash_,
            _NA_
        }

    private:
        static const string TypeStrList [];
        static ST_PrintError* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_DvAspect : public XSD::SimpleType{
    public:
        ST_DvAspect(){
            m_has_type = false

        }
        ST_DvAspect(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_DvAspect::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_DvAspect& default_instance(){

    if (!ST_DvAspect::default_instance_)
    {
        ST_DvAspect::default_instance_ = new ST_DvAspect();
    }
    return *ST_DvAspect::default_instance_;

        }
        enum Type{
            _DVASPECT_CONTENT_ = 1,
            _DVASPECT_ICON_
        }

    private:
        static const string TypeStrList [];
        static ST_DvAspect* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_OleUpdate : public XSD::SimpleType{
    public:
        ST_OleUpdate(){
            m_has_type = false

        }
        ST_OleUpdate(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_OleUpdate::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_OleUpdate& default_instance(){

    if (!ST_OleUpdate::default_instance_)
    {
        ST_OleUpdate::default_instance_ = new ST_OleUpdate();
    }
    return *ST_OleUpdate::default_instance_;

        }
        enum Type{
            _OLEUPDATE_ALWAYS_ = 1,
            _OLEUPDATE_ONCALL_
        }

    private:
        static const string TypeStrList [];
        static ST_OleUpdate* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_WebSourceType : public XSD::SimpleType{
    public:
        ST_WebSourceType(){
            m_has_type = false

        }
        ST_WebSourceType(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_WebSourceType::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_WebSourceType& default_instance(){

    if (!ST_WebSourceType::default_instance_)
    {
        ST_WebSourceType::default_instance_ = new ST_WebSourceType();
    }
    return *ST_WebSourceType::default_instance_;

        }
        enum Type{
            _sheet_ = 1,
            _printArea_,
            _autoFilter_,
            _range_,
            _chart_,
            _pivotTable_,
            _query_,
            _label_
        }

    private:
        static const string TypeStrList [];
        static ST_WebSourceType* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_PaneState : public XSD::SimpleType{
    public:
        ST_PaneState(){
            m_has_type = false

        }
        ST_PaneState(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_PaneState::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_PaneState& default_instance(){

    if (!ST_PaneState::default_instance_)
    {
        ST_PaneState::default_instance_ = new ST_PaneState();
    }
    return *ST_PaneState::default_instance_;

        }
        enum Type{
            _split_ = 1,
            _frozen_,
            _frozenSplit_
        }

    private:
        static const string TypeStrList [];
        static ST_PaneState* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_MdxFunctionType : public XSD::SimpleType{
    public:
        ST_MdxFunctionType(){
            m_has_type = false

        }
        ST_MdxFunctionType(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_MdxFunctionType::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_MdxFunctionType& default_instance(){

    if (!ST_MdxFunctionType::default_instance_)
    {
        ST_MdxFunctionType::default_instance_ = new ST_MdxFunctionType();
    }
    return *ST_MdxFunctionType::default_instance_;

        }
        enum Type{
            _m_ = 1,
            _v_,
            _s_,
            _c_,
            _r_,
            _p_,
            _k_
        }

    private:
        static const string TypeStrList [];
        static ST_MdxFunctionType* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_MdxSetOrder : public XSD::SimpleType{
    public:
        ST_MdxSetOrder(){
            m_has_type = false

        }
        ST_MdxSetOrder(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_MdxSetOrder::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_MdxSetOrder& default_instance(){

    if (!ST_MdxSetOrder::default_instance_)
    {
        ST_MdxSetOrder::default_instance_ = new ST_MdxSetOrder();
    }
    return *ST_MdxSetOrder::default_instance_;

        }
        enum Type{
            _u_ = 1,
            _a_,
            _d_,
            _aa_,
            _ad_,
            _na_,
            _nd_
        }

    private:
        static const string TypeStrList [];
        static ST_MdxSetOrder* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_MdxKPIProperty : public XSD::SimpleType{
    public:
        ST_MdxKPIProperty(){
            m_has_type = false

        }
        ST_MdxKPIProperty(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_MdxKPIProperty::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_MdxKPIProperty& default_instance(){

    if (!ST_MdxKPIProperty::default_instance_)
    {
        ST_MdxKPIProperty::default_instance_ = new ST_MdxKPIProperty();
    }
    return *ST_MdxKPIProperty::default_instance_;

        }
        enum Type{
            _v_ = 1,
            _g_,
            _s_,
            _t_,
            _w_,
            _m_
        }

    private:
        static const string TypeStrList [];
        static ST_MdxKPIProperty* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_BorderStyle : public XSD::SimpleType{
    public:
        ST_BorderStyle(){
            m_has_type = false

        }
        ST_BorderStyle(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_BorderStyle::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_BorderStyle& default_instance(){

    if (!ST_BorderStyle::default_instance_)
    {
        ST_BorderStyle::default_instance_ = new ST_BorderStyle();
    }
    return *ST_BorderStyle::default_instance_;

        }
        enum Type{
            _none_ = 1,
            _thin_,
            _medium_,
            _dashed_,
            _dotted_,
            _thick_,
            _double_,
            _hair_,
            _mediumDashed_,
            _dashDot_,
            _mediumDashDot_,
            _dashDotDot_,
            _mediumDashDotDot_,
            _slantDashDot_
        }

    private:
        static const string TypeStrList [];
        static ST_BorderStyle* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_PatternType : public XSD::SimpleType{
    public:
        ST_PatternType(){
            m_has_type = false

        }
        ST_PatternType(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_PatternType::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_PatternType& default_instance(){

    if (!ST_PatternType::default_instance_)
    {
        ST_PatternType::default_instance_ = new ST_PatternType();
    }
    return *ST_PatternType::default_instance_;

        }
        enum Type{
            _none_ = 1,
            _solid_,
            _mediumGray_,
            _darkGray_,
            _lightGray_,
            _darkHorizontal_,
            _darkVertical_,
            _darkDown_,
            _darkUp_,
            _darkGrid_,
            _darkTrellis_,
            _lightHorizontal_,
            _lightVertical_,
            _lightDown_,
            _lightUp_,
            _lightGrid_,
            _lightTrellis_,
            _gray125_,
            _gray0625_
        }

    private:
        static const string TypeStrList [];
        static ST_PatternType* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_GradientType : public XSD::SimpleType{
    public:
        ST_GradientType(){
            m_has_type = false

        }
        ST_GradientType(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_GradientType::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_GradientType& default_instance(){

    if (!ST_GradientType::default_instance_)
    {
        ST_GradientType::default_instance_ = new ST_GradientType();
    }
    return *ST_GradientType::default_instance_;

        }
        enum Type{
            _linear_ = 1,
            _path_
        }

    private:
        static const string TypeStrList [];
        static ST_GradientType* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_HorizontalAlignment : public XSD::SimpleType{
    public:
        ST_HorizontalAlignment(){
            m_has_type = false

        }
        ST_HorizontalAlignment(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_HorizontalAlignment::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_HorizontalAlignment& default_instance(){

    if (!ST_HorizontalAlignment::default_instance_)
    {
        ST_HorizontalAlignment::default_instance_ = new ST_HorizontalAlignment();
    }
    return *ST_HorizontalAlignment::default_instance_;

        }
        enum Type{
            _general_ = 1,
            _left_,
            _center_,
            _right_,
            _fill_,
            _justify_,
            _centerContinuous_,
            _distributed_
        }

    private:
        static const string TypeStrList [];
        static ST_HorizontalAlignment* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_VerticalAlignment : public XSD::SimpleType{
    public:
        ST_VerticalAlignment(){
            m_has_type = false

        }
        ST_VerticalAlignment(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_VerticalAlignment::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_VerticalAlignment& default_instance(){

    if (!ST_VerticalAlignment::default_instance_)
    {
        ST_VerticalAlignment::default_instance_ = new ST_VerticalAlignment();
    }
    return *ST_VerticalAlignment::default_instance_;

        }
        enum Type{
            _top_ = 1,
            _center_,
            _bottom_,
            _justify_,
            _distributed_
        }

    private:
        static const string TypeStrList [];
        static ST_VerticalAlignment* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_NumFmtId : public XSD::SimpleType{
    public:
        ST_NumFmtId(){
            m_has_unsignedInt = false
            m_unsignedInt = 0

        }
        ST_NumFmtId(const XSD::unsignedInt& _unsignedInt ){
            m_has_unsignedInt = true
            m_unsignedInt = _unsignedInt

        }
        bool has_unsignedInt(){

    return m_has_unsignedInt;

        }
        void set_unsignedInt(const unsignedInt& _unsignedInt ){

    m_has_unsignedInt = true;
    m_unsignedInt = _unsignedInt;

        }
        const unsignedInt& unsignedInt(){

    return m_unsignedInt;

        }
        void clear(){

    m_has_unsignedInt = false;
    m_unsignedInt = 0;;

        }
        void toXml(const string _attrName , ostream _outStream ){

    if (m_has_unsignedInt)
    {
        _outStream << _attrName << \=\\ << m_unsignedInt << \\\;;
    }

        }
        const ST_NumFmtId& default_instance(){

    if (!ST_NumFmtId::default_instance_)
    {
        ST_NumFmtId::default_instance_ = new ST_NumFmtId();
    }
    return *ST_NumFmtId::default_instance_;

        }

    private:
        static ST_NumFmtId* default_instance_ ;
        bool m_has_unsignedInt ;
        unsignedInt m_unsignedInt ;

    }

    class ST_FontId : public XSD::SimpleType{
    public:
        ST_FontId(){
            m_has_unsignedInt = false
            m_unsignedInt = 0

        }
        ST_FontId(const XSD::unsignedInt& _unsignedInt ){
            m_has_unsignedInt = true
            m_unsignedInt = _unsignedInt

        }
        bool has_unsignedInt(){

    return m_has_unsignedInt;

        }
        void set_unsignedInt(const unsignedInt& _unsignedInt ){

    m_has_unsignedInt = true;
    m_unsignedInt = _unsignedInt;

        }
        const unsignedInt& unsignedInt(){

    return m_unsignedInt;

        }
        void clear(){

    m_has_unsignedInt = false;
    m_unsignedInt = 0;;

        }
        void toXml(const string _attrName , ostream _outStream ){

    if (m_has_unsignedInt)
    {
        _outStream << _attrName << \=\\ << m_unsignedInt << \\\;;
    }

        }
        const ST_FontId& default_instance(){

    if (!ST_FontId::default_instance_)
    {
        ST_FontId::default_instance_ = new ST_FontId();
    }
    return *ST_FontId::default_instance_;

        }

    private:
        static ST_FontId* default_instance_ ;
        bool m_has_unsignedInt ;
        unsignedInt m_unsignedInt ;

    }

    class ST_FillId : public XSD::SimpleType{
    public:
        ST_FillId(){
            m_has_unsignedInt = false
            m_unsignedInt = 0

        }
        ST_FillId(const XSD::unsignedInt& _unsignedInt ){
            m_has_unsignedInt = true
            m_unsignedInt = _unsignedInt

        }
        bool has_unsignedInt(){

    return m_has_unsignedInt;

        }
        void set_unsignedInt(const unsignedInt& _unsignedInt ){

    m_has_unsignedInt = true;
    m_unsignedInt = _unsignedInt;

        }
        const unsignedInt& unsignedInt(){

    return m_unsignedInt;

        }
        void clear(){

    m_has_unsignedInt = false;
    m_unsignedInt = 0;;

        }
        void toXml(const string _attrName , ostream _outStream ){

    if (m_has_unsignedInt)
    {
        _outStream << _attrName << \=\\ << m_unsignedInt << \\\;;
    }

        }
        const ST_FillId& default_instance(){

    if (!ST_FillId::default_instance_)
    {
        ST_FillId::default_instance_ = new ST_FillId();
    }
    return *ST_FillId::default_instance_;

        }

    private:
        static ST_FillId* default_instance_ ;
        bool m_has_unsignedInt ;
        unsignedInt m_unsignedInt ;

    }

    class ST_BorderId : public XSD::SimpleType{
    public:
        ST_BorderId(){
            m_has_unsignedInt = false
            m_unsignedInt = 0

        }
        ST_BorderId(const XSD::unsignedInt& _unsignedInt ){
            m_has_unsignedInt = true
            m_unsignedInt = _unsignedInt

        }
        bool has_unsignedInt(){

    return m_has_unsignedInt;

        }
        void set_unsignedInt(const unsignedInt& _unsignedInt ){

    m_has_unsignedInt = true;
    m_unsignedInt = _unsignedInt;

        }
        const unsignedInt& unsignedInt(){

    return m_unsignedInt;

        }
        void clear(){

    m_has_unsignedInt = false;
    m_unsignedInt = 0;;

        }
        void toXml(const string _attrName , ostream _outStream ){

    if (m_has_unsignedInt)
    {
        _outStream << _attrName << \=\\ << m_unsignedInt << \\\;;
    }

        }
        const ST_BorderId& default_instance(){

    if (!ST_BorderId::default_instance_)
    {
        ST_BorderId::default_instance_ = new ST_BorderId();
    }
    return *ST_BorderId::default_instance_;

        }

    private:
        static ST_BorderId* default_instance_ ;
        bool m_has_unsignedInt ;
        unsignedInt m_unsignedInt ;

    }

    class ST_CellStyleXfId : public XSD::SimpleType{
    public:
        ST_CellStyleXfId(){
            m_has_unsignedInt = false
            m_unsignedInt = 0

        }
        ST_CellStyleXfId(const XSD::unsignedInt& _unsignedInt ){
            m_has_unsignedInt = true
            m_unsignedInt = _unsignedInt

        }
        bool has_unsignedInt(){

    return m_has_unsignedInt;

        }
        void set_unsignedInt(const unsignedInt& _unsignedInt ){

    m_has_unsignedInt = true;
    m_unsignedInt = _unsignedInt;

        }
        const unsignedInt& unsignedInt(){

    return m_unsignedInt;

        }
        void clear(){

    m_has_unsignedInt = false;
    m_unsignedInt = 0;;

        }
        void toXml(const string _attrName , ostream _outStream ){

    if (m_has_unsignedInt)
    {
        _outStream << _attrName << \=\\ << m_unsignedInt << \\\;;
    }

        }
        const ST_CellStyleXfId& default_instance(){

    if (!ST_CellStyleXfId::default_instance_)
    {
        ST_CellStyleXfId::default_instance_ = new ST_CellStyleXfId();
    }
    return *ST_CellStyleXfId::default_instance_;

        }

    private:
        static ST_CellStyleXfId* default_instance_ ;
        bool m_has_unsignedInt ;
        unsignedInt m_unsignedInt ;

    }

    class ST_DxfId : public XSD::SimpleType{
    public:
        ST_DxfId(){
            m_has_unsignedInt = false
            m_unsignedInt = 0

        }
        ST_DxfId(const XSD::unsignedInt& _unsignedInt ){
            m_has_unsignedInt = true
            m_unsignedInt = _unsignedInt

        }
        bool has_unsignedInt(){

    return m_has_unsignedInt;

        }
        void set_unsignedInt(const unsignedInt& _unsignedInt ){

    m_has_unsignedInt = true;
    m_unsignedInt = _unsignedInt;

        }
        const unsignedInt& unsignedInt(){

    return m_unsignedInt;

        }
        void clear(){

    m_has_unsignedInt = false;
    m_unsignedInt = 0;;

        }
        void toXml(const string _attrName , ostream _outStream ){

    if (m_has_unsignedInt)
    {
        _outStream << _attrName << \=\\ << m_unsignedInt << \\\;;
    }

        }
        const ST_DxfId& default_instance(){

    if (!ST_DxfId::default_instance_)
    {
        ST_DxfId::default_instance_ = new ST_DxfId();
    }
    return *ST_DxfId::default_instance_;

        }

    private:
        static ST_DxfId* default_instance_ ;
        bool m_has_unsignedInt ;
        unsignedInt m_unsignedInt ;

    }

    class ST_TableStyleType : public XSD::SimpleType{
    public:
        ST_TableStyleType(){
            m_has_type = false

        }
        ST_TableStyleType(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_TableStyleType::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_TableStyleType& default_instance(){

    if (!ST_TableStyleType::default_instance_)
    {
        ST_TableStyleType::default_instance_ = new ST_TableStyleType();
    }
    return *ST_TableStyleType::default_instance_;

        }
        enum Type{
            _wholeTable_ = 1,
            _headerRow_,
            _totalRow_,
            _firstColumn_,
            _lastColumn_,
            _firstRowStripe_,
            _secondRowStripe_,
            _firstColumnStripe_,
            _secondColumnStripe_,
            _firstHeaderCell_,
            _lastHeaderCell_,
            _firstTotalCell_,
            _lastTotalCell_,
            _firstSubtotalColumn_,
            _secondSubtotalColumn_,
            _thirdSubtotalColumn_,
            _firstSubtotalRow_,
            _secondSubtotalRow_,
            _thirdSubtotalRow_,
            _blankRow_,
            _firstColumnSubheading_,
            _secondColumnSubheading_,
            _thirdColumnSubheading_,
            _firstRowSubheading_,
            _secondRowSubheading_,
            _thirdRowSubheading_,
            _pageFieldLabels_,
            _pageFieldValues_
        }

    private:
        static const string TypeStrList [];
        static ST_TableStyleType* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_FontScheme : public XSD::SimpleType{
    public:
        ST_FontScheme(){
            m_has_type = false

        }
        ST_FontScheme(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_FontScheme::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_FontScheme& default_instance(){

    if (!ST_FontScheme::default_instance_)
    {
        ST_FontScheme::default_instance_ = new ST_FontScheme();
    }
    return *ST_FontScheme::default_instance_;

        }
        enum Type{
            _none_ = 1,
            _major_,
            _minor_
        }

    private:
        static const string TypeStrList [];
        static ST_FontScheme* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_UnderlineValues : public XSD::SimpleType{
    public:
        ST_UnderlineValues(){
            m_has_type = false

        }
        ST_UnderlineValues(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_UnderlineValues::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_UnderlineValues& default_instance(){

    if (!ST_UnderlineValues::default_instance_)
    {
        ST_UnderlineValues::default_instance_ = new ST_UnderlineValues();
    }
    return *ST_UnderlineValues::default_instance_;

        }
        enum Type{
            _single_ = 1,
            _double_,
            _singleAccounting_,
            _doubleAccounting_,
            _none_
        }

    private:
        static const string TypeStrList [];
        static ST_UnderlineValues* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_FontFamily : public XSD::SimpleType{
    public:
        ST_FontFamily(){
            m_has_integer = false
            m_integer = 0

        }
        ST_FontFamily(const XSD::integer& _integer ){
            m_has_integer = true
            m_integer = _integer

        }
        bool has_integer(){

    return m_has_integer;

        }
        void set_integer(const integer& _integer ){

    m_has_integer = true;
    m_integer = _integer;

        }
        const integer& integer(){

    return m_integer;

        }
        void clear(){

    m_has_integer = false;
    m_integer = 0;;

        }
        void toXml(const string _attrName , ostream _outStream ){

    if (m_has_integer)
    {
        _outStream << _attrName << \=\\ << m_integer << \\\;;
    }

        }
        const ST_FontFamily& default_instance(){

    if (!ST_FontFamily::default_instance_)
    {
        ST_FontFamily::default_instance_ = new ST_FontFamily();
    }
    return *ST_FontFamily::default_instance_;

        }

    private:
        static ST_FontFamily* default_instance_ ;
        bool m_has_integer ;
        integer m_integer ;

    }

    class ST_DdeValueType : public XSD::SimpleType{
    public:
        ST_DdeValueType(){
            m_has_type = false

        }
        ST_DdeValueType(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_DdeValueType::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_DdeValueType& default_instance(){

    if (!ST_DdeValueType::default_instance_)
    {
        ST_DdeValueType::default_instance_ = new ST_DdeValueType();
    }
    return *ST_DdeValueType::default_instance_;

        }
        enum Type{
            _nil_ = 1,
            _b_,
            _n_,
            _e_,
            _str_
        }

    private:
        static const string TypeStrList [];
        static ST_DdeValueType* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_TableType : public XSD::SimpleType{
    public:
        ST_TableType(){
            m_has_type = false

        }
        ST_TableType(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_TableType::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_TableType& default_instance(){

    if (!ST_TableType::default_instance_)
    {
        ST_TableType::default_instance_ = new ST_TableType();
    }
    return *ST_TableType::default_instance_;

        }
        enum Type{
            _worksheet_ = 1,
            _xml_,
            _queryTable_
        }

    private:
        static const string TypeStrList [];
        static ST_TableType* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_TotalsRowFunction : public XSD::SimpleType{
    public:
        ST_TotalsRowFunction(){
            m_has_type = false

        }
        ST_TotalsRowFunction(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_TotalsRowFunction::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_TotalsRowFunction& default_instance(){

    if (!ST_TotalsRowFunction::default_instance_)
    {
        ST_TotalsRowFunction::default_instance_ = new ST_TotalsRowFunction();
    }
    return *ST_TotalsRowFunction::default_instance_;

        }
        enum Type{
            _none_ = 1,
            _sum_,
            _min_,
            _max_,
            _average_,
            _count_,
            _countNums_,
            _stdDev_,
            _var_,
            _custom_
        }

    private:
        static const string TypeStrList [];
        static ST_TotalsRowFunction* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_XmlDataType : public XSD::SimpleType{
    public:
        ST_XmlDataType(){
            m_has_string = false
            m_string = 

        }
        ST_XmlDataType(const XSD::string& _string ){
            m_has_string = true
            m_string = _string

        }
        bool has_string(){

    return m_has_string;

        }
        void set_string(const string& _string ){

    m_has_string = true;
    m_string = _string;

        }
        const string& string(){

    return m_string;

        }
        void clear(){

    m_has_string = false;
    m_string.clear();;

        }
        void toXml(const string _attrName , ostream _outStream ){

    if (m_has_string)
    {
        _outStream << _attrName << \=\\ << m_string << \\\;;
    }

        }
        const ST_XmlDataType& default_instance(){

    if (!ST_XmlDataType::default_instance_)
    {
        ST_XmlDataType::default_instance_ = new ST_XmlDataType();
    }
    return *ST_XmlDataType::default_instance_;

        }

    private:
        static ST_XmlDataType* default_instance_ ;
        bool m_has_string ;
        string m_string ;

    }

    class ST_VolDepType : public XSD::SimpleType{
    public:
        ST_VolDepType(){
            m_has_type = false

        }
        ST_VolDepType(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_VolDepType::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_VolDepType& default_instance(){

    if (!ST_VolDepType::default_instance_)
    {
        ST_VolDepType::default_instance_ = new ST_VolDepType();
    }
    return *ST_VolDepType::default_instance_;

        }
        enum Type{
            _realTimeData_ = 1,
            _olapFunctions_
        }

    private:
        static const string TypeStrList [];
        static ST_VolDepType* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_VolValueType : public XSD::SimpleType{
    public:
        ST_VolValueType(){
            m_has_type = false

        }
        ST_VolValueType(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_VolValueType::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_VolValueType& default_instance(){

    if (!ST_VolValueType::default_instance_)
    {
        ST_VolValueType::default_instance_ = new ST_VolValueType();
    }
    return *ST_VolValueType::default_instance_;

        }
        enum Type{
            _b_ = 1,
            _n_,
            _e_,
            _s_
        }

    private:
        static const string TypeStrList [];
        static ST_VolValueType* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_Visibility : public XSD::SimpleType{
    public:
        ST_Visibility(){
            m_has_type = false

        }
        ST_Visibility(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_Visibility::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_Visibility& default_instance(){

    if (!ST_Visibility::default_instance_)
    {
        ST_Visibility::default_instance_ = new ST_Visibility();
    }
    return *ST_Visibility::default_instance_;

        }
        enum Type{
            _visible_ = 1,
            _hidden_,
            _veryHidden_
        }

    private:
        static const string TypeStrList [];
        static ST_Visibility* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_Comments : public XSD::SimpleType{
    public:
        ST_Comments(){
            m_has_type = false

        }
        ST_Comments(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_Comments::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_Comments& default_instance(){

    if (!ST_Comments::default_instance_)
    {
        ST_Comments::default_instance_ = new ST_Comments();
    }
    return *ST_Comments::default_instance_;

        }
        enum Type{
            _commNone_ = 1,
            _commIndicator_,
            _commIndAndComment_
        }

    private:
        static const string TypeStrList [];
        static ST_Comments* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_Objects : public XSD::SimpleType{
    public:
        ST_Objects(){
            m_has_type = false

        }
        ST_Objects(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_Objects::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_Objects& default_instance(){

    if (!ST_Objects::default_instance_)
    {
        ST_Objects::default_instance_ = new ST_Objects();
    }
    return *ST_Objects::default_instance_;

        }
        enum Type{
            _all_ = 1,
            _placeholders_,
            _none_
        }

    private:
        static const string TypeStrList [];
        static ST_Objects* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_SheetState : public XSD::SimpleType{
    public:
        ST_SheetState(){
            m_has_type = false

        }
        ST_SheetState(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_SheetState::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_SheetState& default_instance(){

    if (!ST_SheetState::default_instance_)
    {
        ST_SheetState::default_instance_ = new ST_SheetState();
    }
    return *ST_SheetState::default_instance_;

        }
        enum Type{
            _visible_ = 1,
            _hidden_,
            _veryHidden_
        }

    private:
        static const string TypeStrList [];
        static ST_SheetState* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_UpdateLinks : public XSD::SimpleType{
    public:
        ST_UpdateLinks(){
            m_has_type = false

        }
        ST_UpdateLinks(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_UpdateLinks::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_UpdateLinks& default_instance(){

    if (!ST_UpdateLinks::default_instance_)
    {
        ST_UpdateLinks::default_instance_ = new ST_UpdateLinks();
    }
    return *ST_UpdateLinks::default_instance_;

        }
        enum Type{
            _userSet_ = 1,
            _never_,
            _always_
        }

    private:
        static const string TypeStrList [];
        static ST_UpdateLinks* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_SmartTagShow : public XSD::SimpleType{
    public:
        ST_SmartTagShow(){
            m_has_type = false

        }
        ST_SmartTagShow(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_SmartTagShow::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_SmartTagShow& default_instance(){

    if (!ST_SmartTagShow::default_instance_)
    {
        ST_SmartTagShow::default_instance_ = new ST_SmartTagShow();
    }
    return *ST_SmartTagShow::default_instance_;

        }
        enum Type{
            _all_ = 1,
            _none_,
            _noIndicator_
        }

    private:
        static const string TypeStrList [];
        static ST_SmartTagShow* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_CalcMode : public XSD::SimpleType{
    public:
        ST_CalcMode(){
            m_has_type = false

        }
        ST_CalcMode(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_CalcMode::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_CalcMode& default_instance(){

    if (!ST_CalcMode::default_instance_)
    {
        ST_CalcMode::default_instance_ = new ST_CalcMode();
    }
    return *ST_CalcMode::default_instance_;

        }
        enum Type{
            _manual_ = 1,
            _auto_,
            _autoNoTable_
        }

    private:
        static const string TypeStrList [];
        static ST_CalcMode* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_RefMode : public XSD::SimpleType{
    public:
        ST_RefMode(){
            m_has_type = false

        }
        ST_RefMode(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_RefMode::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_RefMode& default_instance(){

    if (!ST_RefMode::default_instance_)
    {
        ST_RefMode::default_instance_ = new ST_RefMode();
    }
    return *ST_RefMode::default_instance_;

        }
        enum Type{
            _A1_ = 1,
            _R1C1_
        }

    private:
        static const string TypeStrList [];
        static ST_RefMode* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class ST_TargetScreenSize : public XSD::SimpleType{
    public:
        ST_TargetScreenSize(){
            m_has_type = false

        }
        ST_TargetScreenSize(const Type _type ){
            m_has_type = true
            m_type = _type

        }
        bool has_type(){

            return m_has_type;
        
        }
        void set_type(const Type& _type ){

            m_has_type = true;
            m_type = _type;
        
        }
        const Type& type(){

            return m_type;
        
        }
        string toString(){

        return ST_TargetScreenSize::TypeStrList[m_type];
    
        }
        void clear(){

            m_has_type = false;
        
        }
        void toXml(const string _attrName , ostream _outStream ){

            if (m_has_type)
            {
                '_outStream << _attrName << \=\\ << toString() << \\\;';
            }
        
        }
        const ST_TargetScreenSize& default_instance(){

    if (!ST_TargetScreenSize::default_instance_)
    {
        ST_TargetScreenSize::default_instance_ = new ST_TargetScreenSize();
    }
    return *ST_TargetScreenSize::default_instance_;

        }
        enum Type{
            _544x376_ = 1,
            _640x480_,
            _720x512_,
            _800x600_,
            _1024x768_,
            _1152x882_,
            _1152x900_,
            _1280x1024_,
            _1600x1200_,
            _1800x1440_,
            _1920x1200_
        }

    private:
        static const string TypeStrList [];
        static ST_TargetScreenSize* default_instance_ ;
        bool m_has_type ;
        Type m_type ;

    }

    class CT_AutoFilter : public XSD::ComplexType{
    public:
        bool has_filterColumn(){

            return m_has_filterColumn;
        
        }
        CT_FilterColumn* mutable_filterColumn(){

                m_has_filterColumn = true;
                if (!m_filterColumn)
                {
                    m_filterColumn = new CT_FilterColumn();
                }
                return m_filterColumn;
            
        }
        const CT_FilterColumn& filterColumn(){

            if (m_filterColumn)
            {
                return *m_filterColumn;
            }
            return CT_FilterColumn::default_instance();
        
        }
        bool has_sortState(){

            return m_has_sortState;
        
        }
        CT_SortState* mutable_sortState(){

                m_has_sortState = true;
                if (!m_sortState)
                {
                    m_sortState = new CT_SortState();
                }
                return m_sortState;
            
        }
        const CT_SortState& sortState(){

            if (m_sortState)
            {
                return *m_sortState;
            }
            return CT_SortState::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_ref_attr = false;
                
        if (m_ref_attr)
        {
            delete m_ref_attr;
            m_ref_attr = NULL;
        }
    
            
                m_has_filterColumn = false;
                
        if (m_filterColumn)
        {
            delete m_filterColumn;
            m_filterColumn = NULL;
        }
    
            
                m_has_sortState = false;
                
        if (m_sortState)
        {
            delete m_sortState;
            m_sortState = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_ref_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_filterColumn)
                {
                    m_filterColumn->toXml(filterColumn, _outStream);;
                }
            
                if (m_has_sortState)
                {
                    m_filterColumn->toXml(sortState, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_filterColumn->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_AutoFilter& default_instance(){

    if (!CT_AutoFilter::default_instance_)
    {
        CT_AutoFilter::default_instance_ = new CT_AutoFilter();
    }
    return *CT_AutoFilter::default_instance_;

        }
        bool has_ref_attr(){

            return m_has_ref_attr;
        
        }
        void set_ref_attr(const ST_Ref& _ref_attr ){

            m_has_ref_attr = true;
            m_ref_attr = new ST_Ref(_ref_attr);
        
        }
        const ST_Ref& ref_attr(){

            if (m_ref_attr)
            {
                return *m_ref_attr;
            }
            return ST_Ref::default_instance();
        
        }

    private:
        bool m_has_filterColumn ;
        CT_FilterColumn* m_filterColumn ;
        bool m_has_sortState ;
        CT_SortState* m_sortState ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_AutoFilter* default_instance_ ;
        bool m_has_ref_attr ;
        ST_Ref* m_ref_attr ;

    }

    class CT_FilterColumn : public XSD::ComplexType{
    public:
        bool has_filters(){

            return m_has_filters;
        
        }
        CT_Filters* mutable_filters(){

                
                m_has_top10 = false;
                
        if (m_top10)
        {
            delete m_top10;
            m_top10 = NULL;
        }
    ;
            
                m_has_customFilters = false;
                
        if (m_customFilters)
        {
            delete m_customFilters;
            m_customFilters = NULL;
        }
    ;
            
                m_has_dynamicFilter = false;
                
        if (m_dynamicFilter)
        {
            delete m_dynamicFilter;
            m_dynamicFilter = NULL;
        }
    ;
            
                m_has_colorFilter = false;
                
        if (m_colorFilter)
        {
            delete m_colorFilter;
            m_colorFilter = NULL;
        }
    ;
            
                m_has_iconFilter = false;
                
        if (m_iconFilter)
        {
            delete m_iconFilter;
            m_iconFilter = NULL;
        }
    ;
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    ;
            
                m_has_filters = true;
                if (!m_filters)
                {
                    m_filters = new CT_Filters();
                }
                return m_filters;
            
        }
        const CT_Filters& filters(){

            if (m_filters)
            {
                return *m_filters;
            }
            return CT_Filters::default_instance();
        
        }
        bool has_top10(){

            return m_has_top10;
        
        }
        CT_Top10* mutable_top10(){

                
                m_has_filters = false;
                
        if (m_filters)
        {
            delete m_filters;
            m_filters = NULL;
        }
    ;
            
                m_has_customFilters = false;
                
        if (m_customFilters)
        {
            delete m_customFilters;
            m_customFilters = NULL;
        }
    ;
            
                m_has_dynamicFilter = false;
                
        if (m_dynamicFilter)
        {
            delete m_dynamicFilter;
            m_dynamicFilter = NULL;
        }
    ;
            
                m_has_colorFilter = false;
                
        if (m_colorFilter)
        {
            delete m_colorFilter;
            m_colorFilter = NULL;
        }
    ;
            
                m_has_iconFilter = false;
                
        if (m_iconFilter)
        {
            delete m_iconFilter;
            m_iconFilter = NULL;
        }
    ;
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    ;
            
                m_has_top10 = true;
                if (!m_top10)
                {
                    m_top10 = new CT_Top10();
                }
                return m_top10;
            
        }
        const CT_Top10& top10(){

            if (m_top10)
            {
                return *m_top10;
            }
            return CT_Top10::default_instance();
        
        }
        bool has_customFilters(){

            return m_has_customFilters;
        
        }
        CT_CustomFilters* mutable_customFilters(){

                
                m_has_filters = false;
                
        if (m_filters)
        {
            delete m_filters;
            m_filters = NULL;
        }
    ;
            
                m_has_top10 = false;
                
        if (m_top10)
        {
            delete m_top10;
            m_top10 = NULL;
        }
    ;
            
                m_has_dynamicFilter = false;
                
        if (m_dynamicFilter)
        {
            delete m_dynamicFilter;
            m_dynamicFilter = NULL;
        }
    ;
            
                m_has_colorFilter = false;
                
        if (m_colorFilter)
        {
            delete m_colorFilter;
            m_colorFilter = NULL;
        }
    ;
            
                m_has_iconFilter = false;
                
        if (m_iconFilter)
        {
            delete m_iconFilter;
            m_iconFilter = NULL;
        }
    ;
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    ;
            
                m_has_customFilters = true;
                if (!m_customFilters)
                {
                    m_customFilters = new CT_CustomFilters();
                }
                return m_customFilters;
            
        }
        const CT_CustomFilters& customFilters(){

            if (m_customFilters)
            {
                return *m_customFilters;
            }
            return CT_CustomFilters::default_instance();
        
        }
        bool has_dynamicFilter(){

            return m_has_dynamicFilter;
        
        }
        CT_DynamicFilter* mutable_dynamicFilter(){

                
                m_has_filters = false;
                
        if (m_filters)
        {
            delete m_filters;
            m_filters = NULL;
        }
    ;
            
                m_has_top10 = false;
                
        if (m_top10)
        {
            delete m_top10;
            m_top10 = NULL;
        }
    ;
            
                m_has_customFilters = false;
                
        if (m_customFilters)
        {
            delete m_customFilters;
            m_customFilters = NULL;
        }
    ;
            
                m_has_colorFilter = false;
                
        if (m_colorFilter)
        {
            delete m_colorFilter;
            m_colorFilter = NULL;
        }
    ;
            
                m_has_iconFilter = false;
                
        if (m_iconFilter)
        {
            delete m_iconFilter;
            m_iconFilter = NULL;
        }
    ;
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    ;
            
                m_has_dynamicFilter = true;
                if (!m_dynamicFilter)
                {
                    m_dynamicFilter = new CT_DynamicFilter();
                }
                return m_dynamicFilter;
            
        }
        const CT_DynamicFilter& dynamicFilter(){

            if (m_dynamicFilter)
            {
                return *m_dynamicFilter;
            }
            return CT_DynamicFilter::default_instance();
        
        }
        bool has_colorFilter(){

            return m_has_colorFilter;
        
        }
        CT_ColorFilter* mutable_colorFilter(){

                
                m_has_filters = false;
                
        if (m_filters)
        {
            delete m_filters;
            m_filters = NULL;
        }
    ;
            
                m_has_top10 = false;
                
        if (m_top10)
        {
            delete m_top10;
            m_top10 = NULL;
        }
    ;
            
                m_has_customFilters = false;
                
        if (m_customFilters)
        {
            delete m_customFilters;
            m_customFilters = NULL;
        }
    ;
            
                m_has_dynamicFilter = false;
                
        if (m_dynamicFilter)
        {
            delete m_dynamicFilter;
            m_dynamicFilter = NULL;
        }
    ;
            
                m_has_iconFilter = false;
                
        if (m_iconFilter)
        {
            delete m_iconFilter;
            m_iconFilter = NULL;
        }
    ;
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    ;
            
                m_has_colorFilter = true;
                if (!m_colorFilter)
                {
                    m_colorFilter = new CT_ColorFilter();
                }
                return m_colorFilter;
            
        }
        const CT_ColorFilter& colorFilter(){

            if (m_colorFilter)
            {
                return *m_colorFilter;
            }
            return CT_ColorFilter::default_instance();
        
        }
        bool has_iconFilter(){

            return m_has_iconFilter;
        
        }
        CT_IconFilter* mutable_iconFilter(){

                
                m_has_filters = false;
                
        if (m_filters)
        {
            delete m_filters;
            m_filters = NULL;
        }
    ;
            
                m_has_top10 = false;
                
        if (m_top10)
        {
            delete m_top10;
            m_top10 = NULL;
        }
    ;
            
                m_has_customFilters = false;
                
        if (m_customFilters)
        {
            delete m_customFilters;
            m_customFilters = NULL;
        }
    ;
            
                m_has_dynamicFilter = false;
                
        if (m_dynamicFilter)
        {
            delete m_dynamicFilter;
            m_dynamicFilter = NULL;
        }
    ;
            
                m_has_colorFilter = false;
                
        if (m_colorFilter)
        {
            delete m_colorFilter;
            m_colorFilter = NULL;
        }
    ;
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    ;
            
                m_has_iconFilter = true;
                if (!m_iconFilter)
                {
                    m_iconFilter = new CT_IconFilter();
                }
                return m_iconFilter;
            
        }
        const CT_IconFilter& iconFilter(){

            if (m_iconFilter)
            {
                return *m_iconFilter;
            }
            return CT_IconFilter::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                
                m_has_filters = false;
                
        if (m_filters)
        {
            delete m_filters;
            m_filters = NULL;
        }
    ;
            
                m_has_top10 = false;
                
        if (m_top10)
        {
            delete m_top10;
            m_top10 = NULL;
        }
    ;
            
                m_has_customFilters = false;
                
        if (m_customFilters)
        {
            delete m_customFilters;
            m_customFilters = NULL;
        }
    ;
            
                m_has_dynamicFilter = false;
                
        if (m_dynamicFilter)
        {
            delete m_dynamicFilter;
            m_dynamicFilter = NULL;
        }
    ;
            
                m_has_colorFilter = false;
                
        if (m_colorFilter)
        {
            delete m_colorFilter;
            m_colorFilter = NULL;
        }
    ;
            
                m_has_iconFilter = false;
                
        if (m_iconFilter)
        {
            delete m_iconFilter;
            m_iconFilter = NULL;
        }
    ;
            
                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_colId_attr = false;
                m_colId_attr = 0;
            
                m_has_hiddenButton_attr = false;
                m_hiddenButton_attr = false;
            
                m_has_showButton_attr = false;
                m_showButton_attr = false;
            
                m_has_filters = false;
                
        if (m_filters)
        {
            delete m_filters;
            m_filters = NULL;
        }
    
            
                m_has_top10 = false;
                
        if (m_top10)
        {
            delete m_top10;
            m_top10 = NULL;
        }
    
            
                m_has_customFilters = false;
                
        if (m_customFilters)
        {
            delete m_customFilters;
            m_customFilters = NULL;
        }
    
            
                m_has_dynamicFilter = false;
                
        if (m_dynamicFilter)
        {
            delete m_dynamicFilter;
            m_dynamicFilter = NULL;
        }
    
            
                m_has_colorFilter = false;
                
        if (m_colorFilter)
        {
            delete m_colorFilter;
            m_colorFilter = NULL;
        }
    
            
                m_has_iconFilter = false;
                
        if (m_iconFilter)
        {
            delete m_iconFilter;
            m_iconFilter = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_colId_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_hiddenButton_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showButton_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_filters)
                {
                    m_filters->toXml(filters, _outStream);;
                }
            
                if (m_has_top10)
                {
                    m_filters->toXml(top10, _outStream);;
                }
            
                if (m_has_customFilters)
                {
                    m_filters->toXml(customFilters, _outStream);;
                }
            
                if (m_has_dynamicFilter)
                {
                    m_filters->toXml(dynamicFilter, _outStream);;
                }
            
                if (m_has_colorFilter)
                {
                    m_filters->toXml(colorFilter, _outStream);;
                }
            
                if (m_has_iconFilter)
                {
                    m_filters->toXml(iconFilter, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_filters->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_FilterColumn& default_instance(){

    if (!CT_FilterColumn::default_instance_)
    {
        CT_FilterColumn::default_instance_ = new CT_FilterColumn();
    }
    return *CT_FilterColumn::default_instance_;

        }
        bool has_colId_attr(){

            return m_has_colId_attr;
        
        }
        void set_colId_attr(const unsignedInt& _colId_attr ){

        m_has_colId_attr = true;
        m_colId_attr = _colId_attr;
        
        }
        const unsignedInt& colId_attr(){

            return type: \unsignedInt\nname: \m_colId_attr\n;
        
        }
        bool has_hiddenButton_attr(){

            return m_has_hiddenButton_attr;
        
        }
        void set_hiddenButton_attr(const boolean& _hiddenButton_attr ){

        m_has_hiddenButton_attr = true;
        m_hiddenButton_attr = _hiddenButton_attr;
        
        }
        const boolean& hiddenButton_attr(){

            return type: oolean\nname: \m_hiddenButton_attr\n;
        
        }
        bool has_showButton_attr(){

            return m_has_showButton_attr;
        
        }
        void set_showButton_attr(const boolean& _showButton_attr ){

        m_has_showButton_attr = true;
        m_showButton_attr = _showButton_attr;
        
        }
        const boolean& showButton_attr(){

            return type: oolean\nname: \m_showButton_attr\n;
        
        }

    private:
        bool m_has_filters ;
        CT_Filters* m_filters ;
        bool m_has_top10 ;
        CT_Top10* m_top10 ;
        bool m_has_customFilters ;
        CT_CustomFilters* m_customFilters ;
        bool m_has_dynamicFilter ;
        CT_DynamicFilter* m_dynamicFilter ;
        bool m_has_colorFilter ;
        CT_ColorFilter* m_colorFilter ;
        bool m_has_iconFilter ;
        CT_IconFilter* m_iconFilter ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_FilterColumn* default_instance_ ;
        bool m_has_colId_attr ;
        unsignedInt m_colId_attr ;
        bool m_has_hiddenButton_attr ;
        boolean m_hiddenButton_attr ;
        bool m_has_showButton_attr ;
        boolean m_showButton_attr ;

    }

    class CT_Filters : public XSD::ComplexType{
    public:
        bool has_filter(){

            return m_has_filter;
        
        }
        CT_Filter* mutable_filter(){

                m_has_filter = true;
                if (!m_filter)
                {
                    m_filter = new CT_Filter();
                }
                return m_filter;
            
        }
        const CT_Filter& filter(){

            if (m_filter)
            {
                return *m_filter;
            }
            return CT_Filter::default_instance();
        
        }
        bool has_dateGroupItem(){

            return m_has_dateGroupItem;
        
        }
        CT_DateGroupItem* mutable_dateGroupItem(){

                m_has_dateGroupItem = true;
                if (!m_dateGroupItem)
                {
                    m_dateGroupItem = new CT_DateGroupItem();
                }
                return m_dateGroupItem;
            
        }
        const CT_DateGroupItem& dateGroupItem(){

            if (m_dateGroupItem)
            {
                return *m_dateGroupItem;
            }
            return CT_DateGroupItem::default_instance();
        
        }
        void clear(){

                m_has_blank_attr = false;
                m_blank_attr = false;
            
                m_has_calendarType_attr = false;
                
        if (m_calendarType_attr)
        {
            delete m_calendarType_attr;
            m_calendarType_attr = NULL;
        }
    
            
                m_has_filter = false;
                
        if (m_filter)
        {
            delete m_filter;
            m_filter = NULL;
        }
    
            
                m_has_dateGroupItem = false;
                
        if (m_dateGroupItem)
        {
            delete m_dateGroupItem;
            m_dateGroupItem = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_blank_attr) << \\\;
m_calendarType_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_filter)
                {
                    m_filter->toXml(filter, _outStream);;
                }
            
                if (m_has_dateGroupItem)
                {
                    m_filter->toXml(dateGroupItem, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Filters& default_instance(){

    if (!CT_Filters::default_instance_)
    {
        CT_Filters::default_instance_ = new CT_Filters();
    }
    return *CT_Filters::default_instance_;

        }
        bool has_blank_attr(){

            return m_has_blank_attr;
        
        }
        void set_blank_attr(const boolean& _blank_attr ){

        m_has_blank_attr = true;
        m_blank_attr = _blank_attr;
        
        }
        const boolean& blank_attr(){

            return type: oolean\nname: \m_blank_attr\n;
        
        }
        bool has_calendarType_attr(){

            return m_has_calendarType_attr;
        
        }
        void set_calendarType_attr(const ns_s::ST_CalendarType& _calendarType_attr ){

            m_has_calendarType_attr = true;
            m_calendarType_attr = new ns_s::ST_CalendarType(_calendarType_attr);
        
        }
        const ns_s::ST_CalendarType& calendarType_attr(){

            if (m_calendarType_attr)
            {
                return *m_calendarType_attr;
            }
            return ns_s::ST_CalendarType::default_instance();
        
        }

    private:
        bool m_has_filter ;
        CT_Filter* m_filter ;
        bool m_has_dateGroupItem ;
        CT_DateGroupItem* m_dateGroupItem ;
        static CT_Filters* default_instance_ ;
        bool m_has_blank_attr ;
        boolean m_blank_attr ;
        bool m_has_calendarType_attr ;
        ns_s::ST_CalendarType* m_calendarType_attr ;

    }

    class CT_Filter : public XSD::ComplexType{
    public:
        void clear(){

                m_has_val_attr = false;
                
        if (m_val_attr)
        {
            delete m_val_attr;
            m_val_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_val_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Filter& default_instance(){

    if (!CT_Filter::default_instance_)
    {
        CT_Filter::default_instance_ = new CT_Filter();
    }
    return *CT_Filter::default_instance_;

        }
        bool has_val_attr(){

            return m_has_val_attr;
        
        }
        void set_val_attr(const ns_s::ST_Xstring& _val_attr ){

            m_has_val_attr = true;
            m_val_attr = new ns_s::ST_Xstring(_val_attr);
        
        }
        const ns_s::ST_Xstring& val_attr(){

            if (m_val_attr)
            {
                return *m_val_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }

    private:
        static CT_Filter* default_instance_ ;
        bool m_has_val_attr ;
        ns_s::ST_Xstring* m_val_attr ;

    }

    class CT_CustomFilters : public XSD::ComplexType{
    public:
        bool has_customFilter(){

            return m_has_customFilter;
        
        }
        CT_CustomFilter* mutable_customFilter(){

                m_has_customFilter = true;
                if (!m_customFilter)
                {
                    m_customFilter = new CT_CustomFilter();
                }
                return m_customFilter;
            
        }
        const CT_CustomFilter& customFilter(){

            if (m_customFilter)
            {
                return *m_customFilter;
            }
            return CT_CustomFilter::default_instance();
        
        }
        void clear(){

                m_has_and_attr = false;
                m_and_attr = false;
            
                m_has_customFilter = false;
                
        if (m_customFilter)
        {
            delete m_customFilter;
            m_customFilter = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_and_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_customFilter)
                {
                    m_customFilter->toXml(customFilter, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CustomFilters& default_instance(){

    if (!CT_CustomFilters::default_instance_)
    {
        CT_CustomFilters::default_instance_ = new CT_CustomFilters();
    }
    return *CT_CustomFilters::default_instance_;

        }
        bool has_and_attr(){

            return m_has_and_attr;
        
        }
        void set_and_attr(const boolean& _and_attr ){

        m_has_and_attr = true;
        m_and_attr = _and_attr;
        
        }
        const boolean& and_attr(){

            return type: oolean\nname: \m_and_attr\n;
        
        }

    private:
        bool m_has_customFilter ;
        CT_CustomFilter* m_customFilter ;
        static CT_CustomFilters* default_instance_ ;
        bool m_has_and_attr ;
        boolean m_and_attr ;

    }

    class CT_CustomFilter : public XSD::ComplexType{
    public:
        void clear(){

                m_has_operator_attr = false;
                
        if (m_operator_attr)
        {
            delete m_operator_attr;
            m_operator_attr = NULL;
        }
    
            
                m_has_val_attr = false;
                
        if (m_val_attr)
        {
            delete m_val_attr;
            m_val_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_operator_attr->toXml(_attrName, _outStream);
m_val_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CustomFilter& default_instance(){

    if (!CT_CustomFilter::default_instance_)
    {
        CT_CustomFilter::default_instance_ = new CT_CustomFilter();
    }
    return *CT_CustomFilter::default_instance_;

        }
        bool has_operator_attr(){

            return m_has_operator_attr;
        
        }
        void set_operator_attr(const ST_FilterOperator& _operator_attr ){

            m_has_operator_attr = true;
            m_operator_attr = new ST_FilterOperator(_operator_attr);
        
        }
        const ST_FilterOperator& operator_attr(){

            if (m_operator_attr)
            {
                return *m_operator_attr;
            }
            return ST_FilterOperator::default_instance();
        
        }
        bool has_val_attr(){

            return m_has_val_attr;
        
        }
        void set_val_attr(const ns_s::ST_Xstring& _val_attr ){

            m_has_val_attr = true;
            m_val_attr = new ns_s::ST_Xstring(_val_attr);
        
        }
        const ns_s::ST_Xstring& val_attr(){

            if (m_val_attr)
            {
                return *m_val_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }

    private:
        static CT_CustomFilter* default_instance_ ;
        bool m_has_operator_attr ;
        ST_FilterOperator* m_operator_attr ;
        bool m_has_val_attr ;
        ns_s::ST_Xstring* m_val_attr ;

    }

    class CT_Top10 : public XSD::ComplexType{
    public:
        void clear(){

                m_has_top_attr = false;
                m_top_attr = false;
            
                m_has_percent_attr = false;
                m_percent_attr = false;
            
                m_has_val_attr = false;
                m_val_attr = 0;
            
                m_has_filterVal_attr = false;
                m_filterVal_attr = 0;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_top_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_percent_attr) << \\\;
_outStream << _attrName << \=\\ << m_val_attr << \\\;
_outStream << _attrName << \=\\ << m_filterVal_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Top10& default_instance(){

    if (!CT_Top10::default_instance_)
    {
        CT_Top10::default_instance_ = new CT_Top10();
    }
    return *CT_Top10::default_instance_;

        }
        bool has_top_attr(){

            return m_has_top_attr;
        
        }
        void set_top_attr(const boolean& _top_attr ){

        m_has_top_attr = true;
        m_top_attr = _top_attr;
        
        }
        const boolean& top_attr(){

            return type: oolean\nname: \m_top_attr\n;
        
        }
        bool has_percent_attr(){

            return m_has_percent_attr;
        
        }
        void set_percent_attr(const boolean& _percent_attr ){

        m_has_percent_attr = true;
        m_percent_attr = _percent_attr;
        
        }
        const boolean& percent_attr(){

            return type: oolean\nname: \m_percent_attr\n;
        
        }
        bool has_val_attr(){

            return m_has_val_attr;
        
        }
        void set_val_attr(const double& _val_attr ){

        m_has_val_attr = true;
        m_val_attr = _val_attr;
        
        }
        const double& val_attr(){

            return type: \double\nname: \m_val_attr\n;
        
        }
        bool has_filterVal_attr(){

            return m_has_filterVal_attr;
        
        }
        void set_filterVal_attr(const double& _filterVal_attr ){

        m_has_filterVal_attr = true;
        m_filterVal_attr = _filterVal_attr;
        
        }
        const double& filterVal_attr(){

            return type: \double\nname: \m_filterVal_attr\n;
        
        }

    private:
        static CT_Top10* default_instance_ ;
        bool m_has_top_attr ;
        boolean m_top_attr ;
        bool m_has_percent_attr ;
        boolean m_percent_attr ;
        bool m_has_val_attr ;
        double m_val_attr ;
        bool m_has_filterVal_attr ;
        double m_filterVal_attr ;

    }

    class CT_ColorFilter : public XSD::ComplexType{
    public:
        void clear(){

                m_has_dxfId_attr = false;
                
        if (m_dxfId_attr)
        {
            delete m_dxfId_attr;
            m_dxfId_attr = NULL;
        }
    
            
                m_has_cellColor_attr = false;
                m_cellColor_attr = false;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_dxfId_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_cellColor_attr) << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_ColorFilter& default_instance(){

    if (!CT_ColorFilter::default_instance_)
    {
        CT_ColorFilter::default_instance_ = new CT_ColorFilter();
    }
    return *CT_ColorFilter::default_instance_;

        }
        bool has_dxfId_attr(){

            return m_has_dxfId_attr;
        
        }
        void set_dxfId_attr(const ST_DxfId& _dxfId_attr ){

            m_has_dxfId_attr = true;
            m_dxfId_attr = new ST_DxfId(_dxfId_attr);
        
        }
        const ST_DxfId& dxfId_attr(){

            if (m_dxfId_attr)
            {
                return *m_dxfId_attr;
            }
            return ST_DxfId::default_instance();
        
        }
        bool has_cellColor_attr(){

            return m_has_cellColor_attr;
        
        }
        void set_cellColor_attr(const boolean& _cellColor_attr ){

        m_has_cellColor_attr = true;
        m_cellColor_attr = _cellColor_attr;
        
        }
        const boolean& cellColor_attr(){

            return type: oolean\nname: \m_cellColor_attr\n;
        
        }

    private:
        static CT_ColorFilter* default_instance_ ;
        bool m_has_dxfId_attr ;
        ST_DxfId* m_dxfId_attr ;
        bool m_has_cellColor_attr ;
        boolean m_cellColor_attr ;

    }

    class CT_IconFilter : public XSD::ComplexType{
    public:
        void clear(){

                m_has_iconSet_attr = false;
                
        if (m_iconSet_attr)
        {
            delete m_iconSet_attr;
            m_iconSet_attr = NULL;
        }
    
            
                m_has_iconId_attr = false;
                m_iconId_attr = 0;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_iconSet_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_iconId_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_IconFilter& default_instance(){

    if (!CT_IconFilter::default_instance_)
    {
        CT_IconFilter::default_instance_ = new CT_IconFilter();
    }
    return *CT_IconFilter::default_instance_;

        }
        bool has_iconSet_attr(){

            return m_has_iconSet_attr;
        
        }
        void set_iconSet_attr(const ST_IconSetType& _iconSet_attr ){

            m_has_iconSet_attr = true;
            m_iconSet_attr = new ST_IconSetType(_iconSet_attr);
        
        }
        const ST_IconSetType& iconSet_attr(){

            if (m_iconSet_attr)
            {
                return *m_iconSet_attr;
            }
            return ST_IconSetType::default_instance();
        
        }
        bool has_iconId_attr(){

            return m_has_iconId_attr;
        
        }
        void set_iconId_attr(const unsignedInt& _iconId_attr ){

        m_has_iconId_attr = true;
        m_iconId_attr = _iconId_attr;
        
        }
        const unsignedInt& iconId_attr(){

            return type: \unsignedInt\nname: \m_iconId_attr\n;
        
        }

    private:
        static CT_IconFilter* default_instance_ ;
        bool m_has_iconSet_attr ;
        ST_IconSetType* m_iconSet_attr ;
        bool m_has_iconId_attr ;
        unsignedInt m_iconId_attr ;

    }

    class CT_DynamicFilter : public XSD::ComplexType{
    public:
        void clear(){

                m_has_type_attr = false;
                
        if (m_type_attr)
        {
            delete m_type_attr;
            m_type_attr = NULL;
        }
    
            
                m_has_val_attr = false;
                m_val_attr = 0;
            
                m_has_valIso_attr = false;
                m_valIso_attr.clear();
            
                m_has_maxVal_attr = false;
                m_maxVal_attr = 0;
            
                m_has_maxValIso_attr = false;
                m_maxValIso_attr.clear();
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_type_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_val_attr << \\\;
_outStream << _attrName << \=\\ << m_valIso_attr << \\\;
_outStream << _attrName << \=\\ << m_maxVal_attr << \\\;
_outStream << _attrName << \=\\ << m_maxValIso_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_DynamicFilter& default_instance(){

    if (!CT_DynamicFilter::default_instance_)
    {
        CT_DynamicFilter::default_instance_ = new CT_DynamicFilter();
    }
    return *CT_DynamicFilter::default_instance_;

        }
        bool has_type_attr(){

            return m_has_type_attr;
        
        }
        void set_type_attr(const ST_DynamicFilterType& _type_attr ){

            m_has_type_attr = true;
            m_type_attr = new ST_DynamicFilterType(_type_attr);
        
        }
        const ST_DynamicFilterType& type_attr(){

            if (m_type_attr)
            {
                return *m_type_attr;
            }
            return ST_DynamicFilterType::default_instance();
        
        }
        bool has_val_attr(){

            return m_has_val_attr;
        
        }
        void set_val_attr(const double& _val_attr ){

        m_has_val_attr = true;
        m_val_attr = _val_attr;
        
        }
        const double& val_attr(){

            return type: \double\nname: \m_val_attr\n;
        
        }
        bool has_valIso_attr(){

            return m_has_valIso_attr;
        
        }
        void set_valIso_attr(const dateTime& _valIso_attr ){

        m_has_valIso_attr = true;
        m_valIso_attr = _valIso_attr;
        
        }
        const dateTime& valIso_attr(){

            return type: \dateTime\nname: \m_valIso_attr\n;
        
        }
        bool has_maxVal_attr(){

            return m_has_maxVal_attr;
        
        }
        void set_maxVal_attr(const double& _maxVal_attr ){

        m_has_maxVal_attr = true;
        m_maxVal_attr = _maxVal_attr;
        
        }
        const double& maxVal_attr(){

            return type: \double\nname: \m_maxVal_attr\n;
        
        }
        bool has_maxValIso_attr(){

            return m_has_maxValIso_attr;
        
        }
        void set_maxValIso_attr(const dateTime& _maxValIso_attr ){

        m_has_maxValIso_attr = true;
        m_maxValIso_attr = _maxValIso_attr;
        
        }
        const dateTime& maxValIso_attr(){

            return type: \dateTime\nname: \m_maxValIso_attr\n;
        
        }

    private:
        static CT_DynamicFilter* default_instance_ ;
        bool m_has_type_attr ;
        ST_DynamicFilterType* m_type_attr ;
        bool m_has_val_attr ;
        double m_val_attr ;
        bool m_has_valIso_attr ;
        dateTime m_valIso_attr ;
        bool m_has_maxVal_attr ;
        double m_maxVal_attr ;
        bool m_has_maxValIso_attr ;
        dateTime m_maxValIso_attr ;

    }

    class CT_SortState : public XSD::ComplexType{
    public:
        bool has_sortCondition(){

            return m_has_sortCondition;
        
        }
        CT_SortCondition* mutable_sortCondition(){

                m_has_sortCondition = true;
                if (!m_sortCondition)
                {
                    m_sortCondition = new CT_SortCondition();
                }
                return m_sortCondition;
            
        }
        const CT_SortCondition& sortCondition(){

            if (m_sortCondition)
            {
                return *m_sortCondition;
            }
            return CT_SortCondition::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_columnSort_attr = false;
                m_columnSort_attr = false;
            
                m_has_caseSensitive_attr = false;
                m_caseSensitive_attr = false;
            
                m_has_sortMethod_attr = false;
                
        if (m_sortMethod_attr)
        {
            delete m_sortMethod_attr;
            m_sortMethod_attr = NULL;
        }
    
            
                m_has_ref_attr = false;
                
        if (m_ref_attr)
        {
            delete m_ref_attr;
            m_ref_attr = NULL;
        }
    
            
                m_has_sortCondition = false;
                
        if (m_sortCondition)
        {
            delete m_sortCondition;
            m_sortCondition = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_columnSort_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_caseSensitive_attr) << \\\;
m_sortMethod_attr->toXml(_attrName, _outStream);
m_ref_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_sortCondition)
                {
                    m_sortCondition->toXml(sortCondition, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_sortCondition->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_SortState& default_instance(){

    if (!CT_SortState::default_instance_)
    {
        CT_SortState::default_instance_ = new CT_SortState();
    }
    return *CT_SortState::default_instance_;

        }
        bool has_columnSort_attr(){

            return m_has_columnSort_attr;
        
        }
        void set_columnSort_attr(const boolean& _columnSort_attr ){

        m_has_columnSort_attr = true;
        m_columnSort_attr = _columnSort_attr;
        
        }
        const boolean& columnSort_attr(){

            return type: oolean\nname: \m_columnSort_attr\n;
        
        }
        bool has_caseSensitive_attr(){

            return m_has_caseSensitive_attr;
        
        }
        void set_caseSensitive_attr(const boolean& _caseSensitive_attr ){

        m_has_caseSensitive_attr = true;
        m_caseSensitive_attr = _caseSensitive_attr;
        
        }
        const boolean& caseSensitive_attr(){

            return type: oolean\nname: \m_caseSensitive_attr\n;
        
        }
        bool has_sortMethod_attr(){

            return m_has_sortMethod_attr;
        
        }
        void set_sortMethod_attr(const ST_SortMethod& _sortMethod_attr ){

            m_has_sortMethod_attr = true;
            m_sortMethod_attr = new ST_SortMethod(_sortMethod_attr);
        
        }
        const ST_SortMethod& sortMethod_attr(){

            if (m_sortMethod_attr)
            {
                return *m_sortMethod_attr;
            }
            return ST_SortMethod::default_instance();
        
        }
        bool has_ref_attr(){

            return m_has_ref_attr;
        
        }
        void set_ref_attr(const ST_Ref& _ref_attr ){

            m_has_ref_attr = true;
            m_ref_attr = new ST_Ref(_ref_attr);
        
        }
        const ST_Ref& ref_attr(){

            if (m_ref_attr)
            {
                return *m_ref_attr;
            }
            return ST_Ref::default_instance();
        
        }

    private:
        bool m_has_sortCondition ;
        CT_SortCondition* m_sortCondition ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_SortState* default_instance_ ;
        bool m_has_columnSort_attr ;
        boolean m_columnSort_attr ;
        bool m_has_caseSensitive_attr ;
        boolean m_caseSensitive_attr ;
        bool m_has_sortMethod_attr ;
        ST_SortMethod* m_sortMethod_attr ;
        bool m_has_ref_attr ;
        ST_Ref* m_ref_attr ;

    }

    class CT_SortCondition : public XSD::ComplexType{
    public:
        void clear(){

                m_has_descending_attr = false;
                m_descending_attr = false;
            
                m_has_sortBy_attr = false;
                
        if (m_sortBy_attr)
        {
            delete m_sortBy_attr;
            m_sortBy_attr = NULL;
        }
    
            
                m_has_ref_attr = false;
                
        if (m_ref_attr)
        {
            delete m_ref_attr;
            m_ref_attr = NULL;
        }
    
            
                m_has_customList_attr = false;
                
        if (m_customList_attr)
        {
            delete m_customList_attr;
            m_customList_attr = NULL;
        }
    
            
                m_has_dxfId_attr = false;
                
        if (m_dxfId_attr)
        {
            delete m_dxfId_attr;
            m_dxfId_attr = NULL;
        }
    
            
                m_has_iconSet_attr = false;
                
        if (m_iconSet_attr)
        {
            delete m_iconSet_attr;
            m_iconSet_attr = NULL;
        }
    
            
                m_has_iconId_attr = false;
                m_iconId_attr = 0;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_descending_attr) << \\\;
m_sortBy_attr->toXml(_attrName, _outStream);
m_ref_attr->toXml(_attrName, _outStream);
m_customList_attr->toXml(_attrName, _outStream);
m_dxfId_attr->toXml(_attrName, _outStream);
m_iconSet_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_iconId_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_SortCondition& default_instance(){

    if (!CT_SortCondition::default_instance_)
    {
        CT_SortCondition::default_instance_ = new CT_SortCondition();
    }
    return *CT_SortCondition::default_instance_;

        }
        bool has_descending_attr(){

            return m_has_descending_attr;
        
        }
        void set_descending_attr(const boolean& _descending_attr ){

        m_has_descending_attr = true;
        m_descending_attr = _descending_attr;
        
        }
        const boolean& descending_attr(){

            return type: oolean\nname: \m_descending_attr\n;
        
        }
        bool has_sortBy_attr(){

            return m_has_sortBy_attr;
        
        }
        void set_sortBy_attr(const ST_SortBy& _sortBy_attr ){

            m_has_sortBy_attr = true;
            m_sortBy_attr = new ST_SortBy(_sortBy_attr);
        
        }
        const ST_SortBy& sortBy_attr(){

            if (m_sortBy_attr)
            {
                return *m_sortBy_attr;
            }
            return ST_SortBy::default_instance();
        
        }
        bool has_ref_attr(){

            return m_has_ref_attr;
        
        }
        void set_ref_attr(const ST_Ref& _ref_attr ){

            m_has_ref_attr = true;
            m_ref_attr = new ST_Ref(_ref_attr);
        
        }
        const ST_Ref& ref_attr(){

            if (m_ref_attr)
            {
                return *m_ref_attr;
            }
            return ST_Ref::default_instance();
        
        }
        bool has_customList_attr(){

            return m_has_customList_attr;
        
        }
        void set_customList_attr(const ns_s::ST_Xstring& _customList_attr ){

            m_has_customList_attr = true;
            m_customList_attr = new ns_s::ST_Xstring(_customList_attr);
        
        }
        const ns_s::ST_Xstring& customList_attr(){

            if (m_customList_attr)
            {
                return *m_customList_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_dxfId_attr(){

            return m_has_dxfId_attr;
        
        }
        void set_dxfId_attr(const ST_DxfId& _dxfId_attr ){

            m_has_dxfId_attr = true;
            m_dxfId_attr = new ST_DxfId(_dxfId_attr);
        
        }
        const ST_DxfId& dxfId_attr(){

            if (m_dxfId_attr)
            {
                return *m_dxfId_attr;
            }
            return ST_DxfId::default_instance();
        
        }
        bool has_iconSet_attr(){

            return m_has_iconSet_attr;
        
        }
        void set_iconSet_attr(const ST_IconSetType& _iconSet_attr ){

            m_has_iconSet_attr = true;
            m_iconSet_attr = new ST_IconSetType(_iconSet_attr);
        
        }
        const ST_IconSetType& iconSet_attr(){

            if (m_iconSet_attr)
            {
                return *m_iconSet_attr;
            }
            return ST_IconSetType::default_instance();
        
        }
        bool has_iconId_attr(){

            return m_has_iconId_attr;
        
        }
        void set_iconId_attr(const unsignedInt& _iconId_attr ){

        m_has_iconId_attr = true;
        m_iconId_attr = _iconId_attr;
        
        }
        const unsignedInt& iconId_attr(){

            return type: \unsignedInt\nname: \m_iconId_attr\n;
        
        }

    private:
        static CT_SortCondition* default_instance_ ;
        bool m_has_descending_attr ;
        boolean m_descending_attr ;
        bool m_has_sortBy_attr ;
        ST_SortBy* m_sortBy_attr ;
        bool m_has_ref_attr ;
        ST_Ref* m_ref_attr ;
        bool m_has_customList_attr ;
        ns_s::ST_Xstring* m_customList_attr ;
        bool m_has_dxfId_attr ;
        ST_DxfId* m_dxfId_attr ;
        bool m_has_iconSet_attr ;
        ST_IconSetType* m_iconSet_attr ;
        bool m_has_iconId_attr ;
        unsignedInt m_iconId_attr ;

    }

    class CT_DateGroupItem : public XSD::ComplexType{
    public:
        void clear(){

                m_has_year_attr = false;
                m_year_attr = 0;
            
                m_has_month_attr = false;
                m_month_attr = 0;
            
                m_has_day_attr = false;
                m_day_attr = 0;
            
                m_has_hour_attr = false;
                m_hour_attr = 0;
            
                m_has_minute_attr = false;
                m_minute_attr = 0;
            
                m_has_second_attr = false;
                m_second_attr = 0;
            
                m_has_dateTimeGrouping_attr = false;
                
        if (m_dateTimeGrouping_attr)
        {
            delete m_dateTimeGrouping_attr;
            m_dateTimeGrouping_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_year_attr << \\\;
_outStream << _attrName << \=\\ << m_month_attr << \\\;
_outStream << _attrName << \=\\ << m_day_attr << \\\;
_outStream << _attrName << \=\\ << m_hour_attr << \\\;
_outStream << _attrName << \=\\ << m_minute_attr << \\\;
_outStream << _attrName << \=\\ << m_second_attr << \\\;
m_dateTimeGrouping_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_DateGroupItem& default_instance(){

    if (!CT_DateGroupItem::default_instance_)
    {
        CT_DateGroupItem::default_instance_ = new CT_DateGroupItem();
    }
    return *CT_DateGroupItem::default_instance_;

        }
        bool has_year_attr(){

            return m_has_year_attr;
        
        }
        void set_year_attr(const unsignedShort& _year_attr ){

        m_has_year_attr = true;
        m_year_attr = _year_attr;
        
        }
        const unsignedShort& year_attr(){

            return type: \unsignedShort\nname: \m_year_attr\n;
        
        }
        bool has_month_attr(){

            return m_has_month_attr;
        
        }
        void set_month_attr(const unsignedShort& _month_attr ){

        m_has_month_attr = true;
        m_month_attr = _month_attr;
        
        }
        const unsignedShort& month_attr(){

            return type: \unsignedShort\nname: \m_month_attr\n;
        
        }
        bool has_day_attr(){

            return m_has_day_attr;
        
        }
        void set_day_attr(const unsignedShort& _day_attr ){

        m_has_day_attr = true;
        m_day_attr = _day_attr;
        
        }
        const unsignedShort& day_attr(){

            return type: \unsignedShort\nname: \m_day_attr\n;
        
        }
        bool has_hour_attr(){

            return m_has_hour_attr;
        
        }
        void set_hour_attr(const unsignedShort& _hour_attr ){

        m_has_hour_attr = true;
        m_hour_attr = _hour_attr;
        
        }
        const unsignedShort& hour_attr(){

            return type: \unsignedShort\nname: \m_hour_attr\n;
        
        }
        bool has_minute_attr(){

            return m_has_minute_attr;
        
        }
        void set_minute_attr(const unsignedShort& _minute_attr ){

        m_has_minute_attr = true;
        m_minute_attr = _minute_attr;
        
        }
        const unsignedShort& minute_attr(){

            return type: \unsignedShort\nname: \m_minute_attr\n;
        
        }
        bool has_second_attr(){

            return m_has_second_attr;
        
        }
        void set_second_attr(const unsignedShort& _second_attr ){

        m_has_second_attr = true;
        m_second_attr = _second_attr;
        
        }
        const unsignedShort& second_attr(){

            return type: \unsignedShort\nname: \m_second_attr\n;
        
        }
        bool has_dateTimeGrouping_attr(){

            return m_has_dateTimeGrouping_attr;
        
        }
        void set_dateTimeGrouping_attr(const ST_DateTimeGrouping& _dateTimeGrouping_attr ){

            m_has_dateTimeGrouping_attr = true;
            m_dateTimeGrouping_attr = new ST_DateTimeGrouping(_dateTimeGrouping_attr);
        
        }
        const ST_DateTimeGrouping& dateTimeGrouping_attr(){

            if (m_dateTimeGrouping_attr)
            {
                return *m_dateTimeGrouping_attr;
            }
            return ST_DateTimeGrouping::default_instance();
        
        }

    private:
        static CT_DateGroupItem* default_instance_ ;
        bool m_has_year_attr ;
        unsignedShort m_year_attr ;
        bool m_has_month_attr ;
        unsignedShort m_month_attr ;
        bool m_has_day_attr ;
        unsignedShort m_day_attr ;
        bool m_has_hour_attr ;
        unsignedShort m_hour_attr ;
        bool m_has_minute_attr ;
        unsignedShort m_minute_attr ;
        bool m_has_second_attr ;
        unsignedShort m_second_attr ;
        bool m_has_dateTimeGrouping_attr ;
        ST_DateTimeGrouping* m_dateTimeGrouping_attr ;

    }

    class CT_XStringElement : public XSD::ComplexType{
    public:
        void clear(){

                m_has_v_attr = false;
                
        if (m_v_attr)
        {
            delete m_v_attr;
            m_v_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_v_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_XStringElement& default_instance(){

    if (!CT_XStringElement::default_instance_)
    {
        CT_XStringElement::default_instance_ = new CT_XStringElement();
    }
    return *CT_XStringElement::default_instance_;

        }
        bool has_v_attr(){

            return m_has_v_attr;
        
        }
        void set_v_attr(const ns_s::ST_Xstring& _v_attr ){

            m_has_v_attr = true;
            m_v_attr = new ns_s::ST_Xstring(_v_attr);
        
        }
        const ns_s::ST_Xstring& v_attr(){

            if (m_v_attr)
            {
                return *m_v_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }

    private:
        static CT_XStringElement* default_instance_ ;
        bool m_has_v_attr ;
        ns_s::ST_Xstring* m_v_attr ;

    }

    class CT_Extension : public XSD::ComplexType{
    public:
        void clear(){

                m_has_uri_attr = false;
                m_uri_attr.clear();
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_uri_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Extension& default_instance(){

    if (!CT_Extension::default_instance_)
    {
        CT_Extension::default_instance_ = new CT_Extension();
    }
    return *CT_Extension::default_instance_;

        }
        bool has_uri_attr(){

            return m_has_uri_attr;
        
        }
        void set_uri_attr(const token& _uri_attr ){

        m_has_uri_attr = true;
        m_uri_attr = _uri_attr;
        
        }
        const token& uri_attr(){

            return type: 	oken\nname: \m_uri_attr\n;
        
        }

    private:
        static CT_Extension* default_instance_ ;
        bool m_has_uri_attr ;
        token m_uri_attr ;

    }

    class CT_ObjectAnchor : public XSD::ComplexType{
    public:
        bool has_from(){

            return m_has_from;
        
        }
        CT_Marker* mutable_from(){

                m_has_from = true;
                if (!m_from)
                {
                    m_from = new CT_Marker();
                }
                return m_from;
            
        }
        const CT_Marker& from(){

            if (m_from)
            {
                return *m_from;
            }
            return CT_Marker::default_instance();
        
        }
        bool has_to(){

            return m_has_to;
        
        }
        CT_Marker* mutable_to(){

                m_has_to = true;
                if (!m_to)
                {
                    m_to = new CT_Marker();
                }
                return m_to;
            
        }
        const CT_Marker& to(){

            if (m_to)
            {
                return *m_to;
            }
            return CT_Marker::default_instance();
        
        }
        void clear(){

                m_has_moveWithCells_attr = false;
                m_moveWithCells_attr = false;
            
                m_has_sizeWithCells_attr = false;
                m_sizeWithCells_attr = false;
            
                m_has_from = false;
                
        if (m_from)
        {
            delete m_from;
            m_from = NULL;
        }
    
            
                m_has_to = false;
                
        if (m_to)
        {
            delete m_to;
            m_to = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_moveWithCells_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_sizeWithCells_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_from)
                {
                    m_from->toXml(from, _outStream);;
                }
            
                if (m_has_to)
                {
                    m_from->toXml(to, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_ObjectAnchor& default_instance(){

    if (!CT_ObjectAnchor::default_instance_)
    {
        CT_ObjectAnchor::default_instance_ = new CT_ObjectAnchor();
    }
    return *CT_ObjectAnchor::default_instance_;

        }
        bool has_moveWithCells_attr(){

            return m_has_moveWithCells_attr;
        
        }
        void set_moveWithCells_attr(const boolean& _moveWithCells_attr ){

        m_has_moveWithCells_attr = true;
        m_moveWithCells_attr = _moveWithCells_attr;
        
        }
        const boolean& moveWithCells_attr(){

            return type: oolean\nname: \m_moveWithCells_attr\n;
        
        }
        bool has_sizeWithCells_attr(){

            return m_has_sizeWithCells_attr;
        
        }
        void set_sizeWithCells_attr(const boolean& _sizeWithCells_attr ){

        m_has_sizeWithCells_attr = true;
        m_sizeWithCells_attr = _sizeWithCells_attr;
        
        }
        const boolean& sizeWithCells_attr(){

            return type: oolean\nname: \m_sizeWithCells_attr\n;
        
        }

    private:
        bool m_has_from ;
        CT_Marker* m_from ;
        bool m_has_to ;
        CT_Marker* m_to ;
        static CT_ObjectAnchor* default_instance_ ;
        bool m_has_moveWithCells_attr ;
        boolean m_moveWithCells_attr ;
        bool m_has_sizeWithCells_attr ;
        boolean m_sizeWithCells_attr ;

    }

    class CT_ExtensionList : public XSD::ComplexType{
    public:
        bool has_ext(){

            return m_has_ext;
        
        }
        CT_Extension* mutable_ext(){

                m_has_ext = true;
                if (!m_ext)
                {
                    m_ext = new CT_Extension();
                }
                return m_ext;
            
        }
        const CT_Extension& ext(){

            if (m_ext)
            {
                return *m_ext;
            }
            return CT_Extension::default_instance();
        
        }
        void clear(){

                m_has_ext = false;
                
        if (m_ext)
        {
            delete m_ext;
            m_ext = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_ext)
                {
                    m_ext->toXml(ext, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_ExtensionList& default_instance(){

    if (!CT_ExtensionList::default_instance_)
    {
        CT_ExtensionList::default_instance_ = new CT_ExtensionList();
    }
    return *CT_ExtensionList::default_instance_;

        }

    private:
        bool m_has_ext ;
        CT_Extension* m_ext ;
        static CT_ExtensionList* default_instance_ ;

    }

    class CT_CalcChain : public XSD::ComplexType{
    public:
        bool has_c(){

            return m_has_c;
        
        }
        CT_CalcCell* mutable_c(){

                m_has_c = true;
                if (!m_c)
                {
                    m_c = new CT_CalcCell();
                }
                return m_c;
            
        }
        const CT_CalcCell& c(){

            if (m_c)
            {
                return *m_c;
            }
            return CT_CalcCell::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_c = false;
                
        if (m_c)
        {
            delete m_c;
            m_c = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_c)
                {
                    m_c->toXml(c, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_c->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CalcChain& default_instance(){

    if (!CT_CalcChain::default_instance_)
    {
        CT_CalcChain::default_instance_ = new CT_CalcChain();
    }
    return *CT_CalcChain::default_instance_;

        }

    private:
        bool m_has_c ;
        CT_CalcCell* m_c ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_CalcChain* default_instance_ ;

    }

    class CT_CalcCell : public XSD::ComplexType{
    public:
        void clear(){

                m_has_r_attr = false;
                
        if (m_r_attr)
        {
            delete m_r_attr;
            m_r_attr = NULL;
        }
    
            
                m_has_ref_attr = false;
                
        if (m_ref_attr)
        {
            delete m_ref_attr;
            m_ref_attr = NULL;
        }
    
            
                m_has_i_attr = false;
                m_i_attr = 0;
            
                m_has_s_attr = false;
                m_s_attr = false;
            
                m_has_l_attr = false;
                m_l_attr = false;
            
                m_has_t_attr = false;
                m_t_attr = false;
            
                m_has_a_attr = false;
                m_a_attr = false;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_r_attr->toXml(_attrName, _outStream);
m_ref_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_i_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_s_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_l_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_t_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_a_attr) << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CalcCell& default_instance(){

    if (!CT_CalcCell::default_instance_)
    {
        CT_CalcCell::default_instance_ = new CT_CalcCell();
    }
    return *CT_CalcCell::default_instance_;

        }
        bool has_r_attr(){

            return m_has_r_attr;
        
        }
        void set_r_attr(const ST_CellRef& _r_attr ){

            m_has_r_attr = true;
            m_r_attr = new ST_CellRef(_r_attr);
        
        }
        const ST_CellRef& r_attr(){

            if (m_r_attr)
            {
                return *m_r_attr;
            }
            return ST_CellRef::default_instance();
        
        }
        bool has_ref_attr(){

            return m_has_ref_attr;
        
        }
        void set_ref_attr(const ST_CellRef& _ref_attr ){

            m_has_ref_attr = true;
            m_ref_attr = new ST_CellRef(_ref_attr);
        
        }
        const ST_CellRef& ref_attr(){

            if (m_ref_attr)
            {
                return *m_ref_attr;
            }
            return ST_CellRef::default_instance();
        
        }
        bool has_i_attr(){

            return m_has_i_attr;
        
        }
        void set_i_attr(const int& _i_attr ){

        m_has_i_attr = true;
        m_i_attr = _i_attr;
        
        }
        const int& i_attr(){

            return type: \int\nname: \m_i_attr\n;
        
        }
        bool has_s_attr(){

            return m_has_s_attr;
        
        }
        void set_s_attr(const boolean& _s_attr ){

        m_has_s_attr = true;
        m_s_attr = _s_attr;
        
        }
        const boolean& s_attr(){

            return type: oolean\nname: \m_s_attr\n;
        
        }
        bool has_l_attr(){

            return m_has_l_attr;
        
        }
        void set_l_attr(const boolean& _l_attr ){

        m_has_l_attr = true;
        m_l_attr = _l_attr;
        
        }
        const boolean& l_attr(){

            return type: oolean\nname: \m_l_attr\n;
        
        }
        bool has_t_attr(){

            return m_has_t_attr;
        
        }
        void set_t_attr(const boolean& _t_attr ){

        m_has_t_attr = true;
        m_t_attr = _t_attr;
        
        }
        const boolean& t_attr(){

            return type: oolean\nname: \m_t_attr\n;
        
        }
        bool has_a_attr(){

            return m_has_a_attr;
        
        }
        void set_a_attr(const boolean& _a_attr ){

        m_has_a_attr = true;
        m_a_attr = _a_attr;
        
        }
        const boolean& a_attr(){

            return type: oolean\nname: \m_a_attr\n;
        
        }

    private:
        static CT_CalcCell* default_instance_ ;
        bool m_has_r_attr ;
        ST_CellRef* m_r_attr ;
        bool m_has_ref_attr ;
        ST_CellRef* m_ref_attr ;
        bool m_has_i_attr ;
        int m_i_attr ;
        bool m_has_s_attr ;
        boolean m_s_attr ;
        bool m_has_l_attr ;
        boolean m_l_attr ;
        bool m_has_t_attr ;
        boolean m_t_attr ;
        bool m_has_a_attr ;
        boolean m_a_attr ;

    }

    class CT_Comments : public XSD::ComplexType{
    public:
        bool has_authors(){

            return m_has_authors;
        
        }
        CT_Authors* mutable_authors(){

                m_has_authors = true;
                if (!m_authors)
                {
                    m_authors = new CT_Authors();
                }
                return m_authors;
            
        }
        const CT_Authors& authors(){

            if (m_authors)
            {
                return *m_authors;
            }
            return CT_Authors::default_instance();
        
        }
        bool has_commentList(){

            return m_has_commentList;
        
        }
        CT_CommentList* mutable_commentList(){

                m_has_commentList = true;
                if (!m_commentList)
                {
                    m_commentList = new CT_CommentList();
                }
                return m_commentList;
            
        }
        const CT_CommentList& commentList(){

            if (m_commentList)
            {
                return *m_commentList;
            }
            return CT_CommentList::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_authors = false;
                
        if (m_authors)
        {
            delete m_authors;
            m_authors = NULL;
        }
    
            
                m_has_commentList = false;
                
        if (m_commentList)
        {
            delete m_commentList;
            m_commentList = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_authors)
                {
                    m_authors->toXml(authors, _outStream);;
                }
            
                if (m_has_commentList)
                {
                    m_authors->toXml(commentList, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_authors->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Comments& default_instance(){

    if (!CT_Comments::default_instance_)
    {
        CT_Comments::default_instance_ = new CT_Comments();
    }
    return *CT_Comments::default_instance_;

        }

    private:
        bool m_has_authors ;
        CT_Authors* m_authors ;
        bool m_has_commentList ;
        CT_CommentList* m_commentList ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_Comments* default_instance_ ;

    }

    class CT_Authors : public XSD::ComplexType{
    public:
        bool has_author(){

            return m_has_author;
        
        }
        ns_s::ST_Xstring* mutable_author(){

                m_has_author = true;
                if (!m_author)
                {
                    m_author = new ns_s::ST_Xstring();
                }
                return m_author;
            
        }
        const ns_s::ST_Xstring& author(){

            if (m_author)
            {
                return *m_author;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        void clear(){

                m_has_author = false;
                
        if (m_author)
        {
            delete m_author;
            m_author = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_author)
                {
                    _outStream << \<author>\ << m_author->toString() << \</author>\;;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Authors& default_instance(){

    if (!CT_Authors::default_instance_)
    {
        CT_Authors::default_instance_ = new CT_Authors();
    }
    return *CT_Authors::default_instance_;

        }

    private:
        bool m_has_author ;
        ns_s::ST_Xstring* m_author ;
        static CT_Authors* default_instance_ ;

    }

    class CT_CommentList : public XSD::ComplexType{
    public:
        bool has_comment(){

            return m_has_comment;
        
        }
        CT_Comment* mutable_comment(){

                m_has_comment = true;
                if (!m_comment)
                {
                    m_comment = new CT_Comment();
                }
                return m_comment;
            
        }
        const CT_Comment& comment(){

            if (m_comment)
            {
                return *m_comment;
            }
            return CT_Comment::default_instance();
        
        }
        void clear(){

                m_has_comment = false;
                
        if (m_comment)
        {
            delete m_comment;
            m_comment = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_comment)
                {
                    m_comment->toXml(comment, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CommentList& default_instance(){

    if (!CT_CommentList::default_instance_)
    {
        CT_CommentList::default_instance_ = new CT_CommentList();
    }
    return *CT_CommentList::default_instance_;

        }

    private:
        bool m_has_comment ;
        CT_Comment* m_comment ;
        static CT_CommentList* default_instance_ ;

    }

    class CT_Comment : public XSD::ComplexType{
    public:
        bool has_text(){

            return m_has_text;
        
        }
        CT_Rst* mutable_text(){

                m_has_text = true;
                if (!m_text)
                {
                    m_text = new CT_Rst();
                }
                return m_text;
            
        }
        const CT_Rst& text(){

            if (m_text)
            {
                return *m_text;
            }
            return CT_Rst::default_instance();
        
        }
        bool has_commentPr(){

            return m_has_commentPr;
        
        }
        CT_CommentPr* mutable_commentPr(){

                m_has_commentPr = true;
                if (!m_commentPr)
                {
                    m_commentPr = new CT_CommentPr();
                }
                return m_commentPr;
            
        }
        const CT_CommentPr& commentPr(){

            if (m_commentPr)
            {
                return *m_commentPr;
            }
            return CT_CommentPr::default_instance();
        
        }
        void clear(){

                m_has_ref_attr = false;
                
        if (m_ref_attr)
        {
            delete m_ref_attr;
            m_ref_attr = NULL;
        }
    
            
                m_has_authorId_attr = false;
                m_authorId_attr = 0;
            
                m_has_guid_attr = false;
                
        if (m_guid_attr)
        {
            delete m_guid_attr;
            m_guid_attr = NULL;
        }
    
            
                m_has_shapeId_attr = false;
                m_shapeId_attr = 0;
            
                m_has_text = false;
                
        if (m_text)
        {
            delete m_text;
            m_text = NULL;
        }
    
            
                m_has_commentPr = false;
                
        if (m_commentPr)
        {
            delete m_commentPr;
            m_commentPr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_ref_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_authorId_attr << \\\;
m_guid_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_shapeId_attr << \\\;
        _outStream << \>\;
    
                if (m_has_text)
                {
                    m_text->toXml(text, _outStream);;
                }
            
                if (m_has_commentPr)
                {
                    m_text->toXml(commentPr, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Comment& default_instance(){

    if (!CT_Comment::default_instance_)
    {
        CT_Comment::default_instance_ = new CT_Comment();
    }
    return *CT_Comment::default_instance_;

        }
        bool has_ref_attr(){

            return m_has_ref_attr;
        
        }
        void set_ref_attr(const ST_Ref& _ref_attr ){

            m_has_ref_attr = true;
            m_ref_attr = new ST_Ref(_ref_attr);
        
        }
        const ST_Ref& ref_attr(){

            if (m_ref_attr)
            {
                return *m_ref_attr;
            }
            return ST_Ref::default_instance();
        
        }
        bool has_authorId_attr(){

            return m_has_authorId_attr;
        
        }
        void set_authorId_attr(const unsignedInt& _authorId_attr ){

        m_has_authorId_attr = true;
        m_authorId_attr = _authorId_attr;
        
        }
        const unsignedInt& authorId_attr(){

            return type: \unsignedInt\nname: \m_authorId_attr\n;
        
        }
        bool has_guid_attr(){

            return m_has_guid_attr;
        
        }
        void set_guid_attr(const ns_s::ST_Guid& _guid_attr ){

            m_has_guid_attr = true;
            m_guid_attr = new ns_s::ST_Guid(_guid_attr);
        
        }
        const ns_s::ST_Guid& guid_attr(){

            if (m_guid_attr)
            {
                return *m_guid_attr;
            }
            return ns_s::ST_Guid::default_instance();
        
        }
        bool has_shapeId_attr(){

            return m_has_shapeId_attr;
        
        }
        void set_shapeId_attr(const unsignedInt& _shapeId_attr ){

        m_has_shapeId_attr = true;
        m_shapeId_attr = _shapeId_attr;
        
        }
        const unsignedInt& shapeId_attr(){

            return type: \unsignedInt\nname: \m_shapeId_attr\n;
        
        }

    private:
        bool m_has_text ;
        CT_Rst* m_text ;
        bool m_has_commentPr ;
        CT_CommentPr* m_commentPr ;
        static CT_Comment* default_instance_ ;
        bool m_has_ref_attr ;
        ST_Ref* m_ref_attr ;
        bool m_has_authorId_attr ;
        unsignedInt m_authorId_attr ;
        bool m_has_guid_attr ;
        ns_s::ST_Guid* m_guid_attr ;
        bool m_has_shapeId_attr ;
        unsignedInt m_shapeId_attr ;

    }

    class CT_CommentPr : public XSD::ComplexType{
    public:
        bool has_anchor(){

            return m_has_anchor;
        
        }
        CT_ObjectAnchor* mutable_anchor(){

                m_has_anchor = true;
                if (!m_anchor)
                {
                    m_anchor = new CT_ObjectAnchor();
                }
                return m_anchor;
            
        }
        const CT_ObjectAnchor& anchor(){

            if (m_anchor)
            {
                return *m_anchor;
            }
            return CT_ObjectAnchor::default_instance();
        
        }
        void clear(){

                m_has_locked_attr = false;
                m_locked_attr = false;
            
                m_has_defaultSize_attr = false;
                m_defaultSize_attr = false;
            
                m_has_print_attr = false;
                m_print_attr = false;
            
                m_has_disabled_attr = false;
                m_disabled_attr = false;
            
                m_has_autoFill_attr = false;
                m_autoFill_attr = false;
            
                m_has_autoLine_attr = false;
                m_autoLine_attr = false;
            
                m_has_altText_attr = false;
                
        if (m_altText_attr)
        {
            delete m_altText_attr;
            m_altText_attr = NULL;
        }
    
            
                m_has_textHAlign_attr = false;
                
        if (m_textHAlign_attr)
        {
            delete m_textHAlign_attr;
            m_textHAlign_attr = NULL;
        }
    
            
                m_has_textVAlign_attr = false;
                
        if (m_textVAlign_attr)
        {
            delete m_textVAlign_attr;
            m_textVAlign_attr = NULL;
        }
    
            
                m_has_lockText_attr = false;
                m_lockText_attr = false;
            
                m_has_justLastX_attr = false;
                m_justLastX_attr = false;
            
                m_has_autoScale_attr = false;
                m_autoScale_attr = false;
            
                m_has_anchor = false;
                
        if (m_anchor)
        {
            delete m_anchor;
            m_anchor = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_locked_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_defaultSize_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_print_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_disabled_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_autoFill_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_autoLine_attr) << \\\;
m_altText_attr->toXml(_attrName, _outStream);
m_textHAlign_attr->toXml(_attrName, _outStream);
m_textVAlign_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_lockText_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_justLastX_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_autoScale_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_anchor)
                {
                    m_anchor->toXml(anchor, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CommentPr& default_instance(){

    if (!CT_CommentPr::default_instance_)
    {
        CT_CommentPr::default_instance_ = new CT_CommentPr();
    }
    return *CT_CommentPr::default_instance_;

        }
        bool has_locked_attr(){

            return m_has_locked_attr;
        
        }
        void set_locked_attr(const boolean& _locked_attr ){

        m_has_locked_attr = true;
        m_locked_attr = _locked_attr;
        
        }
        const boolean& locked_attr(){

            return type: oolean\nname: \m_locked_attr\n;
        
        }
        bool has_defaultSize_attr(){

            return m_has_defaultSize_attr;
        
        }
        void set_defaultSize_attr(const boolean& _defaultSize_attr ){

        m_has_defaultSize_attr = true;
        m_defaultSize_attr = _defaultSize_attr;
        
        }
        const boolean& defaultSize_attr(){

            return type: oolean\nname: \m_defaultSize_attr\n;
        
        }
        bool has_print_attr(){

            return m_has_print_attr;
        
        }
        void set_print_attr(const boolean& _print_attr ){

        m_has_print_attr = true;
        m_print_attr = _print_attr;
        
        }
        const boolean& print_attr(){

            return type: oolean\nname: \m_print_attr\n;
        
        }
        bool has_disabled_attr(){

            return m_has_disabled_attr;
        
        }
        void set_disabled_attr(const boolean& _disabled_attr ){

        m_has_disabled_attr = true;
        m_disabled_attr = _disabled_attr;
        
        }
        const boolean& disabled_attr(){

            return type: oolean\nname: \m_disabled_attr\n;
        
        }
        bool has_autoFill_attr(){

            return m_has_autoFill_attr;
        
        }
        void set_autoFill_attr(const boolean& _autoFill_attr ){

        m_has_autoFill_attr = true;
        m_autoFill_attr = _autoFill_attr;
        
        }
        const boolean& autoFill_attr(){

            return type: oolean\nname: \m_autoFill_attr\n;
        
        }
        bool has_autoLine_attr(){

            return m_has_autoLine_attr;
        
        }
        void set_autoLine_attr(const boolean& _autoLine_attr ){

        m_has_autoLine_attr = true;
        m_autoLine_attr = _autoLine_attr;
        
        }
        const boolean& autoLine_attr(){

            return type: oolean\nname: \m_autoLine_attr\n;
        
        }
        bool has_altText_attr(){

            return m_has_altText_attr;
        
        }
        void set_altText_attr(const ns_s::ST_Xstring& _altText_attr ){

            m_has_altText_attr = true;
            m_altText_attr = new ns_s::ST_Xstring(_altText_attr);
        
        }
        const ns_s::ST_Xstring& altText_attr(){

            if (m_altText_attr)
            {
                return *m_altText_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_textHAlign_attr(){

            return m_has_textHAlign_attr;
        
        }
        void set_textHAlign_attr(const ST_TextHAlign& _textHAlign_attr ){

            m_has_textHAlign_attr = true;
            m_textHAlign_attr = new ST_TextHAlign(_textHAlign_attr);
        
        }
        const ST_TextHAlign& textHAlign_attr(){

            if (m_textHAlign_attr)
            {
                return *m_textHAlign_attr;
            }
            return ST_TextHAlign::default_instance();
        
        }
        bool has_textVAlign_attr(){

            return m_has_textVAlign_attr;
        
        }
        void set_textVAlign_attr(const ST_TextVAlign& _textVAlign_attr ){

            m_has_textVAlign_attr = true;
            m_textVAlign_attr = new ST_TextVAlign(_textVAlign_attr);
        
        }
        const ST_TextVAlign& textVAlign_attr(){

            if (m_textVAlign_attr)
            {
                return *m_textVAlign_attr;
            }
            return ST_TextVAlign::default_instance();
        
        }
        bool has_lockText_attr(){

            return m_has_lockText_attr;
        
        }
        void set_lockText_attr(const boolean& _lockText_attr ){

        m_has_lockText_attr = true;
        m_lockText_attr = _lockText_attr;
        
        }
        const boolean& lockText_attr(){

            return type: oolean\nname: \m_lockText_attr\n;
        
        }
        bool has_justLastX_attr(){

            return m_has_justLastX_attr;
        
        }
        void set_justLastX_attr(const boolean& _justLastX_attr ){

        m_has_justLastX_attr = true;
        m_justLastX_attr = _justLastX_attr;
        
        }
        const boolean& justLastX_attr(){

            return type: oolean\nname: \m_justLastX_attr\n;
        
        }
        bool has_autoScale_attr(){

            return m_has_autoScale_attr;
        
        }
        void set_autoScale_attr(const boolean& _autoScale_attr ){

        m_has_autoScale_attr = true;
        m_autoScale_attr = _autoScale_attr;
        
        }
        const boolean& autoScale_attr(){

            return type: oolean\nname: \m_autoScale_attr\n;
        
        }

    private:
        bool m_has_anchor ;
        CT_ObjectAnchor* m_anchor ;
        static CT_CommentPr* default_instance_ ;
        bool m_has_locked_attr ;
        boolean m_locked_attr ;
        bool m_has_defaultSize_attr ;
        boolean m_defaultSize_attr ;
        bool m_has_print_attr ;
        boolean m_print_attr ;
        bool m_has_disabled_attr ;
        boolean m_disabled_attr ;
        bool m_has_autoFill_attr ;
        boolean m_autoFill_attr ;
        bool m_has_autoLine_attr ;
        boolean m_autoLine_attr ;
        bool m_has_altText_attr ;
        ns_s::ST_Xstring* m_altText_attr ;
        bool m_has_textHAlign_attr ;
        ST_TextHAlign* m_textHAlign_attr ;
        bool m_has_textVAlign_attr ;
        ST_TextVAlign* m_textVAlign_attr ;
        bool m_has_lockText_attr ;
        boolean m_lockText_attr ;
        bool m_has_justLastX_attr ;
        boolean m_justLastX_attr ;
        bool m_has_autoScale_attr ;
        boolean m_autoScale_attr ;

    }

    class CT_MapInfo : public XSD::ComplexType{
    public:
        bool has_Schema(){

            return m_has_Schema;
        
        }
        CT_Schema* mutable_Schema(){

                m_has_Schema = true;
                if (!m_Schema)
                {
                    m_Schema = new CT_Schema();
                }
                return m_Schema;
            
        }
        const CT_Schema& Schema(){

            if (m_Schema)
            {
                return *m_Schema;
            }
            return CT_Schema::default_instance();
        
        }
        bool has_Map(){

            return m_has_Map;
        
        }
        CT_Map* mutable_Map(){

                m_has_Map = true;
                if (!m_Map)
                {
                    m_Map = new CT_Map();
                }
                return m_Map;
            
        }
        const CT_Map& Map(){

            if (m_Map)
            {
                return *m_Map;
            }
            return CT_Map::default_instance();
        
        }
        void clear(){

                m_has_SelectionNamespaces_attr = false;
                m_SelectionNamespaces_attr.clear();
            
                m_has_Schema = false;
                
        if (m_Schema)
        {
            delete m_Schema;
            m_Schema = NULL;
        }
    
            
                m_has_Map = false;
                
        if (m_Map)
        {
            delete m_Map;
            m_Map = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_SelectionNamespaces_attr << \\\;
        _outStream << \>\;
    
                if (m_has_Schema)
                {
                    m_Schema->toXml(Schema, _outStream);;
                }
            
                if (m_has_Map)
                {
                    m_Schema->toXml(Map, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_MapInfo& default_instance(){

    if (!CT_MapInfo::default_instance_)
    {
        CT_MapInfo::default_instance_ = new CT_MapInfo();
    }
    return *CT_MapInfo::default_instance_;

        }
        bool has_SelectionNamespaces_attr(){

            return m_has_SelectionNamespaces_attr;
        
        }
        void set_SelectionNamespaces_attr(const string& _SelectionNamespaces_attr ){

        m_has_SelectionNamespaces_attr = true;
        m_SelectionNamespaces_attr = _SelectionNamespaces_attr;
        
        }
        const string& SelectionNamespaces_attr(){

            return type: \string\nname: \m_SelectionNamespaces_attr\n;
        
        }

    private:
        bool m_has_Schema ;
        CT_Schema* m_Schema ;
        bool m_has_Map ;
        CT_Map* m_Map ;
        static CT_MapInfo* default_instance_ ;
        bool m_has_SelectionNamespaces_attr ;
        string m_SelectionNamespaces_attr ;

    }

    class CT_Schema : public XSD::ComplexType{
    public:
        void clear(){

                m_has_ID_attr = false;
                m_ID_attr.clear();
            
                m_has_SchemaRef_attr = false;
                m_SchemaRef_attr.clear();
            
                m_has_Namespace_attr = false;
                m_Namespace_attr.clear();
            
                m_has_SchemaLanguage_attr = false;
                m_SchemaLanguage_attr.clear();
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_ID_attr << \\\;
_outStream << _attrName << \=\\ << m_SchemaRef_attr << \\\;
_outStream << _attrName << \=\\ << m_Namespace_attr << \\\;
_outStream << _attrName << \=\\ << m_SchemaLanguage_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Schema& default_instance(){

    if (!CT_Schema::default_instance_)
    {
        CT_Schema::default_instance_ = new CT_Schema();
    }
    return *CT_Schema::default_instance_;

        }
        bool has_ID_attr(){

            return m_has_ID_attr;
        
        }
        void set_ID_attr(const string& _ID_attr ){

        m_has_ID_attr = true;
        m_ID_attr = _ID_attr;
        
        }
        const string& ID_attr(){

            return type: \string\nname: \m_ID_attr\n;
        
        }
        bool has_SchemaRef_attr(){

            return m_has_SchemaRef_attr;
        
        }
        void set_SchemaRef_attr(const string& _SchemaRef_attr ){

        m_has_SchemaRef_attr = true;
        m_SchemaRef_attr = _SchemaRef_attr;
        
        }
        const string& SchemaRef_attr(){

            return type: \string\nname: \m_SchemaRef_attr\n;
        
        }
        bool has_Namespace_attr(){

            return m_has_Namespace_attr;
        
        }
        void set_Namespace_attr(const string& _Namespace_attr ){

        m_has_Namespace_attr = true;
        m_Namespace_attr = _Namespace_attr;
        
        }
        const string& Namespace_attr(){

            return type: \string\nname: \m_Namespace_attr\n;
        
        }
        bool has_SchemaLanguage_attr(){

            return m_has_SchemaLanguage_attr;
        
        }
        void set_SchemaLanguage_attr(const token& _SchemaLanguage_attr ){

        m_has_SchemaLanguage_attr = true;
        m_SchemaLanguage_attr = _SchemaLanguage_attr;
        
        }
        const token& SchemaLanguage_attr(){

            return type: 	oken\nname: \m_SchemaLanguage_attr\n;
        
        }

    private:
        static CT_Schema* default_instance_ ;
        bool m_has_ID_attr ;
        string m_ID_attr ;
        bool m_has_SchemaRef_attr ;
        string m_SchemaRef_attr ;
        bool m_has_Namespace_attr ;
        string m_Namespace_attr ;
        bool m_has_SchemaLanguage_attr ;
        token m_SchemaLanguage_attr ;

    }

    class CT_Map : public XSD::ComplexType{
    public:
        bool has_DataBinding(){

            return m_has_DataBinding;
        
        }
        CT_DataBinding* mutable_DataBinding(){

                m_has_DataBinding = true;
                if (!m_DataBinding)
                {
                    m_DataBinding = new CT_DataBinding();
                }
                return m_DataBinding;
            
        }
        const CT_DataBinding& DataBinding(){

            if (m_DataBinding)
            {
                return *m_DataBinding;
            }
            return CT_DataBinding::default_instance();
        
        }
        void clear(){

                m_has_ID_attr = false;
                m_ID_attr = 0;
            
                m_has_Name_attr = false;
                m_Name_attr.clear();
            
                m_has_RootElement_attr = false;
                m_RootElement_attr.clear();
            
                m_has_SchemaID_attr = false;
                m_SchemaID_attr.clear();
            
                m_has_ShowImportExportValidationErrors_attr = false;
                m_ShowImportExportValidationErrors_attr = false;
            
                m_has_AutoFit_attr = false;
                m_AutoFit_attr = false;
            
                m_has_Append_attr = false;
                m_Append_attr = false;
            
                m_has_PreserveSortAFLayout_attr = false;
                m_PreserveSortAFLayout_attr = false;
            
                m_has_PreserveFormat_attr = false;
                m_PreserveFormat_attr = false;
            
                m_has_DataBinding = false;
                
        if (m_DataBinding)
        {
            delete m_DataBinding;
            m_DataBinding = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_ID_attr << \\\;
_outStream << _attrName << \=\\ << m_Name_attr << \\\;
_outStream << _attrName << \=\\ << m_RootElement_attr << \\\;
_outStream << _attrName << \=\\ << m_SchemaID_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_ShowImportExportValidationErrors_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_AutoFit_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_Append_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_PreserveSortAFLayout_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_PreserveFormat_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_DataBinding)
                {
                    m_DataBinding->toXml(DataBinding, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Map& default_instance(){

    if (!CT_Map::default_instance_)
    {
        CT_Map::default_instance_ = new CT_Map();
    }
    return *CT_Map::default_instance_;

        }
        bool has_ID_attr(){

            return m_has_ID_attr;
        
        }
        void set_ID_attr(const unsignedInt& _ID_attr ){

        m_has_ID_attr = true;
        m_ID_attr = _ID_attr;
        
        }
        const unsignedInt& ID_attr(){

            return type: \unsignedInt\nname: \m_ID_attr\n;
        
        }
        bool has_Name_attr(){

            return m_has_Name_attr;
        
        }
        void set_Name_attr(const string& _Name_attr ){

        m_has_Name_attr = true;
        m_Name_attr = _Name_attr;
        
        }
        const string& Name_attr(){

            return type: \string\nname: \m_Name_attr\n;
        
        }
        bool has_RootElement_attr(){

            return m_has_RootElement_attr;
        
        }
        void set_RootElement_attr(const string& _RootElement_attr ){

        m_has_RootElement_attr = true;
        m_RootElement_attr = _RootElement_attr;
        
        }
        const string& RootElement_attr(){

            return type: \string\nname: \m_RootElement_attr\n;
        
        }
        bool has_SchemaID_attr(){

            return m_has_SchemaID_attr;
        
        }
        void set_SchemaID_attr(const string& _SchemaID_attr ){

        m_has_SchemaID_attr = true;
        m_SchemaID_attr = _SchemaID_attr;
        
        }
        const string& SchemaID_attr(){

            return type: \string\nname: \m_SchemaID_attr\n;
        
        }
        bool has_ShowImportExportValidationErrors_attr(){

            return m_has_ShowImportExportValidationErrors_attr;
        
        }
        void set_ShowImportExportValidationErrors_attr(const boolean& _ShowImportExportValidationErrors_attr ){

        m_has_ShowImportExportValidationErrors_attr = true;
        m_ShowImportExportValidationErrors_attr = _ShowImportExportValidationErrors_attr;
        
        }
        const boolean& ShowImportExportValidationErrors_attr(){

            return type: oolean\nname: \m_ShowImportExportValidationErrors_attr\n;
        
        }
        bool has_AutoFit_attr(){

            return m_has_AutoFit_attr;
        
        }
        void set_AutoFit_attr(const boolean& _AutoFit_attr ){

        m_has_AutoFit_attr = true;
        m_AutoFit_attr = _AutoFit_attr;
        
        }
        const boolean& AutoFit_attr(){

            return type: oolean\nname: \m_AutoFit_attr\n;
        
        }
        bool has_Append_attr(){

            return m_has_Append_attr;
        
        }
        void set_Append_attr(const boolean& _Append_attr ){

        m_has_Append_attr = true;
        m_Append_attr = _Append_attr;
        
        }
        const boolean& Append_attr(){

            return type: oolean\nname: \m_Append_attr\n;
        
        }
        bool has_PreserveSortAFLayout_attr(){

            return m_has_PreserveSortAFLayout_attr;
        
        }
        void set_PreserveSortAFLayout_attr(const boolean& _PreserveSortAFLayout_attr ){

        m_has_PreserveSortAFLayout_attr = true;
        m_PreserveSortAFLayout_attr = _PreserveSortAFLayout_attr;
        
        }
        const boolean& PreserveSortAFLayout_attr(){

            return type: oolean\nname: \m_PreserveSortAFLayout_attr\n;
        
        }
        bool has_PreserveFormat_attr(){

            return m_has_PreserveFormat_attr;
        
        }
        void set_PreserveFormat_attr(const boolean& _PreserveFormat_attr ){

        m_has_PreserveFormat_attr = true;
        m_PreserveFormat_attr = _PreserveFormat_attr;
        
        }
        const boolean& PreserveFormat_attr(){

            return type: oolean\nname: \m_PreserveFormat_attr\n;
        
        }

    private:
        bool m_has_DataBinding ;
        CT_DataBinding* m_DataBinding ;
        static CT_Map* default_instance_ ;
        bool m_has_ID_attr ;
        unsignedInt m_ID_attr ;
        bool m_has_Name_attr ;
        string m_Name_attr ;
        bool m_has_RootElement_attr ;
        string m_RootElement_attr ;
        bool m_has_SchemaID_attr ;
        string m_SchemaID_attr ;
        bool m_has_ShowImportExportValidationErrors_attr ;
        boolean m_ShowImportExportValidationErrors_attr ;
        bool m_has_AutoFit_attr ;
        boolean m_AutoFit_attr ;
        bool m_has_Append_attr ;
        boolean m_Append_attr ;
        bool m_has_PreserveSortAFLayout_attr ;
        boolean m_PreserveSortAFLayout_attr ;
        bool m_has_PreserveFormat_attr ;
        boolean m_PreserveFormat_attr ;

    }

    class CT_DataBinding : public XSD::ComplexType{
    public:
        void clear(){

                m_has_DataBindingName_attr = false;
                m_DataBindingName_attr.clear();
            
                m_has_FileBinding_attr = false;
                m_FileBinding_attr = false;
            
                m_has_ConnectionID_attr = false;
                m_ConnectionID_attr = 0;
            
                m_has_FileBindingName_attr = false;
                m_FileBindingName_attr.clear();
            
                m_has_DataBindingLoadMode_attr = false;
                m_DataBindingLoadMode_attr = 0;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_DataBindingName_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_FileBinding_attr) << \\\;
_outStream << _attrName << \=\\ << m_ConnectionID_attr << \\\;
_outStream << _attrName << \=\\ << m_FileBindingName_attr << \\\;
_outStream << _attrName << \=\\ << m_DataBindingLoadMode_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_DataBinding& default_instance(){

    if (!CT_DataBinding::default_instance_)
    {
        CT_DataBinding::default_instance_ = new CT_DataBinding();
    }
    return *CT_DataBinding::default_instance_;

        }
        bool has_DataBindingName_attr(){

            return m_has_DataBindingName_attr;
        
        }
        void set_DataBindingName_attr(const string& _DataBindingName_attr ){

        m_has_DataBindingName_attr = true;
        m_DataBindingName_attr = _DataBindingName_attr;
        
        }
        const string& DataBindingName_attr(){

            return type: \string\nname: \m_DataBindingName_attr\n;
        
        }
        bool has_FileBinding_attr(){

            return m_has_FileBinding_attr;
        
        }
        void set_FileBinding_attr(const boolean& _FileBinding_attr ){

        m_has_FileBinding_attr = true;
        m_FileBinding_attr = _FileBinding_attr;
        
        }
        const boolean& FileBinding_attr(){

            return type: oolean\nname: \m_FileBinding_attr\n;
        
        }
        bool has_ConnectionID_attr(){

            return m_has_ConnectionID_attr;
        
        }
        void set_ConnectionID_attr(const unsignedInt& _ConnectionID_attr ){

        m_has_ConnectionID_attr = true;
        m_ConnectionID_attr = _ConnectionID_attr;
        
        }
        const unsignedInt& ConnectionID_attr(){

            return type: \unsignedInt\nname: \m_ConnectionID_attr\n;
        
        }
        bool has_FileBindingName_attr(){

            return m_has_FileBindingName_attr;
        
        }
        void set_FileBindingName_attr(const string& _FileBindingName_attr ){

        m_has_FileBindingName_attr = true;
        m_FileBindingName_attr = _FileBindingName_attr;
        
        }
        const string& FileBindingName_attr(){

            return type: \string\nname: \m_FileBindingName_attr\n;
        
        }
        bool has_DataBindingLoadMode_attr(){

            return m_has_DataBindingLoadMode_attr;
        
        }
        void set_DataBindingLoadMode_attr(const unsignedInt& _DataBindingLoadMode_attr ){

        m_has_DataBindingLoadMode_attr = true;
        m_DataBindingLoadMode_attr = _DataBindingLoadMode_attr;
        
        }
        const unsignedInt& DataBindingLoadMode_attr(){

            return type: \unsignedInt\nname: \m_DataBindingLoadMode_attr\n;
        
        }

    private:
        static CT_DataBinding* default_instance_ ;
        bool m_has_DataBindingName_attr ;
        string m_DataBindingName_attr ;
        bool m_has_FileBinding_attr ;
        boolean m_FileBinding_attr ;
        bool m_has_ConnectionID_attr ;
        unsignedInt m_ConnectionID_attr ;
        bool m_has_FileBindingName_attr ;
        string m_FileBindingName_attr ;
        bool m_has_DataBindingLoadMode_attr ;
        unsignedInt m_DataBindingLoadMode_attr ;

    }

    class CT_Connections : public XSD::ComplexType{
    public:
        bool has_connection(){

            return m_has_connection;
        
        }
        CT_Connection* mutable_connection(){

                m_has_connection = true;
                if (!m_connection)
                {
                    m_connection = new CT_Connection();
                }
                return m_connection;
            
        }
        const CT_Connection& connection(){

            if (m_connection)
            {
                return *m_connection;
            }
            return CT_Connection::default_instance();
        
        }
        void clear(){

                m_has_connection = false;
                
        if (m_connection)
        {
            delete m_connection;
            m_connection = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_connection)
                {
                    m_connection->toXml(connection, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Connections& default_instance(){

    if (!CT_Connections::default_instance_)
    {
        CT_Connections::default_instance_ = new CT_Connections();
    }
    return *CT_Connections::default_instance_;

        }

    private:
        bool m_has_connection ;
        CT_Connection* m_connection ;
        static CT_Connections* default_instance_ ;

    }

    class CT_Connection : public XSD::ComplexType{
    public:
        bool has_dbPr(){

            return m_has_dbPr;
        
        }
        CT_DbPr* mutable_dbPr(){

                m_has_dbPr = true;
                if (!m_dbPr)
                {
                    m_dbPr = new CT_DbPr();
                }
                return m_dbPr;
            
        }
        const CT_DbPr& dbPr(){

            if (m_dbPr)
            {
                return *m_dbPr;
            }
            return CT_DbPr::default_instance();
        
        }
        bool has_olapPr(){

            return m_has_olapPr;
        
        }
        CT_OlapPr* mutable_olapPr(){

                m_has_olapPr = true;
                if (!m_olapPr)
                {
                    m_olapPr = new CT_OlapPr();
                }
                return m_olapPr;
            
        }
        const CT_OlapPr& olapPr(){

            if (m_olapPr)
            {
                return *m_olapPr;
            }
            return CT_OlapPr::default_instance();
        
        }
        bool has_webPr(){

            return m_has_webPr;
        
        }
        CT_WebPr* mutable_webPr(){

                m_has_webPr = true;
                if (!m_webPr)
                {
                    m_webPr = new CT_WebPr();
                }
                return m_webPr;
            
        }
        const CT_WebPr& webPr(){

            if (m_webPr)
            {
                return *m_webPr;
            }
            return CT_WebPr::default_instance();
        
        }
        bool has_textPr(){

            return m_has_textPr;
        
        }
        CT_TextPr* mutable_textPr(){

                m_has_textPr = true;
                if (!m_textPr)
                {
                    m_textPr = new CT_TextPr();
                }
                return m_textPr;
            
        }
        const CT_TextPr& textPr(){

            if (m_textPr)
            {
                return *m_textPr;
            }
            return CT_TextPr::default_instance();
        
        }
        bool has_parameters(){

            return m_has_parameters;
        
        }
        CT_Parameters* mutable_parameters(){

                m_has_parameters = true;
                if (!m_parameters)
                {
                    m_parameters = new CT_Parameters();
                }
                return m_parameters;
            
        }
        const CT_Parameters& parameters(){

            if (m_parameters)
            {
                return *m_parameters;
            }
            return CT_Parameters::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_id_attr = false;
                m_id_attr = 0;
            
                m_has_sourceFile_attr = false;
                
        if (m_sourceFile_attr)
        {
            delete m_sourceFile_attr;
            m_sourceFile_attr = NULL;
        }
    
            
                m_has_odcFile_attr = false;
                
        if (m_odcFile_attr)
        {
            delete m_odcFile_attr;
            m_odcFile_attr = NULL;
        }
    
            
                m_has_keepAlive_attr = false;
                m_keepAlive_attr = false;
            
                m_has_interval_attr = false;
                m_interval_attr = 0;
            
                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
                m_has_description_attr = false;
                
        if (m_description_attr)
        {
            delete m_description_attr;
            m_description_attr = NULL;
        }
    
            
                m_has_type_attr = false;
                m_type_attr = 0;
            
                m_has_reconnectionMethod_attr = false;
                m_reconnectionMethod_attr = 0;
            
                m_has_refreshedVersion_attr = false;
                m_refreshedVersion_attr = 0;
            
                m_has_minRefreshableVersion_attr = false;
                m_minRefreshableVersion_attr = 0;
            
                m_has_savePassword_attr = false;
                m_savePassword_attr = false;
            
                m_has_new_attr = false;
                m_new_attr = false;
            
                m_has_deleted_attr = false;
                m_deleted_attr = false;
            
                m_has_onlyUseConnectionFile_attr = false;
                m_onlyUseConnectionFile_attr = false;
            
                m_has_background_attr = false;
                m_background_attr = false;
            
                m_has_refreshOnLoad_attr = false;
                m_refreshOnLoad_attr = false;
            
                m_has_saveData_attr = false;
                m_saveData_attr = false;
            
                m_has_credentials_attr = false;
                
        if (m_credentials_attr)
        {
            delete m_credentials_attr;
            m_credentials_attr = NULL;
        }
    
            
                m_has_singleSignOnId_attr = false;
                
        if (m_singleSignOnId_attr)
        {
            delete m_singleSignOnId_attr;
            m_singleSignOnId_attr = NULL;
        }
    
            
                m_has_dbPr = false;
                
        if (m_dbPr)
        {
            delete m_dbPr;
            m_dbPr = NULL;
        }
    
            
                m_has_olapPr = false;
                
        if (m_olapPr)
        {
            delete m_olapPr;
            m_olapPr = NULL;
        }
    
            
                m_has_webPr = false;
                
        if (m_webPr)
        {
            delete m_webPr;
            m_webPr = NULL;
        }
    
            
                m_has_textPr = false;
                
        if (m_textPr)
        {
            delete m_textPr;
            m_textPr = NULL;
        }
    
            
                m_has_parameters = false;
                
        if (m_parameters)
        {
            delete m_parameters;
            m_parameters = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_id_attr << \\\;
m_sourceFile_attr->toXml(_attrName, _outStream);
m_odcFile_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_keepAlive_attr) << \\\;
_outStream << _attrName << \=\\ << m_interval_attr << \\\;
m_name_attr->toXml(_attrName, _outStream);
m_description_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_type_attr << \\\;
_outStream << _attrName << \=\\ << m_reconnectionMethod_attr << \\\;
_outStream << _attrName << \=\\ << m_refreshedVersion_attr << \\\;
_outStream << _attrName << \=\\ << m_minRefreshableVersion_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_savePassword_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_new_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_deleted_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_onlyUseConnectionFile_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_background_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_refreshOnLoad_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_saveData_attr) << \\\;
m_credentials_attr->toXml(_attrName, _outStream);
m_singleSignOnId_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_dbPr)
                {
                    m_dbPr->toXml(dbPr, _outStream);;
                }
            
                if (m_has_olapPr)
                {
                    m_dbPr->toXml(olapPr, _outStream);;
                }
            
                if (m_has_webPr)
                {
                    m_dbPr->toXml(webPr, _outStream);;
                }
            
                if (m_has_textPr)
                {
                    m_dbPr->toXml(textPr, _outStream);;
                }
            
                if (m_has_parameters)
                {
                    m_dbPr->toXml(parameters, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_dbPr->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Connection& default_instance(){

    if (!CT_Connection::default_instance_)
    {
        CT_Connection::default_instance_ = new CT_Connection();
    }
    return *CT_Connection::default_instance_;

        }
        bool has_id_attr(){

            return m_has_id_attr;
        
        }
        void set_id_attr(const unsignedInt& _id_attr ){

        m_has_id_attr = true;
        m_id_attr = _id_attr;
        
        }
        const unsignedInt& id_attr(){

            return type: \unsignedInt\nname: \m_id_attr\n;
        
        }
        bool has_sourceFile_attr(){

            return m_has_sourceFile_attr;
        
        }
        void set_sourceFile_attr(const ns_s::ST_Xstring& _sourceFile_attr ){

            m_has_sourceFile_attr = true;
            m_sourceFile_attr = new ns_s::ST_Xstring(_sourceFile_attr);
        
        }
        const ns_s::ST_Xstring& sourceFile_attr(){

            if (m_sourceFile_attr)
            {
                return *m_sourceFile_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_odcFile_attr(){

            return m_has_odcFile_attr;
        
        }
        void set_odcFile_attr(const ns_s::ST_Xstring& _odcFile_attr ){

            m_has_odcFile_attr = true;
            m_odcFile_attr = new ns_s::ST_Xstring(_odcFile_attr);
        
        }
        const ns_s::ST_Xstring& odcFile_attr(){

            if (m_odcFile_attr)
            {
                return *m_odcFile_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_keepAlive_attr(){

            return m_has_keepAlive_attr;
        
        }
        void set_keepAlive_attr(const boolean& _keepAlive_attr ){

        m_has_keepAlive_attr = true;
        m_keepAlive_attr = _keepAlive_attr;
        
        }
        const boolean& keepAlive_attr(){

            return type: oolean\nname: \m_keepAlive_attr\n;
        
        }
        bool has_interval_attr(){

            return m_has_interval_attr;
        
        }
        void set_interval_attr(const unsignedInt& _interval_attr ){

        m_has_interval_attr = true;
        m_interval_attr = _interval_attr;
        
        }
        const unsignedInt& interval_attr(){

            return type: \unsignedInt\nname: \m_interval_attr\n;
        
        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_description_attr(){

            return m_has_description_attr;
        
        }
        void set_description_attr(const ns_s::ST_Xstring& _description_attr ){

            m_has_description_attr = true;
            m_description_attr = new ns_s::ST_Xstring(_description_attr);
        
        }
        const ns_s::ST_Xstring& description_attr(){

            if (m_description_attr)
            {
                return *m_description_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_type_attr(){

            return m_has_type_attr;
        
        }
        void set_type_attr(const unsignedInt& _type_attr ){

        m_has_type_attr = true;
        m_type_attr = _type_attr;
        
        }
        const unsignedInt& type_attr(){

            return type: \unsignedInt\nname: \m_type_attr\n;
        
        }
        bool has_reconnectionMethod_attr(){

            return m_has_reconnectionMethod_attr;
        
        }
        void set_reconnectionMethod_attr(const unsignedInt& _reconnectionMethod_attr ){

        m_has_reconnectionMethod_attr = true;
        m_reconnectionMethod_attr = _reconnectionMethod_attr;
        
        }
        const unsignedInt& reconnectionMethod_attr(){

            return type: \unsignedInt\nname: \m_reconnectionMethod_attr\n;
        
        }
        bool has_refreshedVersion_attr(){

            return m_has_refreshedVersion_attr;
        
        }
        void set_refreshedVersion_attr(const unsignedByte& _refreshedVersion_attr ){

        m_has_refreshedVersion_attr = true;
        m_refreshedVersion_attr = _refreshedVersion_attr;
        
        }
        const unsignedByte& refreshedVersion_attr(){

            return type: \unsignedByte\nname: \m_refreshedVersion_attr\n;
        
        }
        bool has_minRefreshableVersion_attr(){

            return m_has_minRefreshableVersion_attr;
        
        }
        void set_minRefreshableVersion_attr(const unsignedByte& _minRefreshableVersion_attr ){

        m_has_minRefreshableVersion_attr = true;
        m_minRefreshableVersion_attr = _minRefreshableVersion_attr;
        
        }
        const unsignedByte& minRefreshableVersion_attr(){

            return type: \unsignedByte\nname: \m_minRefreshableVersion_attr\n;
        
        }
        bool has_savePassword_attr(){

            return m_has_savePassword_attr;
        
        }
        void set_savePassword_attr(const boolean& _savePassword_attr ){

        m_has_savePassword_attr = true;
        m_savePassword_attr = _savePassword_attr;
        
        }
        const boolean& savePassword_attr(){

            return type: oolean\nname: \m_savePassword_attr\n;
        
        }
        bool has_new_attr(){

            return m_has_new_attr;
        
        }
        void set_new_attr(const boolean& _new_attr ){

        m_has_new_attr = true;
        m_new_attr = _new_attr;
        
        }
        const boolean& new_attr(){

            return type: oolean\nname: \m_new_attr\n;
        
        }
        bool has_deleted_attr(){

            return m_has_deleted_attr;
        
        }
        void set_deleted_attr(const boolean& _deleted_attr ){

        m_has_deleted_attr = true;
        m_deleted_attr = _deleted_attr;
        
        }
        const boolean& deleted_attr(){

            return type: oolean\nname: \m_deleted_attr\n;
        
        }
        bool has_onlyUseConnectionFile_attr(){

            return m_has_onlyUseConnectionFile_attr;
        
        }
        void set_onlyUseConnectionFile_attr(const boolean& _onlyUseConnectionFile_attr ){

        m_has_onlyUseConnectionFile_attr = true;
        m_onlyUseConnectionFile_attr = _onlyUseConnectionFile_attr;
        
        }
        const boolean& onlyUseConnectionFile_attr(){

            return type: oolean\nname: \m_onlyUseConnectionFile_attr\n;
        
        }
        bool has_background_attr(){

            return m_has_background_attr;
        
        }
        void set_background_attr(const boolean& _background_attr ){

        m_has_background_attr = true;
        m_background_attr = _background_attr;
        
        }
        const boolean& background_attr(){

            return type: oolean\nname: \m_background_attr\n;
        
        }
        bool has_refreshOnLoad_attr(){

            return m_has_refreshOnLoad_attr;
        
        }
        void set_refreshOnLoad_attr(const boolean& _refreshOnLoad_attr ){

        m_has_refreshOnLoad_attr = true;
        m_refreshOnLoad_attr = _refreshOnLoad_attr;
        
        }
        const boolean& refreshOnLoad_attr(){

            return type: oolean\nname: \m_refreshOnLoad_attr\n;
        
        }
        bool has_saveData_attr(){

            return m_has_saveData_attr;
        
        }
        void set_saveData_attr(const boolean& _saveData_attr ){

        m_has_saveData_attr = true;
        m_saveData_attr = _saveData_attr;
        
        }
        const boolean& saveData_attr(){

            return type: oolean\nname: \m_saveData_attr\n;
        
        }
        bool has_credentials_attr(){

            return m_has_credentials_attr;
        
        }
        void set_credentials_attr(const ST_CredMethod& _credentials_attr ){

            m_has_credentials_attr = true;
            m_credentials_attr = new ST_CredMethod(_credentials_attr);
        
        }
        const ST_CredMethod& credentials_attr(){

            if (m_credentials_attr)
            {
                return *m_credentials_attr;
            }
            return ST_CredMethod::default_instance();
        
        }
        bool has_singleSignOnId_attr(){

            return m_has_singleSignOnId_attr;
        
        }
        void set_singleSignOnId_attr(const ns_s::ST_Xstring& _singleSignOnId_attr ){

            m_has_singleSignOnId_attr = true;
            m_singleSignOnId_attr = new ns_s::ST_Xstring(_singleSignOnId_attr);
        
        }
        const ns_s::ST_Xstring& singleSignOnId_attr(){

            if (m_singleSignOnId_attr)
            {
                return *m_singleSignOnId_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }

    private:
        bool m_has_dbPr ;
        CT_DbPr* m_dbPr ;
        bool m_has_olapPr ;
        CT_OlapPr* m_olapPr ;
        bool m_has_webPr ;
        CT_WebPr* m_webPr ;
        bool m_has_textPr ;
        CT_TextPr* m_textPr ;
        bool m_has_parameters ;
        CT_Parameters* m_parameters ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_Connection* default_instance_ ;
        bool m_has_id_attr ;
        unsignedInt m_id_attr ;
        bool m_has_sourceFile_attr ;
        ns_s::ST_Xstring* m_sourceFile_attr ;
        bool m_has_odcFile_attr ;
        ns_s::ST_Xstring* m_odcFile_attr ;
        bool m_has_keepAlive_attr ;
        boolean m_keepAlive_attr ;
        bool m_has_interval_attr ;
        unsignedInt m_interval_attr ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;
        bool m_has_description_attr ;
        ns_s::ST_Xstring* m_description_attr ;
        bool m_has_type_attr ;
        unsignedInt m_type_attr ;
        bool m_has_reconnectionMethod_attr ;
        unsignedInt m_reconnectionMethod_attr ;
        bool m_has_refreshedVersion_attr ;
        unsignedByte m_refreshedVersion_attr ;
        bool m_has_minRefreshableVersion_attr ;
        unsignedByte m_minRefreshableVersion_attr ;
        bool m_has_savePassword_attr ;
        boolean m_savePassword_attr ;
        bool m_has_new_attr ;
        boolean m_new_attr ;
        bool m_has_deleted_attr ;
        boolean m_deleted_attr ;
        bool m_has_onlyUseConnectionFile_attr ;
        boolean m_onlyUseConnectionFile_attr ;
        bool m_has_background_attr ;
        boolean m_background_attr ;
        bool m_has_refreshOnLoad_attr ;
        boolean m_refreshOnLoad_attr ;
        bool m_has_saveData_attr ;
        boolean m_saveData_attr ;
        bool m_has_credentials_attr ;
        ST_CredMethod* m_credentials_attr ;
        bool m_has_singleSignOnId_attr ;
        ns_s::ST_Xstring* m_singleSignOnId_attr ;

    }

    class CT_DbPr : public XSD::ComplexType{
    public:
        void clear(){

                m_has_connection_attr = false;
                
        if (m_connection_attr)
        {
            delete m_connection_attr;
            m_connection_attr = NULL;
        }
    
            
                m_has_command_attr = false;
                
        if (m_command_attr)
        {
            delete m_command_attr;
            m_command_attr = NULL;
        }
    
            
                m_has_serverCommand_attr = false;
                
        if (m_serverCommand_attr)
        {
            delete m_serverCommand_attr;
            m_serverCommand_attr = NULL;
        }
    
            
                m_has_commandType_attr = false;
                m_commandType_attr = 0;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_connection_attr->toXml(_attrName, _outStream);
m_command_attr->toXml(_attrName, _outStream);
m_serverCommand_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_commandType_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_DbPr& default_instance(){

    if (!CT_DbPr::default_instance_)
    {
        CT_DbPr::default_instance_ = new CT_DbPr();
    }
    return *CT_DbPr::default_instance_;

        }
        bool has_connection_attr(){

            return m_has_connection_attr;
        
        }
        void set_connection_attr(const ns_s::ST_Xstring& _connection_attr ){

            m_has_connection_attr = true;
            m_connection_attr = new ns_s::ST_Xstring(_connection_attr);
        
        }
        const ns_s::ST_Xstring& connection_attr(){

            if (m_connection_attr)
            {
                return *m_connection_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_command_attr(){

            return m_has_command_attr;
        
        }
        void set_command_attr(const ns_s::ST_Xstring& _command_attr ){

            m_has_command_attr = true;
            m_command_attr = new ns_s::ST_Xstring(_command_attr);
        
        }
        const ns_s::ST_Xstring& command_attr(){

            if (m_command_attr)
            {
                return *m_command_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_serverCommand_attr(){

            return m_has_serverCommand_attr;
        
        }
        void set_serverCommand_attr(const ns_s::ST_Xstring& _serverCommand_attr ){

            m_has_serverCommand_attr = true;
            m_serverCommand_attr = new ns_s::ST_Xstring(_serverCommand_attr);
        
        }
        const ns_s::ST_Xstring& serverCommand_attr(){

            if (m_serverCommand_attr)
            {
                return *m_serverCommand_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_commandType_attr(){

            return m_has_commandType_attr;
        
        }
        void set_commandType_attr(const unsignedInt& _commandType_attr ){

        m_has_commandType_attr = true;
        m_commandType_attr = _commandType_attr;
        
        }
        const unsignedInt& commandType_attr(){

            return type: \unsignedInt\nname: \m_commandType_attr\n;
        
        }

    private:
        static CT_DbPr* default_instance_ ;
        bool m_has_connection_attr ;
        ns_s::ST_Xstring* m_connection_attr ;
        bool m_has_command_attr ;
        ns_s::ST_Xstring* m_command_attr ;
        bool m_has_serverCommand_attr ;
        ns_s::ST_Xstring* m_serverCommand_attr ;
        bool m_has_commandType_attr ;
        unsignedInt m_commandType_attr ;

    }

    class CT_OlapPr : public XSD::ComplexType{
    public:
        void clear(){

                m_has_local_attr = false;
                m_local_attr = false;
            
                m_has_localConnection_attr = false;
                
        if (m_localConnection_attr)
        {
            delete m_localConnection_attr;
            m_localConnection_attr = NULL;
        }
    
            
                m_has_localRefresh_attr = false;
                m_localRefresh_attr = false;
            
                m_has_sendLocale_attr = false;
                m_sendLocale_attr = false;
            
                m_has_rowDrillCount_attr = false;
                m_rowDrillCount_attr = 0;
            
                m_has_serverFill_attr = false;
                m_serverFill_attr = false;
            
                m_has_serverNumberFormat_attr = false;
                m_serverNumberFormat_attr = false;
            
                m_has_serverFont_attr = false;
                m_serverFont_attr = false;
            
                m_has_serverFontColor_attr = false;
                m_serverFontColor_attr = false;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_local_attr) << \\\;
m_localConnection_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_localRefresh_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_sendLocale_attr) << \\\;
_outStream << _attrName << \=\\ << m_rowDrillCount_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_serverFill_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_serverNumberFormat_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_serverFont_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_serverFontColor_attr) << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_OlapPr& default_instance(){

    if (!CT_OlapPr::default_instance_)
    {
        CT_OlapPr::default_instance_ = new CT_OlapPr();
    }
    return *CT_OlapPr::default_instance_;

        }
        bool has_local_attr(){

            return m_has_local_attr;
        
        }
        void set_local_attr(const boolean& _local_attr ){

        m_has_local_attr = true;
        m_local_attr = _local_attr;
        
        }
        const boolean& local_attr(){

            return type: oolean\nname: \m_local_attr\n;
        
        }
        bool has_localConnection_attr(){

            return m_has_localConnection_attr;
        
        }
        void set_localConnection_attr(const ns_s::ST_Xstring& _localConnection_attr ){

            m_has_localConnection_attr = true;
            m_localConnection_attr = new ns_s::ST_Xstring(_localConnection_attr);
        
        }
        const ns_s::ST_Xstring& localConnection_attr(){

            if (m_localConnection_attr)
            {
                return *m_localConnection_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_localRefresh_attr(){

            return m_has_localRefresh_attr;
        
        }
        void set_localRefresh_attr(const boolean& _localRefresh_attr ){

        m_has_localRefresh_attr = true;
        m_localRefresh_attr = _localRefresh_attr;
        
        }
        const boolean& localRefresh_attr(){

            return type: oolean\nname: \m_localRefresh_attr\n;
        
        }
        bool has_sendLocale_attr(){

            return m_has_sendLocale_attr;
        
        }
        void set_sendLocale_attr(const boolean& _sendLocale_attr ){

        m_has_sendLocale_attr = true;
        m_sendLocale_attr = _sendLocale_attr;
        
        }
        const boolean& sendLocale_attr(){

            return type: oolean\nname: \m_sendLocale_attr\n;
        
        }
        bool has_rowDrillCount_attr(){

            return m_has_rowDrillCount_attr;
        
        }
        void set_rowDrillCount_attr(const unsignedInt& _rowDrillCount_attr ){

        m_has_rowDrillCount_attr = true;
        m_rowDrillCount_attr = _rowDrillCount_attr;
        
        }
        const unsignedInt& rowDrillCount_attr(){

            return type: \unsignedInt\nname: \m_rowDrillCount_attr\n;
        
        }
        bool has_serverFill_attr(){

            return m_has_serverFill_attr;
        
        }
        void set_serverFill_attr(const boolean& _serverFill_attr ){

        m_has_serverFill_attr = true;
        m_serverFill_attr = _serverFill_attr;
        
        }
        const boolean& serverFill_attr(){

            return type: oolean\nname: \m_serverFill_attr\n;
        
        }
        bool has_serverNumberFormat_attr(){

            return m_has_serverNumberFormat_attr;
        
        }
        void set_serverNumberFormat_attr(const boolean& _serverNumberFormat_attr ){

        m_has_serverNumberFormat_attr = true;
        m_serverNumberFormat_attr = _serverNumberFormat_attr;
        
        }
        const boolean& serverNumberFormat_attr(){

            return type: oolean\nname: \m_serverNumberFormat_attr\n;
        
        }
        bool has_serverFont_attr(){

            return m_has_serverFont_attr;
        
        }
        void set_serverFont_attr(const boolean& _serverFont_attr ){

        m_has_serverFont_attr = true;
        m_serverFont_attr = _serverFont_attr;
        
        }
        const boolean& serverFont_attr(){

            return type: oolean\nname: \m_serverFont_attr\n;
        
        }
        bool has_serverFontColor_attr(){

            return m_has_serverFontColor_attr;
        
        }
        void set_serverFontColor_attr(const boolean& _serverFontColor_attr ){

        m_has_serverFontColor_attr = true;
        m_serverFontColor_attr = _serverFontColor_attr;
        
        }
        const boolean& serverFontColor_attr(){

            return type: oolean\nname: \m_serverFontColor_attr\n;
        
        }

    private:
        static CT_OlapPr* default_instance_ ;
        bool m_has_local_attr ;
        boolean m_local_attr ;
        bool m_has_localConnection_attr ;
        ns_s::ST_Xstring* m_localConnection_attr ;
        bool m_has_localRefresh_attr ;
        boolean m_localRefresh_attr ;
        bool m_has_sendLocale_attr ;
        boolean m_sendLocale_attr ;
        bool m_has_rowDrillCount_attr ;
        unsignedInt m_rowDrillCount_attr ;
        bool m_has_serverFill_attr ;
        boolean m_serverFill_attr ;
        bool m_has_serverNumberFormat_attr ;
        boolean m_serverNumberFormat_attr ;
        bool m_has_serverFont_attr ;
        boolean m_serverFont_attr ;
        bool m_has_serverFontColor_attr ;
        boolean m_serverFontColor_attr ;

    }

    class CT_WebPr : public XSD::ComplexType{
    public:
        bool has_tables(){

            return m_has_tables;
        
        }
        CT_Tables* mutable_tables(){

                m_has_tables = true;
                if (!m_tables)
                {
                    m_tables = new CT_Tables();
                }
                return m_tables;
            
        }
        const CT_Tables& tables(){

            if (m_tables)
            {
                return *m_tables;
            }
            return CT_Tables::default_instance();
        
        }
        void clear(){

                m_has_xml_attr = false;
                m_xml_attr = false;
            
                m_has_sourceData_attr = false;
                m_sourceData_attr = false;
            
                m_has_parsePre_attr = false;
                m_parsePre_attr = false;
            
                m_has_consecutive_attr = false;
                m_consecutive_attr = false;
            
                m_has_firstRow_attr = false;
                m_firstRow_attr = false;
            
                m_has_xl97_attr = false;
                m_xl97_attr = false;
            
                m_has_textDates_attr = false;
                m_textDates_attr = false;
            
                m_has_xl2000_attr = false;
                m_xl2000_attr = false;
            
                m_has_url_attr = false;
                
        if (m_url_attr)
        {
            delete m_url_attr;
            m_url_attr = NULL;
        }
    
            
                m_has_post_attr = false;
                
        if (m_post_attr)
        {
            delete m_post_attr;
            m_post_attr = NULL;
        }
    
            
                m_has_htmlTables_attr = false;
                m_htmlTables_attr = false;
            
                m_has_htmlFormat_attr = false;
                
        if (m_htmlFormat_attr)
        {
            delete m_htmlFormat_attr;
            m_htmlFormat_attr = NULL;
        }
    
            
                m_has_editPage_attr = false;
                
        if (m_editPage_attr)
        {
            delete m_editPage_attr;
            m_editPage_attr = NULL;
        }
    
            
                m_has_tables = false;
                
        if (m_tables)
        {
            delete m_tables;
            m_tables = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_xml_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_sourceData_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_parsePre_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_consecutive_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_firstRow_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_xl97_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_textDates_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_xl2000_attr) << \\\;
m_url_attr->toXml(_attrName, _outStream);
m_post_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_htmlTables_attr) << \\\;
m_htmlFormat_attr->toXml(_attrName, _outStream);
m_editPage_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_tables)
                {
                    m_tables->toXml(tables, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_WebPr& default_instance(){

    if (!CT_WebPr::default_instance_)
    {
        CT_WebPr::default_instance_ = new CT_WebPr();
    }
    return *CT_WebPr::default_instance_;

        }
        bool has_xml_attr(){

            return m_has_xml_attr;
        
        }
        void set_xml_attr(const boolean& _xml_attr ){

        m_has_xml_attr = true;
        m_xml_attr = _xml_attr;
        
        }
        const boolean& xml_attr(){

            return type: oolean\nname: \m_xml_attr\n;
        
        }
        bool has_sourceData_attr(){

            return m_has_sourceData_attr;
        
        }
        void set_sourceData_attr(const boolean& _sourceData_attr ){

        m_has_sourceData_attr = true;
        m_sourceData_attr = _sourceData_attr;
        
        }
        const boolean& sourceData_attr(){

            return type: oolean\nname: \m_sourceData_attr\n;
        
        }
        bool has_parsePre_attr(){

            return m_has_parsePre_attr;
        
        }
        void set_parsePre_attr(const boolean& _parsePre_attr ){

        m_has_parsePre_attr = true;
        m_parsePre_attr = _parsePre_attr;
        
        }
        const boolean& parsePre_attr(){

            return type: oolean\nname: \m_parsePre_attr\n;
        
        }
        bool has_consecutive_attr(){

            return m_has_consecutive_attr;
        
        }
        void set_consecutive_attr(const boolean& _consecutive_attr ){

        m_has_consecutive_attr = true;
        m_consecutive_attr = _consecutive_attr;
        
        }
        const boolean& consecutive_attr(){

            return type: oolean\nname: \m_consecutive_attr\n;
        
        }
        bool has_firstRow_attr(){

            return m_has_firstRow_attr;
        
        }
        void set_firstRow_attr(const boolean& _firstRow_attr ){

        m_has_firstRow_attr = true;
        m_firstRow_attr = _firstRow_attr;
        
        }
        const boolean& firstRow_attr(){

            return type: oolean\nname: \m_firstRow_attr\n;
        
        }
        bool has_xl97_attr(){

            return m_has_xl97_attr;
        
        }
        void set_xl97_attr(const boolean& _xl97_attr ){

        m_has_xl97_attr = true;
        m_xl97_attr = _xl97_attr;
        
        }
        const boolean& xl97_attr(){

            return type: oolean\nname: \m_xl97_attr\n;
        
        }
        bool has_textDates_attr(){

            return m_has_textDates_attr;
        
        }
        void set_textDates_attr(const boolean& _textDates_attr ){

        m_has_textDates_attr = true;
        m_textDates_attr = _textDates_attr;
        
        }
        const boolean& textDates_attr(){

            return type: oolean\nname: \m_textDates_attr\n;
        
        }
        bool has_xl2000_attr(){

            return m_has_xl2000_attr;
        
        }
        void set_xl2000_attr(const boolean& _xl2000_attr ){

        m_has_xl2000_attr = true;
        m_xl2000_attr = _xl2000_attr;
        
        }
        const boolean& xl2000_attr(){

            return type: oolean\nname: \m_xl2000_attr\n;
        
        }
        bool has_url_attr(){

            return m_has_url_attr;
        
        }
        void set_url_attr(const ns_s::ST_Xstring& _url_attr ){

            m_has_url_attr = true;
            m_url_attr = new ns_s::ST_Xstring(_url_attr);
        
        }
        const ns_s::ST_Xstring& url_attr(){

            if (m_url_attr)
            {
                return *m_url_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_post_attr(){

            return m_has_post_attr;
        
        }
        void set_post_attr(const ns_s::ST_Xstring& _post_attr ){

            m_has_post_attr = true;
            m_post_attr = new ns_s::ST_Xstring(_post_attr);
        
        }
        const ns_s::ST_Xstring& post_attr(){

            if (m_post_attr)
            {
                return *m_post_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_htmlTables_attr(){

            return m_has_htmlTables_attr;
        
        }
        void set_htmlTables_attr(const boolean& _htmlTables_attr ){

        m_has_htmlTables_attr = true;
        m_htmlTables_attr = _htmlTables_attr;
        
        }
        const boolean& htmlTables_attr(){

            return type: oolean\nname: \m_htmlTables_attr\n;
        
        }
        bool has_htmlFormat_attr(){

            return m_has_htmlFormat_attr;
        
        }
        void set_htmlFormat_attr(const ST_HtmlFmt& _htmlFormat_attr ){

            m_has_htmlFormat_attr = true;
            m_htmlFormat_attr = new ST_HtmlFmt(_htmlFormat_attr);
        
        }
        const ST_HtmlFmt& htmlFormat_attr(){

            if (m_htmlFormat_attr)
            {
                return *m_htmlFormat_attr;
            }
            return ST_HtmlFmt::default_instance();
        
        }
        bool has_editPage_attr(){

            return m_has_editPage_attr;
        
        }
        void set_editPage_attr(const ns_s::ST_Xstring& _editPage_attr ){

            m_has_editPage_attr = true;
            m_editPage_attr = new ns_s::ST_Xstring(_editPage_attr);
        
        }
        const ns_s::ST_Xstring& editPage_attr(){

            if (m_editPage_attr)
            {
                return *m_editPage_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }

    private:
        bool m_has_tables ;
        CT_Tables* m_tables ;
        static CT_WebPr* default_instance_ ;
        bool m_has_xml_attr ;
        boolean m_xml_attr ;
        bool m_has_sourceData_attr ;
        boolean m_sourceData_attr ;
        bool m_has_parsePre_attr ;
        boolean m_parsePre_attr ;
        bool m_has_consecutive_attr ;
        boolean m_consecutive_attr ;
        bool m_has_firstRow_attr ;
        boolean m_firstRow_attr ;
        bool m_has_xl97_attr ;
        boolean m_xl97_attr ;
        bool m_has_textDates_attr ;
        boolean m_textDates_attr ;
        bool m_has_xl2000_attr ;
        boolean m_xl2000_attr ;
        bool m_has_url_attr ;
        ns_s::ST_Xstring* m_url_attr ;
        bool m_has_post_attr ;
        ns_s::ST_Xstring* m_post_attr ;
        bool m_has_htmlTables_attr ;
        boolean m_htmlTables_attr ;
        bool m_has_htmlFormat_attr ;
        ST_HtmlFmt* m_htmlFormat_attr ;
        bool m_has_editPage_attr ;
        ns_s::ST_Xstring* m_editPage_attr ;

    }

    class CT_Parameters : public XSD::ComplexType{
    public:
        bool has_parameter(){

            return m_has_parameter;
        
        }
        CT_Parameter* mutable_parameter(){

                m_has_parameter = true;
                if (!m_parameter)
                {
                    m_parameter = new CT_Parameter();
                }
                return m_parameter;
            
        }
        const CT_Parameter& parameter(){

            if (m_parameter)
            {
                return *m_parameter;
            }
            return CT_Parameter::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_parameter = false;
                
        if (m_parameter)
        {
            delete m_parameter;
            m_parameter = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_parameter)
                {
                    m_parameter->toXml(parameter, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Parameters& default_instance(){

    if (!CT_Parameters::default_instance_)
    {
        CT_Parameters::default_instance_ = new CT_Parameters();
    }
    return *CT_Parameters::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_parameter ;
        CT_Parameter* m_parameter ;
        static CT_Parameters* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_Parameter : public XSD::ComplexType{
    public:
        void clear(){

                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
                m_has_sqlType_attr = false;
                m_sqlType_attr = 0;
            
                m_has_parameterType_attr = false;
                
        if (m_parameterType_attr)
        {
            delete m_parameterType_attr;
            m_parameterType_attr = NULL;
        }
    
            
                m_has_refreshOnChange_attr = false;
                m_refreshOnChange_attr = false;
            
                m_has_prompt_attr = false;
                
        if (m_prompt_attr)
        {
            delete m_prompt_attr;
            m_prompt_attr = NULL;
        }
    
            
                m_has_boolean_attr = false;
                m_boolean_attr = false;
            
                m_has_double_attr = false;
                m_double_attr = 0;
            
                m_has_integer_attr = false;
                m_integer_attr = 0;
            
                m_has_string_attr = false;
                
        if (m_string_attr)
        {
            delete m_string_attr;
            m_string_attr = NULL;
        }
    
            
                m_has_cell_attr = false;
                
        if (m_cell_attr)
        {
            delete m_cell_attr;
            m_cell_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_name_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_sqlType_attr << \\\;
m_parameterType_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_refreshOnChange_attr) << \\\;
m_prompt_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_boolean_attr) << \\\;
_outStream << _attrName << \=\\ << m_double_attr << \\\;
_outStream << _attrName << \=\\ << m_integer_attr << \\\;
m_string_attr->toXml(_attrName, _outStream);
m_cell_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Parameter& default_instance(){

    if (!CT_Parameter::default_instance_)
    {
        CT_Parameter::default_instance_ = new CT_Parameter();
    }
    return *CT_Parameter::default_instance_;

        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_sqlType_attr(){

            return m_has_sqlType_attr;
        
        }
        void set_sqlType_attr(const int& _sqlType_attr ){

        m_has_sqlType_attr = true;
        m_sqlType_attr = _sqlType_attr;
        
        }
        const int& sqlType_attr(){

            return type: \int\nname: \m_sqlType_attr\n;
        
        }
        bool has_parameterType_attr(){

            return m_has_parameterType_attr;
        
        }
        void set_parameterType_attr(const ST_ParameterType& _parameterType_attr ){

            m_has_parameterType_attr = true;
            m_parameterType_attr = new ST_ParameterType(_parameterType_attr);
        
        }
        const ST_ParameterType& parameterType_attr(){

            if (m_parameterType_attr)
            {
                return *m_parameterType_attr;
            }
            return ST_ParameterType::default_instance();
        
        }
        bool has_refreshOnChange_attr(){

            return m_has_refreshOnChange_attr;
        
        }
        void set_refreshOnChange_attr(const boolean& _refreshOnChange_attr ){

        m_has_refreshOnChange_attr = true;
        m_refreshOnChange_attr = _refreshOnChange_attr;
        
        }
        const boolean& refreshOnChange_attr(){

            return type: oolean\nname: \m_refreshOnChange_attr\n;
        
        }
        bool has_prompt_attr(){

            return m_has_prompt_attr;
        
        }
        void set_prompt_attr(const ns_s::ST_Xstring& _prompt_attr ){

            m_has_prompt_attr = true;
            m_prompt_attr = new ns_s::ST_Xstring(_prompt_attr);
        
        }
        const ns_s::ST_Xstring& prompt_attr(){

            if (m_prompt_attr)
            {
                return *m_prompt_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_boolean_attr(){

            return m_has_boolean_attr;
        
        }
        void set_boolean_attr(const boolean& _boolean_attr ){

        m_has_boolean_attr = true;
        m_boolean_attr = _boolean_attr;
        
        }
        const boolean& boolean_attr(){

            return type: oolean\nname: \m_boolean_attr\n;
        
        }
        bool has_double_attr(){

            return m_has_double_attr;
        
        }
        void set_double_attr(const double& _double_attr ){

        m_has_double_attr = true;
        m_double_attr = _double_attr;
        
        }
        const double& double_attr(){

            return type: \double\nname: \m_double_attr\n;
        
        }
        bool has_integer_attr(){

            return m_has_integer_attr;
        
        }
        void set_integer_attr(const int& _integer_attr ){

        m_has_integer_attr = true;
        m_integer_attr = _integer_attr;
        
        }
        const int& integer_attr(){

            return type: \int\nname: \m_integer_attr\n;
        
        }
        bool has_string_attr(){

            return m_has_string_attr;
        
        }
        void set_string_attr(const ns_s::ST_Xstring& _string_attr ){

            m_has_string_attr = true;
            m_string_attr = new ns_s::ST_Xstring(_string_attr);
        
        }
        const ns_s::ST_Xstring& string_attr(){

            if (m_string_attr)
            {
                return *m_string_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_cell_attr(){

            return m_has_cell_attr;
        
        }
        void set_cell_attr(const ns_s::ST_Xstring& _cell_attr ){

            m_has_cell_attr = true;
            m_cell_attr = new ns_s::ST_Xstring(_cell_attr);
        
        }
        const ns_s::ST_Xstring& cell_attr(){

            if (m_cell_attr)
            {
                return *m_cell_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }

    private:
        static CT_Parameter* default_instance_ ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;
        bool m_has_sqlType_attr ;
        int m_sqlType_attr ;
        bool m_has_parameterType_attr ;
        ST_ParameterType* m_parameterType_attr ;
        bool m_has_refreshOnChange_attr ;
        boolean m_refreshOnChange_attr ;
        bool m_has_prompt_attr ;
        ns_s::ST_Xstring* m_prompt_attr ;
        bool m_has_boolean_attr ;
        boolean m_boolean_attr ;
        bool m_has_double_attr ;
        double m_double_attr ;
        bool m_has_integer_attr ;
        int m_integer_attr ;
        bool m_has_string_attr ;
        ns_s::ST_Xstring* m_string_attr ;
        bool m_has_cell_attr ;
        ns_s::ST_Xstring* m_cell_attr ;

    }

    class CT_Tables : public XSD::ComplexType{
    public:
        CT_TableMissing* add_m(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_TableMissing* pNewChild = pChildGroup->mutable_m();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_XStringElement* add_s(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_XStringElement* pNewChild = pChildGroup->mutable_s();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_Index* add_x(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_Index* pNewChild = pChildGroup->mutable_x();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
            vector<ChildGroup_1*>::iterator iter;
            for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
            {
                delete *iter;
            }
            m_childGroupList_1.clear();
        
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_m())
            {
                (*iter)->toXml(m, _outStream);
            }
            else if ((*iter)->has_s())
            {
                (*iter)->toXml(s, _outStream);
            }
            else if ((*iter)->has_x())
            {
                (*iter)->toXml(x, _outStream);
            }
        }
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Tables& default_instance(){

    if (!CT_Tables::default_instance_)
    {
        CT_Tables::default_instance_ = new CT_Tables();
    }
    return *CT_Tables::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        vector<ChildGroup_1*> m_childGroupList_1 ;
        static CT_Tables* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;
        class ChildGroup_1{
        public:
            bool has_m(){

            return m_has_m;
        
            }
            CT_TableMissing* mutable_m(){

                
                m_has_s = false;
                
        if (m_s)
        {
            delete m_s;
            m_s = NULL;
        }
    ;
            
                m_has_x = false;
                
        if (m_x)
        {
            delete m_x;
            m_x = NULL;
        }
    ;
            
                m_has_m = true;
                if (!m_m)
                {
                    m_m = new CT_TableMissing();
                }
                return m_m;
            
            }
            const CT_TableMissing& m(){

            if (m_m)
            {
                return *m_m;
            }
            return CT_TableMissing::default_instance();
        
            }
            bool has_s(){

            return m_has_s;
        
            }
            CT_XStringElement* mutable_s(){

                
                m_has_m = false;
                
        if (m_m)
        {
            delete m_m;
            m_m = NULL;
        }
    ;
            
                m_has_x = false;
                
        if (m_x)
        {
            delete m_x;
            m_x = NULL;
        }
    ;
            
                m_has_s = true;
                if (!m_s)
                {
                    m_s = new CT_XStringElement();
                }
                return m_s;
            
            }
            const CT_XStringElement& s(){

            if (m_s)
            {
                return *m_s;
            }
            return CT_XStringElement::default_instance();
        
            }
            bool has_x(){

            return m_has_x;
        
            }
            CT_Index* mutable_x(){

                
                m_has_m = false;
                
        if (m_m)
        {
            delete m_m;
            m_m = NULL;
        }
    ;
            
                m_has_s = false;
                
        if (m_s)
        {
            delete m_s;
            m_s = NULL;
        }
    ;
            
                m_has_x = true;
                if (!m_x)
                {
                    m_x = new CT_Index();
                }
                return m_x;
            
            }
            const CT_Index& x(){

            if (m_x)
            {
                return *m_x;
            }
            return CT_Index::default_instance();
        
            }

        private:
            bool m_has_m ;
            CT_TableMissing* m_m ;
            bool m_has_s ;
            CT_XStringElement* m_s ;
            bool m_has_x ;
            CT_Index* m_x ;

        }


    }

    class CT_TableMissing : public XSD::ComplexType{
    public:
        void clear(){

        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_TableMissing& default_instance(){

    if (!CT_TableMissing::default_instance_)
    {
        CT_TableMissing::default_instance_ = new CT_TableMissing();
    }
    return *CT_TableMissing::default_instance_;

        }

    private:
        static CT_TableMissing* default_instance_ ;

    }

    class CT_TextPr : public XSD::ComplexType{
    public:
        bool has_textFields(){

            return m_has_textFields;
        
        }
        CT_TextFields* mutable_textFields(){

                m_has_textFields = true;
                if (!m_textFields)
                {
                    m_textFields = new CT_TextFields();
                }
                return m_textFields;
            
        }
        const CT_TextFields& textFields(){

            if (m_textFields)
            {
                return *m_textFields;
            }
            return CT_TextFields::default_instance();
        
        }
        void clear(){

                m_has_prompt_attr = false;
                m_prompt_attr = false;
            
                m_has_fileType_attr = false;
                
        if (m_fileType_attr)
        {
            delete m_fileType_attr;
            m_fileType_attr = NULL;
        }
    
            
                m_has_codePage_attr = false;
                m_codePage_attr = 0;
            
                m_has_characterSet_attr = false;
                m_characterSet_attr.clear();
            
                m_has_firstRow_attr = false;
                m_firstRow_attr = 0;
            
                m_has_sourceFile_attr = false;
                
        if (m_sourceFile_attr)
        {
            delete m_sourceFile_attr;
            m_sourceFile_attr = NULL;
        }
    
            
                m_has_delimited_attr = false;
                m_delimited_attr = false;
            
                m_has_decimal_attr = false;
                
        if (m_decimal_attr)
        {
            delete m_decimal_attr;
            m_decimal_attr = NULL;
        }
    
            
                m_has_thousands_attr = false;
                
        if (m_thousands_attr)
        {
            delete m_thousands_attr;
            m_thousands_attr = NULL;
        }
    
            
                m_has_tab_attr = false;
                m_tab_attr = false;
            
                m_has_space_attr = false;
                m_space_attr = false;
            
                m_has_comma_attr = false;
                m_comma_attr = false;
            
                m_has_semicolon_attr = false;
                m_semicolon_attr = false;
            
                m_has_consecutive_attr = false;
                m_consecutive_attr = false;
            
                m_has_qualifier_attr = false;
                
        if (m_qualifier_attr)
        {
            delete m_qualifier_attr;
            m_qualifier_attr = NULL;
        }
    
            
                m_has_delimiter_attr = false;
                
        if (m_delimiter_attr)
        {
            delete m_delimiter_attr;
            m_delimiter_attr = NULL;
        }
    
            
                m_has_textFields = false;
                
        if (m_textFields)
        {
            delete m_textFields;
            m_textFields = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_prompt_attr) << \\\;
m_fileType_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_codePage_attr << \\\;
_outStream << _attrName << \=\\ << m_characterSet_attr << \\\;
_outStream << _attrName << \=\\ << m_firstRow_attr << \\\;
m_sourceFile_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_delimited_attr) << \\\;
m_decimal_attr->toXml(_attrName, _outStream);
m_thousands_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_tab_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_space_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_comma_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_semicolon_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_consecutive_attr) << \\\;
m_qualifier_attr->toXml(_attrName, _outStream);
m_delimiter_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_textFields)
                {
                    m_textFields->toXml(textFields, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_TextPr& default_instance(){

    if (!CT_TextPr::default_instance_)
    {
        CT_TextPr::default_instance_ = new CT_TextPr();
    }
    return *CT_TextPr::default_instance_;

        }
        bool has_prompt_attr(){

            return m_has_prompt_attr;
        
        }
        void set_prompt_attr(const boolean& _prompt_attr ){

        m_has_prompt_attr = true;
        m_prompt_attr = _prompt_attr;
        
        }
        const boolean& prompt_attr(){

            return type: oolean\nname: \m_prompt_attr\n;
        
        }
        bool has_fileType_attr(){

            return m_has_fileType_attr;
        
        }
        void set_fileType_attr(const ST_FileType& _fileType_attr ){

            m_has_fileType_attr = true;
            m_fileType_attr = new ST_FileType(_fileType_attr);
        
        }
        const ST_FileType& fileType_attr(){

            if (m_fileType_attr)
            {
                return *m_fileType_attr;
            }
            return ST_FileType::default_instance();
        
        }
        bool has_codePage_attr(){

            return m_has_codePage_attr;
        
        }
        void set_codePage_attr(const unsignedInt& _codePage_attr ){

        m_has_codePage_attr = true;
        m_codePage_attr = _codePage_attr;
        
        }
        const unsignedInt& codePage_attr(){

            return type: \unsignedInt\nname: \m_codePage_attr\n;
        
        }
        bool has_characterSet_attr(){

            return m_has_characterSet_attr;
        
        }
        void set_characterSet_attr(const string& _characterSet_attr ){

        m_has_characterSet_attr = true;
        m_characterSet_attr = _characterSet_attr;
        
        }
        const string& characterSet_attr(){

            return type: \string\nname: \m_characterSet_attr\n;
        
        }
        bool has_firstRow_attr(){

            return m_has_firstRow_attr;
        
        }
        void set_firstRow_attr(const unsignedInt& _firstRow_attr ){

        m_has_firstRow_attr = true;
        m_firstRow_attr = _firstRow_attr;
        
        }
        const unsignedInt& firstRow_attr(){

            return type: \unsignedInt\nname: \m_firstRow_attr\n;
        
        }
        bool has_sourceFile_attr(){

            return m_has_sourceFile_attr;
        
        }
        void set_sourceFile_attr(const ns_s::ST_Xstring& _sourceFile_attr ){

            m_has_sourceFile_attr = true;
            m_sourceFile_attr = new ns_s::ST_Xstring(_sourceFile_attr);
        
        }
        const ns_s::ST_Xstring& sourceFile_attr(){

            if (m_sourceFile_attr)
            {
                return *m_sourceFile_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_delimited_attr(){

            return m_has_delimited_attr;
        
        }
        void set_delimited_attr(const boolean& _delimited_attr ){

        m_has_delimited_attr = true;
        m_delimited_attr = _delimited_attr;
        
        }
        const boolean& delimited_attr(){

            return type: oolean\nname: \m_delimited_attr\n;
        
        }
        bool has_decimal_attr(){

            return m_has_decimal_attr;
        
        }
        void set_decimal_attr(const ns_s::ST_Xstring& _decimal_attr ){

            m_has_decimal_attr = true;
            m_decimal_attr = new ns_s::ST_Xstring(_decimal_attr);
        
        }
        const ns_s::ST_Xstring& decimal_attr(){

            if (m_decimal_attr)
            {
                return *m_decimal_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_thousands_attr(){

            return m_has_thousands_attr;
        
        }
        void set_thousands_attr(const ns_s::ST_Xstring& _thousands_attr ){

            m_has_thousands_attr = true;
            m_thousands_attr = new ns_s::ST_Xstring(_thousands_attr);
        
        }
        const ns_s::ST_Xstring& thousands_attr(){

            if (m_thousands_attr)
            {
                return *m_thousands_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_tab_attr(){

            return m_has_tab_attr;
        
        }
        void set_tab_attr(const boolean& _tab_attr ){

        m_has_tab_attr = true;
        m_tab_attr = _tab_attr;
        
        }
        const boolean& tab_attr(){

            return type: oolean\nname: \m_tab_attr\n;
        
        }
        bool has_space_attr(){

            return m_has_space_attr;
        
        }
        void set_space_attr(const boolean& _space_attr ){

        m_has_space_attr = true;
        m_space_attr = _space_attr;
        
        }
        const boolean& space_attr(){

            return type: oolean\nname: \m_space_attr\n;
        
        }
        bool has_comma_attr(){

            return m_has_comma_attr;
        
        }
        void set_comma_attr(const boolean& _comma_attr ){

        m_has_comma_attr = true;
        m_comma_attr = _comma_attr;
        
        }
        const boolean& comma_attr(){

            return type: oolean\nname: \m_comma_attr\n;
        
        }
        bool has_semicolon_attr(){

            return m_has_semicolon_attr;
        
        }
        void set_semicolon_attr(const boolean& _semicolon_attr ){

        m_has_semicolon_attr = true;
        m_semicolon_attr = _semicolon_attr;
        
        }
        const boolean& semicolon_attr(){

            return type: oolean\nname: \m_semicolon_attr\n;
        
        }
        bool has_consecutive_attr(){

            return m_has_consecutive_attr;
        
        }
        void set_consecutive_attr(const boolean& _consecutive_attr ){

        m_has_consecutive_attr = true;
        m_consecutive_attr = _consecutive_attr;
        
        }
        const boolean& consecutive_attr(){

            return type: oolean\nname: \m_consecutive_attr\n;
        
        }
        bool has_qualifier_attr(){

            return m_has_qualifier_attr;
        
        }
        void set_qualifier_attr(const ST_Qualifier& _qualifier_attr ){

            m_has_qualifier_attr = true;
            m_qualifier_attr = new ST_Qualifier(_qualifier_attr);
        
        }
        const ST_Qualifier& qualifier_attr(){

            if (m_qualifier_attr)
            {
                return *m_qualifier_attr;
            }
            return ST_Qualifier::default_instance();
        
        }
        bool has_delimiter_attr(){

            return m_has_delimiter_attr;
        
        }
        void set_delimiter_attr(const ns_s::ST_Xstring& _delimiter_attr ){

            m_has_delimiter_attr = true;
            m_delimiter_attr = new ns_s::ST_Xstring(_delimiter_attr);
        
        }
        const ns_s::ST_Xstring& delimiter_attr(){

            if (m_delimiter_attr)
            {
                return *m_delimiter_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }

    private:
        bool m_has_textFields ;
        CT_TextFields* m_textFields ;
        static CT_TextPr* default_instance_ ;
        bool m_has_prompt_attr ;
        boolean m_prompt_attr ;
        bool m_has_fileType_attr ;
        ST_FileType* m_fileType_attr ;
        bool m_has_codePage_attr ;
        unsignedInt m_codePage_attr ;
        bool m_has_characterSet_attr ;
        string m_characterSet_attr ;
        bool m_has_firstRow_attr ;
        unsignedInt m_firstRow_attr ;
        bool m_has_sourceFile_attr ;
        ns_s::ST_Xstring* m_sourceFile_attr ;
        bool m_has_delimited_attr ;
        boolean m_delimited_attr ;
        bool m_has_decimal_attr ;
        ns_s::ST_Xstring* m_decimal_attr ;
        bool m_has_thousands_attr ;
        ns_s::ST_Xstring* m_thousands_attr ;
        bool m_has_tab_attr ;
        boolean m_tab_attr ;
        bool m_has_space_attr ;
        boolean m_space_attr ;
        bool m_has_comma_attr ;
        boolean m_comma_attr ;
        bool m_has_semicolon_attr ;
        boolean m_semicolon_attr ;
        bool m_has_consecutive_attr ;
        boolean m_consecutive_attr ;
        bool m_has_qualifier_attr ;
        ST_Qualifier* m_qualifier_attr ;
        bool m_has_delimiter_attr ;
        ns_s::ST_Xstring* m_delimiter_attr ;

    }

    class CT_TextFields : public XSD::ComplexType{
    public:
        bool has_textField(){

            return m_has_textField;
        
        }
        CT_TextField* mutable_textField(){

                m_has_textField = true;
                if (!m_textField)
                {
                    m_textField = new CT_TextField();
                }
                return m_textField;
            
        }
        const CT_TextField& textField(){

            if (m_textField)
            {
                return *m_textField;
            }
            return CT_TextField::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_textField = false;
                
        if (m_textField)
        {
            delete m_textField;
            m_textField = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_textField)
                {
                    m_textField->toXml(textField, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_TextFields& default_instance(){

    if (!CT_TextFields::default_instance_)
    {
        CT_TextFields::default_instance_ = new CT_TextFields();
    }
    return *CT_TextFields::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_textField ;
        CT_TextField* m_textField ;
        static CT_TextFields* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_TextField : public XSD::ComplexType{
    public:
        void clear(){

                m_has_type_attr = false;
                
        if (m_type_attr)
        {
            delete m_type_attr;
            m_type_attr = NULL;
        }
    
            
                m_has_position_attr = false;
                m_position_attr = 0;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_type_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_position_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_TextField& default_instance(){

    if (!CT_TextField::default_instance_)
    {
        CT_TextField::default_instance_ = new CT_TextField();
    }
    return *CT_TextField::default_instance_;

        }
        bool has_type_attr(){

            return m_has_type_attr;
        
        }
        void set_type_attr(const ST_ExternalConnectionType& _type_attr ){

            m_has_type_attr = true;
            m_type_attr = new ST_ExternalConnectionType(_type_attr);
        
        }
        const ST_ExternalConnectionType& type_attr(){

            if (m_type_attr)
            {
                return *m_type_attr;
            }
            return ST_ExternalConnectionType::default_instance();
        
        }
        bool has_position_attr(){

            return m_has_position_attr;
        
        }
        void set_position_attr(const unsignedInt& _position_attr ){

        m_has_position_attr = true;
        m_position_attr = _position_attr;
        
        }
        const unsignedInt& position_attr(){

            return type: \unsignedInt\nname: \m_position_attr\n;
        
        }

    private:
        static CT_TextField* default_instance_ ;
        bool m_has_type_attr ;
        ST_ExternalConnectionType* m_type_attr ;
        bool m_has_position_attr ;
        unsignedInt m_position_attr ;

    }

    class CT_PivotCacheDefinition : public XSD::ComplexType{
    public:
        bool has_cacheSource(){

            return m_has_cacheSource;
        
        }
        CT_CacheSource* mutable_cacheSource(){

                m_has_cacheSource = true;
                if (!m_cacheSource)
                {
                    m_cacheSource = new CT_CacheSource();
                }
                return m_cacheSource;
            
        }
        const CT_CacheSource& cacheSource(){

            if (m_cacheSource)
            {
                return *m_cacheSource;
            }
            return CT_CacheSource::default_instance();
        
        }
        bool has_cacheFields(){

            return m_has_cacheFields;
        
        }
        CT_CacheFields* mutable_cacheFields(){

                m_has_cacheFields = true;
                if (!m_cacheFields)
                {
                    m_cacheFields = new CT_CacheFields();
                }
                return m_cacheFields;
            
        }
        const CT_CacheFields& cacheFields(){

            if (m_cacheFields)
            {
                return *m_cacheFields;
            }
            return CT_CacheFields::default_instance();
        
        }
        bool has_cacheHierarchies(){

            return m_has_cacheHierarchies;
        
        }
        CT_CacheHierarchies* mutable_cacheHierarchies(){

                m_has_cacheHierarchies = true;
                if (!m_cacheHierarchies)
                {
                    m_cacheHierarchies = new CT_CacheHierarchies();
                }
                return m_cacheHierarchies;
            
        }
        const CT_CacheHierarchies& cacheHierarchies(){

            if (m_cacheHierarchies)
            {
                return *m_cacheHierarchies;
            }
            return CT_CacheHierarchies::default_instance();
        
        }
        bool has_kpis(){

            return m_has_kpis;
        
        }
        CT_PCDKPIs* mutable_kpis(){

                m_has_kpis = true;
                if (!m_kpis)
                {
                    m_kpis = new CT_PCDKPIs();
                }
                return m_kpis;
            
        }
        const CT_PCDKPIs& kpis(){

            if (m_kpis)
            {
                return *m_kpis;
            }
            return CT_PCDKPIs::default_instance();
        
        }
        bool has_tupleCache(){

            return m_has_tupleCache;
        
        }
        CT_TupleCache* mutable_tupleCache(){

                m_has_tupleCache = true;
                if (!m_tupleCache)
                {
                    m_tupleCache = new CT_TupleCache();
                }
                return m_tupleCache;
            
        }
        const CT_TupleCache& tupleCache(){

            if (m_tupleCache)
            {
                return *m_tupleCache;
            }
            return CT_TupleCache::default_instance();
        
        }
        bool has_calculatedItems(){

            return m_has_calculatedItems;
        
        }
        CT_CalculatedItems* mutable_calculatedItems(){

                m_has_calculatedItems = true;
                if (!m_calculatedItems)
                {
                    m_calculatedItems = new CT_CalculatedItems();
                }
                return m_calculatedItems;
            
        }
        const CT_CalculatedItems& calculatedItems(){

            if (m_calculatedItems)
            {
                return *m_calculatedItems;
            }
            return CT_CalculatedItems::default_instance();
        
        }
        bool has_calculatedMembers(){

            return m_has_calculatedMembers;
        
        }
        CT_CalculatedMembers* mutable_calculatedMembers(){

                m_has_calculatedMembers = true;
                if (!m_calculatedMembers)
                {
                    m_calculatedMembers = new CT_CalculatedMembers();
                }
                return m_calculatedMembers;
            
        }
        const CT_CalculatedMembers& calculatedMembers(){

            if (m_calculatedMembers)
            {
                return *m_calculatedMembers;
            }
            return CT_CalculatedMembers::default_instance();
        
        }
        bool has_dimensions(){

            return m_has_dimensions;
        
        }
        CT_Dimensions* mutable_dimensions(){

                m_has_dimensions = true;
                if (!m_dimensions)
                {
                    m_dimensions = new CT_Dimensions();
                }
                return m_dimensions;
            
        }
        const CT_Dimensions& dimensions(){

            if (m_dimensions)
            {
                return *m_dimensions;
            }
            return CT_Dimensions::default_instance();
        
        }
        bool has_measureGroups(){

            return m_has_measureGroups;
        
        }
        CT_MeasureGroups* mutable_measureGroups(){

                m_has_measureGroups = true;
                if (!m_measureGroups)
                {
                    m_measureGroups = new CT_MeasureGroups();
                }
                return m_measureGroups;
            
        }
        const CT_MeasureGroups& measureGroups(){

            if (m_measureGroups)
            {
                return *m_measureGroups;
            }
            return CT_MeasureGroups::default_instance();
        
        }
        bool has_maps(){

            return m_has_maps;
        
        }
        CT_MeasureDimensionMaps* mutable_maps(){

                m_has_maps = true;
                if (!m_maps)
                {
                    m_maps = new CT_MeasureDimensionMaps();
                }
                return m_maps;
            
        }
        const CT_MeasureDimensionMaps& maps(){

            if (m_maps)
            {
                return *m_maps;
            }
            return CT_MeasureDimensionMaps::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_id_attr = false;
                
        if (m_id_attr)
        {
            delete m_id_attr;
            m_id_attr = NULL;
        }
    
            
                m_has_invalid_attr = false;
                m_invalid_attr = false;
            
                m_has_saveData_attr = false;
                m_saveData_attr = false;
            
                m_has_refreshOnLoad_attr = false;
                m_refreshOnLoad_attr = false;
            
                m_has_optimizeMemory_attr = false;
                m_optimizeMemory_attr = false;
            
                m_has_enableRefresh_attr = false;
                m_enableRefresh_attr = false;
            
                m_has_refreshedBy_attr = false;
                
        if (m_refreshedBy_attr)
        {
            delete m_refreshedBy_attr;
            m_refreshedBy_attr = NULL;
        }
    
            
                m_has_refreshedDate_attr = false;
                m_refreshedDate_attr = 0;
            
                m_has_refreshedDateIso_attr = false;
                m_refreshedDateIso_attr.clear();
            
                m_has_backgroundQuery_attr = false;
                m_backgroundQuery_attr = false;
            
                m_has_missingItemsLimit_attr = false;
                m_missingItemsLimit_attr = 0;
            
                m_has_createdVersion_attr = false;
                m_createdVersion_attr = 0;
            
                m_has_refreshedVersion_attr = false;
                m_refreshedVersion_attr = 0;
            
                m_has_minRefreshableVersion_attr = false;
                m_minRefreshableVersion_attr = 0;
            
                m_has_recordCount_attr = false;
                m_recordCount_attr = 0;
            
                m_has_upgradeOnRefresh_attr = false;
                m_upgradeOnRefresh_attr = false;
            
                m_has_tupleCache_attr = false;
                m_tupleCache_attr = false;
            
                m_has_supportSubquery_attr = false;
                m_supportSubquery_attr = false;
            
                m_has_supportAdvancedDrill_attr = false;
                m_supportAdvancedDrill_attr = false;
            
                m_has_cacheSource = false;
                
        if (m_cacheSource)
        {
            delete m_cacheSource;
            m_cacheSource = NULL;
        }
    
            
                m_has_cacheFields = false;
                
        if (m_cacheFields)
        {
            delete m_cacheFields;
            m_cacheFields = NULL;
        }
    
            
                m_has_cacheHierarchies = false;
                
        if (m_cacheHierarchies)
        {
            delete m_cacheHierarchies;
            m_cacheHierarchies = NULL;
        }
    
            
                m_has_kpis = false;
                
        if (m_kpis)
        {
            delete m_kpis;
            m_kpis = NULL;
        }
    
            
                m_has_tupleCache = false;
                
        if (m_tupleCache)
        {
            delete m_tupleCache;
            m_tupleCache = NULL;
        }
    
            
                m_has_calculatedItems = false;
                
        if (m_calculatedItems)
        {
            delete m_calculatedItems;
            m_calculatedItems = NULL;
        }
    
            
                m_has_calculatedMembers = false;
                
        if (m_calculatedMembers)
        {
            delete m_calculatedMembers;
            m_calculatedMembers = NULL;
        }
    
            
                m_has_dimensions = false;
                
        if (m_dimensions)
        {
            delete m_dimensions;
            m_dimensions = NULL;
        }
    
            
                m_has_measureGroups = false;
                
        if (m_measureGroups)
        {
            delete m_measureGroups;
            m_measureGroups = NULL;
        }
    
            
                m_has_maps = false;
                
        if (m_maps)
        {
            delete m_maps;
            m_maps = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_id_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_invalid_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_saveData_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_refreshOnLoad_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_optimizeMemory_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_enableRefresh_attr) << \\\;
m_refreshedBy_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_refreshedDate_attr << \\\;
_outStream << _attrName << \=\\ << m_refreshedDateIso_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_backgroundQuery_attr) << \\\;
_outStream << _attrName << \=\\ << m_missingItemsLimit_attr << \\\;
_outStream << _attrName << \=\\ << m_createdVersion_attr << \\\;
_outStream << _attrName << \=\\ << m_refreshedVersion_attr << \\\;
_outStream << _attrName << \=\\ << m_minRefreshableVersion_attr << \\\;
_outStream << _attrName << \=\\ << m_recordCount_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_upgradeOnRefresh_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_tupleCache_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_supportSubquery_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_supportAdvancedDrill_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_cacheSource)
                {
                    m_cacheSource->toXml(cacheSource, _outStream);;
                }
            
                if (m_has_cacheFields)
                {
                    m_cacheSource->toXml(cacheFields, _outStream);;
                }
            
                if (m_has_cacheHierarchies)
                {
                    m_cacheSource->toXml(cacheHierarchies, _outStream);;
                }
            
                if (m_has_kpis)
                {
                    m_cacheSource->toXml(kpis, _outStream);;
                }
            
                if (m_has_tupleCache)
                {
                    m_cacheSource->toXml(tupleCache, _outStream);;
                }
            
                if (m_has_calculatedItems)
                {
                    m_cacheSource->toXml(calculatedItems, _outStream);;
                }
            
                if (m_has_calculatedMembers)
                {
                    m_cacheSource->toXml(calculatedMembers, _outStream);;
                }
            
                if (m_has_dimensions)
                {
                    m_cacheSource->toXml(dimensions, _outStream);;
                }
            
                if (m_has_measureGroups)
                {
                    m_cacheSource->toXml(measureGroups, _outStream);;
                }
            
                if (m_has_maps)
                {
                    m_cacheSource->toXml(maps, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_cacheSource->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_PivotCacheDefinition& default_instance(){

    if (!CT_PivotCacheDefinition::default_instance_)
    {
        CT_PivotCacheDefinition::default_instance_ = new CT_PivotCacheDefinition();
    }
    return *CT_PivotCacheDefinition::default_instance_;

        }
        bool has_id_attr(){

            return m_has_id_attr;
        
        }
        void set_id_attr(const ST_RelationshipId& _id_attr ){

            m_has_id_attr = true;
            m_id_attr = new ST_RelationshipId(_id_attr);
        
        }
        const ST_RelationshipId& id_attr(){

            if (m_id_attr)
            {
                return *m_id_attr;
            }
            return ST_RelationshipId::default_instance();
        
        }
        bool has_invalid_attr(){

            return m_has_invalid_attr;
        
        }
        void set_invalid_attr(const boolean& _invalid_attr ){

        m_has_invalid_attr = true;
        m_invalid_attr = _invalid_attr;
        
        }
        const boolean& invalid_attr(){

            return type: oolean\nname: \m_invalid_attr\n;
        
        }
        bool has_saveData_attr(){

            return m_has_saveData_attr;
        
        }
        void set_saveData_attr(const boolean& _saveData_attr ){

        m_has_saveData_attr = true;
        m_saveData_attr = _saveData_attr;
        
        }
        const boolean& saveData_attr(){

            return type: oolean\nname: \m_saveData_attr\n;
        
        }
        bool has_refreshOnLoad_attr(){

            return m_has_refreshOnLoad_attr;
        
        }
        void set_refreshOnLoad_attr(const boolean& _refreshOnLoad_attr ){

        m_has_refreshOnLoad_attr = true;
        m_refreshOnLoad_attr = _refreshOnLoad_attr;
        
        }
        const boolean& refreshOnLoad_attr(){

            return type: oolean\nname: \m_refreshOnLoad_attr\n;
        
        }
        bool has_optimizeMemory_attr(){

            return m_has_optimizeMemory_attr;
        
        }
        void set_optimizeMemory_attr(const boolean& _optimizeMemory_attr ){

        m_has_optimizeMemory_attr = true;
        m_optimizeMemory_attr = _optimizeMemory_attr;
        
        }
        const boolean& optimizeMemory_attr(){

            return type: oolean\nname: \m_optimizeMemory_attr\n;
        
        }
        bool has_enableRefresh_attr(){

            return m_has_enableRefresh_attr;
        
        }
        void set_enableRefresh_attr(const boolean& _enableRefresh_attr ){

        m_has_enableRefresh_attr = true;
        m_enableRefresh_attr = _enableRefresh_attr;
        
        }
        const boolean& enableRefresh_attr(){

            return type: oolean\nname: \m_enableRefresh_attr\n;
        
        }
        bool has_refreshedBy_attr(){

            return m_has_refreshedBy_attr;
        
        }
        void set_refreshedBy_attr(const ns_s::ST_Xstring& _refreshedBy_attr ){

            m_has_refreshedBy_attr = true;
            m_refreshedBy_attr = new ns_s::ST_Xstring(_refreshedBy_attr);
        
        }
        const ns_s::ST_Xstring& refreshedBy_attr(){

            if (m_refreshedBy_attr)
            {
                return *m_refreshedBy_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_refreshedDate_attr(){

            return m_has_refreshedDate_attr;
        
        }
        void set_refreshedDate_attr(const double& _refreshedDate_attr ){

        m_has_refreshedDate_attr = true;
        m_refreshedDate_attr = _refreshedDate_attr;
        
        }
        const double& refreshedDate_attr(){

            return type: \double\nname: \m_refreshedDate_attr\n;
        
        }
        bool has_refreshedDateIso_attr(){

            return m_has_refreshedDateIso_attr;
        
        }
        void set_refreshedDateIso_attr(const dateTime& _refreshedDateIso_attr ){

        m_has_refreshedDateIso_attr = true;
        m_refreshedDateIso_attr = _refreshedDateIso_attr;
        
        }
        const dateTime& refreshedDateIso_attr(){

            return type: \dateTime\nname: \m_refreshedDateIso_attr\n;
        
        }
        bool has_backgroundQuery_attr(){

            return m_has_backgroundQuery_attr;
        
        }
        void set_backgroundQuery_attr(const boolean& _backgroundQuery_attr ){

        m_has_backgroundQuery_attr = true;
        m_backgroundQuery_attr = _backgroundQuery_attr;
        
        }
        const boolean& backgroundQuery_attr(){

            return type: oolean\nname: \m_backgroundQuery_attr\n;
        
        }
        bool has_missingItemsLimit_attr(){

            return m_has_missingItemsLimit_attr;
        
        }
        void set_missingItemsLimit_attr(const unsignedInt& _missingItemsLimit_attr ){

        m_has_missingItemsLimit_attr = true;
        m_missingItemsLimit_attr = _missingItemsLimit_attr;
        
        }
        const unsignedInt& missingItemsLimit_attr(){

            return type: \unsignedInt\nname: \m_missingItemsLimit_attr\n;
        
        }
        bool has_createdVersion_attr(){

            return m_has_createdVersion_attr;
        
        }
        void set_createdVersion_attr(const unsignedByte& _createdVersion_attr ){

        m_has_createdVersion_attr = true;
        m_createdVersion_attr = _createdVersion_attr;
        
        }
        const unsignedByte& createdVersion_attr(){

            return type: \unsignedByte\nname: \m_createdVersion_attr\n;
        
        }
        bool has_refreshedVersion_attr(){

            return m_has_refreshedVersion_attr;
        
        }
        void set_refreshedVersion_attr(const unsignedByte& _refreshedVersion_attr ){

        m_has_refreshedVersion_attr = true;
        m_refreshedVersion_attr = _refreshedVersion_attr;
        
        }
        const unsignedByte& refreshedVersion_attr(){

            return type: \unsignedByte\nname: \m_refreshedVersion_attr\n;
        
        }
        bool has_minRefreshableVersion_attr(){

            return m_has_minRefreshableVersion_attr;
        
        }
        void set_minRefreshableVersion_attr(const unsignedByte& _minRefreshableVersion_attr ){

        m_has_minRefreshableVersion_attr = true;
        m_minRefreshableVersion_attr = _minRefreshableVersion_attr;
        
        }
        const unsignedByte& minRefreshableVersion_attr(){

            return type: \unsignedByte\nname: \m_minRefreshableVersion_attr\n;
        
        }
        bool has_recordCount_attr(){

            return m_has_recordCount_attr;
        
        }
        void set_recordCount_attr(const unsignedInt& _recordCount_attr ){

        m_has_recordCount_attr = true;
        m_recordCount_attr = _recordCount_attr;
        
        }
        const unsignedInt& recordCount_attr(){

            return type: \unsignedInt\nname: \m_recordCount_attr\n;
        
        }
        bool has_upgradeOnRefresh_attr(){

            return m_has_upgradeOnRefresh_attr;
        
        }
        void set_upgradeOnRefresh_attr(const boolean& _upgradeOnRefresh_attr ){

        m_has_upgradeOnRefresh_attr = true;
        m_upgradeOnRefresh_attr = _upgradeOnRefresh_attr;
        
        }
        const boolean& upgradeOnRefresh_attr(){

            return type: oolean\nname: \m_upgradeOnRefresh_attr\n;
        
        }
        bool has_tupleCache_attr(){

            return m_has_tupleCache_attr;
        
        }
        void set_tupleCache_attr(const boolean& _tupleCache_attr ){

        m_has_tupleCache_attr = true;
        m_tupleCache_attr = _tupleCache_attr;
        
        }
        const boolean& tupleCache_attr(){

            return type: oolean\nname: \m_tupleCache_attr\n;
        
        }
        bool has_supportSubquery_attr(){

            return m_has_supportSubquery_attr;
        
        }
        void set_supportSubquery_attr(const boolean& _supportSubquery_attr ){

        m_has_supportSubquery_attr = true;
        m_supportSubquery_attr = _supportSubquery_attr;
        
        }
        const boolean& supportSubquery_attr(){

            return type: oolean\nname: \m_supportSubquery_attr\n;
        
        }
        bool has_supportAdvancedDrill_attr(){

            return m_has_supportAdvancedDrill_attr;
        
        }
        void set_supportAdvancedDrill_attr(const boolean& _supportAdvancedDrill_attr ){

        m_has_supportAdvancedDrill_attr = true;
        m_supportAdvancedDrill_attr = _supportAdvancedDrill_attr;
        
        }
        const boolean& supportAdvancedDrill_attr(){

            return type: oolean\nname: \m_supportAdvancedDrill_attr\n;
        
        }

    private:
        bool m_has_cacheSource ;
        CT_CacheSource* m_cacheSource ;
        bool m_has_cacheFields ;
        CT_CacheFields* m_cacheFields ;
        bool m_has_cacheHierarchies ;
        CT_CacheHierarchies* m_cacheHierarchies ;
        bool m_has_kpis ;
        CT_PCDKPIs* m_kpis ;
        bool m_has_tupleCache ;
        CT_TupleCache* m_tupleCache ;
        bool m_has_calculatedItems ;
        CT_CalculatedItems* m_calculatedItems ;
        bool m_has_calculatedMembers ;
        CT_CalculatedMembers* m_calculatedMembers ;
        bool m_has_dimensions ;
        CT_Dimensions* m_dimensions ;
        bool m_has_measureGroups ;
        CT_MeasureGroups* m_measureGroups ;
        bool m_has_maps ;
        CT_MeasureDimensionMaps* m_maps ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_PivotCacheDefinition* default_instance_ ;
        bool m_has_id_attr ;
        ST_RelationshipId* m_id_attr ;
        bool m_has_invalid_attr ;
        boolean m_invalid_attr ;
        bool m_has_saveData_attr ;
        boolean m_saveData_attr ;
        bool m_has_refreshOnLoad_attr ;
        boolean m_refreshOnLoad_attr ;
        bool m_has_optimizeMemory_attr ;
        boolean m_optimizeMemory_attr ;
        bool m_has_enableRefresh_attr ;
        boolean m_enableRefresh_attr ;
        bool m_has_refreshedBy_attr ;
        ns_s::ST_Xstring* m_refreshedBy_attr ;
        bool m_has_refreshedDate_attr ;
        double m_refreshedDate_attr ;
        bool m_has_refreshedDateIso_attr ;
        dateTime m_refreshedDateIso_attr ;
        bool m_has_backgroundQuery_attr ;
        boolean m_backgroundQuery_attr ;
        bool m_has_missingItemsLimit_attr ;
        unsignedInt m_missingItemsLimit_attr ;
        bool m_has_createdVersion_attr ;
        unsignedByte m_createdVersion_attr ;
        bool m_has_refreshedVersion_attr ;
        unsignedByte m_refreshedVersion_attr ;
        bool m_has_minRefreshableVersion_attr ;
        unsignedByte m_minRefreshableVersion_attr ;
        bool m_has_recordCount_attr ;
        unsignedInt m_recordCount_attr ;
        bool m_has_upgradeOnRefresh_attr ;
        boolean m_upgradeOnRefresh_attr ;
        bool m_has_tupleCache_attr ;
        boolean m_tupleCache_attr ;
        bool m_has_supportSubquery_attr ;
        boolean m_supportSubquery_attr ;
        bool m_has_supportAdvancedDrill_attr ;
        boolean m_supportAdvancedDrill_attr ;

    }

    class CT_CacheFields : public XSD::ComplexType{
    public:
        bool has_cacheField(){

            return m_has_cacheField;
        
        }
        CT_CacheField* mutable_cacheField(){

                m_has_cacheField = true;
                if (!m_cacheField)
                {
                    m_cacheField = new CT_CacheField();
                }
                return m_cacheField;
            
        }
        const CT_CacheField& cacheField(){

            if (m_cacheField)
            {
                return *m_cacheField;
            }
            return CT_CacheField::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_cacheField = false;
                
        if (m_cacheField)
        {
            delete m_cacheField;
            m_cacheField = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_cacheField)
                {
                    m_cacheField->toXml(cacheField, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CacheFields& default_instance(){

    if (!CT_CacheFields::default_instance_)
    {
        CT_CacheFields::default_instance_ = new CT_CacheFields();
    }
    return *CT_CacheFields::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_cacheField ;
        CT_CacheField* m_cacheField ;
        static CT_CacheFields* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_CacheField : public XSD::ComplexType{
    public:
        bool has_sharedItems(){

            return m_has_sharedItems;
        
        }
        CT_SharedItems* mutable_sharedItems(){

                m_has_sharedItems = true;
                if (!m_sharedItems)
                {
                    m_sharedItems = new CT_SharedItems();
                }
                return m_sharedItems;
            
        }
        const CT_SharedItems& sharedItems(){

            if (m_sharedItems)
            {
                return *m_sharedItems;
            }
            return CT_SharedItems::default_instance();
        
        }
        bool has_fieldGroup(){

            return m_has_fieldGroup;
        
        }
        CT_FieldGroup* mutable_fieldGroup(){

                m_has_fieldGroup = true;
                if (!m_fieldGroup)
                {
                    m_fieldGroup = new CT_FieldGroup();
                }
                return m_fieldGroup;
            
        }
        const CT_FieldGroup& fieldGroup(){

            if (m_fieldGroup)
            {
                return *m_fieldGroup;
            }
            return CT_FieldGroup::default_instance();
        
        }
        bool has_mpMap(){

            return m_has_mpMap;
        
        }
        CT_X* mutable_mpMap(){

                m_has_mpMap = true;
                if (!m_mpMap)
                {
                    m_mpMap = new CT_X();
                }
                return m_mpMap;
            
        }
        const CT_X& mpMap(){

            if (m_mpMap)
            {
                return *m_mpMap;
            }
            return CT_X::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
                m_has_caption_attr = false;
                
        if (m_caption_attr)
        {
            delete m_caption_attr;
            m_caption_attr = NULL;
        }
    
            
                m_has_propertyName_attr = false;
                
        if (m_propertyName_attr)
        {
            delete m_propertyName_attr;
            m_propertyName_attr = NULL;
        }
    
            
                m_has_serverField_attr = false;
                m_serverField_attr = false;
            
                m_has_uniqueList_attr = false;
                m_uniqueList_attr = false;
            
                m_has_numFmtId_attr = false;
                
        if (m_numFmtId_attr)
        {
            delete m_numFmtId_attr;
            m_numFmtId_attr = NULL;
        }
    
            
                m_has_formula_attr = false;
                
        if (m_formula_attr)
        {
            delete m_formula_attr;
            m_formula_attr = NULL;
        }
    
            
                m_has_sqlType_attr = false;
                m_sqlType_attr = 0;
            
                m_has_hierarchy_attr = false;
                m_hierarchy_attr = 0;
            
                m_has_level_attr = false;
                m_level_attr = 0;
            
                m_has_databaseField_attr = false;
                m_databaseField_attr = false;
            
                m_has_mappingCount_attr = false;
                m_mappingCount_attr = 0;
            
                m_has_memberPropertyField_attr = false;
                m_memberPropertyField_attr = false;
            
                m_has_sharedItems = false;
                
        if (m_sharedItems)
        {
            delete m_sharedItems;
            m_sharedItems = NULL;
        }
    
            
                m_has_fieldGroup = false;
                
        if (m_fieldGroup)
        {
            delete m_fieldGroup;
            m_fieldGroup = NULL;
        }
    
            
                m_has_mpMap = false;
                
        if (m_mpMap)
        {
            delete m_mpMap;
            m_mpMap = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_name_attr->toXml(_attrName, _outStream);
m_caption_attr->toXml(_attrName, _outStream);
m_propertyName_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_serverField_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_uniqueList_attr) << \\\;
m_numFmtId_attr->toXml(_attrName, _outStream);
m_formula_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_sqlType_attr << \\\;
_outStream << _attrName << \=\\ << m_hierarchy_attr << \\\;
_outStream << _attrName << \=\\ << m_level_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_databaseField_attr) << \\\;
_outStream << _attrName << \=\\ << m_mappingCount_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_memberPropertyField_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_sharedItems)
                {
                    m_sharedItems->toXml(sharedItems, _outStream);;
                }
            
                if (m_has_fieldGroup)
                {
                    m_sharedItems->toXml(fieldGroup, _outStream);;
                }
            
                if (m_has_mpMap)
                {
                    m_sharedItems->toXml(mpMap, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_sharedItems->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CacheField& default_instance(){

    if (!CT_CacheField::default_instance_)
    {
        CT_CacheField::default_instance_ = new CT_CacheField();
    }
    return *CT_CacheField::default_instance_;

        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_caption_attr(){

            return m_has_caption_attr;
        
        }
        void set_caption_attr(const ns_s::ST_Xstring& _caption_attr ){

            m_has_caption_attr = true;
            m_caption_attr = new ns_s::ST_Xstring(_caption_attr);
        
        }
        const ns_s::ST_Xstring& caption_attr(){

            if (m_caption_attr)
            {
                return *m_caption_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_propertyName_attr(){

            return m_has_propertyName_attr;
        
        }
        void set_propertyName_attr(const ns_s::ST_Xstring& _propertyName_attr ){

            m_has_propertyName_attr = true;
            m_propertyName_attr = new ns_s::ST_Xstring(_propertyName_attr);
        
        }
        const ns_s::ST_Xstring& propertyName_attr(){

            if (m_propertyName_attr)
            {
                return *m_propertyName_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_serverField_attr(){

            return m_has_serverField_attr;
        
        }
        void set_serverField_attr(const boolean& _serverField_attr ){

        m_has_serverField_attr = true;
        m_serverField_attr = _serverField_attr;
        
        }
        const boolean& serverField_attr(){

            return type: oolean\nname: \m_serverField_attr\n;
        
        }
        bool has_uniqueList_attr(){

            return m_has_uniqueList_attr;
        
        }
        void set_uniqueList_attr(const boolean& _uniqueList_attr ){

        m_has_uniqueList_attr = true;
        m_uniqueList_attr = _uniqueList_attr;
        
        }
        const boolean& uniqueList_attr(){

            return type: oolean\nname: \m_uniqueList_attr\n;
        
        }
        bool has_numFmtId_attr(){

            return m_has_numFmtId_attr;
        
        }
        void set_numFmtId_attr(const ST_NumFmtId& _numFmtId_attr ){

            m_has_numFmtId_attr = true;
            m_numFmtId_attr = new ST_NumFmtId(_numFmtId_attr);
        
        }
        const ST_NumFmtId& numFmtId_attr(){

            if (m_numFmtId_attr)
            {
                return *m_numFmtId_attr;
            }
            return ST_NumFmtId::default_instance();
        
        }
        bool has_formula_attr(){

            return m_has_formula_attr;
        
        }
        void set_formula_attr(const ns_s::ST_Xstring& _formula_attr ){

            m_has_formula_attr = true;
            m_formula_attr = new ns_s::ST_Xstring(_formula_attr);
        
        }
        const ns_s::ST_Xstring& formula_attr(){

            if (m_formula_attr)
            {
                return *m_formula_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_sqlType_attr(){

            return m_has_sqlType_attr;
        
        }
        void set_sqlType_attr(const int& _sqlType_attr ){

        m_has_sqlType_attr = true;
        m_sqlType_attr = _sqlType_attr;
        
        }
        const int& sqlType_attr(){

            return type: \int\nname: \m_sqlType_attr\n;
        
        }
        bool has_hierarchy_attr(){

            return m_has_hierarchy_attr;
        
        }
        void set_hierarchy_attr(const int& _hierarchy_attr ){

        m_has_hierarchy_attr = true;
        m_hierarchy_attr = _hierarchy_attr;
        
        }
        const int& hierarchy_attr(){

            return type: \int\nname: \m_hierarchy_attr\n;
        
        }
        bool has_level_attr(){

            return m_has_level_attr;
        
        }
        void set_level_attr(const unsignedInt& _level_attr ){

        m_has_level_attr = true;
        m_level_attr = _level_attr;
        
        }
        const unsignedInt& level_attr(){

            return type: \unsignedInt\nname: \m_level_attr\n;
        
        }
        bool has_databaseField_attr(){

            return m_has_databaseField_attr;
        
        }
        void set_databaseField_attr(const boolean& _databaseField_attr ){

        m_has_databaseField_attr = true;
        m_databaseField_attr = _databaseField_attr;
        
        }
        const boolean& databaseField_attr(){

            return type: oolean\nname: \m_databaseField_attr\n;
        
        }
        bool has_mappingCount_attr(){

            return m_has_mappingCount_attr;
        
        }
        void set_mappingCount_attr(const unsignedInt& _mappingCount_attr ){

        m_has_mappingCount_attr = true;
        m_mappingCount_attr = _mappingCount_attr;
        
        }
        const unsignedInt& mappingCount_attr(){

            return type: \unsignedInt\nname: \m_mappingCount_attr\n;
        
        }
        bool has_memberPropertyField_attr(){

            return m_has_memberPropertyField_attr;
        
        }
        void set_memberPropertyField_attr(const boolean& _memberPropertyField_attr ){

        m_has_memberPropertyField_attr = true;
        m_memberPropertyField_attr = _memberPropertyField_attr;
        
        }
        const boolean& memberPropertyField_attr(){

            return type: oolean\nname: \m_memberPropertyField_attr\n;
        
        }

    private:
        bool m_has_sharedItems ;
        CT_SharedItems* m_sharedItems ;
        bool m_has_fieldGroup ;
        CT_FieldGroup* m_fieldGroup ;
        bool m_has_mpMap ;
        CT_X* m_mpMap ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_CacheField* default_instance_ ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;
        bool m_has_caption_attr ;
        ns_s::ST_Xstring* m_caption_attr ;
        bool m_has_propertyName_attr ;
        ns_s::ST_Xstring* m_propertyName_attr ;
        bool m_has_serverField_attr ;
        boolean m_serverField_attr ;
        bool m_has_uniqueList_attr ;
        boolean m_uniqueList_attr ;
        bool m_has_numFmtId_attr ;
        ST_NumFmtId* m_numFmtId_attr ;
        bool m_has_formula_attr ;
        ns_s::ST_Xstring* m_formula_attr ;
        bool m_has_sqlType_attr ;
        int m_sqlType_attr ;
        bool m_has_hierarchy_attr ;
        int m_hierarchy_attr ;
        bool m_has_level_attr ;
        unsignedInt m_level_attr ;
        bool m_has_databaseField_attr ;
        boolean m_databaseField_attr ;
        bool m_has_mappingCount_attr ;
        unsignedInt m_mappingCount_attr ;
        bool m_has_memberPropertyField_attr ;
        boolean m_memberPropertyField_attr ;

    }

    class CT_CacheSource : public XSD::ComplexType{
    public:
        bool has_worksheetSource(){

            return m_has_worksheetSource;
        
        }
        CT_WorksheetSource* mutable_worksheetSource(){

                
                m_has_consolidation = false;
                
        if (m_consolidation)
        {
            delete m_consolidation;
            m_consolidation = NULL;
        }
    ;
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    ;
            
                m_has_worksheetSource = true;
                if (!m_worksheetSource)
                {
                    m_worksheetSource = new CT_WorksheetSource();
                }
                return m_worksheetSource;
            
        }
        const CT_WorksheetSource& worksheetSource(){

            if (m_worksheetSource)
            {
                return *m_worksheetSource;
            }
            return CT_WorksheetSource::default_instance();
        
        }
        bool has_consolidation(){

            return m_has_consolidation;
        
        }
        CT_Consolidation* mutable_consolidation(){

                
                m_has_worksheetSource = false;
                
        if (m_worksheetSource)
        {
            delete m_worksheetSource;
            m_worksheetSource = NULL;
        }
    ;
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    ;
            
                m_has_consolidation = true;
                if (!m_consolidation)
                {
                    m_consolidation = new CT_Consolidation();
                }
                return m_consolidation;
            
        }
        const CT_Consolidation& consolidation(){

            if (m_consolidation)
            {
                return *m_consolidation;
            }
            return CT_Consolidation::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                
                m_has_worksheetSource = false;
                
        if (m_worksheetSource)
        {
            delete m_worksheetSource;
            m_worksheetSource = NULL;
        }
    ;
            
                m_has_consolidation = false;
                
        if (m_consolidation)
        {
            delete m_consolidation;
            m_consolidation = NULL;
        }
    ;
            
                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_type_attr = false;
                
        if (m_type_attr)
        {
            delete m_type_attr;
            m_type_attr = NULL;
        }
    
            
                m_has_connectionId_attr = false;
                m_connectionId_attr = 0;
            
                m_has_worksheetSource = false;
                
        if (m_worksheetSource)
        {
            delete m_worksheetSource;
            m_worksheetSource = NULL;
        }
    
            
                m_has_consolidation = false;
                
        if (m_consolidation)
        {
            delete m_consolidation;
            m_consolidation = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_type_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_connectionId_attr << \\\;
        _outStream << \>\;
    
                if (m_has_worksheetSource)
                {
                    m_worksheetSource->toXml(worksheetSource, _outStream);;
                }
            
                if (m_has_consolidation)
                {
                    m_worksheetSource->toXml(consolidation, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_worksheetSource->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CacheSource& default_instance(){

    if (!CT_CacheSource::default_instance_)
    {
        CT_CacheSource::default_instance_ = new CT_CacheSource();
    }
    return *CT_CacheSource::default_instance_;

        }
        bool has_type_attr(){

            return m_has_type_attr;
        
        }
        void set_type_attr(const ST_SourceType& _type_attr ){

            m_has_type_attr = true;
            m_type_attr = new ST_SourceType(_type_attr);
        
        }
        const ST_SourceType& type_attr(){

            if (m_type_attr)
            {
                return *m_type_attr;
            }
            return ST_SourceType::default_instance();
        
        }
        bool has_connectionId_attr(){

            return m_has_connectionId_attr;
        
        }
        void set_connectionId_attr(const unsignedInt& _connectionId_attr ){

        m_has_connectionId_attr = true;
        m_connectionId_attr = _connectionId_attr;
        
        }
        const unsignedInt& connectionId_attr(){

            return type: \unsignedInt\nname: \m_connectionId_attr\n;
        
        }

    private:
        bool m_has_worksheetSource ;
        CT_WorksheetSource* m_worksheetSource ;
        bool m_has_consolidation ;
        CT_Consolidation* m_consolidation ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_CacheSource* default_instance_ ;
        bool m_has_type_attr ;
        ST_SourceType* m_type_attr ;
        bool m_has_connectionId_attr ;
        unsignedInt m_connectionId_attr ;

    }

    class CT_WorksheetSource : public XSD::ComplexType{
    public:
        void clear(){

                m_has_ref_attr = false;
                
        if (m_ref_attr)
        {
            delete m_ref_attr;
            m_ref_attr = NULL;
        }
    
            
                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
                m_has_sheet_attr = false;
                
        if (m_sheet_attr)
        {
            delete m_sheet_attr;
            m_sheet_attr = NULL;
        }
    
            
                m_has_id_attr = false;
                
        if (m_id_attr)
        {
            delete m_id_attr;
            m_id_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_ref_attr->toXml(_attrName, _outStream);
m_name_attr->toXml(_attrName, _outStream);
m_sheet_attr->toXml(_attrName, _outStream);
m_id_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_WorksheetSource& default_instance(){

    if (!CT_WorksheetSource::default_instance_)
    {
        CT_WorksheetSource::default_instance_ = new CT_WorksheetSource();
    }
    return *CT_WorksheetSource::default_instance_;

        }
        bool has_ref_attr(){

            return m_has_ref_attr;
        
        }
        void set_ref_attr(const ST_Ref& _ref_attr ){

            m_has_ref_attr = true;
            m_ref_attr = new ST_Ref(_ref_attr);
        
        }
        const ST_Ref& ref_attr(){

            if (m_ref_attr)
            {
                return *m_ref_attr;
            }
            return ST_Ref::default_instance();
        
        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_sheet_attr(){

            return m_has_sheet_attr;
        
        }
        void set_sheet_attr(const ns_s::ST_Xstring& _sheet_attr ){

            m_has_sheet_attr = true;
            m_sheet_attr = new ns_s::ST_Xstring(_sheet_attr);
        
        }
        const ns_s::ST_Xstring& sheet_attr(){

            if (m_sheet_attr)
            {
                return *m_sheet_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_id_attr(){

            return m_has_id_attr;
        
        }
        void set_id_attr(const ST_RelationshipId& _id_attr ){

            m_has_id_attr = true;
            m_id_attr = new ST_RelationshipId(_id_attr);
        
        }
        const ST_RelationshipId& id_attr(){

            if (m_id_attr)
            {
                return *m_id_attr;
            }
            return ST_RelationshipId::default_instance();
        
        }

    private:
        static CT_WorksheetSource* default_instance_ ;
        bool m_has_ref_attr ;
        ST_Ref* m_ref_attr ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;
        bool m_has_sheet_attr ;
        ns_s::ST_Xstring* m_sheet_attr ;
        bool m_has_id_attr ;
        ST_RelationshipId* m_id_attr ;

    }

    class CT_Consolidation : public XSD::ComplexType{
    public:
        bool has_pages(){

            return m_has_pages;
        
        }
        CT_Pages* mutable_pages(){

                m_has_pages = true;
                if (!m_pages)
                {
                    m_pages = new CT_Pages();
                }
                return m_pages;
            
        }
        const CT_Pages& pages(){

            if (m_pages)
            {
                return *m_pages;
            }
            return CT_Pages::default_instance();
        
        }
        bool has_rangeSets(){

            return m_has_rangeSets;
        
        }
        CT_RangeSets* mutable_rangeSets(){

                m_has_rangeSets = true;
                if (!m_rangeSets)
                {
                    m_rangeSets = new CT_RangeSets();
                }
                return m_rangeSets;
            
        }
        const CT_RangeSets& rangeSets(){

            if (m_rangeSets)
            {
                return *m_rangeSets;
            }
            return CT_RangeSets::default_instance();
        
        }
        void clear(){

                m_has_autoPage_attr = false;
                m_autoPage_attr = false;
            
                m_has_pages = false;
                
        if (m_pages)
        {
            delete m_pages;
            m_pages = NULL;
        }
    
            
                m_has_rangeSets = false;
                
        if (m_rangeSets)
        {
            delete m_rangeSets;
            m_rangeSets = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_autoPage_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_pages)
                {
                    m_pages->toXml(pages, _outStream);;
                }
            
                if (m_has_rangeSets)
                {
                    m_pages->toXml(rangeSets, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Consolidation& default_instance(){

    if (!CT_Consolidation::default_instance_)
    {
        CT_Consolidation::default_instance_ = new CT_Consolidation();
    }
    return *CT_Consolidation::default_instance_;

        }
        bool has_autoPage_attr(){

            return m_has_autoPage_attr;
        
        }
        void set_autoPage_attr(const boolean& _autoPage_attr ){

        m_has_autoPage_attr = true;
        m_autoPage_attr = _autoPage_attr;
        
        }
        const boolean& autoPage_attr(){

            return type: oolean\nname: \m_autoPage_attr\n;
        
        }

    private:
        bool m_has_pages ;
        CT_Pages* m_pages ;
        bool m_has_rangeSets ;
        CT_RangeSets* m_rangeSets ;
        static CT_Consolidation* default_instance_ ;
        bool m_has_autoPage_attr ;
        boolean m_autoPage_attr ;

    }

    class CT_Pages : public XSD::ComplexType{
    public:
        bool has_page(){

            return m_has_page;
        
        }
        CT_PCDSCPage* mutable_page(){

                m_has_page = true;
                if (!m_page)
                {
                    m_page = new CT_PCDSCPage();
                }
                return m_page;
            
        }
        const CT_PCDSCPage& page(){

            if (m_page)
            {
                return *m_page;
            }
            return CT_PCDSCPage::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_page = false;
                
        if (m_page)
        {
            delete m_page;
            m_page = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_page)
                {
                    m_page->toXml(page, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Pages& default_instance(){

    if (!CT_Pages::default_instance_)
    {
        CT_Pages::default_instance_ = new CT_Pages();
    }
    return *CT_Pages::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_page ;
        CT_PCDSCPage* m_page ;
        static CT_Pages* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_PCDSCPage : public XSD::ComplexType{
    public:
        bool has_pageItem(){

            return m_has_pageItem;
        
        }
        CT_PageItem* mutable_pageItem(){

                m_has_pageItem = true;
                if (!m_pageItem)
                {
                    m_pageItem = new CT_PageItem();
                }
                return m_pageItem;
            
        }
        const CT_PageItem& pageItem(){

            if (m_pageItem)
            {
                return *m_pageItem;
            }
            return CT_PageItem::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_pageItem = false;
                
        if (m_pageItem)
        {
            delete m_pageItem;
            m_pageItem = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_pageItem)
                {
                    m_pageItem->toXml(pageItem, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_PCDSCPage& default_instance(){

    if (!CT_PCDSCPage::default_instance_)
    {
        CT_PCDSCPage::default_instance_ = new CT_PCDSCPage();
    }
    return *CT_PCDSCPage::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_pageItem ;
        CT_PageItem* m_pageItem ;
        static CT_PCDSCPage* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_PageItem : public XSD::ComplexType{
    public:
        void clear(){

                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_name_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_PageItem& default_instance(){

    if (!CT_PageItem::default_instance_)
    {
        CT_PageItem::default_instance_ = new CT_PageItem();
    }
    return *CT_PageItem::default_instance_;

        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }

    private:
        static CT_PageItem* default_instance_ ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;

    }

    class CT_RangeSets : public XSD::ComplexType{
    public:
        bool has_rangeSet(){

            return m_has_rangeSet;
        
        }
        CT_RangeSet* mutable_rangeSet(){

                m_has_rangeSet = true;
                if (!m_rangeSet)
                {
                    m_rangeSet = new CT_RangeSet();
                }
                return m_rangeSet;
            
        }
        const CT_RangeSet& rangeSet(){

            if (m_rangeSet)
            {
                return *m_rangeSet;
            }
            return CT_RangeSet::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_rangeSet = false;
                
        if (m_rangeSet)
        {
            delete m_rangeSet;
            m_rangeSet = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_rangeSet)
                {
                    m_rangeSet->toXml(rangeSet, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_RangeSets& default_instance(){

    if (!CT_RangeSets::default_instance_)
    {
        CT_RangeSets::default_instance_ = new CT_RangeSets();
    }
    return *CT_RangeSets::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_rangeSet ;
        CT_RangeSet* m_rangeSet ;
        static CT_RangeSets* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_RangeSet : public XSD::ComplexType{
    public:
        void clear(){

                m_has_i1_attr = false;
                m_i1_attr = 0;
            
                m_has_i2_attr = false;
                m_i2_attr = 0;
            
                m_has_i3_attr = false;
                m_i3_attr = 0;
            
                m_has_i4_attr = false;
                m_i4_attr = 0;
            
                m_has_ref_attr = false;
                
        if (m_ref_attr)
        {
            delete m_ref_attr;
            m_ref_attr = NULL;
        }
    
            
                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
                m_has_sheet_attr = false;
                
        if (m_sheet_attr)
        {
            delete m_sheet_attr;
            m_sheet_attr = NULL;
        }
    
            
                m_has_id_attr = false;
                
        if (m_id_attr)
        {
            delete m_id_attr;
            m_id_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_i1_attr << \\\;
_outStream << _attrName << \=\\ << m_i2_attr << \\\;
_outStream << _attrName << \=\\ << m_i3_attr << \\\;
_outStream << _attrName << \=\\ << m_i4_attr << \\\;
m_ref_attr->toXml(_attrName, _outStream);
m_name_attr->toXml(_attrName, _outStream);
m_sheet_attr->toXml(_attrName, _outStream);
m_id_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_RangeSet& default_instance(){

    if (!CT_RangeSet::default_instance_)
    {
        CT_RangeSet::default_instance_ = new CT_RangeSet();
    }
    return *CT_RangeSet::default_instance_;

        }
        bool has_i1_attr(){

            return m_has_i1_attr;
        
        }
        void set_i1_attr(const unsignedInt& _i1_attr ){

        m_has_i1_attr = true;
        m_i1_attr = _i1_attr;
        
        }
        const unsignedInt& i1_attr(){

            return type: \unsignedInt\nname: \m_i1_attr\n;
        
        }
        bool has_i2_attr(){

            return m_has_i2_attr;
        
        }
        void set_i2_attr(const unsignedInt& _i2_attr ){

        m_has_i2_attr = true;
        m_i2_attr = _i2_attr;
        
        }
        const unsignedInt& i2_attr(){

            return type: \unsignedInt\nname: \m_i2_attr\n;
        
        }
        bool has_i3_attr(){

            return m_has_i3_attr;
        
        }
        void set_i3_attr(const unsignedInt& _i3_attr ){

        m_has_i3_attr = true;
        m_i3_attr = _i3_attr;
        
        }
        const unsignedInt& i3_attr(){

            return type: \unsignedInt\nname: \m_i3_attr\n;
        
        }
        bool has_i4_attr(){

            return m_has_i4_attr;
        
        }
        void set_i4_attr(const unsignedInt& _i4_attr ){

        m_has_i4_attr = true;
        m_i4_attr = _i4_attr;
        
        }
        const unsignedInt& i4_attr(){

            return type: \unsignedInt\nname: \m_i4_attr\n;
        
        }
        bool has_ref_attr(){

            return m_has_ref_attr;
        
        }
        void set_ref_attr(const ST_Ref& _ref_attr ){

            m_has_ref_attr = true;
            m_ref_attr = new ST_Ref(_ref_attr);
        
        }
        const ST_Ref& ref_attr(){

            if (m_ref_attr)
            {
                return *m_ref_attr;
            }
            return ST_Ref::default_instance();
        
        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_sheet_attr(){

            return m_has_sheet_attr;
        
        }
        void set_sheet_attr(const ns_s::ST_Xstring& _sheet_attr ){

            m_has_sheet_attr = true;
            m_sheet_attr = new ns_s::ST_Xstring(_sheet_attr);
        
        }
        const ns_s::ST_Xstring& sheet_attr(){

            if (m_sheet_attr)
            {
                return *m_sheet_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_id_attr(){

            return m_has_id_attr;
        
        }
        void set_id_attr(const ST_RelationshipId& _id_attr ){

            m_has_id_attr = true;
            m_id_attr = new ST_RelationshipId(_id_attr);
        
        }
        const ST_RelationshipId& id_attr(){

            if (m_id_attr)
            {
                return *m_id_attr;
            }
            return ST_RelationshipId::default_instance();
        
        }

    private:
        static CT_RangeSet* default_instance_ ;
        bool m_has_i1_attr ;
        unsignedInt m_i1_attr ;
        bool m_has_i2_attr ;
        unsignedInt m_i2_attr ;
        bool m_has_i3_attr ;
        unsignedInt m_i3_attr ;
        bool m_has_i4_attr ;
        unsignedInt m_i4_attr ;
        bool m_has_ref_attr ;
        ST_Ref* m_ref_attr ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;
        bool m_has_sheet_attr ;
        ns_s::ST_Xstring* m_sheet_attr ;
        bool m_has_id_attr ;
        ST_RelationshipId* m_id_attr ;

    }

    class CT_SharedItems : public XSD::ComplexType{
    public:
        CT_Missing* add_m(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_Missing* pNewChild = pChildGroup->mutable_m();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_Number* add_n(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_Number* pNewChild = pChildGroup->mutable_n();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_Boolean* add_b(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_Boolean* pNewChild = pChildGroup->mutable_b();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_Error* add_e(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_Error* pNewChild = pChildGroup->mutable_e();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_String* add_s(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_String* pNewChild = pChildGroup->mutable_s();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_DateTime* add_d(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_DateTime* pNewChild = pChildGroup->mutable_d();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        void clear(){

                m_has_containsSemiMixedTypes_attr = false;
                m_containsSemiMixedTypes_attr = false;
            
                m_has_containsNonDate_attr = false;
                m_containsNonDate_attr = false;
            
                m_has_containsDate_attr = false;
                m_containsDate_attr = false;
            
                m_has_containsString_attr = false;
                m_containsString_attr = false;
            
                m_has_containsBlank_attr = false;
                m_containsBlank_attr = false;
            
                m_has_containsMixedTypes_attr = false;
                m_containsMixedTypes_attr = false;
            
                m_has_containsNumber_attr = false;
                m_containsNumber_attr = false;
            
                m_has_containsInteger_attr = false;
                m_containsInteger_attr = false;
            
                m_has_minValue_attr = false;
                m_minValue_attr = 0;
            
                m_has_maxValue_attr = false;
                m_maxValue_attr = 0;
            
                m_has_minDate_attr = false;
                m_minDate_attr.clear();
            
                m_has_maxDate_attr = false;
                m_maxDate_attr.clear();
            
                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_longText_attr = false;
                m_longText_attr = false;
            
            vector<ChildGroup_1*>::iterator iter;
            for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
            {
                delete *iter;
            }
            m_childGroupList_1.clear();
        
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_containsSemiMixedTypes_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_containsNonDate_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_containsDate_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_containsString_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_containsBlank_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_containsMixedTypes_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_containsNumber_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_containsInteger_attr) << \\\;
_outStream << _attrName << \=\\ << m_minValue_attr << \\\;
_outStream << _attrName << \=\\ << m_maxValue_attr << \\\;
_outStream << _attrName << \=\\ << m_minDate_attr << \\\;
_outStream << _attrName << \=\\ << m_maxDate_attr << \\\;
_outStream << _attrName << \=\\ << m_count_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_longText_attr) << \\\;
        _outStream << \>\;
    
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_m())
            {
                (*iter)->toXml(m, _outStream);
            }
            else if ((*iter)->has_n())
            {
                (*iter)->toXml(n, _outStream);
            }
            else if ((*iter)->has_b())
            {
                (*iter)->toXml(b, _outStream);
            }
            else if ((*iter)->has_e())
            {
                (*iter)->toXml(e, _outStream);
            }
            else if ((*iter)->has_s())
            {
                (*iter)->toXml(s, _outStream);
            }
            else if ((*iter)->has_d())
            {
                (*iter)->toXml(d, _outStream);
            }
        }
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_SharedItems& default_instance(){

    if (!CT_SharedItems::default_instance_)
    {
        CT_SharedItems::default_instance_ = new CT_SharedItems();
    }
    return *CT_SharedItems::default_instance_;

        }
        bool has_containsSemiMixedTypes_attr(){

            return m_has_containsSemiMixedTypes_attr;
        
        }
        void set_containsSemiMixedTypes_attr(const boolean& _containsSemiMixedTypes_attr ){

        m_has_containsSemiMixedTypes_attr = true;
        m_containsSemiMixedTypes_attr = _containsSemiMixedTypes_attr;
        
        }
        const boolean& containsSemiMixedTypes_attr(){

            return type: oolean\nname: \m_containsSemiMixedTypes_attr\n;
        
        }
        bool has_containsNonDate_attr(){

            return m_has_containsNonDate_attr;
        
        }
        void set_containsNonDate_attr(const boolean& _containsNonDate_attr ){

        m_has_containsNonDate_attr = true;
        m_containsNonDate_attr = _containsNonDate_attr;
        
        }
        const boolean& containsNonDate_attr(){

            return type: oolean\nname: \m_containsNonDate_attr\n;
        
        }
        bool has_containsDate_attr(){

            return m_has_containsDate_attr;
        
        }
        void set_containsDate_attr(const boolean& _containsDate_attr ){

        m_has_containsDate_attr = true;
        m_containsDate_attr = _containsDate_attr;
        
        }
        const boolean& containsDate_attr(){

            return type: oolean\nname: \m_containsDate_attr\n;
        
        }
        bool has_containsString_attr(){

            return m_has_containsString_attr;
        
        }
        void set_containsString_attr(const boolean& _containsString_attr ){

        m_has_containsString_attr = true;
        m_containsString_attr = _containsString_attr;
        
        }
        const boolean& containsString_attr(){

            return type: oolean\nname: \m_containsString_attr\n;
        
        }
        bool has_containsBlank_attr(){

            return m_has_containsBlank_attr;
        
        }
        void set_containsBlank_attr(const boolean& _containsBlank_attr ){

        m_has_containsBlank_attr = true;
        m_containsBlank_attr = _containsBlank_attr;
        
        }
        const boolean& containsBlank_attr(){

            return type: oolean\nname: \m_containsBlank_attr\n;
        
        }
        bool has_containsMixedTypes_attr(){

            return m_has_containsMixedTypes_attr;
        
        }
        void set_containsMixedTypes_attr(const boolean& _containsMixedTypes_attr ){

        m_has_containsMixedTypes_attr = true;
        m_containsMixedTypes_attr = _containsMixedTypes_attr;
        
        }
        const boolean& containsMixedTypes_attr(){

            return type: oolean\nname: \m_containsMixedTypes_attr\n;
        
        }
        bool has_containsNumber_attr(){

            return m_has_containsNumber_attr;
        
        }
        void set_containsNumber_attr(const boolean& _containsNumber_attr ){

        m_has_containsNumber_attr = true;
        m_containsNumber_attr = _containsNumber_attr;
        
        }
        const boolean& containsNumber_attr(){

            return type: oolean\nname: \m_containsNumber_attr\n;
        
        }
        bool has_containsInteger_attr(){

            return m_has_containsInteger_attr;
        
        }
        void set_containsInteger_attr(const boolean& _containsInteger_attr ){

        m_has_containsInteger_attr = true;
        m_containsInteger_attr = _containsInteger_attr;
        
        }
        const boolean& containsInteger_attr(){

            return type: oolean\nname: \m_containsInteger_attr\n;
        
        }
        bool has_minValue_attr(){

            return m_has_minValue_attr;
        
        }
        void set_minValue_attr(const double& _minValue_attr ){

        m_has_minValue_attr = true;
        m_minValue_attr = _minValue_attr;
        
        }
        const double& minValue_attr(){

            return type: \double\nname: \m_minValue_attr\n;
        
        }
        bool has_maxValue_attr(){

            return m_has_maxValue_attr;
        
        }
        void set_maxValue_attr(const double& _maxValue_attr ){

        m_has_maxValue_attr = true;
        m_maxValue_attr = _maxValue_attr;
        
        }
        const double& maxValue_attr(){

            return type: \double\nname: \m_maxValue_attr\n;
        
        }
        bool has_minDate_attr(){

            return m_has_minDate_attr;
        
        }
        void set_minDate_attr(const dateTime& _minDate_attr ){

        m_has_minDate_attr = true;
        m_minDate_attr = _minDate_attr;
        
        }
        const dateTime& minDate_attr(){

            return type: \dateTime\nname: \m_minDate_attr\n;
        
        }
        bool has_maxDate_attr(){

            return m_has_maxDate_attr;
        
        }
        void set_maxDate_attr(const dateTime& _maxDate_attr ){

        m_has_maxDate_attr = true;
        m_maxDate_attr = _maxDate_attr;
        
        }
        const dateTime& maxDate_attr(){

            return type: \dateTime\nname: \m_maxDate_attr\n;
        
        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }
        bool has_longText_attr(){

            return m_has_longText_attr;
        
        }
        void set_longText_attr(const boolean& _longText_attr ){

        m_has_longText_attr = true;
        m_longText_attr = _longText_attr;
        
        }
        const boolean& longText_attr(){

            return type: oolean\nname: \m_longText_attr\n;
        
        }

    private:
        vector<ChildGroup_1*> m_childGroupList_1 ;
        static CT_SharedItems* default_instance_ ;
        bool m_has_containsSemiMixedTypes_attr ;
        boolean m_containsSemiMixedTypes_attr ;
        bool m_has_containsNonDate_attr ;
        boolean m_containsNonDate_attr ;
        bool m_has_containsDate_attr ;
        boolean m_containsDate_attr ;
        bool m_has_containsString_attr ;
        boolean m_containsString_attr ;
        bool m_has_containsBlank_attr ;
        boolean m_containsBlank_attr ;
        bool m_has_containsMixedTypes_attr ;
        boolean m_containsMixedTypes_attr ;
        bool m_has_containsNumber_attr ;
        boolean m_containsNumber_attr ;
        bool m_has_containsInteger_attr ;
        boolean m_containsInteger_attr ;
        bool m_has_minValue_attr ;
        double m_minValue_attr ;
        bool m_has_maxValue_attr ;
        double m_maxValue_attr ;
        bool m_has_minDate_attr ;
        dateTime m_minDate_attr ;
        bool m_has_maxDate_attr ;
        dateTime m_maxDate_attr ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;
        bool m_has_longText_attr ;
        boolean m_longText_attr ;
        class ChildGroup_1{
        public:
            bool has_m(){

            return m_has_m;
        
            }
            CT_Missing* mutable_m(){

                
                m_has_n = false;
                
        if (m_n)
        {
            delete m_n;
            m_n = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_e = false;
                
        if (m_e)
        {
            delete m_e;
            m_e = NULL;
        }
    ;
            
                m_has_s = false;
                
        if (m_s)
        {
            delete m_s;
            m_s = NULL;
        }
    ;
            
                m_has_d = false;
                
        if (m_d)
        {
            delete m_d;
            m_d = NULL;
        }
    ;
            
                m_has_m = true;
                if (!m_m)
                {
                    m_m = new CT_Missing();
                }
                return m_m;
            
            }
            const CT_Missing& m(){

            if (m_m)
            {
                return *m_m;
            }
            return CT_Missing::default_instance();
        
            }
            bool has_n(){

            return m_has_n;
        
            }
            CT_Number* mutable_n(){

                
                m_has_m = false;
                
        if (m_m)
        {
            delete m_m;
            m_m = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_e = false;
                
        if (m_e)
        {
            delete m_e;
            m_e = NULL;
        }
    ;
            
                m_has_s = false;
                
        if (m_s)
        {
            delete m_s;
            m_s = NULL;
        }
    ;
            
                m_has_d = false;
                
        if (m_d)
        {
            delete m_d;
            m_d = NULL;
        }
    ;
            
                m_has_n = true;
                if (!m_n)
                {
                    m_n = new CT_Number();
                }
                return m_n;
            
            }
            const CT_Number& n(){

            if (m_n)
            {
                return *m_n;
            }
            return CT_Number::default_instance();
        
            }
            bool has_b(){

            return m_has_b;
        
            }
            CT_Boolean* mutable_b(){

                
                m_has_m = false;
                
        if (m_m)
        {
            delete m_m;
            m_m = NULL;
        }
    ;
            
                m_has_n = false;
                
        if (m_n)
        {
            delete m_n;
            m_n = NULL;
        }
    ;
            
                m_has_e = false;
                
        if (m_e)
        {
            delete m_e;
            m_e = NULL;
        }
    ;
            
                m_has_s = false;
                
        if (m_s)
        {
            delete m_s;
            m_s = NULL;
        }
    ;
            
                m_has_d = false;
                
        if (m_d)
        {
            delete m_d;
            m_d = NULL;
        }
    ;
            
                m_has_b = true;
                if (!m_b)
                {
                    m_b = new CT_Boolean();
                }
                return m_b;
            
            }
            const CT_Boolean& b(){

            if (m_b)
            {
                return *m_b;
            }
            return CT_Boolean::default_instance();
        
            }
            bool has_e(){

            return m_has_e;
        
            }
            CT_Error* mutable_e(){

                
                m_has_m = false;
                
        if (m_m)
        {
            delete m_m;
            m_m = NULL;
        }
    ;
            
                m_has_n = false;
                
        if (m_n)
        {
            delete m_n;
            m_n = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_s = false;
                
        if (m_s)
        {
            delete m_s;
            m_s = NULL;
        }
    ;
            
                m_has_d = false;
                
        if (m_d)
        {
            delete m_d;
            m_d = NULL;
        }
    ;
            
                m_has_e = true;
                if (!m_e)
                {
                    m_e = new CT_Error();
                }
                return m_e;
            
            }
            const CT_Error& e(){

            if (m_e)
            {
                return *m_e;
            }
            return CT_Error::default_instance();
        
            }
            bool has_s(){

            return m_has_s;
        
            }
            CT_String* mutable_s(){

                
                m_has_m = false;
                
        if (m_m)
        {
            delete m_m;
            m_m = NULL;
        }
    ;
            
                m_has_n = false;
                
        if (m_n)
        {
            delete m_n;
            m_n = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_e = false;
                
        if (m_e)
        {
            delete m_e;
            m_e = NULL;
        }
    ;
            
                m_has_d = false;
                
        if (m_d)
        {
            delete m_d;
            m_d = NULL;
        }
    ;
            
                m_has_s = true;
                if (!m_s)
                {
                    m_s = new CT_String();
                }
                return m_s;
            
            }
            const CT_String& s(){

            if (m_s)
            {
                return *m_s;
            }
            return CT_String::default_instance();
        
            }
            bool has_d(){

            return m_has_d;
        
            }
            CT_DateTime* mutable_d(){

                
                m_has_m = false;
                
        if (m_m)
        {
            delete m_m;
            m_m = NULL;
        }
    ;
            
                m_has_n = false;
                
        if (m_n)
        {
            delete m_n;
            m_n = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_e = false;
                
        if (m_e)
        {
            delete m_e;
            m_e = NULL;
        }
    ;
            
                m_has_s = false;
                
        if (m_s)
        {
            delete m_s;
            m_s = NULL;
        }
    ;
            
                m_has_d = true;
                if (!m_d)
                {
                    m_d = new CT_DateTime();
                }
                return m_d;
            
            }
            const CT_DateTime& d(){

            if (m_d)
            {
                return *m_d;
            }
            return CT_DateTime::default_instance();
        
            }

        private:
            bool m_has_m ;
            CT_Missing* m_m ;
            bool m_has_n ;
            CT_Number* m_n ;
            bool m_has_b ;
            CT_Boolean* m_b ;
            bool m_has_e ;
            CT_Error* m_e ;
            bool m_has_s ;
            CT_String* m_s ;
            bool m_has_d ;
            CT_DateTime* m_d ;

        }


    }

    class CT_Missing : public XSD::ComplexType{
    public:
        bool has_tpls(){

            return m_has_tpls;
        
        }
        CT_Tuples* mutable_tpls(){

                m_has_tpls = true;
                if (!m_tpls)
                {
                    m_tpls = new CT_Tuples();
                }
                return m_tpls;
            
        }
        const CT_Tuples& tpls(){

            if (m_tpls)
            {
                return *m_tpls;
            }
            return CT_Tuples::default_instance();
        
        }
        bool has_x(){

            return m_has_x;
        
        }
        CT_X* mutable_x(){

                m_has_x = true;
                if (!m_x)
                {
                    m_x = new CT_X();
                }
                return m_x;
            
        }
        const CT_X& x(){

            if (m_x)
            {
                return *m_x;
            }
            return CT_X::default_instance();
        
        }
        void clear(){

                m_has_u_attr = false;
                m_u_attr = false;
            
                m_has_f_attr = false;
                m_f_attr = false;
            
                m_has_c_attr = false;
                
        if (m_c_attr)
        {
            delete m_c_attr;
            m_c_attr = NULL;
        }
    
            
                m_has_cp_attr = false;
                m_cp_attr = 0;
            
                m_has_in_attr = false;
                m_in_attr = 0;
            
                m_has_bc_attr = false;
                
        if (m_bc_attr)
        {
            delete m_bc_attr;
            m_bc_attr = NULL;
        }
    
            
                m_has_fc_attr = false;
                
        if (m_fc_attr)
        {
            delete m_fc_attr;
            m_fc_attr = NULL;
        }
    
            
                m_has_i_attr = false;
                m_i_attr = false;
            
                m_has_un_attr = false;
                m_un_attr = false;
            
                m_has_st_attr = false;
                m_st_attr = false;
            
                m_has_b_attr = false;
                m_b_attr = false;
            
                m_has_tpls = false;
                
        if (m_tpls)
        {
            delete m_tpls;
            m_tpls = NULL;
        }
    
            
                m_has_x = false;
                
        if (m_x)
        {
            delete m_x;
            m_x = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_u_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_f_attr) << \\\;
m_c_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_cp_attr << \\\;
_outStream << _attrName << \=\\ << m_in_attr << \\\;
m_bc_attr->toXml(_attrName, _outStream);
m_fc_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_i_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_un_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_st_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_b_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_tpls)
                {
                    m_tpls->toXml(tpls, _outStream);;
                }
            
                if (m_has_x)
                {
                    m_tpls->toXml(x, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Missing& default_instance(){

    if (!CT_Missing::default_instance_)
    {
        CT_Missing::default_instance_ = new CT_Missing();
    }
    return *CT_Missing::default_instance_;

        }
        bool has_u_attr(){

            return m_has_u_attr;
        
        }
        void set_u_attr(const boolean& _u_attr ){

        m_has_u_attr = true;
        m_u_attr = _u_attr;
        
        }
        const boolean& u_attr(){

            return type: oolean\nname: \m_u_attr\n;
        
        }
        bool has_f_attr(){

            return m_has_f_attr;
        
        }
        void set_f_attr(const boolean& _f_attr ){

        m_has_f_attr = true;
        m_f_attr = _f_attr;
        
        }
        const boolean& f_attr(){

            return type: oolean\nname: \m_f_attr\n;
        
        }
        bool has_c_attr(){

            return m_has_c_attr;
        
        }
        void set_c_attr(const ns_s::ST_Xstring& _c_attr ){

            m_has_c_attr = true;
            m_c_attr = new ns_s::ST_Xstring(_c_attr);
        
        }
        const ns_s::ST_Xstring& c_attr(){

            if (m_c_attr)
            {
                return *m_c_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_cp_attr(){

            return m_has_cp_attr;
        
        }
        void set_cp_attr(const unsignedInt& _cp_attr ){

        m_has_cp_attr = true;
        m_cp_attr = _cp_attr;
        
        }
        const unsignedInt& cp_attr(){

            return type: \unsignedInt\nname: \m_cp_attr\n;
        
        }
        bool has_in_attr(){

            return m_has_in_attr;
        
        }
        void set_in_attr(const unsignedInt& _in_attr ){

        m_has_in_attr = true;
        m_in_attr = _in_attr;
        
        }
        const unsignedInt& in_attr(){

            return type: \unsignedInt\nname: \m_in_attr\n;
        
        }
        bool has_bc_attr(){

            return m_has_bc_attr;
        
        }
        void set_bc_attr(const ST_UnsignedIntHex& _bc_attr ){

            m_has_bc_attr = true;
            m_bc_attr = new ST_UnsignedIntHex(_bc_attr);
        
        }
        const ST_UnsignedIntHex& bc_attr(){

            if (m_bc_attr)
            {
                return *m_bc_attr;
            }
            return ST_UnsignedIntHex::default_instance();
        
        }
        bool has_fc_attr(){

            return m_has_fc_attr;
        
        }
        void set_fc_attr(const ST_UnsignedIntHex& _fc_attr ){

            m_has_fc_attr = true;
            m_fc_attr = new ST_UnsignedIntHex(_fc_attr);
        
        }
        const ST_UnsignedIntHex& fc_attr(){

            if (m_fc_attr)
            {
                return *m_fc_attr;
            }
            return ST_UnsignedIntHex::default_instance();
        
        }
        bool has_i_attr(){

            return m_has_i_attr;
        
        }
        void set_i_attr(const boolean& _i_attr ){

        m_has_i_attr = true;
        m_i_attr = _i_attr;
        
        }
        const boolean& i_attr(){

            return type: oolean\nname: \m_i_attr\n;
        
        }
        bool has_un_attr(){

            return m_has_un_attr;
        
        }
        void set_un_attr(const boolean& _un_attr ){

        m_has_un_attr = true;
        m_un_attr = _un_attr;
        
        }
        const boolean& un_attr(){

            return type: oolean\nname: \m_un_attr\n;
        
        }
        bool has_st_attr(){

            return m_has_st_attr;
        
        }
        void set_st_attr(const boolean& _st_attr ){

        m_has_st_attr = true;
        m_st_attr = _st_attr;
        
        }
        const boolean& st_attr(){

            return type: oolean\nname: \m_st_attr\n;
        
        }
        bool has_b_attr(){

            return m_has_b_attr;
        
        }
        void set_b_attr(const boolean& _b_attr ){

        m_has_b_attr = true;
        m_b_attr = _b_attr;
        
        }
        const boolean& b_attr(){

            return type: oolean\nname: \m_b_attr\n;
        
        }

    private:
        bool m_has_tpls ;
        CT_Tuples* m_tpls ;
        bool m_has_x ;
        CT_X* m_x ;
        static CT_Missing* default_instance_ ;
        bool m_has_u_attr ;
        boolean m_u_attr ;
        bool m_has_f_attr ;
        boolean m_f_attr ;
        bool m_has_c_attr ;
        ns_s::ST_Xstring* m_c_attr ;
        bool m_has_cp_attr ;
        unsignedInt m_cp_attr ;
        bool m_has_in_attr ;
        unsignedInt m_in_attr ;
        bool m_has_bc_attr ;
        ST_UnsignedIntHex* m_bc_attr ;
        bool m_has_fc_attr ;
        ST_UnsignedIntHex* m_fc_attr ;
        bool m_has_i_attr ;
        boolean m_i_attr ;
        bool m_has_un_attr ;
        boolean m_un_attr ;
        bool m_has_st_attr ;
        boolean m_st_attr ;
        bool m_has_b_attr ;
        boolean m_b_attr ;

    }

    class CT_Number : public XSD::ComplexType{
    public:
        bool has_tpls(){

            return m_has_tpls;
        
        }
        CT_Tuples* mutable_tpls(){

                m_has_tpls = true;
                if (!m_tpls)
                {
                    m_tpls = new CT_Tuples();
                }
                return m_tpls;
            
        }
        const CT_Tuples& tpls(){

            if (m_tpls)
            {
                return *m_tpls;
            }
            return CT_Tuples::default_instance();
        
        }
        bool has_x(){

            return m_has_x;
        
        }
        CT_X* mutable_x(){

                m_has_x = true;
                if (!m_x)
                {
                    m_x = new CT_X();
                }
                return m_x;
            
        }
        const CT_X& x(){

            if (m_x)
            {
                return *m_x;
            }
            return CT_X::default_instance();
        
        }
        void clear(){

                m_has_v_attr = false;
                m_v_attr = 0;
            
                m_has_u_attr = false;
                m_u_attr = false;
            
                m_has_f_attr = false;
                m_f_attr = false;
            
                m_has_c_attr = false;
                
        if (m_c_attr)
        {
            delete m_c_attr;
            m_c_attr = NULL;
        }
    
            
                m_has_cp_attr = false;
                m_cp_attr = 0;
            
                m_has_in_attr = false;
                m_in_attr = 0;
            
                m_has_bc_attr = false;
                
        if (m_bc_attr)
        {
            delete m_bc_attr;
            m_bc_attr = NULL;
        }
    
            
                m_has_fc_attr = false;
                
        if (m_fc_attr)
        {
            delete m_fc_attr;
            m_fc_attr = NULL;
        }
    
            
                m_has_i_attr = false;
                m_i_attr = false;
            
                m_has_un_attr = false;
                m_un_attr = false;
            
                m_has_st_attr = false;
                m_st_attr = false;
            
                m_has_b_attr = false;
                m_b_attr = false;
            
                m_has_tpls = false;
                
        if (m_tpls)
        {
            delete m_tpls;
            m_tpls = NULL;
        }
    
            
                m_has_x = false;
                
        if (m_x)
        {
            delete m_x;
            m_x = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_v_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_u_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_f_attr) << \\\;
m_c_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_cp_attr << \\\;
_outStream << _attrName << \=\\ << m_in_attr << \\\;
m_bc_attr->toXml(_attrName, _outStream);
m_fc_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_i_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_un_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_st_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_b_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_tpls)
                {
                    m_tpls->toXml(tpls, _outStream);;
                }
            
                if (m_has_x)
                {
                    m_tpls->toXml(x, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Number& default_instance(){

    if (!CT_Number::default_instance_)
    {
        CT_Number::default_instance_ = new CT_Number();
    }
    return *CT_Number::default_instance_;

        }
        bool has_v_attr(){

            return m_has_v_attr;
        
        }
        void set_v_attr(const double& _v_attr ){

        m_has_v_attr = true;
        m_v_attr = _v_attr;
        
        }
        const double& v_attr(){

            return type: \double\nname: \m_v_attr\n;
        
        }
        bool has_u_attr(){

            return m_has_u_attr;
        
        }
        void set_u_attr(const boolean& _u_attr ){

        m_has_u_attr = true;
        m_u_attr = _u_attr;
        
        }
        const boolean& u_attr(){

            return type: oolean\nname: \m_u_attr\n;
        
        }
        bool has_f_attr(){

            return m_has_f_attr;
        
        }
        void set_f_attr(const boolean& _f_attr ){

        m_has_f_attr = true;
        m_f_attr = _f_attr;
        
        }
        const boolean& f_attr(){

            return type: oolean\nname: \m_f_attr\n;
        
        }
        bool has_c_attr(){

            return m_has_c_attr;
        
        }
        void set_c_attr(const ns_s::ST_Xstring& _c_attr ){

            m_has_c_attr = true;
            m_c_attr = new ns_s::ST_Xstring(_c_attr);
        
        }
        const ns_s::ST_Xstring& c_attr(){

            if (m_c_attr)
            {
                return *m_c_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_cp_attr(){

            return m_has_cp_attr;
        
        }
        void set_cp_attr(const unsignedInt& _cp_attr ){

        m_has_cp_attr = true;
        m_cp_attr = _cp_attr;
        
        }
        const unsignedInt& cp_attr(){

            return type: \unsignedInt\nname: \m_cp_attr\n;
        
        }
        bool has_in_attr(){

            return m_has_in_attr;
        
        }
        void set_in_attr(const unsignedInt& _in_attr ){

        m_has_in_attr = true;
        m_in_attr = _in_attr;
        
        }
        const unsignedInt& in_attr(){

            return type: \unsignedInt\nname: \m_in_attr\n;
        
        }
        bool has_bc_attr(){

            return m_has_bc_attr;
        
        }
        void set_bc_attr(const ST_UnsignedIntHex& _bc_attr ){

            m_has_bc_attr = true;
            m_bc_attr = new ST_UnsignedIntHex(_bc_attr);
        
        }
        const ST_UnsignedIntHex& bc_attr(){

            if (m_bc_attr)
            {
                return *m_bc_attr;
            }
            return ST_UnsignedIntHex::default_instance();
        
        }
        bool has_fc_attr(){

            return m_has_fc_attr;
        
        }
        void set_fc_attr(const ST_UnsignedIntHex& _fc_attr ){

            m_has_fc_attr = true;
            m_fc_attr = new ST_UnsignedIntHex(_fc_attr);
        
        }
        const ST_UnsignedIntHex& fc_attr(){

            if (m_fc_attr)
            {
                return *m_fc_attr;
            }
            return ST_UnsignedIntHex::default_instance();
        
        }
        bool has_i_attr(){

            return m_has_i_attr;
        
        }
        void set_i_attr(const boolean& _i_attr ){

        m_has_i_attr = true;
        m_i_attr = _i_attr;
        
        }
        const boolean& i_attr(){

            return type: oolean\nname: \m_i_attr\n;
        
        }
        bool has_un_attr(){

            return m_has_un_attr;
        
        }
        void set_un_attr(const boolean& _un_attr ){

        m_has_un_attr = true;
        m_un_attr = _un_attr;
        
        }
        const boolean& un_attr(){

            return type: oolean\nname: \m_un_attr\n;
        
        }
        bool has_st_attr(){

            return m_has_st_attr;
        
        }
        void set_st_attr(const boolean& _st_attr ){

        m_has_st_attr = true;
        m_st_attr = _st_attr;
        
        }
        const boolean& st_attr(){

            return type: oolean\nname: \m_st_attr\n;
        
        }
        bool has_b_attr(){

            return m_has_b_attr;
        
        }
        void set_b_attr(const boolean& _b_attr ){

        m_has_b_attr = true;
        m_b_attr = _b_attr;
        
        }
        const boolean& b_attr(){

            return type: oolean\nname: \m_b_attr\n;
        
        }

    private:
        bool m_has_tpls ;
        CT_Tuples* m_tpls ;
        bool m_has_x ;
        CT_X* m_x ;
        static CT_Number* default_instance_ ;
        bool m_has_v_attr ;
        double m_v_attr ;
        bool m_has_u_attr ;
        boolean m_u_attr ;
        bool m_has_f_attr ;
        boolean m_f_attr ;
        bool m_has_c_attr ;
        ns_s::ST_Xstring* m_c_attr ;
        bool m_has_cp_attr ;
        unsignedInt m_cp_attr ;
        bool m_has_in_attr ;
        unsignedInt m_in_attr ;
        bool m_has_bc_attr ;
        ST_UnsignedIntHex* m_bc_attr ;
        bool m_has_fc_attr ;
        ST_UnsignedIntHex* m_fc_attr ;
        bool m_has_i_attr ;
        boolean m_i_attr ;
        bool m_has_un_attr ;
        boolean m_un_attr ;
        bool m_has_st_attr ;
        boolean m_st_attr ;
        bool m_has_b_attr ;
        boolean m_b_attr ;

    }

    class CT_Boolean : public XSD::ComplexType{
    public:
        bool has_x(){

            return m_has_x;
        
        }
        CT_X* mutable_x(){

                m_has_x = true;
                if (!m_x)
                {
                    m_x = new CT_X();
                }
                return m_x;
            
        }
        const CT_X& x(){

            if (m_x)
            {
                return *m_x;
            }
            return CT_X::default_instance();
        
        }
        void clear(){

                m_has_v_attr = false;
                m_v_attr = false;
            
                m_has_u_attr = false;
                m_u_attr = false;
            
                m_has_f_attr = false;
                m_f_attr = false;
            
                m_has_c_attr = false;
                
        if (m_c_attr)
        {
            delete m_c_attr;
            m_c_attr = NULL;
        }
    
            
                m_has_cp_attr = false;
                m_cp_attr = 0;
            
                m_has_x = false;
                
        if (m_x)
        {
            delete m_x;
            m_x = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_v_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_u_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_f_attr) << \\\;
m_c_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_cp_attr << \\\;
        _outStream << \>\;
    
                if (m_has_x)
                {
                    m_x->toXml(x, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Boolean& default_instance(){

    if (!CT_Boolean::default_instance_)
    {
        CT_Boolean::default_instance_ = new CT_Boolean();
    }
    return *CT_Boolean::default_instance_;

        }
        bool has_v_attr(){

            return m_has_v_attr;
        
        }
        void set_v_attr(const boolean& _v_attr ){

        m_has_v_attr = true;
        m_v_attr = _v_attr;
        
        }
        const boolean& v_attr(){

            return type: oolean\nname: \m_v_attr\n;
        
        }
        bool has_u_attr(){

            return m_has_u_attr;
        
        }
        void set_u_attr(const boolean& _u_attr ){

        m_has_u_attr = true;
        m_u_attr = _u_attr;
        
        }
        const boolean& u_attr(){

            return type: oolean\nname: \m_u_attr\n;
        
        }
        bool has_f_attr(){

            return m_has_f_attr;
        
        }
        void set_f_attr(const boolean& _f_attr ){

        m_has_f_attr = true;
        m_f_attr = _f_attr;
        
        }
        const boolean& f_attr(){

            return type: oolean\nname: \m_f_attr\n;
        
        }
        bool has_c_attr(){

            return m_has_c_attr;
        
        }
        void set_c_attr(const ns_s::ST_Xstring& _c_attr ){

            m_has_c_attr = true;
            m_c_attr = new ns_s::ST_Xstring(_c_attr);
        
        }
        const ns_s::ST_Xstring& c_attr(){

            if (m_c_attr)
            {
                return *m_c_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_cp_attr(){

            return m_has_cp_attr;
        
        }
        void set_cp_attr(const unsignedInt& _cp_attr ){

        m_has_cp_attr = true;
        m_cp_attr = _cp_attr;
        
        }
        const unsignedInt& cp_attr(){

            return type: \unsignedInt\nname: \m_cp_attr\n;
        
        }

    private:
        bool m_has_x ;
        CT_X* m_x ;
        static CT_Boolean* default_instance_ ;
        bool m_has_v_attr ;
        boolean m_v_attr ;
        bool m_has_u_attr ;
        boolean m_u_attr ;
        bool m_has_f_attr ;
        boolean m_f_attr ;
        bool m_has_c_attr ;
        ns_s::ST_Xstring* m_c_attr ;
        bool m_has_cp_attr ;
        unsignedInt m_cp_attr ;

    }

    class CT_Error : public XSD::ComplexType{
    public:
        bool has_tpls(){

            return m_has_tpls;
        
        }
        CT_Tuples* mutable_tpls(){

                m_has_tpls = true;
                if (!m_tpls)
                {
                    m_tpls = new CT_Tuples();
                }
                return m_tpls;
            
        }
        const CT_Tuples& tpls(){

            if (m_tpls)
            {
                return *m_tpls;
            }
            return CT_Tuples::default_instance();
        
        }
        bool has_x(){

            return m_has_x;
        
        }
        CT_X* mutable_x(){

                m_has_x = true;
                if (!m_x)
                {
                    m_x = new CT_X();
                }
                return m_x;
            
        }
        const CT_X& x(){

            if (m_x)
            {
                return *m_x;
            }
            return CT_X::default_instance();
        
        }
        void clear(){

                m_has_v_attr = false;
                
        if (m_v_attr)
        {
            delete m_v_attr;
            m_v_attr = NULL;
        }
    
            
                m_has_u_attr = false;
                m_u_attr = false;
            
                m_has_f_attr = false;
                m_f_attr = false;
            
                m_has_c_attr = false;
                
        if (m_c_attr)
        {
            delete m_c_attr;
            m_c_attr = NULL;
        }
    
            
                m_has_cp_attr = false;
                m_cp_attr = 0;
            
                m_has_in_attr = false;
                m_in_attr = 0;
            
                m_has_bc_attr = false;
                
        if (m_bc_attr)
        {
            delete m_bc_attr;
            m_bc_attr = NULL;
        }
    
            
                m_has_fc_attr = false;
                
        if (m_fc_attr)
        {
            delete m_fc_attr;
            m_fc_attr = NULL;
        }
    
            
                m_has_i_attr = false;
                m_i_attr = false;
            
                m_has_un_attr = false;
                m_un_attr = false;
            
                m_has_st_attr = false;
                m_st_attr = false;
            
                m_has_b_attr = false;
                m_b_attr = false;
            
                m_has_tpls = false;
                
        if (m_tpls)
        {
            delete m_tpls;
            m_tpls = NULL;
        }
    
            
                m_has_x = false;
                
        if (m_x)
        {
            delete m_x;
            m_x = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_v_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_u_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_f_attr) << \\\;
m_c_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_cp_attr << \\\;
_outStream << _attrName << \=\\ << m_in_attr << \\\;
m_bc_attr->toXml(_attrName, _outStream);
m_fc_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_i_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_un_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_st_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_b_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_tpls)
                {
                    m_tpls->toXml(tpls, _outStream);;
                }
            
                if (m_has_x)
                {
                    m_tpls->toXml(x, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Error& default_instance(){

    if (!CT_Error::default_instance_)
    {
        CT_Error::default_instance_ = new CT_Error();
    }
    return *CT_Error::default_instance_;

        }
        bool has_v_attr(){

            return m_has_v_attr;
        
        }
        void set_v_attr(const ns_s::ST_Xstring& _v_attr ){

            m_has_v_attr = true;
            m_v_attr = new ns_s::ST_Xstring(_v_attr);
        
        }
        const ns_s::ST_Xstring& v_attr(){

            if (m_v_attr)
            {
                return *m_v_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_u_attr(){

            return m_has_u_attr;
        
        }
        void set_u_attr(const boolean& _u_attr ){

        m_has_u_attr = true;
        m_u_attr = _u_attr;
        
        }
        const boolean& u_attr(){

            return type: oolean\nname: \m_u_attr\n;
        
        }
        bool has_f_attr(){

            return m_has_f_attr;
        
        }
        void set_f_attr(const boolean& _f_attr ){

        m_has_f_attr = true;
        m_f_attr = _f_attr;
        
        }
        const boolean& f_attr(){

            return type: oolean\nname: \m_f_attr\n;
        
        }
        bool has_c_attr(){

            return m_has_c_attr;
        
        }
        void set_c_attr(const ns_s::ST_Xstring& _c_attr ){

            m_has_c_attr = true;
            m_c_attr = new ns_s::ST_Xstring(_c_attr);
        
        }
        const ns_s::ST_Xstring& c_attr(){

            if (m_c_attr)
            {
                return *m_c_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_cp_attr(){

            return m_has_cp_attr;
        
        }
        void set_cp_attr(const unsignedInt& _cp_attr ){

        m_has_cp_attr = true;
        m_cp_attr = _cp_attr;
        
        }
        const unsignedInt& cp_attr(){

            return type: \unsignedInt\nname: \m_cp_attr\n;
        
        }
        bool has_in_attr(){

            return m_has_in_attr;
        
        }
        void set_in_attr(const unsignedInt& _in_attr ){

        m_has_in_attr = true;
        m_in_attr = _in_attr;
        
        }
        const unsignedInt& in_attr(){

            return type: \unsignedInt\nname: \m_in_attr\n;
        
        }
        bool has_bc_attr(){

            return m_has_bc_attr;
        
        }
        void set_bc_attr(const ST_UnsignedIntHex& _bc_attr ){

            m_has_bc_attr = true;
            m_bc_attr = new ST_UnsignedIntHex(_bc_attr);
        
        }
        const ST_UnsignedIntHex& bc_attr(){

            if (m_bc_attr)
            {
                return *m_bc_attr;
            }
            return ST_UnsignedIntHex::default_instance();
        
        }
        bool has_fc_attr(){

            return m_has_fc_attr;
        
        }
        void set_fc_attr(const ST_UnsignedIntHex& _fc_attr ){

            m_has_fc_attr = true;
            m_fc_attr = new ST_UnsignedIntHex(_fc_attr);
        
        }
        const ST_UnsignedIntHex& fc_attr(){

            if (m_fc_attr)
            {
                return *m_fc_attr;
            }
            return ST_UnsignedIntHex::default_instance();
        
        }
        bool has_i_attr(){

            return m_has_i_attr;
        
        }
        void set_i_attr(const boolean& _i_attr ){

        m_has_i_attr = true;
        m_i_attr = _i_attr;
        
        }
        const boolean& i_attr(){

            return type: oolean\nname: \m_i_attr\n;
        
        }
        bool has_un_attr(){

            return m_has_un_attr;
        
        }
        void set_un_attr(const boolean& _un_attr ){

        m_has_un_attr = true;
        m_un_attr = _un_attr;
        
        }
        const boolean& un_attr(){

            return type: oolean\nname: \m_un_attr\n;
        
        }
        bool has_st_attr(){

            return m_has_st_attr;
        
        }
        void set_st_attr(const boolean& _st_attr ){

        m_has_st_attr = true;
        m_st_attr = _st_attr;
        
        }
        const boolean& st_attr(){

            return type: oolean\nname: \m_st_attr\n;
        
        }
        bool has_b_attr(){

            return m_has_b_attr;
        
        }
        void set_b_attr(const boolean& _b_attr ){

        m_has_b_attr = true;
        m_b_attr = _b_attr;
        
        }
        const boolean& b_attr(){

            return type: oolean\nname: \m_b_attr\n;
        
        }

    private:
        bool m_has_tpls ;
        CT_Tuples* m_tpls ;
        bool m_has_x ;
        CT_X* m_x ;
        static CT_Error* default_instance_ ;
        bool m_has_v_attr ;
        ns_s::ST_Xstring* m_v_attr ;
        bool m_has_u_attr ;
        boolean m_u_attr ;
        bool m_has_f_attr ;
        boolean m_f_attr ;
        bool m_has_c_attr ;
        ns_s::ST_Xstring* m_c_attr ;
        bool m_has_cp_attr ;
        unsignedInt m_cp_attr ;
        bool m_has_in_attr ;
        unsignedInt m_in_attr ;
        bool m_has_bc_attr ;
        ST_UnsignedIntHex* m_bc_attr ;
        bool m_has_fc_attr ;
        ST_UnsignedIntHex* m_fc_attr ;
        bool m_has_i_attr ;
        boolean m_i_attr ;
        bool m_has_un_attr ;
        boolean m_un_attr ;
        bool m_has_st_attr ;
        boolean m_st_attr ;
        bool m_has_b_attr ;
        boolean m_b_attr ;

    }

    class CT_String : public XSD::ComplexType{
    public:
        bool has_tpls(){

            return m_has_tpls;
        
        }
        CT_Tuples* mutable_tpls(){

                m_has_tpls = true;
                if (!m_tpls)
                {
                    m_tpls = new CT_Tuples();
                }
                return m_tpls;
            
        }
        const CT_Tuples& tpls(){

            if (m_tpls)
            {
                return *m_tpls;
            }
            return CT_Tuples::default_instance();
        
        }
        bool has_x(){

            return m_has_x;
        
        }
        CT_X* mutable_x(){

                m_has_x = true;
                if (!m_x)
                {
                    m_x = new CT_X();
                }
                return m_x;
            
        }
        const CT_X& x(){

            if (m_x)
            {
                return *m_x;
            }
            return CT_X::default_instance();
        
        }
        void clear(){

                m_has_v_attr = false;
                
        if (m_v_attr)
        {
            delete m_v_attr;
            m_v_attr = NULL;
        }
    
            
                m_has_u_attr = false;
                m_u_attr = false;
            
                m_has_f_attr = false;
                m_f_attr = false;
            
                m_has_c_attr = false;
                
        if (m_c_attr)
        {
            delete m_c_attr;
            m_c_attr = NULL;
        }
    
            
                m_has_cp_attr = false;
                m_cp_attr = 0;
            
                m_has_in_attr = false;
                m_in_attr = 0;
            
                m_has_bc_attr = false;
                
        if (m_bc_attr)
        {
            delete m_bc_attr;
            m_bc_attr = NULL;
        }
    
            
                m_has_fc_attr = false;
                
        if (m_fc_attr)
        {
            delete m_fc_attr;
            m_fc_attr = NULL;
        }
    
            
                m_has_i_attr = false;
                m_i_attr = false;
            
                m_has_un_attr = false;
                m_un_attr = false;
            
                m_has_st_attr = false;
                m_st_attr = false;
            
                m_has_b_attr = false;
                m_b_attr = false;
            
                m_has_tpls = false;
                
        if (m_tpls)
        {
            delete m_tpls;
            m_tpls = NULL;
        }
    
            
                m_has_x = false;
                
        if (m_x)
        {
            delete m_x;
            m_x = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_v_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_u_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_f_attr) << \\\;
m_c_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_cp_attr << \\\;
_outStream << _attrName << \=\\ << m_in_attr << \\\;
m_bc_attr->toXml(_attrName, _outStream);
m_fc_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_i_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_un_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_st_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_b_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_tpls)
                {
                    m_tpls->toXml(tpls, _outStream);;
                }
            
                if (m_has_x)
                {
                    m_tpls->toXml(x, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_String& default_instance(){

    if (!CT_String::default_instance_)
    {
        CT_String::default_instance_ = new CT_String();
    }
    return *CT_String::default_instance_;

        }
        bool has_v_attr(){

            return m_has_v_attr;
        
        }
        void set_v_attr(const ns_s::ST_Xstring& _v_attr ){

            m_has_v_attr = true;
            m_v_attr = new ns_s::ST_Xstring(_v_attr);
        
        }
        const ns_s::ST_Xstring& v_attr(){

            if (m_v_attr)
            {
                return *m_v_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_u_attr(){

            return m_has_u_attr;
        
        }
        void set_u_attr(const boolean& _u_attr ){

        m_has_u_attr = true;
        m_u_attr = _u_attr;
        
        }
        const boolean& u_attr(){

            return type: oolean\nname: \m_u_attr\n;
        
        }
        bool has_f_attr(){

            return m_has_f_attr;
        
        }
        void set_f_attr(const boolean& _f_attr ){

        m_has_f_attr = true;
        m_f_attr = _f_attr;
        
        }
        const boolean& f_attr(){

            return type: oolean\nname: \m_f_attr\n;
        
        }
        bool has_c_attr(){

            return m_has_c_attr;
        
        }
        void set_c_attr(const ns_s::ST_Xstring& _c_attr ){

            m_has_c_attr = true;
            m_c_attr = new ns_s::ST_Xstring(_c_attr);
        
        }
        const ns_s::ST_Xstring& c_attr(){

            if (m_c_attr)
            {
                return *m_c_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_cp_attr(){

            return m_has_cp_attr;
        
        }
        void set_cp_attr(const unsignedInt& _cp_attr ){

        m_has_cp_attr = true;
        m_cp_attr = _cp_attr;
        
        }
        const unsignedInt& cp_attr(){

            return type: \unsignedInt\nname: \m_cp_attr\n;
        
        }
        bool has_in_attr(){

            return m_has_in_attr;
        
        }
        void set_in_attr(const unsignedInt& _in_attr ){

        m_has_in_attr = true;
        m_in_attr = _in_attr;
        
        }
        const unsignedInt& in_attr(){

            return type: \unsignedInt\nname: \m_in_attr\n;
        
        }
        bool has_bc_attr(){

            return m_has_bc_attr;
        
        }
        void set_bc_attr(const ST_UnsignedIntHex& _bc_attr ){

            m_has_bc_attr = true;
            m_bc_attr = new ST_UnsignedIntHex(_bc_attr);
        
        }
        const ST_UnsignedIntHex& bc_attr(){

            if (m_bc_attr)
            {
                return *m_bc_attr;
            }
            return ST_UnsignedIntHex::default_instance();
        
        }
        bool has_fc_attr(){

            return m_has_fc_attr;
        
        }
        void set_fc_attr(const ST_UnsignedIntHex& _fc_attr ){

            m_has_fc_attr = true;
            m_fc_attr = new ST_UnsignedIntHex(_fc_attr);
        
        }
        const ST_UnsignedIntHex& fc_attr(){

            if (m_fc_attr)
            {
                return *m_fc_attr;
            }
            return ST_UnsignedIntHex::default_instance();
        
        }
        bool has_i_attr(){

            return m_has_i_attr;
        
        }
        void set_i_attr(const boolean& _i_attr ){

        m_has_i_attr = true;
        m_i_attr = _i_attr;
        
        }
        const boolean& i_attr(){

            return type: oolean\nname: \m_i_attr\n;
        
        }
        bool has_un_attr(){

            return m_has_un_attr;
        
        }
        void set_un_attr(const boolean& _un_attr ){

        m_has_un_attr = true;
        m_un_attr = _un_attr;
        
        }
        const boolean& un_attr(){

            return type: oolean\nname: \m_un_attr\n;
        
        }
        bool has_st_attr(){

            return m_has_st_attr;
        
        }
        void set_st_attr(const boolean& _st_attr ){

        m_has_st_attr = true;
        m_st_attr = _st_attr;
        
        }
        const boolean& st_attr(){

            return type: oolean\nname: \m_st_attr\n;
        
        }
        bool has_b_attr(){

            return m_has_b_attr;
        
        }
        void set_b_attr(const boolean& _b_attr ){

        m_has_b_attr = true;
        m_b_attr = _b_attr;
        
        }
        const boolean& b_attr(){

            return type: oolean\nname: \m_b_attr\n;
        
        }

    private:
        bool m_has_tpls ;
        CT_Tuples* m_tpls ;
        bool m_has_x ;
        CT_X* m_x ;
        static CT_String* default_instance_ ;
        bool m_has_v_attr ;
        ns_s::ST_Xstring* m_v_attr ;
        bool m_has_u_attr ;
        boolean m_u_attr ;
        bool m_has_f_attr ;
        boolean m_f_attr ;
        bool m_has_c_attr ;
        ns_s::ST_Xstring* m_c_attr ;
        bool m_has_cp_attr ;
        unsignedInt m_cp_attr ;
        bool m_has_in_attr ;
        unsignedInt m_in_attr ;
        bool m_has_bc_attr ;
        ST_UnsignedIntHex* m_bc_attr ;
        bool m_has_fc_attr ;
        ST_UnsignedIntHex* m_fc_attr ;
        bool m_has_i_attr ;
        boolean m_i_attr ;
        bool m_has_un_attr ;
        boolean m_un_attr ;
        bool m_has_st_attr ;
        boolean m_st_attr ;
        bool m_has_b_attr ;
        boolean m_b_attr ;

    }

    class CT_DateTime : public XSD::ComplexType{
    public:
        bool has_x(){

            return m_has_x;
        
        }
        CT_X* mutable_x(){

                m_has_x = true;
                if (!m_x)
                {
                    m_x = new CT_X();
                }
                return m_x;
            
        }
        const CT_X& x(){

            if (m_x)
            {
                return *m_x;
            }
            return CT_X::default_instance();
        
        }
        void clear(){

                m_has_v_attr = false;
                m_v_attr.clear();
            
                m_has_u_attr = false;
                m_u_attr = false;
            
                m_has_f_attr = false;
                m_f_attr = false;
            
                m_has_c_attr = false;
                
        if (m_c_attr)
        {
            delete m_c_attr;
            m_c_attr = NULL;
        }
    
            
                m_has_cp_attr = false;
                m_cp_attr = 0;
            
                m_has_x = false;
                
        if (m_x)
        {
            delete m_x;
            m_x = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_v_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_u_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_f_attr) << \\\;
m_c_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_cp_attr << \\\;
        _outStream << \>\;
    
                if (m_has_x)
                {
                    m_x->toXml(x, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_DateTime& default_instance(){

    if (!CT_DateTime::default_instance_)
    {
        CT_DateTime::default_instance_ = new CT_DateTime();
    }
    return *CT_DateTime::default_instance_;

        }
        bool has_v_attr(){

            return m_has_v_attr;
        
        }
        void set_v_attr(const dateTime& _v_attr ){

        m_has_v_attr = true;
        m_v_attr = _v_attr;
        
        }
        const dateTime& v_attr(){

            return type: \dateTime\nname: \m_v_attr\n;
        
        }
        bool has_u_attr(){

            return m_has_u_attr;
        
        }
        void set_u_attr(const boolean& _u_attr ){

        m_has_u_attr = true;
        m_u_attr = _u_attr;
        
        }
        const boolean& u_attr(){

            return type: oolean\nname: \m_u_attr\n;
        
        }
        bool has_f_attr(){

            return m_has_f_attr;
        
        }
        void set_f_attr(const boolean& _f_attr ){

        m_has_f_attr = true;
        m_f_attr = _f_attr;
        
        }
        const boolean& f_attr(){

            return type: oolean\nname: \m_f_attr\n;
        
        }
        bool has_c_attr(){

            return m_has_c_attr;
        
        }
        void set_c_attr(const ns_s::ST_Xstring& _c_attr ){

            m_has_c_attr = true;
            m_c_attr = new ns_s::ST_Xstring(_c_attr);
        
        }
        const ns_s::ST_Xstring& c_attr(){

            if (m_c_attr)
            {
                return *m_c_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_cp_attr(){

            return m_has_cp_attr;
        
        }
        void set_cp_attr(const unsignedInt& _cp_attr ){

        m_has_cp_attr = true;
        m_cp_attr = _cp_attr;
        
        }
        const unsignedInt& cp_attr(){

            return type: \unsignedInt\nname: \m_cp_attr\n;
        
        }

    private:
        bool m_has_x ;
        CT_X* m_x ;
        static CT_DateTime* default_instance_ ;
        bool m_has_v_attr ;
        dateTime m_v_attr ;
        bool m_has_u_attr ;
        boolean m_u_attr ;
        bool m_has_f_attr ;
        boolean m_f_attr ;
        bool m_has_c_attr ;
        ns_s::ST_Xstring* m_c_attr ;
        bool m_has_cp_attr ;
        unsignedInt m_cp_attr ;

    }

    class CT_FieldGroup : public XSD::ComplexType{
    public:
        bool has_rangePr(){

            return m_has_rangePr;
        
        }
        CT_RangePr* mutable_rangePr(){

                m_has_rangePr = true;
                if (!m_rangePr)
                {
                    m_rangePr = new CT_RangePr();
                }
                return m_rangePr;
            
        }
        const CT_RangePr& rangePr(){

            if (m_rangePr)
            {
                return *m_rangePr;
            }
            return CT_RangePr::default_instance();
        
        }
        bool has_discretePr(){

            return m_has_discretePr;
        
        }
        CT_DiscretePr* mutable_discretePr(){

                m_has_discretePr = true;
                if (!m_discretePr)
                {
                    m_discretePr = new CT_DiscretePr();
                }
                return m_discretePr;
            
        }
        const CT_DiscretePr& discretePr(){

            if (m_discretePr)
            {
                return *m_discretePr;
            }
            return CT_DiscretePr::default_instance();
        
        }
        bool has_groupItems(){

            return m_has_groupItems;
        
        }
        CT_GroupItems* mutable_groupItems(){

                m_has_groupItems = true;
                if (!m_groupItems)
                {
                    m_groupItems = new CT_GroupItems();
                }
                return m_groupItems;
            
        }
        const CT_GroupItems& groupItems(){

            if (m_groupItems)
            {
                return *m_groupItems;
            }
            return CT_GroupItems::default_instance();
        
        }
        void clear(){

                m_has_par_attr = false;
                m_par_attr = 0;
            
                m_has_base_attr = false;
                m_base_attr = 0;
            
                m_has_rangePr = false;
                
        if (m_rangePr)
        {
            delete m_rangePr;
            m_rangePr = NULL;
        }
    
            
                m_has_discretePr = false;
                
        if (m_discretePr)
        {
            delete m_discretePr;
            m_discretePr = NULL;
        }
    
            
                m_has_groupItems = false;
                
        if (m_groupItems)
        {
            delete m_groupItems;
            m_groupItems = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_par_attr << \\\;
_outStream << _attrName << \=\\ << m_base_attr << \\\;
        _outStream << \>\;
    
                if (m_has_rangePr)
                {
                    m_rangePr->toXml(rangePr, _outStream);;
                }
            
                if (m_has_discretePr)
                {
                    m_rangePr->toXml(discretePr, _outStream);;
                }
            
                if (m_has_groupItems)
                {
                    m_rangePr->toXml(groupItems, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_FieldGroup& default_instance(){

    if (!CT_FieldGroup::default_instance_)
    {
        CT_FieldGroup::default_instance_ = new CT_FieldGroup();
    }
    return *CT_FieldGroup::default_instance_;

        }
        bool has_par_attr(){

            return m_has_par_attr;
        
        }
        void set_par_attr(const unsignedInt& _par_attr ){

        m_has_par_attr = true;
        m_par_attr = _par_attr;
        
        }
        const unsignedInt& par_attr(){

            return type: \unsignedInt\nname: \m_par_attr\n;
        
        }
        bool has_base_attr(){

            return m_has_base_attr;
        
        }
        void set_base_attr(const unsignedInt& _base_attr ){

        m_has_base_attr = true;
        m_base_attr = _base_attr;
        
        }
        const unsignedInt& base_attr(){

            return type: \unsignedInt\nname: \m_base_attr\n;
        
        }

    private:
        bool m_has_rangePr ;
        CT_RangePr* m_rangePr ;
        bool m_has_discretePr ;
        CT_DiscretePr* m_discretePr ;
        bool m_has_groupItems ;
        CT_GroupItems* m_groupItems ;
        static CT_FieldGroup* default_instance_ ;
        bool m_has_par_attr ;
        unsignedInt m_par_attr ;
        bool m_has_base_attr ;
        unsignedInt m_base_attr ;

    }

    class CT_RangePr : public XSD::ComplexType{
    public:
        void clear(){

                m_has_autoStart_attr = false;
                m_autoStart_attr = false;
            
                m_has_autoEnd_attr = false;
                m_autoEnd_attr = false;
            
                m_has_groupBy_attr = false;
                
        if (m_groupBy_attr)
        {
            delete m_groupBy_attr;
            m_groupBy_attr = NULL;
        }
    
            
                m_has_startNum_attr = false;
                m_startNum_attr = 0;
            
                m_has_endNum_attr = false;
                m_endNum_attr = 0;
            
                m_has_startDate_attr = false;
                m_startDate_attr.clear();
            
                m_has_endDate_attr = false;
                m_endDate_attr.clear();
            
                m_has_groupInterval_attr = false;
                m_groupInterval_attr = 0;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_autoStart_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_autoEnd_attr) << \\\;
m_groupBy_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_startNum_attr << \\\;
_outStream << _attrName << \=\\ << m_endNum_attr << \\\;
_outStream << _attrName << \=\\ << m_startDate_attr << \\\;
_outStream << _attrName << \=\\ << m_endDate_attr << \\\;
_outStream << _attrName << \=\\ << m_groupInterval_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_RangePr& default_instance(){

    if (!CT_RangePr::default_instance_)
    {
        CT_RangePr::default_instance_ = new CT_RangePr();
    }
    return *CT_RangePr::default_instance_;

        }
        bool has_autoStart_attr(){

            return m_has_autoStart_attr;
        
        }
        void set_autoStart_attr(const boolean& _autoStart_attr ){

        m_has_autoStart_attr = true;
        m_autoStart_attr = _autoStart_attr;
        
        }
        const boolean& autoStart_attr(){

            return type: oolean\nname: \m_autoStart_attr\n;
        
        }
        bool has_autoEnd_attr(){

            return m_has_autoEnd_attr;
        
        }
        void set_autoEnd_attr(const boolean& _autoEnd_attr ){

        m_has_autoEnd_attr = true;
        m_autoEnd_attr = _autoEnd_attr;
        
        }
        const boolean& autoEnd_attr(){

            return type: oolean\nname: \m_autoEnd_attr\n;
        
        }
        bool has_groupBy_attr(){

            return m_has_groupBy_attr;
        
        }
        void set_groupBy_attr(const ST_GroupBy& _groupBy_attr ){

            m_has_groupBy_attr = true;
            m_groupBy_attr = new ST_GroupBy(_groupBy_attr);
        
        }
        const ST_GroupBy& groupBy_attr(){

            if (m_groupBy_attr)
            {
                return *m_groupBy_attr;
            }
            return ST_GroupBy::default_instance();
        
        }
        bool has_startNum_attr(){

            return m_has_startNum_attr;
        
        }
        void set_startNum_attr(const double& _startNum_attr ){

        m_has_startNum_attr = true;
        m_startNum_attr = _startNum_attr;
        
        }
        const double& startNum_attr(){

            return type: \double\nname: \m_startNum_attr\n;
        
        }
        bool has_endNum_attr(){

            return m_has_endNum_attr;
        
        }
        void set_endNum_attr(const double& _endNum_attr ){

        m_has_endNum_attr = true;
        m_endNum_attr = _endNum_attr;
        
        }
        const double& endNum_attr(){

            return type: \double\nname: \m_endNum_attr\n;
        
        }
        bool has_startDate_attr(){

            return m_has_startDate_attr;
        
        }
        void set_startDate_attr(const dateTime& _startDate_attr ){

        m_has_startDate_attr = true;
        m_startDate_attr = _startDate_attr;
        
        }
        const dateTime& startDate_attr(){

            return type: \dateTime\nname: \m_startDate_attr\n;
        
        }
        bool has_endDate_attr(){

            return m_has_endDate_attr;
        
        }
        void set_endDate_attr(const dateTime& _endDate_attr ){

        m_has_endDate_attr = true;
        m_endDate_attr = _endDate_attr;
        
        }
        const dateTime& endDate_attr(){

            return type: \dateTime\nname: \m_endDate_attr\n;
        
        }
        bool has_groupInterval_attr(){

            return m_has_groupInterval_attr;
        
        }
        void set_groupInterval_attr(const double& _groupInterval_attr ){

        m_has_groupInterval_attr = true;
        m_groupInterval_attr = _groupInterval_attr;
        
        }
        const double& groupInterval_attr(){

            return type: \double\nname: \m_groupInterval_attr\n;
        
        }

    private:
        static CT_RangePr* default_instance_ ;
        bool m_has_autoStart_attr ;
        boolean m_autoStart_attr ;
        bool m_has_autoEnd_attr ;
        boolean m_autoEnd_attr ;
        bool m_has_groupBy_attr ;
        ST_GroupBy* m_groupBy_attr ;
        bool m_has_startNum_attr ;
        double m_startNum_attr ;
        bool m_has_endNum_attr ;
        double m_endNum_attr ;
        bool m_has_startDate_attr ;
        dateTime m_startDate_attr ;
        bool m_has_endDate_attr ;
        dateTime m_endDate_attr ;
        bool m_has_groupInterval_attr ;
        double m_groupInterval_attr ;

    }

    class CT_DiscretePr : public XSD::ComplexType{
    public:
        bool has_x(){

            return m_has_x;
        
        }
        CT_Index* mutable_x(){

                m_has_x = true;
                if (!m_x)
                {
                    m_x = new CT_Index();
                }
                return m_x;
            
        }
        const CT_Index& x(){

            if (m_x)
            {
                return *m_x;
            }
            return CT_Index::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_x = false;
                
        if (m_x)
        {
            delete m_x;
            m_x = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_x)
                {
                    m_x->toXml(x, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_DiscretePr& default_instance(){

    if (!CT_DiscretePr::default_instance_)
    {
        CT_DiscretePr::default_instance_ = new CT_DiscretePr();
    }
    return *CT_DiscretePr::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_x ;
        CT_Index* m_x ;
        static CT_DiscretePr* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_GroupItems : public XSD::ComplexType{
    public:
        CT_Missing* add_m(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_Missing* pNewChild = pChildGroup->mutable_m();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_Number* add_n(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_Number* pNewChild = pChildGroup->mutable_n();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_Boolean* add_b(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_Boolean* pNewChild = pChildGroup->mutable_b();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_Error* add_e(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_Error* pNewChild = pChildGroup->mutable_e();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_String* add_s(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_String* pNewChild = pChildGroup->mutable_s();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_DateTime* add_d(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_DateTime* pNewChild = pChildGroup->mutable_d();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
            vector<ChildGroup_1*>::iterator iter;
            for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
            {
                delete *iter;
            }
            m_childGroupList_1.clear();
        
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_m())
            {
                (*iter)->toXml(m, _outStream);
            }
            else if ((*iter)->has_n())
            {
                (*iter)->toXml(n, _outStream);
            }
            else if ((*iter)->has_b())
            {
                (*iter)->toXml(b, _outStream);
            }
            else if ((*iter)->has_e())
            {
                (*iter)->toXml(e, _outStream);
            }
            else if ((*iter)->has_s())
            {
                (*iter)->toXml(s, _outStream);
            }
            else if ((*iter)->has_d())
            {
                (*iter)->toXml(d, _outStream);
            }
        }
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_GroupItems& default_instance(){

    if (!CT_GroupItems::default_instance_)
    {
        CT_GroupItems::default_instance_ = new CT_GroupItems();
    }
    return *CT_GroupItems::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        vector<ChildGroup_1*> m_childGroupList_1 ;
        static CT_GroupItems* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;
        class ChildGroup_1{
        public:
            bool has_m(){

            return m_has_m;
        
            }
            CT_Missing* mutable_m(){

                
                m_has_n = false;
                
        if (m_n)
        {
            delete m_n;
            m_n = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_e = false;
                
        if (m_e)
        {
            delete m_e;
            m_e = NULL;
        }
    ;
            
                m_has_s = false;
                
        if (m_s)
        {
            delete m_s;
            m_s = NULL;
        }
    ;
            
                m_has_d = false;
                
        if (m_d)
        {
            delete m_d;
            m_d = NULL;
        }
    ;
            
                m_has_m = true;
                if (!m_m)
                {
                    m_m = new CT_Missing();
                }
                return m_m;
            
            }
            const CT_Missing& m(){

            if (m_m)
            {
                return *m_m;
            }
            return CT_Missing::default_instance();
        
            }
            bool has_n(){

            return m_has_n;
        
            }
            CT_Number* mutable_n(){

                
                m_has_m = false;
                
        if (m_m)
        {
            delete m_m;
            m_m = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_e = false;
                
        if (m_e)
        {
            delete m_e;
            m_e = NULL;
        }
    ;
            
                m_has_s = false;
                
        if (m_s)
        {
            delete m_s;
            m_s = NULL;
        }
    ;
            
                m_has_d = false;
                
        if (m_d)
        {
            delete m_d;
            m_d = NULL;
        }
    ;
            
                m_has_n = true;
                if (!m_n)
                {
                    m_n = new CT_Number();
                }
                return m_n;
            
            }
            const CT_Number& n(){

            if (m_n)
            {
                return *m_n;
            }
            return CT_Number::default_instance();
        
            }
            bool has_b(){

            return m_has_b;
        
            }
            CT_Boolean* mutable_b(){

                
                m_has_m = false;
                
        if (m_m)
        {
            delete m_m;
            m_m = NULL;
        }
    ;
            
                m_has_n = false;
                
        if (m_n)
        {
            delete m_n;
            m_n = NULL;
        }
    ;
            
                m_has_e = false;
                
        if (m_e)
        {
            delete m_e;
            m_e = NULL;
        }
    ;
            
                m_has_s = false;
                
        if (m_s)
        {
            delete m_s;
            m_s = NULL;
        }
    ;
            
                m_has_d = false;
                
        if (m_d)
        {
            delete m_d;
            m_d = NULL;
        }
    ;
            
                m_has_b = true;
                if (!m_b)
                {
                    m_b = new CT_Boolean();
                }
                return m_b;
            
            }
            const CT_Boolean& b(){

            if (m_b)
            {
                return *m_b;
            }
            return CT_Boolean::default_instance();
        
            }
            bool has_e(){

            return m_has_e;
        
            }
            CT_Error* mutable_e(){

                
                m_has_m = false;
                
        if (m_m)
        {
            delete m_m;
            m_m = NULL;
        }
    ;
            
                m_has_n = false;
                
        if (m_n)
        {
            delete m_n;
            m_n = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_s = false;
                
        if (m_s)
        {
            delete m_s;
            m_s = NULL;
        }
    ;
            
                m_has_d = false;
                
        if (m_d)
        {
            delete m_d;
            m_d = NULL;
        }
    ;
            
                m_has_e = true;
                if (!m_e)
                {
                    m_e = new CT_Error();
                }
                return m_e;
            
            }
            const CT_Error& e(){

            if (m_e)
            {
                return *m_e;
            }
            return CT_Error::default_instance();
        
            }
            bool has_s(){

            return m_has_s;
        
            }
            CT_String* mutable_s(){

                
                m_has_m = false;
                
        if (m_m)
        {
            delete m_m;
            m_m = NULL;
        }
    ;
            
                m_has_n = false;
                
        if (m_n)
        {
            delete m_n;
            m_n = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_e = false;
                
        if (m_e)
        {
            delete m_e;
            m_e = NULL;
        }
    ;
            
                m_has_d = false;
                
        if (m_d)
        {
            delete m_d;
            m_d = NULL;
        }
    ;
            
                m_has_s = true;
                if (!m_s)
                {
                    m_s = new CT_String();
                }
                return m_s;
            
            }
            const CT_String& s(){

            if (m_s)
            {
                return *m_s;
            }
            return CT_String::default_instance();
        
            }
            bool has_d(){

            return m_has_d;
        
            }
            CT_DateTime* mutable_d(){

                
                m_has_m = false;
                
        if (m_m)
        {
            delete m_m;
            m_m = NULL;
        }
    ;
            
                m_has_n = false;
                
        if (m_n)
        {
            delete m_n;
            m_n = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_e = false;
                
        if (m_e)
        {
            delete m_e;
            m_e = NULL;
        }
    ;
            
                m_has_s = false;
                
        if (m_s)
        {
            delete m_s;
            m_s = NULL;
        }
    ;
            
                m_has_d = true;
                if (!m_d)
                {
                    m_d = new CT_DateTime();
                }
                return m_d;
            
            }
            const CT_DateTime& d(){

            if (m_d)
            {
                return *m_d;
            }
            return CT_DateTime::default_instance();
        
            }

        private:
            bool m_has_m ;
            CT_Missing* m_m ;
            bool m_has_n ;
            CT_Number* m_n ;
            bool m_has_b ;
            CT_Boolean* m_b ;
            bool m_has_e ;
            CT_Error* m_e ;
            bool m_has_s ;
            CT_String* m_s ;
            bool m_has_d ;
            CT_DateTime* m_d ;

        }


    }

    class CT_PivotCacheRecords : public XSD::ComplexType{
    public:
        bool has_r(){

            return m_has_r;
        
        }
        CT_Record* mutable_r(){

                m_has_r = true;
                if (!m_r)
                {
                    m_r = new CT_Record();
                }
                return m_r;
            
        }
        const CT_Record& r(){

            if (m_r)
            {
                return *m_r;
            }
            return CT_Record::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_r = false;
                
        if (m_r)
        {
            delete m_r;
            m_r = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_r)
                {
                    m_r->toXml(r, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_r->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_PivotCacheRecords& default_instance(){

    if (!CT_PivotCacheRecords::default_instance_)
    {
        CT_PivotCacheRecords::default_instance_ = new CT_PivotCacheRecords();
    }
    return *CT_PivotCacheRecords::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_r ;
        CT_Record* m_r ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_PivotCacheRecords* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_Record : public XSD::ComplexType{
    public:
        CT_Missing* add_m(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_Missing* pNewChild = pChildGroup->mutable_m();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_Number* add_n(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_Number* pNewChild = pChildGroup->mutable_n();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_Boolean* add_b(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_Boolean* pNewChild = pChildGroup->mutable_b();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_Error* add_e(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_Error* pNewChild = pChildGroup->mutable_e();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_String* add_s(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_String* pNewChild = pChildGroup->mutable_s();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_DateTime* add_d(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_DateTime* pNewChild = pChildGroup->mutable_d();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_Index* add_x(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_Index* pNewChild = pChildGroup->mutable_x();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        void clear(){

            vector<ChildGroup_1*>::iterator iter;
            for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
            {
                delete *iter;
            }
            m_childGroupList_1.clear();
        
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_m())
            {
                (*iter)->toXml(m, _outStream);
            }
            else if ((*iter)->has_n())
            {
                (*iter)->toXml(n, _outStream);
            }
            else if ((*iter)->has_b())
            {
                (*iter)->toXml(b, _outStream);
            }
            else if ((*iter)->has_e())
            {
                (*iter)->toXml(e, _outStream);
            }
            else if ((*iter)->has_s())
            {
                (*iter)->toXml(s, _outStream);
            }
            else if ((*iter)->has_d())
            {
                (*iter)->toXml(d, _outStream);
            }
            else if ((*iter)->has_x())
            {
                (*iter)->toXml(x, _outStream);
            }
        }
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Record& default_instance(){

    if (!CT_Record::default_instance_)
    {
        CT_Record::default_instance_ = new CT_Record();
    }
    return *CT_Record::default_instance_;

        }

    private:
        vector<ChildGroup_1*> m_childGroupList_1 ;
        static CT_Record* default_instance_ ;
        class ChildGroup_1{
        public:
            bool has_m(){

            return m_has_m;
        
            }
            CT_Missing* mutable_m(){

                
                m_has_n = false;
                
        if (m_n)
        {
            delete m_n;
            m_n = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_e = false;
                
        if (m_e)
        {
            delete m_e;
            m_e = NULL;
        }
    ;
            
                m_has_s = false;
                
        if (m_s)
        {
            delete m_s;
            m_s = NULL;
        }
    ;
            
                m_has_d = false;
                
        if (m_d)
        {
            delete m_d;
            m_d = NULL;
        }
    ;
            
                m_has_x = false;
                
        if (m_x)
        {
            delete m_x;
            m_x = NULL;
        }
    ;
            
                m_has_m = true;
                if (!m_m)
                {
                    m_m = new CT_Missing();
                }
                return m_m;
            
            }
            const CT_Missing& m(){

            if (m_m)
            {
                return *m_m;
            }
            return CT_Missing::default_instance();
        
            }
            bool has_n(){

            return m_has_n;
        
            }
            CT_Number* mutable_n(){

                
                m_has_m = false;
                
        if (m_m)
        {
            delete m_m;
            m_m = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_e = false;
                
        if (m_e)
        {
            delete m_e;
            m_e = NULL;
        }
    ;
            
                m_has_s = false;
                
        if (m_s)
        {
            delete m_s;
            m_s = NULL;
        }
    ;
            
                m_has_d = false;
                
        if (m_d)
        {
            delete m_d;
            m_d = NULL;
        }
    ;
            
                m_has_x = false;
                
        if (m_x)
        {
            delete m_x;
            m_x = NULL;
        }
    ;
            
                m_has_n = true;
                if (!m_n)
                {
                    m_n = new CT_Number();
                }
                return m_n;
            
            }
            const CT_Number& n(){

            if (m_n)
            {
                return *m_n;
            }
            return CT_Number::default_instance();
        
            }
            bool has_b(){

            return m_has_b;
        
            }
            CT_Boolean* mutable_b(){

                
                m_has_m = false;
                
        if (m_m)
        {
            delete m_m;
            m_m = NULL;
        }
    ;
            
                m_has_n = false;
                
        if (m_n)
        {
            delete m_n;
            m_n = NULL;
        }
    ;
            
                m_has_e = false;
                
        if (m_e)
        {
            delete m_e;
            m_e = NULL;
        }
    ;
            
                m_has_s = false;
                
        if (m_s)
        {
            delete m_s;
            m_s = NULL;
        }
    ;
            
                m_has_d = false;
                
        if (m_d)
        {
            delete m_d;
            m_d = NULL;
        }
    ;
            
                m_has_x = false;
                
        if (m_x)
        {
            delete m_x;
            m_x = NULL;
        }
    ;
            
                m_has_b = true;
                if (!m_b)
                {
                    m_b = new CT_Boolean();
                }
                return m_b;
            
            }
            const CT_Boolean& b(){

            if (m_b)
            {
                return *m_b;
            }
            return CT_Boolean::default_instance();
        
            }
            bool has_e(){

            return m_has_e;
        
            }
            CT_Error* mutable_e(){

                
                m_has_m = false;
                
        if (m_m)
        {
            delete m_m;
            m_m = NULL;
        }
    ;
            
                m_has_n = false;
                
        if (m_n)
        {
            delete m_n;
            m_n = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_s = false;
                
        if (m_s)
        {
            delete m_s;
            m_s = NULL;
        }
    ;
            
                m_has_d = false;
                
        if (m_d)
        {
            delete m_d;
            m_d = NULL;
        }
    ;
            
                m_has_x = false;
                
        if (m_x)
        {
            delete m_x;
            m_x = NULL;
        }
    ;
            
                m_has_e = true;
                if (!m_e)
                {
                    m_e = new CT_Error();
                }
                return m_e;
            
            }
            const CT_Error& e(){

            if (m_e)
            {
                return *m_e;
            }
            return CT_Error::default_instance();
        
            }
            bool has_s(){

            return m_has_s;
        
            }
            CT_String* mutable_s(){

                
                m_has_m = false;
                
        if (m_m)
        {
            delete m_m;
            m_m = NULL;
        }
    ;
            
                m_has_n = false;
                
        if (m_n)
        {
            delete m_n;
            m_n = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_e = false;
                
        if (m_e)
        {
            delete m_e;
            m_e = NULL;
        }
    ;
            
                m_has_d = false;
                
        if (m_d)
        {
            delete m_d;
            m_d = NULL;
        }
    ;
            
                m_has_x = false;
                
        if (m_x)
        {
            delete m_x;
            m_x = NULL;
        }
    ;
            
                m_has_s = true;
                if (!m_s)
                {
                    m_s = new CT_String();
                }
                return m_s;
            
            }
            const CT_String& s(){

            if (m_s)
            {
                return *m_s;
            }
            return CT_String::default_instance();
        
            }
            bool has_d(){

            return m_has_d;
        
            }
            CT_DateTime* mutable_d(){

                
                m_has_m = false;
                
        if (m_m)
        {
            delete m_m;
            m_m = NULL;
        }
    ;
            
                m_has_n = false;
                
        if (m_n)
        {
            delete m_n;
            m_n = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_e = false;
                
        if (m_e)
        {
            delete m_e;
            m_e = NULL;
        }
    ;
            
                m_has_s = false;
                
        if (m_s)
        {
            delete m_s;
            m_s = NULL;
        }
    ;
            
                m_has_x = false;
                
        if (m_x)
        {
            delete m_x;
            m_x = NULL;
        }
    ;
            
                m_has_d = true;
                if (!m_d)
                {
                    m_d = new CT_DateTime();
                }
                return m_d;
            
            }
            const CT_DateTime& d(){

            if (m_d)
            {
                return *m_d;
            }
            return CT_DateTime::default_instance();
        
            }
            bool has_x(){

            return m_has_x;
        
            }
            CT_Index* mutable_x(){

                
                m_has_m = false;
                
        if (m_m)
        {
            delete m_m;
            m_m = NULL;
        }
    ;
            
                m_has_n = false;
                
        if (m_n)
        {
            delete m_n;
            m_n = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_e = false;
                
        if (m_e)
        {
            delete m_e;
            m_e = NULL;
        }
    ;
            
                m_has_s = false;
                
        if (m_s)
        {
            delete m_s;
            m_s = NULL;
        }
    ;
            
                m_has_d = false;
                
        if (m_d)
        {
            delete m_d;
            m_d = NULL;
        }
    ;
            
                m_has_x = true;
                if (!m_x)
                {
                    m_x = new CT_Index();
                }
                return m_x;
            
            }
            const CT_Index& x(){

            if (m_x)
            {
                return *m_x;
            }
            return CT_Index::default_instance();
        
            }

        private:
            bool m_has_m ;
            CT_Missing* m_m ;
            bool m_has_n ;
            CT_Number* m_n ;
            bool m_has_b ;
            CT_Boolean* m_b ;
            bool m_has_e ;
            CT_Error* m_e ;
            bool m_has_s ;
            CT_String* m_s ;
            bool m_has_d ;
            CT_DateTime* m_d ;
            bool m_has_x ;
            CT_Index* m_x ;

        }


    }

    class CT_PCDKPIs : public XSD::ComplexType{
    public:
        bool has_kpi(){

            return m_has_kpi;
        
        }
        CT_PCDKPI* mutable_kpi(){

                m_has_kpi = true;
                if (!m_kpi)
                {
                    m_kpi = new CT_PCDKPI();
                }
                return m_kpi;
            
        }
        const CT_PCDKPI& kpi(){

            if (m_kpi)
            {
                return *m_kpi;
            }
            return CT_PCDKPI::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_kpi = false;
                
        if (m_kpi)
        {
            delete m_kpi;
            m_kpi = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_kpi)
                {
                    m_kpi->toXml(kpi, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_PCDKPIs& default_instance(){

    if (!CT_PCDKPIs::default_instance_)
    {
        CT_PCDKPIs::default_instance_ = new CT_PCDKPIs();
    }
    return *CT_PCDKPIs::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_kpi ;
        CT_PCDKPI* m_kpi ;
        static CT_PCDKPIs* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_PCDKPI : public XSD::ComplexType{
    public:
        void clear(){

                m_has_uniqueName_attr = false;
                
        if (m_uniqueName_attr)
        {
            delete m_uniqueName_attr;
            m_uniqueName_attr = NULL;
        }
    
            
                m_has_caption_attr = false;
                
        if (m_caption_attr)
        {
            delete m_caption_attr;
            m_caption_attr = NULL;
        }
    
            
                m_has_displayFolder_attr = false;
                
        if (m_displayFolder_attr)
        {
            delete m_displayFolder_attr;
            m_displayFolder_attr = NULL;
        }
    
            
                m_has_measureGroup_attr = false;
                
        if (m_measureGroup_attr)
        {
            delete m_measureGroup_attr;
            m_measureGroup_attr = NULL;
        }
    
            
                m_has_parent_attr = false;
                
        if (m_parent_attr)
        {
            delete m_parent_attr;
            m_parent_attr = NULL;
        }
    
            
                m_has_value_attr = false;
                
        if (m_value_attr)
        {
            delete m_value_attr;
            m_value_attr = NULL;
        }
    
            
                m_has_goal_attr = false;
                
        if (m_goal_attr)
        {
            delete m_goal_attr;
            m_goal_attr = NULL;
        }
    
            
                m_has_status_attr = false;
                
        if (m_status_attr)
        {
            delete m_status_attr;
            m_status_attr = NULL;
        }
    
            
                m_has_trend_attr = false;
                
        if (m_trend_attr)
        {
            delete m_trend_attr;
            m_trend_attr = NULL;
        }
    
            
                m_has_weight_attr = false;
                
        if (m_weight_attr)
        {
            delete m_weight_attr;
            m_weight_attr = NULL;
        }
    
            
                m_has_time_attr = false;
                
        if (m_time_attr)
        {
            delete m_time_attr;
            m_time_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_uniqueName_attr->toXml(_attrName, _outStream);
m_caption_attr->toXml(_attrName, _outStream);
m_displayFolder_attr->toXml(_attrName, _outStream);
m_measureGroup_attr->toXml(_attrName, _outStream);
m_parent_attr->toXml(_attrName, _outStream);
m_value_attr->toXml(_attrName, _outStream);
m_goal_attr->toXml(_attrName, _outStream);
m_status_attr->toXml(_attrName, _outStream);
m_trend_attr->toXml(_attrName, _outStream);
m_weight_attr->toXml(_attrName, _outStream);
m_time_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_PCDKPI& default_instance(){

    if (!CT_PCDKPI::default_instance_)
    {
        CT_PCDKPI::default_instance_ = new CT_PCDKPI();
    }
    return *CT_PCDKPI::default_instance_;

        }
        bool has_uniqueName_attr(){

            return m_has_uniqueName_attr;
        
        }
        void set_uniqueName_attr(const ns_s::ST_Xstring& _uniqueName_attr ){

            m_has_uniqueName_attr = true;
            m_uniqueName_attr = new ns_s::ST_Xstring(_uniqueName_attr);
        
        }
        const ns_s::ST_Xstring& uniqueName_attr(){

            if (m_uniqueName_attr)
            {
                return *m_uniqueName_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_caption_attr(){

            return m_has_caption_attr;
        
        }
        void set_caption_attr(const ns_s::ST_Xstring& _caption_attr ){

            m_has_caption_attr = true;
            m_caption_attr = new ns_s::ST_Xstring(_caption_attr);
        
        }
        const ns_s::ST_Xstring& caption_attr(){

            if (m_caption_attr)
            {
                return *m_caption_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_displayFolder_attr(){

            return m_has_displayFolder_attr;
        
        }
        void set_displayFolder_attr(const ns_s::ST_Xstring& _displayFolder_attr ){

            m_has_displayFolder_attr = true;
            m_displayFolder_attr = new ns_s::ST_Xstring(_displayFolder_attr);
        
        }
        const ns_s::ST_Xstring& displayFolder_attr(){

            if (m_displayFolder_attr)
            {
                return *m_displayFolder_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_measureGroup_attr(){

            return m_has_measureGroup_attr;
        
        }
        void set_measureGroup_attr(const ns_s::ST_Xstring& _measureGroup_attr ){

            m_has_measureGroup_attr = true;
            m_measureGroup_attr = new ns_s::ST_Xstring(_measureGroup_attr);
        
        }
        const ns_s::ST_Xstring& measureGroup_attr(){

            if (m_measureGroup_attr)
            {
                return *m_measureGroup_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_parent_attr(){

            return m_has_parent_attr;
        
        }
        void set_parent_attr(const ns_s::ST_Xstring& _parent_attr ){

            m_has_parent_attr = true;
            m_parent_attr = new ns_s::ST_Xstring(_parent_attr);
        
        }
        const ns_s::ST_Xstring& parent_attr(){

            if (m_parent_attr)
            {
                return *m_parent_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_value_attr(){

            return m_has_value_attr;
        
        }
        void set_value_attr(const ns_s::ST_Xstring& _value_attr ){

            m_has_value_attr = true;
            m_value_attr = new ns_s::ST_Xstring(_value_attr);
        
        }
        const ns_s::ST_Xstring& value_attr(){

            if (m_value_attr)
            {
                return *m_value_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_goal_attr(){

            return m_has_goal_attr;
        
        }
        void set_goal_attr(const ns_s::ST_Xstring& _goal_attr ){

            m_has_goal_attr = true;
            m_goal_attr = new ns_s::ST_Xstring(_goal_attr);
        
        }
        const ns_s::ST_Xstring& goal_attr(){

            if (m_goal_attr)
            {
                return *m_goal_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_status_attr(){

            return m_has_status_attr;
        
        }
        void set_status_attr(const ns_s::ST_Xstring& _status_attr ){

            m_has_status_attr = true;
            m_status_attr = new ns_s::ST_Xstring(_status_attr);
        
        }
        const ns_s::ST_Xstring& status_attr(){

            if (m_status_attr)
            {
                return *m_status_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_trend_attr(){

            return m_has_trend_attr;
        
        }
        void set_trend_attr(const ns_s::ST_Xstring& _trend_attr ){

            m_has_trend_attr = true;
            m_trend_attr = new ns_s::ST_Xstring(_trend_attr);
        
        }
        const ns_s::ST_Xstring& trend_attr(){

            if (m_trend_attr)
            {
                return *m_trend_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_weight_attr(){

            return m_has_weight_attr;
        
        }
        void set_weight_attr(const ns_s::ST_Xstring& _weight_attr ){

            m_has_weight_attr = true;
            m_weight_attr = new ns_s::ST_Xstring(_weight_attr);
        
        }
        const ns_s::ST_Xstring& weight_attr(){

            if (m_weight_attr)
            {
                return *m_weight_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_time_attr(){

            return m_has_time_attr;
        
        }
        void set_time_attr(const ns_s::ST_Xstring& _time_attr ){

            m_has_time_attr = true;
            m_time_attr = new ns_s::ST_Xstring(_time_attr);
        
        }
        const ns_s::ST_Xstring& time_attr(){

            if (m_time_attr)
            {
                return *m_time_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }

    private:
        static CT_PCDKPI* default_instance_ ;
        bool m_has_uniqueName_attr ;
        ns_s::ST_Xstring* m_uniqueName_attr ;
        bool m_has_caption_attr ;
        ns_s::ST_Xstring* m_caption_attr ;
        bool m_has_displayFolder_attr ;
        ns_s::ST_Xstring* m_displayFolder_attr ;
        bool m_has_measureGroup_attr ;
        ns_s::ST_Xstring* m_measureGroup_attr ;
        bool m_has_parent_attr ;
        ns_s::ST_Xstring* m_parent_attr ;
        bool m_has_value_attr ;
        ns_s::ST_Xstring* m_value_attr ;
        bool m_has_goal_attr ;
        ns_s::ST_Xstring* m_goal_attr ;
        bool m_has_status_attr ;
        ns_s::ST_Xstring* m_status_attr ;
        bool m_has_trend_attr ;
        ns_s::ST_Xstring* m_trend_attr ;
        bool m_has_weight_attr ;
        ns_s::ST_Xstring* m_weight_attr ;
        bool m_has_time_attr ;
        ns_s::ST_Xstring* m_time_attr ;

    }

    class CT_CacheHierarchies : public XSD::ComplexType{
    public:
        bool has_cacheHierarchy(){

            return m_has_cacheHierarchy;
        
        }
        CT_CacheHierarchy* mutable_cacheHierarchy(){

                m_has_cacheHierarchy = true;
                if (!m_cacheHierarchy)
                {
                    m_cacheHierarchy = new CT_CacheHierarchy();
                }
                return m_cacheHierarchy;
            
        }
        const CT_CacheHierarchy& cacheHierarchy(){

            if (m_cacheHierarchy)
            {
                return *m_cacheHierarchy;
            }
            return CT_CacheHierarchy::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_cacheHierarchy = false;
                
        if (m_cacheHierarchy)
        {
            delete m_cacheHierarchy;
            m_cacheHierarchy = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_cacheHierarchy)
                {
                    m_cacheHierarchy->toXml(cacheHierarchy, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CacheHierarchies& default_instance(){

    if (!CT_CacheHierarchies::default_instance_)
    {
        CT_CacheHierarchies::default_instance_ = new CT_CacheHierarchies();
    }
    return *CT_CacheHierarchies::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_cacheHierarchy ;
        CT_CacheHierarchy* m_cacheHierarchy ;
        static CT_CacheHierarchies* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_CacheHierarchy : public XSD::ComplexType{
    public:
        bool has_fieldsUsage(){

            return m_has_fieldsUsage;
        
        }
        CT_FieldsUsage* mutable_fieldsUsage(){

                m_has_fieldsUsage = true;
                if (!m_fieldsUsage)
                {
                    m_fieldsUsage = new CT_FieldsUsage();
                }
                return m_fieldsUsage;
            
        }
        const CT_FieldsUsage& fieldsUsage(){

            if (m_fieldsUsage)
            {
                return *m_fieldsUsage;
            }
            return CT_FieldsUsage::default_instance();
        
        }
        bool has_groupLevels(){

            return m_has_groupLevels;
        
        }
        CT_GroupLevels* mutable_groupLevels(){

                m_has_groupLevels = true;
                if (!m_groupLevels)
                {
                    m_groupLevels = new CT_GroupLevels();
                }
                return m_groupLevels;
            
        }
        const CT_GroupLevels& groupLevels(){

            if (m_groupLevels)
            {
                return *m_groupLevels;
            }
            return CT_GroupLevels::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_uniqueName_attr = false;
                
        if (m_uniqueName_attr)
        {
            delete m_uniqueName_attr;
            m_uniqueName_attr = NULL;
        }
    
            
                m_has_caption_attr = false;
                
        if (m_caption_attr)
        {
            delete m_caption_attr;
            m_caption_attr = NULL;
        }
    
            
                m_has_measure_attr = false;
                m_measure_attr = false;
            
                m_has_set_attr = false;
                m_set_attr = false;
            
                m_has_parentSet_attr = false;
                m_parentSet_attr = 0;
            
                m_has_iconSet_attr = false;
                m_iconSet_attr = 0;
            
                m_has_attribute_attr = false;
                m_attribute_attr = false;
            
                m_has_time_attr = false;
                m_time_attr = false;
            
                m_has_keyAttribute_attr = false;
                m_keyAttribute_attr = false;
            
                m_has_defaultMemberUniqueName_attr = false;
                
        if (m_defaultMemberUniqueName_attr)
        {
            delete m_defaultMemberUniqueName_attr;
            m_defaultMemberUniqueName_attr = NULL;
        }
    
            
                m_has_allUniqueName_attr = false;
                
        if (m_allUniqueName_attr)
        {
            delete m_allUniqueName_attr;
            m_allUniqueName_attr = NULL;
        }
    
            
                m_has_allCaption_attr = false;
                
        if (m_allCaption_attr)
        {
            delete m_allCaption_attr;
            m_allCaption_attr = NULL;
        }
    
            
                m_has_dimensionUniqueName_attr = false;
                
        if (m_dimensionUniqueName_attr)
        {
            delete m_dimensionUniqueName_attr;
            m_dimensionUniqueName_attr = NULL;
        }
    
            
                m_has_displayFolder_attr = false;
                
        if (m_displayFolder_attr)
        {
            delete m_displayFolder_attr;
            m_displayFolder_attr = NULL;
        }
    
            
                m_has_measureGroup_attr = false;
                
        if (m_measureGroup_attr)
        {
            delete m_measureGroup_attr;
            m_measureGroup_attr = NULL;
        }
    
            
                m_has_measures_attr = false;
                m_measures_attr = false;
            
                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_oneField_attr = false;
                m_oneField_attr = false;
            
                m_has_memberValueDatatype_attr = false;
                m_memberValueDatatype_attr = 0;
            
                m_has_unbalanced_attr = false;
                m_unbalanced_attr = false;
            
                m_has_unbalancedGroup_attr = false;
                m_unbalancedGroup_attr = false;
            
                m_has_hidden_attr = false;
                m_hidden_attr = false;
            
                m_has_fieldsUsage = false;
                
        if (m_fieldsUsage)
        {
            delete m_fieldsUsage;
            m_fieldsUsage = NULL;
        }
    
            
                m_has_groupLevels = false;
                
        if (m_groupLevels)
        {
            delete m_groupLevels;
            m_groupLevels = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_uniqueName_attr->toXml(_attrName, _outStream);
m_caption_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_measure_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_set_attr) << \\\;
_outStream << _attrName << \=\\ << m_parentSet_attr << \\\;
_outStream << _attrName << \=\\ << m_iconSet_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_attribute_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_time_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_keyAttribute_attr) << \\\;
m_defaultMemberUniqueName_attr->toXml(_attrName, _outStream);
m_allUniqueName_attr->toXml(_attrName, _outStream);
m_allCaption_attr->toXml(_attrName, _outStream);
m_dimensionUniqueName_attr->toXml(_attrName, _outStream);
m_displayFolder_attr->toXml(_attrName, _outStream);
m_measureGroup_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_measures_attr) << \\\;
_outStream << _attrName << \=\\ << m_count_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_oneField_attr) << \\\;
_outStream << _attrName << \=\\ << m_memberValueDatatype_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_unbalanced_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_unbalancedGroup_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_hidden_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_fieldsUsage)
                {
                    m_fieldsUsage->toXml(fieldsUsage, _outStream);;
                }
            
                if (m_has_groupLevels)
                {
                    m_fieldsUsage->toXml(groupLevels, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_fieldsUsage->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CacheHierarchy& default_instance(){

    if (!CT_CacheHierarchy::default_instance_)
    {
        CT_CacheHierarchy::default_instance_ = new CT_CacheHierarchy();
    }
    return *CT_CacheHierarchy::default_instance_;

        }
        bool has_uniqueName_attr(){

            return m_has_uniqueName_attr;
        
        }
        void set_uniqueName_attr(const ns_s::ST_Xstring& _uniqueName_attr ){

            m_has_uniqueName_attr = true;
            m_uniqueName_attr = new ns_s::ST_Xstring(_uniqueName_attr);
        
        }
        const ns_s::ST_Xstring& uniqueName_attr(){

            if (m_uniqueName_attr)
            {
                return *m_uniqueName_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_caption_attr(){

            return m_has_caption_attr;
        
        }
        void set_caption_attr(const ns_s::ST_Xstring& _caption_attr ){

            m_has_caption_attr = true;
            m_caption_attr = new ns_s::ST_Xstring(_caption_attr);
        
        }
        const ns_s::ST_Xstring& caption_attr(){

            if (m_caption_attr)
            {
                return *m_caption_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_measure_attr(){

            return m_has_measure_attr;
        
        }
        void set_measure_attr(const boolean& _measure_attr ){

        m_has_measure_attr = true;
        m_measure_attr = _measure_attr;
        
        }
        const boolean& measure_attr(){

            return type: oolean\nname: \m_measure_attr\n;
        
        }
        bool has_set_attr(){

            return m_has_set_attr;
        
        }
        void set_set_attr(const boolean& _set_attr ){

        m_has_set_attr = true;
        m_set_attr = _set_attr;
        
        }
        const boolean& set_attr(){

            return type: oolean\nname: \m_set_attr\n;
        
        }
        bool has_parentSet_attr(){

            return m_has_parentSet_attr;
        
        }
        void set_parentSet_attr(const unsignedInt& _parentSet_attr ){

        m_has_parentSet_attr = true;
        m_parentSet_attr = _parentSet_attr;
        
        }
        const unsignedInt& parentSet_attr(){

            return type: \unsignedInt\nname: \m_parentSet_attr\n;
        
        }
        bool has_iconSet_attr(){

            return m_has_iconSet_attr;
        
        }
        void set_iconSet_attr(const int& _iconSet_attr ){

        m_has_iconSet_attr = true;
        m_iconSet_attr = _iconSet_attr;
        
        }
        const int& iconSet_attr(){

            return type: \int\nname: \m_iconSet_attr\n;
        
        }
        bool has_attribute_attr(){

            return m_has_attribute_attr;
        
        }
        void set_attribute_attr(const boolean& _attribute_attr ){

        m_has_attribute_attr = true;
        m_attribute_attr = _attribute_attr;
        
        }
        const boolean& attribute_attr(){

            return type: oolean\nname: \m_attribute_attr\n;
        
        }
        bool has_time_attr(){

            return m_has_time_attr;
        
        }
        void set_time_attr(const boolean& _time_attr ){

        m_has_time_attr = true;
        m_time_attr = _time_attr;
        
        }
        const boolean& time_attr(){

            return type: oolean\nname: \m_time_attr\n;
        
        }
        bool has_keyAttribute_attr(){

            return m_has_keyAttribute_attr;
        
        }
        void set_keyAttribute_attr(const boolean& _keyAttribute_attr ){

        m_has_keyAttribute_attr = true;
        m_keyAttribute_attr = _keyAttribute_attr;
        
        }
        const boolean& keyAttribute_attr(){

            return type: oolean\nname: \m_keyAttribute_attr\n;
        
        }
        bool has_defaultMemberUniqueName_attr(){

            return m_has_defaultMemberUniqueName_attr;
        
        }
        void set_defaultMemberUniqueName_attr(const ns_s::ST_Xstring& _defaultMemberUniqueName_attr ){

            m_has_defaultMemberUniqueName_attr = true;
            m_defaultMemberUniqueName_attr = new ns_s::ST_Xstring(_defaultMemberUniqueName_attr);
        
        }
        const ns_s::ST_Xstring& defaultMemberUniqueName_attr(){

            if (m_defaultMemberUniqueName_attr)
            {
                return *m_defaultMemberUniqueName_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_allUniqueName_attr(){

            return m_has_allUniqueName_attr;
        
        }
        void set_allUniqueName_attr(const ns_s::ST_Xstring& _allUniqueName_attr ){

            m_has_allUniqueName_attr = true;
            m_allUniqueName_attr = new ns_s::ST_Xstring(_allUniqueName_attr);
        
        }
        const ns_s::ST_Xstring& allUniqueName_attr(){

            if (m_allUniqueName_attr)
            {
                return *m_allUniqueName_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_allCaption_attr(){

            return m_has_allCaption_attr;
        
        }
        void set_allCaption_attr(const ns_s::ST_Xstring& _allCaption_attr ){

            m_has_allCaption_attr = true;
            m_allCaption_attr = new ns_s::ST_Xstring(_allCaption_attr);
        
        }
        const ns_s::ST_Xstring& allCaption_attr(){

            if (m_allCaption_attr)
            {
                return *m_allCaption_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_dimensionUniqueName_attr(){

            return m_has_dimensionUniqueName_attr;
        
        }
        void set_dimensionUniqueName_attr(const ns_s::ST_Xstring& _dimensionUniqueName_attr ){

            m_has_dimensionUniqueName_attr = true;
            m_dimensionUniqueName_attr = new ns_s::ST_Xstring(_dimensionUniqueName_attr);
        
        }
        const ns_s::ST_Xstring& dimensionUniqueName_attr(){

            if (m_dimensionUniqueName_attr)
            {
                return *m_dimensionUniqueName_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_displayFolder_attr(){

            return m_has_displayFolder_attr;
        
        }
        void set_displayFolder_attr(const ns_s::ST_Xstring& _displayFolder_attr ){

            m_has_displayFolder_attr = true;
            m_displayFolder_attr = new ns_s::ST_Xstring(_displayFolder_attr);
        
        }
        const ns_s::ST_Xstring& displayFolder_attr(){

            if (m_displayFolder_attr)
            {
                return *m_displayFolder_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_measureGroup_attr(){

            return m_has_measureGroup_attr;
        
        }
        void set_measureGroup_attr(const ns_s::ST_Xstring& _measureGroup_attr ){

            m_has_measureGroup_attr = true;
            m_measureGroup_attr = new ns_s::ST_Xstring(_measureGroup_attr);
        
        }
        const ns_s::ST_Xstring& measureGroup_attr(){

            if (m_measureGroup_attr)
            {
                return *m_measureGroup_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_measures_attr(){

            return m_has_measures_attr;
        
        }
        void set_measures_attr(const boolean& _measures_attr ){

        m_has_measures_attr = true;
        m_measures_attr = _measures_attr;
        
        }
        const boolean& measures_attr(){

            return type: oolean\nname: \m_measures_attr\n;
        
        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }
        bool has_oneField_attr(){

            return m_has_oneField_attr;
        
        }
        void set_oneField_attr(const boolean& _oneField_attr ){

        m_has_oneField_attr = true;
        m_oneField_attr = _oneField_attr;
        
        }
        const boolean& oneField_attr(){

            return type: oolean\nname: \m_oneField_attr\n;
        
        }
        bool has_memberValueDatatype_attr(){

            return m_has_memberValueDatatype_attr;
        
        }
        void set_memberValueDatatype_attr(const unsignedShort& _memberValueDatatype_attr ){

        m_has_memberValueDatatype_attr = true;
        m_memberValueDatatype_attr = _memberValueDatatype_attr;
        
        }
        const unsignedShort& memberValueDatatype_attr(){

            return type: \unsignedShort\nname: \m_memberValueDatatype_attr\n;
        
        }
        bool has_unbalanced_attr(){

            return m_has_unbalanced_attr;
        
        }
        void set_unbalanced_attr(const boolean& _unbalanced_attr ){

        m_has_unbalanced_attr = true;
        m_unbalanced_attr = _unbalanced_attr;
        
        }
        const boolean& unbalanced_attr(){

            return type: oolean\nname: \m_unbalanced_attr\n;
        
        }
        bool has_unbalancedGroup_attr(){

            return m_has_unbalancedGroup_attr;
        
        }
        void set_unbalancedGroup_attr(const boolean& _unbalancedGroup_attr ){

        m_has_unbalancedGroup_attr = true;
        m_unbalancedGroup_attr = _unbalancedGroup_attr;
        
        }
        const boolean& unbalancedGroup_attr(){

            return type: oolean\nname: \m_unbalancedGroup_attr\n;
        
        }
        bool has_hidden_attr(){

            return m_has_hidden_attr;
        
        }
        void set_hidden_attr(const boolean& _hidden_attr ){

        m_has_hidden_attr = true;
        m_hidden_attr = _hidden_attr;
        
        }
        const boolean& hidden_attr(){

            return type: oolean\nname: \m_hidden_attr\n;
        
        }

    private:
        bool m_has_fieldsUsage ;
        CT_FieldsUsage* m_fieldsUsage ;
        bool m_has_groupLevels ;
        CT_GroupLevels* m_groupLevels ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_CacheHierarchy* default_instance_ ;
        bool m_has_uniqueName_attr ;
        ns_s::ST_Xstring* m_uniqueName_attr ;
        bool m_has_caption_attr ;
        ns_s::ST_Xstring* m_caption_attr ;
        bool m_has_measure_attr ;
        boolean m_measure_attr ;
        bool m_has_set_attr ;
        boolean m_set_attr ;
        bool m_has_parentSet_attr ;
        unsignedInt m_parentSet_attr ;
        bool m_has_iconSet_attr ;
        int m_iconSet_attr ;
        bool m_has_attribute_attr ;
        boolean m_attribute_attr ;
        bool m_has_time_attr ;
        boolean m_time_attr ;
        bool m_has_keyAttribute_attr ;
        boolean m_keyAttribute_attr ;
        bool m_has_defaultMemberUniqueName_attr ;
        ns_s::ST_Xstring* m_defaultMemberUniqueName_attr ;
        bool m_has_allUniqueName_attr ;
        ns_s::ST_Xstring* m_allUniqueName_attr ;
        bool m_has_allCaption_attr ;
        ns_s::ST_Xstring* m_allCaption_attr ;
        bool m_has_dimensionUniqueName_attr ;
        ns_s::ST_Xstring* m_dimensionUniqueName_attr ;
        bool m_has_displayFolder_attr ;
        ns_s::ST_Xstring* m_displayFolder_attr ;
        bool m_has_measureGroup_attr ;
        ns_s::ST_Xstring* m_measureGroup_attr ;
        bool m_has_measures_attr ;
        boolean m_measures_attr ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;
        bool m_has_oneField_attr ;
        boolean m_oneField_attr ;
        bool m_has_memberValueDatatype_attr ;
        unsignedShort m_memberValueDatatype_attr ;
        bool m_has_unbalanced_attr ;
        boolean m_unbalanced_attr ;
        bool m_has_unbalancedGroup_attr ;
        boolean m_unbalancedGroup_attr ;
        bool m_has_hidden_attr ;
        boolean m_hidden_attr ;

    }

    class CT_FieldsUsage : public XSD::ComplexType{
    public:
        bool has_fieldUsage(){

            return m_has_fieldUsage;
        
        }
        CT_FieldUsage* mutable_fieldUsage(){

                m_has_fieldUsage = true;
                if (!m_fieldUsage)
                {
                    m_fieldUsage = new CT_FieldUsage();
                }
                return m_fieldUsage;
            
        }
        const CT_FieldUsage& fieldUsage(){

            if (m_fieldUsage)
            {
                return *m_fieldUsage;
            }
            return CT_FieldUsage::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_fieldUsage = false;
                
        if (m_fieldUsage)
        {
            delete m_fieldUsage;
            m_fieldUsage = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_fieldUsage)
                {
                    m_fieldUsage->toXml(fieldUsage, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_FieldsUsage& default_instance(){

    if (!CT_FieldsUsage::default_instance_)
    {
        CT_FieldsUsage::default_instance_ = new CT_FieldsUsage();
    }
    return *CT_FieldsUsage::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_fieldUsage ;
        CT_FieldUsage* m_fieldUsage ;
        static CT_FieldsUsage* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_FieldUsage : public XSD::ComplexType{
    public:
        void clear(){

                m_has_x_attr = false;
                m_x_attr = 0;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_x_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_FieldUsage& default_instance(){

    if (!CT_FieldUsage::default_instance_)
    {
        CT_FieldUsage::default_instance_ = new CT_FieldUsage();
    }
    return *CT_FieldUsage::default_instance_;

        }
        bool has_x_attr(){

            return m_has_x_attr;
        
        }
        void set_x_attr(const int& _x_attr ){

        m_has_x_attr = true;
        m_x_attr = _x_attr;
        
        }
        const int& x_attr(){

            return type: \int\nname: \m_x_attr\n;
        
        }

    private:
        static CT_FieldUsage* default_instance_ ;
        bool m_has_x_attr ;
        int m_x_attr ;

    }

    class CT_GroupLevels : public XSD::ComplexType{
    public:
        bool has_groupLevel(){

            return m_has_groupLevel;
        
        }
        CT_GroupLevel* mutable_groupLevel(){

                m_has_groupLevel = true;
                if (!m_groupLevel)
                {
                    m_groupLevel = new CT_GroupLevel();
                }
                return m_groupLevel;
            
        }
        const CT_GroupLevel& groupLevel(){

            if (m_groupLevel)
            {
                return *m_groupLevel;
            }
            return CT_GroupLevel::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_groupLevel = false;
                
        if (m_groupLevel)
        {
            delete m_groupLevel;
            m_groupLevel = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_groupLevel)
                {
                    m_groupLevel->toXml(groupLevel, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_GroupLevels& default_instance(){

    if (!CT_GroupLevels::default_instance_)
    {
        CT_GroupLevels::default_instance_ = new CT_GroupLevels();
    }
    return *CT_GroupLevels::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_groupLevel ;
        CT_GroupLevel* m_groupLevel ;
        static CT_GroupLevels* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_GroupLevel : public XSD::ComplexType{
    public:
        bool has_groups(){

            return m_has_groups;
        
        }
        CT_Groups* mutable_groups(){

                m_has_groups = true;
                if (!m_groups)
                {
                    m_groups = new CT_Groups();
                }
                return m_groups;
            
        }
        const CT_Groups& groups(){

            if (m_groups)
            {
                return *m_groups;
            }
            return CT_Groups::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_uniqueName_attr = false;
                
        if (m_uniqueName_attr)
        {
            delete m_uniqueName_attr;
            m_uniqueName_attr = NULL;
        }
    
            
                m_has_caption_attr = false;
                
        if (m_caption_attr)
        {
            delete m_caption_attr;
            m_caption_attr = NULL;
        }
    
            
                m_has_user_attr = false;
                m_user_attr = false;
            
                m_has_customRollUp_attr = false;
                m_customRollUp_attr = false;
            
                m_has_groups = false;
                
        if (m_groups)
        {
            delete m_groups;
            m_groups = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_uniqueName_attr->toXml(_attrName, _outStream);
m_caption_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_user_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_customRollUp_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_groups)
                {
                    m_groups->toXml(groups, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_groups->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_GroupLevel& default_instance(){

    if (!CT_GroupLevel::default_instance_)
    {
        CT_GroupLevel::default_instance_ = new CT_GroupLevel();
    }
    return *CT_GroupLevel::default_instance_;

        }
        bool has_uniqueName_attr(){

            return m_has_uniqueName_attr;
        
        }
        void set_uniqueName_attr(const ns_s::ST_Xstring& _uniqueName_attr ){

            m_has_uniqueName_attr = true;
            m_uniqueName_attr = new ns_s::ST_Xstring(_uniqueName_attr);
        
        }
        const ns_s::ST_Xstring& uniqueName_attr(){

            if (m_uniqueName_attr)
            {
                return *m_uniqueName_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_caption_attr(){

            return m_has_caption_attr;
        
        }
        void set_caption_attr(const ns_s::ST_Xstring& _caption_attr ){

            m_has_caption_attr = true;
            m_caption_attr = new ns_s::ST_Xstring(_caption_attr);
        
        }
        const ns_s::ST_Xstring& caption_attr(){

            if (m_caption_attr)
            {
                return *m_caption_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_user_attr(){

            return m_has_user_attr;
        
        }
        void set_user_attr(const boolean& _user_attr ){

        m_has_user_attr = true;
        m_user_attr = _user_attr;
        
        }
        const boolean& user_attr(){

            return type: oolean\nname: \m_user_attr\n;
        
        }
        bool has_customRollUp_attr(){

            return m_has_customRollUp_attr;
        
        }
        void set_customRollUp_attr(const boolean& _customRollUp_attr ){

        m_has_customRollUp_attr = true;
        m_customRollUp_attr = _customRollUp_attr;
        
        }
        const boolean& customRollUp_attr(){

            return type: oolean\nname: \m_customRollUp_attr\n;
        
        }

    private:
        bool m_has_groups ;
        CT_Groups* m_groups ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_GroupLevel* default_instance_ ;
        bool m_has_uniqueName_attr ;
        ns_s::ST_Xstring* m_uniqueName_attr ;
        bool m_has_caption_attr ;
        ns_s::ST_Xstring* m_caption_attr ;
        bool m_has_user_attr ;
        boolean m_user_attr ;
        bool m_has_customRollUp_attr ;
        boolean m_customRollUp_attr ;

    }

    class CT_Groups : public XSD::ComplexType{
    public:
        bool has_group(){

            return m_has_group;
        
        }
        CT_LevelGroup* mutable_group(){

                m_has_group = true;
                if (!m_group)
                {
                    m_group = new CT_LevelGroup();
                }
                return m_group;
            
        }
        const CT_LevelGroup& group(){

            if (m_group)
            {
                return *m_group;
            }
            return CT_LevelGroup::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_group = false;
                
        if (m_group)
        {
            delete m_group;
            m_group = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_group)
                {
                    m_group->toXml(group, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Groups& default_instance(){

    if (!CT_Groups::default_instance_)
    {
        CT_Groups::default_instance_ = new CT_Groups();
    }
    return *CT_Groups::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_group ;
        CT_LevelGroup* m_group ;
        static CT_Groups* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_LevelGroup : public XSD::ComplexType{
    public:
        bool has_groupMembers(){

            return m_has_groupMembers;
        
        }
        CT_GroupMembers* mutable_groupMembers(){

                m_has_groupMembers = true;
                if (!m_groupMembers)
                {
                    m_groupMembers = new CT_GroupMembers();
                }
                return m_groupMembers;
            
        }
        const CT_GroupMembers& groupMembers(){

            if (m_groupMembers)
            {
                return *m_groupMembers;
            }
            return CT_GroupMembers::default_instance();
        
        }
        void clear(){

                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
                m_has_uniqueName_attr = false;
                
        if (m_uniqueName_attr)
        {
            delete m_uniqueName_attr;
            m_uniqueName_attr = NULL;
        }
    
            
                m_has_caption_attr = false;
                
        if (m_caption_attr)
        {
            delete m_caption_attr;
            m_caption_attr = NULL;
        }
    
            
                m_has_uniqueParent_attr = false;
                
        if (m_uniqueParent_attr)
        {
            delete m_uniqueParent_attr;
            m_uniqueParent_attr = NULL;
        }
    
            
                m_has_id_attr = false;
                m_id_attr = 0;
            
                m_has_groupMembers = false;
                
        if (m_groupMembers)
        {
            delete m_groupMembers;
            m_groupMembers = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_name_attr->toXml(_attrName, _outStream);
m_uniqueName_attr->toXml(_attrName, _outStream);
m_caption_attr->toXml(_attrName, _outStream);
m_uniqueParent_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_id_attr << \\\;
        _outStream << \>\;
    
                if (m_has_groupMembers)
                {
                    m_groupMembers->toXml(groupMembers, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_LevelGroup& default_instance(){

    if (!CT_LevelGroup::default_instance_)
    {
        CT_LevelGroup::default_instance_ = new CT_LevelGroup();
    }
    return *CT_LevelGroup::default_instance_;

        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_uniqueName_attr(){

            return m_has_uniqueName_attr;
        
        }
        void set_uniqueName_attr(const ns_s::ST_Xstring& _uniqueName_attr ){

            m_has_uniqueName_attr = true;
            m_uniqueName_attr = new ns_s::ST_Xstring(_uniqueName_attr);
        
        }
        const ns_s::ST_Xstring& uniqueName_attr(){

            if (m_uniqueName_attr)
            {
                return *m_uniqueName_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_caption_attr(){

            return m_has_caption_attr;
        
        }
        void set_caption_attr(const ns_s::ST_Xstring& _caption_attr ){

            m_has_caption_attr = true;
            m_caption_attr = new ns_s::ST_Xstring(_caption_attr);
        
        }
        const ns_s::ST_Xstring& caption_attr(){

            if (m_caption_attr)
            {
                return *m_caption_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_uniqueParent_attr(){

            return m_has_uniqueParent_attr;
        
        }
        void set_uniqueParent_attr(const ns_s::ST_Xstring& _uniqueParent_attr ){

            m_has_uniqueParent_attr = true;
            m_uniqueParent_attr = new ns_s::ST_Xstring(_uniqueParent_attr);
        
        }
        const ns_s::ST_Xstring& uniqueParent_attr(){

            if (m_uniqueParent_attr)
            {
                return *m_uniqueParent_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_id_attr(){

            return m_has_id_attr;
        
        }
        void set_id_attr(const int& _id_attr ){

        m_has_id_attr = true;
        m_id_attr = _id_attr;
        
        }
        const int& id_attr(){

            return type: \int\nname: \m_id_attr\n;
        
        }

    private:
        bool m_has_groupMembers ;
        CT_GroupMembers* m_groupMembers ;
        static CT_LevelGroup* default_instance_ ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;
        bool m_has_uniqueName_attr ;
        ns_s::ST_Xstring* m_uniqueName_attr ;
        bool m_has_caption_attr ;
        ns_s::ST_Xstring* m_caption_attr ;
        bool m_has_uniqueParent_attr ;
        ns_s::ST_Xstring* m_uniqueParent_attr ;
        bool m_has_id_attr ;
        int m_id_attr ;

    }

    class CT_GroupMembers : public XSD::ComplexType{
    public:
        bool has_groupMember(){

            return m_has_groupMember;
        
        }
        CT_GroupMember* mutable_groupMember(){

                m_has_groupMember = true;
                if (!m_groupMember)
                {
                    m_groupMember = new CT_GroupMember();
                }
                return m_groupMember;
            
        }
        const CT_GroupMember& groupMember(){

            if (m_groupMember)
            {
                return *m_groupMember;
            }
            return CT_GroupMember::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_groupMember = false;
                
        if (m_groupMember)
        {
            delete m_groupMember;
            m_groupMember = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_groupMember)
                {
                    m_groupMember->toXml(groupMember, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_GroupMembers& default_instance(){

    if (!CT_GroupMembers::default_instance_)
    {
        CT_GroupMembers::default_instance_ = new CT_GroupMembers();
    }
    return *CT_GroupMembers::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_groupMember ;
        CT_GroupMember* m_groupMember ;
        static CT_GroupMembers* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_GroupMember : public XSD::ComplexType{
    public:
        void clear(){

                m_has_uniqueName_attr = false;
                
        if (m_uniqueName_attr)
        {
            delete m_uniqueName_attr;
            m_uniqueName_attr = NULL;
        }
    
            
                m_has_group_attr = false;
                m_group_attr = false;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_uniqueName_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_group_attr) << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_GroupMember& default_instance(){

    if (!CT_GroupMember::default_instance_)
    {
        CT_GroupMember::default_instance_ = new CT_GroupMember();
    }
    return *CT_GroupMember::default_instance_;

        }
        bool has_uniqueName_attr(){

            return m_has_uniqueName_attr;
        
        }
        void set_uniqueName_attr(const ns_s::ST_Xstring& _uniqueName_attr ){

            m_has_uniqueName_attr = true;
            m_uniqueName_attr = new ns_s::ST_Xstring(_uniqueName_attr);
        
        }
        const ns_s::ST_Xstring& uniqueName_attr(){

            if (m_uniqueName_attr)
            {
                return *m_uniqueName_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_group_attr(){

            return m_has_group_attr;
        
        }
        void set_group_attr(const boolean& _group_attr ){

        m_has_group_attr = true;
        m_group_attr = _group_attr;
        
        }
        const boolean& group_attr(){

            return type: oolean\nname: \m_group_attr\n;
        
        }

    private:
        static CT_GroupMember* default_instance_ ;
        bool m_has_uniqueName_attr ;
        ns_s::ST_Xstring* m_uniqueName_attr ;
        bool m_has_group_attr ;
        boolean m_group_attr ;

    }

    class CT_TupleCache : public XSD::ComplexType{
    public:
        bool has_entries(){

            return m_has_entries;
        
        }
        CT_PCDSDTCEntries* mutable_entries(){

                m_has_entries = true;
                if (!m_entries)
                {
                    m_entries = new CT_PCDSDTCEntries();
                }
                return m_entries;
            
        }
        const CT_PCDSDTCEntries& entries(){

            if (m_entries)
            {
                return *m_entries;
            }
            return CT_PCDSDTCEntries::default_instance();
        
        }
        bool has_sets(){

            return m_has_sets;
        
        }
        CT_Sets* mutable_sets(){

                m_has_sets = true;
                if (!m_sets)
                {
                    m_sets = new CT_Sets();
                }
                return m_sets;
            
        }
        const CT_Sets& sets(){

            if (m_sets)
            {
                return *m_sets;
            }
            return CT_Sets::default_instance();
        
        }
        bool has_queryCache(){

            return m_has_queryCache;
        
        }
        CT_QueryCache* mutable_queryCache(){

                m_has_queryCache = true;
                if (!m_queryCache)
                {
                    m_queryCache = new CT_QueryCache();
                }
                return m_queryCache;
            
        }
        const CT_QueryCache& queryCache(){

            if (m_queryCache)
            {
                return *m_queryCache;
            }
            return CT_QueryCache::default_instance();
        
        }
        bool has_serverFormats(){

            return m_has_serverFormats;
        
        }
        CT_ServerFormats* mutable_serverFormats(){

                m_has_serverFormats = true;
                if (!m_serverFormats)
                {
                    m_serverFormats = new CT_ServerFormats();
                }
                return m_serverFormats;
            
        }
        const CT_ServerFormats& serverFormats(){

            if (m_serverFormats)
            {
                return *m_serverFormats;
            }
            return CT_ServerFormats::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_entries = false;
                
        if (m_entries)
        {
            delete m_entries;
            m_entries = NULL;
        }
    
            
                m_has_sets = false;
                
        if (m_sets)
        {
            delete m_sets;
            m_sets = NULL;
        }
    
            
                m_has_queryCache = false;
                
        if (m_queryCache)
        {
            delete m_queryCache;
            m_queryCache = NULL;
        }
    
            
                m_has_serverFormats = false;
                
        if (m_serverFormats)
        {
            delete m_serverFormats;
            m_serverFormats = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_entries)
                {
                    m_entries->toXml(entries, _outStream);;
                }
            
                if (m_has_sets)
                {
                    m_entries->toXml(sets, _outStream);;
                }
            
                if (m_has_queryCache)
                {
                    m_entries->toXml(queryCache, _outStream);;
                }
            
                if (m_has_serverFormats)
                {
                    m_entries->toXml(serverFormats, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_entries->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_TupleCache& default_instance(){

    if (!CT_TupleCache::default_instance_)
    {
        CT_TupleCache::default_instance_ = new CT_TupleCache();
    }
    return *CT_TupleCache::default_instance_;

        }

    private:
        bool m_has_entries ;
        CT_PCDSDTCEntries* m_entries ;
        bool m_has_sets ;
        CT_Sets* m_sets ;
        bool m_has_queryCache ;
        CT_QueryCache* m_queryCache ;
        bool m_has_serverFormats ;
        CT_ServerFormats* m_serverFormats ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_TupleCache* default_instance_ ;

    }

    class CT_ServerFormat : public XSD::ComplexType{
    public:
        void clear(){

                m_has_culture_attr = false;
                
        if (m_culture_attr)
        {
            delete m_culture_attr;
            m_culture_attr = NULL;
        }
    
            
                m_has_format_attr = false;
                
        if (m_format_attr)
        {
            delete m_format_attr;
            m_format_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_culture_attr->toXml(_attrName, _outStream);
m_format_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_ServerFormat& default_instance(){

    if (!CT_ServerFormat::default_instance_)
    {
        CT_ServerFormat::default_instance_ = new CT_ServerFormat();
    }
    return *CT_ServerFormat::default_instance_;

        }
        bool has_culture_attr(){

            return m_has_culture_attr;
        
        }
        void set_culture_attr(const ns_s::ST_Xstring& _culture_attr ){

            m_has_culture_attr = true;
            m_culture_attr = new ns_s::ST_Xstring(_culture_attr);
        
        }
        const ns_s::ST_Xstring& culture_attr(){

            if (m_culture_attr)
            {
                return *m_culture_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_format_attr(){

            return m_has_format_attr;
        
        }
        void set_format_attr(const ns_s::ST_Xstring& _format_attr ){

            m_has_format_attr = true;
            m_format_attr = new ns_s::ST_Xstring(_format_attr);
        
        }
        const ns_s::ST_Xstring& format_attr(){

            if (m_format_attr)
            {
                return *m_format_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }

    private:
        static CT_ServerFormat* default_instance_ ;
        bool m_has_culture_attr ;
        ns_s::ST_Xstring* m_culture_attr ;
        bool m_has_format_attr ;
        ns_s::ST_Xstring* m_format_attr ;

    }

    class CT_ServerFormats : public XSD::ComplexType{
    public:
        bool has_serverFormat(){

            return m_has_serverFormat;
        
        }
        CT_ServerFormat* mutable_serverFormat(){

                m_has_serverFormat = true;
                if (!m_serverFormat)
                {
                    m_serverFormat = new CT_ServerFormat();
                }
                return m_serverFormat;
            
        }
        const CT_ServerFormat& serverFormat(){

            if (m_serverFormat)
            {
                return *m_serverFormat;
            }
            return CT_ServerFormat::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_serverFormat = false;
                
        if (m_serverFormat)
        {
            delete m_serverFormat;
            m_serverFormat = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_serverFormat)
                {
                    m_serverFormat->toXml(serverFormat, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_ServerFormats& default_instance(){

    if (!CT_ServerFormats::default_instance_)
    {
        CT_ServerFormats::default_instance_ = new CT_ServerFormats();
    }
    return *CT_ServerFormats::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_serverFormat ;
        CT_ServerFormat* m_serverFormat ;
        static CT_ServerFormats* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_PCDSDTCEntries : public XSD::ComplexType{
    public:
        CT_Missing* add_m(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_Missing* pNewChild = pChildGroup->mutable_m();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_Number* add_n(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_Number* pNewChild = pChildGroup->mutable_n();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_Error* add_e(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_Error* pNewChild = pChildGroup->mutable_e();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_String* add_s(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_String* pNewChild = pChildGroup->mutable_s();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
            vector<ChildGroup_1*>::iterator iter;
            for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
            {
                delete *iter;
            }
            m_childGroupList_1.clear();
        
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_m())
            {
                (*iter)->toXml(m, _outStream);
            }
            else if ((*iter)->has_n())
            {
                (*iter)->toXml(n, _outStream);
            }
            else if ((*iter)->has_e())
            {
                (*iter)->toXml(e, _outStream);
            }
            else if ((*iter)->has_s())
            {
                (*iter)->toXml(s, _outStream);
            }
        }
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_PCDSDTCEntries& default_instance(){

    if (!CT_PCDSDTCEntries::default_instance_)
    {
        CT_PCDSDTCEntries::default_instance_ = new CT_PCDSDTCEntries();
    }
    return *CT_PCDSDTCEntries::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        vector<ChildGroup_1*> m_childGroupList_1 ;
        static CT_PCDSDTCEntries* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;
        class ChildGroup_1{
        public:
            bool has_m(){

            return m_has_m;
        
            }
            CT_Missing* mutable_m(){

                
                m_has_n = false;
                
        if (m_n)
        {
            delete m_n;
            m_n = NULL;
        }
    ;
            
                m_has_e = false;
                
        if (m_e)
        {
            delete m_e;
            m_e = NULL;
        }
    ;
            
                m_has_s = false;
                
        if (m_s)
        {
            delete m_s;
            m_s = NULL;
        }
    ;
            
                m_has_m = true;
                if (!m_m)
                {
                    m_m = new CT_Missing();
                }
                return m_m;
            
            }
            const CT_Missing& m(){

            if (m_m)
            {
                return *m_m;
            }
            return CT_Missing::default_instance();
        
            }
            bool has_n(){

            return m_has_n;
        
            }
            CT_Number* mutable_n(){

                
                m_has_m = false;
                
        if (m_m)
        {
            delete m_m;
            m_m = NULL;
        }
    ;
            
                m_has_e = false;
                
        if (m_e)
        {
            delete m_e;
            m_e = NULL;
        }
    ;
            
                m_has_s = false;
                
        if (m_s)
        {
            delete m_s;
            m_s = NULL;
        }
    ;
            
                m_has_n = true;
                if (!m_n)
                {
                    m_n = new CT_Number();
                }
                return m_n;
            
            }
            const CT_Number& n(){

            if (m_n)
            {
                return *m_n;
            }
            return CT_Number::default_instance();
        
            }
            bool has_e(){

            return m_has_e;
        
            }
            CT_Error* mutable_e(){

                
                m_has_m = false;
                
        if (m_m)
        {
            delete m_m;
            m_m = NULL;
        }
    ;
            
                m_has_n = false;
                
        if (m_n)
        {
            delete m_n;
            m_n = NULL;
        }
    ;
            
                m_has_s = false;
                
        if (m_s)
        {
            delete m_s;
            m_s = NULL;
        }
    ;
            
                m_has_e = true;
                if (!m_e)
                {
                    m_e = new CT_Error();
                }
                return m_e;
            
            }
            const CT_Error& e(){

            if (m_e)
            {
                return *m_e;
            }
            return CT_Error::default_instance();
        
            }
            bool has_s(){

            return m_has_s;
        
            }
            CT_String* mutable_s(){

                
                m_has_m = false;
                
        if (m_m)
        {
            delete m_m;
            m_m = NULL;
        }
    ;
            
                m_has_n = false;
                
        if (m_n)
        {
            delete m_n;
            m_n = NULL;
        }
    ;
            
                m_has_e = false;
                
        if (m_e)
        {
            delete m_e;
            m_e = NULL;
        }
    ;
            
                m_has_s = true;
                if (!m_s)
                {
                    m_s = new CT_String();
                }
                return m_s;
            
            }
            const CT_String& s(){

            if (m_s)
            {
                return *m_s;
            }
            return CT_String::default_instance();
        
            }

        private:
            bool m_has_m ;
            CT_Missing* m_m ;
            bool m_has_n ;
            CT_Number* m_n ;
            bool m_has_e ;
            CT_Error* m_e ;
            bool m_has_s ;
            CT_String* m_s ;

        }


    }

    class CT_Tuples : public XSD::ComplexType{
    public:
        bool has_tpl(){

            return m_has_tpl;
        
        }
        CT_Tuple* mutable_tpl(){

                m_has_tpl = true;
                if (!m_tpl)
                {
                    m_tpl = new CT_Tuple();
                }
                return m_tpl;
            
        }
        const CT_Tuple& tpl(){

            if (m_tpl)
            {
                return *m_tpl;
            }
            return CT_Tuple::default_instance();
        
        }
        void clear(){

                m_has_c_attr = false;
                m_c_attr = 0;
            
                m_has_tpl = false;
                
        if (m_tpl)
        {
            delete m_tpl;
            m_tpl = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_c_attr << \\\;
        _outStream << \>\;
    
                if (m_has_tpl)
                {
                    m_tpl->toXml(tpl, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Tuples& default_instance(){

    if (!CT_Tuples::default_instance_)
    {
        CT_Tuples::default_instance_ = new CT_Tuples();
    }
    return *CT_Tuples::default_instance_;

        }
        bool has_c_attr(){

            return m_has_c_attr;
        
        }
        void set_c_attr(const unsignedInt& _c_attr ){

        m_has_c_attr = true;
        m_c_attr = _c_attr;
        
        }
        const unsignedInt& c_attr(){

            return type: \unsignedInt\nname: \m_c_attr\n;
        
        }

    private:
        bool m_has_tpl ;
        CT_Tuple* m_tpl ;
        static CT_Tuples* default_instance_ ;
        bool m_has_c_attr ;
        unsignedInt m_c_attr ;

    }

    class CT_Tuple : public XSD::ComplexType{
    public:
        void clear(){

                m_has_fld_attr = false;
                m_fld_attr = 0;
            
                m_has_hier_attr = false;
                m_hier_attr = 0;
            
                m_has_item_attr = false;
                m_item_attr = 0;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_fld_attr << \\\;
_outStream << _attrName << \=\\ << m_hier_attr << \\\;
_outStream << _attrName << \=\\ << m_item_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Tuple& default_instance(){

    if (!CT_Tuple::default_instance_)
    {
        CT_Tuple::default_instance_ = new CT_Tuple();
    }
    return *CT_Tuple::default_instance_;

        }
        bool has_fld_attr(){

            return m_has_fld_attr;
        
        }
        void set_fld_attr(const unsignedInt& _fld_attr ){

        m_has_fld_attr = true;
        m_fld_attr = _fld_attr;
        
        }
        const unsignedInt& fld_attr(){

            return type: \unsignedInt\nname: \m_fld_attr\n;
        
        }
        bool has_hier_attr(){

            return m_has_hier_attr;
        
        }
        void set_hier_attr(const unsignedInt& _hier_attr ){

        m_has_hier_attr = true;
        m_hier_attr = _hier_attr;
        
        }
        const unsignedInt& hier_attr(){

            return type: \unsignedInt\nname: \m_hier_attr\n;
        
        }
        bool has_item_attr(){

            return m_has_item_attr;
        
        }
        void set_item_attr(const unsignedInt& _item_attr ){

        m_has_item_attr = true;
        m_item_attr = _item_attr;
        
        }
        const unsignedInt& item_attr(){

            return type: \unsignedInt\nname: \m_item_attr\n;
        
        }

    private:
        static CT_Tuple* default_instance_ ;
        bool m_has_fld_attr ;
        unsignedInt m_fld_attr ;
        bool m_has_hier_attr ;
        unsignedInt m_hier_attr ;
        bool m_has_item_attr ;
        unsignedInt m_item_attr ;

    }

    class CT_Sets : public XSD::ComplexType{
    public:
        bool has_set(){

            return m_has_set;
        
        }
        CT_Set* mutable_set(){

                m_has_set = true;
                if (!m_set)
                {
                    m_set = new CT_Set();
                }
                return m_set;
            
        }
        const CT_Set& set(){

            if (m_set)
            {
                return *m_set;
            }
            return CT_Set::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_set = false;
                
        if (m_set)
        {
            delete m_set;
            m_set = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_set)
                {
                    m_set->toXml(set, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Sets& default_instance(){

    if (!CT_Sets::default_instance_)
    {
        CT_Sets::default_instance_ = new CT_Sets();
    }
    return *CT_Sets::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_set ;
        CT_Set* m_set ;
        static CT_Sets* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_Set : public XSD::ComplexType{
    public:
        bool has_tpls(){

            return m_has_tpls;
        
        }
        CT_Tuples* mutable_tpls(){

                m_has_tpls = true;
                if (!m_tpls)
                {
                    m_tpls = new CT_Tuples();
                }
                return m_tpls;
            
        }
        const CT_Tuples& tpls(){

            if (m_tpls)
            {
                return *m_tpls;
            }
            return CT_Tuples::default_instance();
        
        }
        bool has_sortByTuple(){

            return m_has_sortByTuple;
        
        }
        CT_Tuples* mutable_sortByTuple(){

                m_has_sortByTuple = true;
                if (!m_sortByTuple)
                {
                    m_sortByTuple = new CT_Tuples();
                }
                return m_sortByTuple;
            
        }
        const CT_Tuples& sortByTuple(){

            if (m_sortByTuple)
            {
                return *m_sortByTuple;
            }
            return CT_Tuples::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_maxRank_attr = false;
                m_maxRank_attr = 0;
            
                m_has_setDefinition_attr = false;
                
        if (m_setDefinition_attr)
        {
            delete m_setDefinition_attr;
            m_setDefinition_attr = NULL;
        }
    
            
                m_has_sortType_attr = false;
                
        if (m_sortType_attr)
        {
            delete m_sortType_attr;
            m_sortType_attr = NULL;
        }
    
            
                m_has_queryFailed_attr = false;
                m_queryFailed_attr = false;
            
                m_has_tpls = false;
                
        if (m_tpls)
        {
            delete m_tpls;
            m_tpls = NULL;
        }
    
            
                m_has_sortByTuple = false;
                
        if (m_sortByTuple)
        {
            delete m_sortByTuple;
            m_sortByTuple = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
_outStream << _attrName << \=\\ << m_maxRank_attr << \\\;
m_setDefinition_attr->toXml(_attrName, _outStream);
m_sortType_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_queryFailed_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_tpls)
                {
                    m_tpls->toXml(tpls, _outStream);;
                }
            
                if (m_has_sortByTuple)
                {
                    m_tpls->toXml(sortByTuple, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Set& default_instance(){

    if (!CT_Set::default_instance_)
    {
        CT_Set::default_instance_ = new CT_Set();
    }
    return *CT_Set::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }
        bool has_maxRank_attr(){

            return m_has_maxRank_attr;
        
        }
        void set_maxRank_attr(const int& _maxRank_attr ){

        m_has_maxRank_attr = true;
        m_maxRank_attr = _maxRank_attr;
        
        }
        const int& maxRank_attr(){

            return type: \int\nname: \m_maxRank_attr\n;
        
        }
        bool has_setDefinition_attr(){

            return m_has_setDefinition_attr;
        
        }
        void set_setDefinition_attr(const ns_s::ST_Xstring& _setDefinition_attr ){

            m_has_setDefinition_attr = true;
            m_setDefinition_attr = new ns_s::ST_Xstring(_setDefinition_attr);
        
        }
        const ns_s::ST_Xstring& setDefinition_attr(){

            if (m_setDefinition_attr)
            {
                return *m_setDefinition_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_sortType_attr(){

            return m_has_sortType_attr;
        
        }
        void set_sortType_attr(const ST_SortType& _sortType_attr ){

            m_has_sortType_attr = true;
            m_sortType_attr = new ST_SortType(_sortType_attr);
        
        }
        const ST_SortType& sortType_attr(){

            if (m_sortType_attr)
            {
                return *m_sortType_attr;
            }
            return ST_SortType::default_instance();
        
        }
        bool has_queryFailed_attr(){

            return m_has_queryFailed_attr;
        
        }
        void set_queryFailed_attr(const boolean& _queryFailed_attr ){

        m_has_queryFailed_attr = true;
        m_queryFailed_attr = _queryFailed_attr;
        
        }
        const boolean& queryFailed_attr(){

            return type: oolean\nname: \m_queryFailed_attr\n;
        
        }

    private:
        bool m_has_tpls ;
        CT_Tuples* m_tpls ;
        bool m_has_sortByTuple ;
        CT_Tuples* m_sortByTuple ;
        static CT_Set* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;
        bool m_has_maxRank_attr ;
        int m_maxRank_attr ;
        bool m_has_setDefinition_attr ;
        ns_s::ST_Xstring* m_setDefinition_attr ;
        bool m_has_sortType_attr ;
        ST_SortType* m_sortType_attr ;
        bool m_has_queryFailed_attr ;
        boolean m_queryFailed_attr ;

    }

    class CT_QueryCache : public XSD::ComplexType{
    public:
        bool has_query(){

            return m_has_query;
        
        }
        CT_Query* mutable_query(){

                m_has_query = true;
                if (!m_query)
                {
                    m_query = new CT_Query();
                }
                return m_query;
            
        }
        const CT_Query& query(){

            if (m_query)
            {
                return *m_query;
            }
            return CT_Query::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_query = false;
                
        if (m_query)
        {
            delete m_query;
            m_query = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_query)
                {
                    m_query->toXml(query, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_QueryCache& default_instance(){

    if (!CT_QueryCache::default_instance_)
    {
        CT_QueryCache::default_instance_ = new CT_QueryCache();
    }
    return *CT_QueryCache::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_query ;
        CT_Query* m_query ;
        static CT_QueryCache* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_Query : public XSD::ComplexType{
    public:
        bool has_tpls(){

            return m_has_tpls;
        
        }
        CT_Tuples* mutable_tpls(){

                m_has_tpls = true;
                if (!m_tpls)
                {
                    m_tpls = new CT_Tuples();
                }
                return m_tpls;
            
        }
        const CT_Tuples& tpls(){

            if (m_tpls)
            {
                return *m_tpls;
            }
            return CT_Tuples::default_instance();
        
        }
        void clear(){

                m_has_mdx_attr = false;
                
        if (m_mdx_attr)
        {
            delete m_mdx_attr;
            m_mdx_attr = NULL;
        }
    
            
                m_has_tpls = false;
                
        if (m_tpls)
        {
            delete m_tpls;
            m_tpls = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_mdx_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_tpls)
                {
                    m_tpls->toXml(tpls, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Query& default_instance(){

    if (!CT_Query::default_instance_)
    {
        CT_Query::default_instance_ = new CT_Query();
    }
    return *CT_Query::default_instance_;

        }
        bool has_mdx_attr(){

            return m_has_mdx_attr;
        
        }
        void set_mdx_attr(const ns_s::ST_Xstring& _mdx_attr ){

            m_has_mdx_attr = true;
            m_mdx_attr = new ns_s::ST_Xstring(_mdx_attr);
        
        }
        const ns_s::ST_Xstring& mdx_attr(){

            if (m_mdx_attr)
            {
                return *m_mdx_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }

    private:
        bool m_has_tpls ;
        CT_Tuples* m_tpls ;
        static CT_Query* default_instance_ ;
        bool m_has_mdx_attr ;
        ns_s::ST_Xstring* m_mdx_attr ;

    }

    class CT_CalculatedItems : public XSD::ComplexType{
    public:
        bool has_calculatedItem(){

            return m_has_calculatedItem;
        
        }
        CT_CalculatedItem* mutable_calculatedItem(){

                m_has_calculatedItem = true;
                if (!m_calculatedItem)
                {
                    m_calculatedItem = new CT_CalculatedItem();
                }
                return m_calculatedItem;
            
        }
        const CT_CalculatedItem& calculatedItem(){

            if (m_calculatedItem)
            {
                return *m_calculatedItem;
            }
            return CT_CalculatedItem::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_calculatedItem = false;
                
        if (m_calculatedItem)
        {
            delete m_calculatedItem;
            m_calculatedItem = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_calculatedItem)
                {
                    m_calculatedItem->toXml(calculatedItem, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CalculatedItems& default_instance(){

    if (!CT_CalculatedItems::default_instance_)
    {
        CT_CalculatedItems::default_instance_ = new CT_CalculatedItems();
    }
    return *CT_CalculatedItems::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_calculatedItem ;
        CT_CalculatedItem* m_calculatedItem ;
        static CT_CalculatedItems* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_CalculatedItem : public XSD::ComplexType{
    public:
        bool has_pivotArea(){

            return m_has_pivotArea;
        
        }
        CT_PivotArea* mutable_pivotArea(){

                m_has_pivotArea = true;
                if (!m_pivotArea)
                {
                    m_pivotArea = new CT_PivotArea();
                }
                return m_pivotArea;
            
        }
        const CT_PivotArea& pivotArea(){

            if (m_pivotArea)
            {
                return *m_pivotArea;
            }
            return CT_PivotArea::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_field_attr = false;
                m_field_attr = 0;
            
                m_has_formula_attr = false;
                
        if (m_formula_attr)
        {
            delete m_formula_attr;
            m_formula_attr = NULL;
        }
    
            
                m_has_pivotArea = false;
                
        if (m_pivotArea)
        {
            delete m_pivotArea;
            m_pivotArea = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_field_attr << \\\;
m_formula_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_pivotArea)
                {
                    m_pivotArea->toXml(pivotArea, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_pivotArea->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CalculatedItem& default_instance(){

    if (!CT_CalculatedItem::default_instance_)
    {
        CT_CalculatedItem::default_instance_ = new CT_CalculatedItem();
    }
    return *CT_CalculatedItem::default_instance_;

        }
        bool has_field_attr(){

            return m_has_field_attr;
        
        }
        void set_field_attr(const unsignedInt& _field_attr ){

        m_has_field_attr = true;
        m_field_attr = _field_attr;
        
        }
        const unsignedInt& field_attr(){

            return type: \unsignedInt\nname: \m_field_attr\n;
        
        }
        bool has_formula_attr(){

            return m_has_formula_attr;
        
        }
        void set_formula_attr(const ns_s::ST_Xstring& _formula_attr ){

            m_has_formula_attr = true;
            m_formula_attr = new ns_s::ST_Xstring(_formula_attr);
        
        }
        const ns_s::ST_Xstring& formula_attr(){

            if (m_formula_attr)
            {
                return *m_formula_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }

    private:
        bool m_has_pivotArea ;
        CT_PivotArea* m_pivotArea ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_CalculatedItem* default_instance_ ;
        bool m_has_field_attr ;
        unsignedInt m_field_attr ;
        bool m_has_formula_attr ;
        ns_s::ST_Xstring* m_formula_attr ;

    }

    class CT_CalculatedMembers : public XSD::ComplexType{
    public:
        bool has_calculatedMember(){

            return m_has_calculatedMember;
        
        }
        CT_CalculatedMember* mutable_calculatedMember(){

                m_has_calculatedMember = true;
                if (!m_calculatedMember)
                {
                    m_calculatedMember = new CT_CalculatedMember();
                }
                return m_calculatedMember;
            
        }
        const CT_CalculatedMember& calculatedMember(){

            if (m_calculatedMember)
            {
                return *m_calculatedMember;
            }
            return CT_CalculatedMember::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_calculatedMember = false;
                
        if (m_calculatedMember)
        {
            delete m_calculatedMember;
            m_calculatedMember = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_calculatedMember)
                {
                    m_calculatedMember->toXml(calculatedMember, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CalculatedMembers& default_instance(){

    if (!CT_CalculatedMembers::default_instance_)
    {
        CT_CalculatedMembers::default_instance_ = new CT_CalculatedMembers();
    }
    return *CT_CalculatedMembers::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_calculatedMember ;
        CT_CalculatedMember* m_calculatedMember ;
        static CT_CalculatedMembers* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_CalculatedMember : public XSD::ComplexType{
    public:
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
                m_has_mdx_attr = false;
                
        if (m_mdx_attr)
        {
            delete m_mdx_attr;
            m_mdx_attr = NULL;
        }
    
            
                m_has_memberName_attr = false;
                
        if (m_memberName_attr)
        {
            delete m_memberName_attr;
            m_memberName_attr = NULL;
        }
    
            
                m_has_hierarchy_attr = false;
                
        if (m_hierarchy_attr)
        {
            delete m_hierarchy_attr;
            m_hierarchy_attr = NULL;
        }
    
            
                m_has_parent_attr = false;
                
        if (m_parent_attr)
        {
            delete m_parent_attr;
            m_parent_attr = NULL;
        }
    
            
                m_has_solveOrder_attr = false;
                m_solveOrder_attr = 0;
            
                m_has_set_attr = false;
                m_set_attr = false;
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_name_attr->toXml(_attrName, _outStream);
m_mdx_attr->toXml(_attrName, _outStream);
m_memberName_attr->toXml(_attrName, _outStream);
m_hierarchy_attr->toXml(_attrName, _outStream);
m_parent_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_solveOrder_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_set_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_extLst)
                {
                    m_extLst->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CalculatedMember& default_instance(){

    if (!CT_CalculatedMember::default_instance_)
    {
        CT_CalculatedMember::default_instance_ = new CT_CalculatedMember();
    }
    return *CT_CalculatedMember::default_instance_;

        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_mdx_attr(){

            return m_has_mdx_attr;
        
        }
        void set_mdx_attr(const ns_s::ST_Xstring& _mdx_attr ){

            m_has_mdx_attr = true;
            m_mdx_attr = new ns_s::ST_Xstring(_mdx_attr);
        
        }
        const ns_s::ST_Xstring& mdx_attr(){

            if (m_mdx_attr)
            {
                return *m_mdx_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_memberName_attr(){

            return m_has_memberName_attr;
        
        }
        void set_memberName_attr(const ns_s::ST_Xstring& _memberName_attr ){

            m_has_memberName_attr = true;
            m_memberName_attr = new ns_s::ST_Xstring(_memberName_attr);
        
        }
        const ns_s::ST_Xstring& memberName_attr(){

            if (m_memberName_attr)
            {
                return *m_memberName_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_hierarchy_attr(){

            return m_has_hierarchy_attr;
        
        }
        void set_hierarchy_attr(const ns_s::ST_Xstring& _hierarchy_attr ){

            m_has_hierarchy_attr = true;
            m_hierarchy_attr = new ns_s::ST_Xstring(_hierarchy_attr);
        
        }
        const ns_s::ST_Xstring& hierarchy_attr(){

            if (m_hierarchy_attr)
            {
                return *m_hierarchy_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_parent_attr(){

            return m_has_parent_attr;
        
        }
        void set_parent_attr(const ns_s::ST_Xstring& _parent_attr ){

            m_has_parent_attr = true;
            m_parent_attr = new ns_s::ST_Xstring(_parent_attr);
        
        }
        const ns_s::ST_Xstring& parent_attr(){

            if (m_parent_attr)
            {
                return *m_parent_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_solveOrder_attr(){

            return m_has_solveOrder_attr;
        
        }
        void set_solveOrder_attr(const int& _solveOrder_attr ){

        m_has_solveOrder_attr = true;
        m_solveOrder_attr = _solveOrder_attr;
        
        }
        const int& solveOrder_attr(){

            return type: \int\nname: \m_solveOrder_attr\n;
        
        }
        bool has_set_attr(){

            return m_has_set_attr;
        
        }
        void set_set_attr(const boolean& _set_attr ){

        m_has_set_attr = true;
        m_set_attr = _set_attr;
        
        }
        const boolean& set_attr(){

            return type: oolean\nname: \m_set_attr\n;
        
        }

    private:
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_CalculatedMember* default_instance_ ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;
        bool m_has_mdx_attr ;
        ns_s::ST_Xstring* m_mdx_attr ;
        bool m_has_memberName_attr ;
        ns_s::ST_Xstring* m_memberName_attr ;
        bool m_has_hierarchy_attr ;
        ns_s::ST_Xstring* m_hierarchy_attr ;
        bool m_has_parent_attr ;
        ns_s::ST_Xstring* m_parent_attr ;
        bool m_has_solveOrder_attr ;
        int m_solveOrder_attr ;
        bool m_has_set_attr ;
        boolean m_set_attr ;

    }

    class CT_pivotTableDefinition : public XSD::ComplexType{
    public:
        bool has_location(){

            return m_has_location;
        
        }
        CT_Location* mutable_location(){

                m_has_location = true;
                if (!m_location)
                {
                    m_location = new CT_Location();
                }
                return m_location;
            
        }
        const CT_Location& location(){

            if (m_location)
            {
                return *m_location;
            }
            return CT_Location::default_instance();
        
        }
        bool has_pivotFields(){

            return m_has_pivotFields;
        
        }
        CT_PivotFields* mutable_pivotFields(){

                m_has_pivotFields = true;
                if (!m_pivotFields)
                {
                    m_pivotFields = new CT_PivotFields();
                }
                return m_pivotFields;
            
        }
        const CT_PivotFields& pivotFields(){

            if (m_pivotFields)
            {
                return *m_pivotFields;
            }
            return CT_PivotFields::default_instance();
        
        }
        bool has_rowFields(){

            return m_has_rowFields;
        
        }
        CT_RowFields* mutable_rowFields(){

                m_has_rowFields = true;
                if (!m_rowFields)
                {
                    m_rowFields = new CT_RowFields();
                }
                return m_rowFields;
            
        }
        const CT_RowFields& rowFields(){

            if (m_rowFields)
            {
                return *m_rowFields;
            }
            return CT_RowFields::default_instance();
        
        }
        bool has_rowItems(){

            return m_has_rowItems;
        
        }
        CT_rowItems* mutable_rowItems(){

                m_has_rowItems = true;
                if (!m_rowItems)
                {
                    m_rowItems = new CT_rowItems();
                }
                return m_rowItems;
            
        }
        const CT_rowItems& rowItems(){

            if (m_rowItems)
            {
                return *m_rowItems;
            }
            return CT_rowItems::default_instance();
        
        }
        bool has_colFields(){

            return m_has_colFields;
        
        }
        CT_ColFields* mutable_colFields(){

                m_has_colFields = true;
                if (!m_colFields)
                {
                    m_colFields = new CT_ColFields();
                }
                return m_colFields;
            
        }
        const CT_ColFields& colFields(){

            if (m_colFields)
            {
                return *m_colFields;
            }
            return CT_ColFields::default_instance();
        
        }
        bool has_colItems(){

            return m_has_colItems;
        
        }
        CT_colItems* mutable_colItems(){

                m_has_colItems = true;
                if (!m_colItems)
                {
                    m_colItems = new CT_colItems();
                }
                return m_colItems;
            
        }
        const CT_colItems& colItems(){

            if (m_colItems)
            {
                return *m_colItems;
            }
            return CT_colItems::default_instance();
        
        }
        bool has_pageFields(){

            return m_has_pageFields;
        
        }
        CT_PageFields* mutable_pageFields(){

                m_has_pageFields = true;
                if (!m_pageFields)
                {
                    m_pageFields = new CT_PageFields();
                }
                return m_pageFields;
            
        }
        const CT_PageFields& pageFields(){

            if (m_pageFields)
            {
                return *m_pageFields;
            }
            return CT_PageFields::default_instance();
        
        }
        bool has_dataFields(){

            return m_has_dataFields;
        
        }
        CT_DataFields* mutable_dataFields(){

                m_has_dataFields = true;
                if (!m_dataFields)
                {
                    m_dataFields = new CT_DataFields();
                }
                return m_dataFields;
            
        }
        const CT_DataFields& dataFields(){

            if (m_dataFields)
            {
                return *m_dataFields;
            }
            return CT_DataFields::default_instance();
        
        }
        bool has_formats(){

            return m_has_formats;
        
        }
        CT_Formats* mutable_formats(){

                m_has_formats = true;
                if (!m_formats)
                {
                    m_formats = new CT_Formats();
                }
                return m_formats;
            
        }
        const CT_Formats& formats(){

            if (m_formats)
            {
                return *m_formats;
            }
            return CT_Formats::default_instance();
        
        }
        bool has_conditionalFormats(){

            return m_has_conditionalFormats;
        
        }
        CT_ConditionalFormats* mutable_conditionalFormats(){

                m_has_conditionalFormats = true;
                if (!m_conditionalFormats)
                {
                    m_conditionalFormats = new CT_ConditionalFormats();
                }
                return m_conditionalFormats;
            
        }
        const CT_ConditionalFormats& conditionalFormats(){

            if (m_conditionalFormats)
            {
                return *m_conditionalFormats;
            }
            return CT_ConditionalFormats::default_instance();
        
        }
        bool has_chartFormats(){

            return m_has_chartFormats;
        
        }
        CT_ChartFormats* mutable_chartFormats(){

                m_has_chartFormats = true;
                if (!m_chartFormats)
                {
                    m_chartFormats = new CT_ChartFormats();
                }
                return m_chartFormats;
            
        }
        const CT_ChartFormats& chartFormats(){

            if (m_chartFormats)
            {
                return *m_chartFormats;
            }
            return CT_ChartFormats::default_instance();
        
        }
        bool has_pivotHierarchies(){

            return m_has_pivotHierarchies;
        
        }
        CT_PivotHierarchies* mutable_pivotHierarchies(){

                m_has_pivotHierarchies = true;
                if (!m_pivotHierarchies)
                {
                    m_pivotHierarchies = new CT_PivotHierarchies();
                }
                return m_pivotHierarchies;
            
        }
        const CT_PivotHierarchies& pivotHierarchies(){

            if (m_pivotHierarchies)
            {
                return *m_pivotHierarchies;
            }
            return CT_PivotHierarchies::default_instance();
        
        }
        bool has_pivotTableStyleInfo(){

            return m_has_pivotTableStyleInfo;
        
        }
        CT_PivotTableStyle* mutable_pivotTableStyleInfo(){

                m_has_pivotTableStyleInfo = true;
                if (!m_pivotTableStyleInfo)
                {
                    m_pivotTableStyleInfo = new CT_PivotTableStyle();
                }
                return m_pivotTableStyleInfo;
            
        }
        const CT_PivotTableStyle& pivotTableStyleInfo(){

            if (m_pivotTableStyleInfo)
            {
                return *m_pivotTableStyleInfo;
            }
            return CT_PivotTableStyle::default_instance();
        
        }
        bool has_filters(){

            return m_has_filters;
        
        }
        CT_PivotFilters* mutable_filters(){

                m_has_filters = true;
                if (!m_filters)
                {
                    m_filters = new CT_PivotFilters();
                }
                return m_filters;
            
        }
        const CT_PivotFilters& filters(){

            if (m_filters)
            {
                return *m_filters;
            }
            return CT_PivotFilters::default_instance();
        
        }
        bool has_rowHierarchiesUsage(){

            return m_has_rowHierarchiesUsage;
        
        }
        CT_RowHierarchiesUsage* mutable_rowHierarchiesUsage(){

                m_has_rowHierarchiesUsage = true;
                if (!m_rowHierarchiesUsage)
                {
                    m_rowHierarchiesUsage = new CT_RowHierarchiesUsage();
                }
                return m_rowHierarchiesUsage;
            
        }
        const CT_RowHierarchiesUsage& rowHierarchiesUsage(){

            if (m_rowHierarchiesUsage)
            {
                return *m_rowHierarchiesUsage;
            }
            return CT_RowHierarchiesUsage::default_instance();
        
        }
        bool has_colHierarchiesUsage(){

            return m_has_colHierarchiesUsage;
        
        }
        CT_ColHierarchiesUsage* mutable_colHierarchiesUsage(){

                m_has_colHierarchiesUsage = true;
                if (!m_colHierarchiesUsage)
                {
                    m_colHierarchiesUsage = new CT_ColHierarchiesUsage();
                }
                return m_colHierarchiesUsage;
            
        }
        const CT_ColHierarchiesUsage& colHierarchiesUsage(){

            if (m_colHierarchiesUsage)
            {
                return *m_colHierarchiesUsage;
            }
            return CT_ColHierarchiesUsage::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
                m_has_cacheId_attr = false;
                m_cacheId_attr = 0;
            
                m_has_dataOnRows_attr = false;
                m_dataOnRows_attr = false;
            
                m_has_dataPosition_attr = false;
                m_dataPosition_attr = 0;
            
                m_has_autoFormatId_attr = false;
                m_autoFormatId_attr = 0;
            
                m_has_applyNumberFormats_attr = false;
                m_applyNumberFormats_attr = false;
            
                m_has_applyBorderFormats_attr = false;
                m_applyBorderFormats_attr = false;
            
                m_has_applyFontFormats_attr = false;
                m_applyFontFormats_attr = false;
            
                m_has_applyPatternFormats_attr = false;
                m_applyPatternFormats_attr = false;
            
                m_has_applyAlignmentFormats_attr = false;
                m_applyAlignmentFormats_attr = false;
            
                m_has_applyWidthHeightFormats_attr = false;
                m_applyWidthHeightFormats_attr = false;
            
                m_has_dataCaption_attr = false;
                
        if (m_dataCaption_attr)
        {
            delete m_dataCaption_attr;
            m_dataCaption_attr = NULL;
        }
    
            
                m_has_grandTotalCaption_attr = false;
                
        if (m_grandTotalCaption_attr)
        {
            delete m_grandTotalCaption_attr;
            m_grandTotalCaption_attr = NULL;
        }
    
            
                m_has_errorCaption_attr = false;
                
        if (m_errorCaption_attr)
        {
            delete m_errorCaption_attr;
            m_errorCaption_attr = NULL;
        }
    
            
                m_has_showError_attr = false;
                m_showError_attr = false;
            
                m_has_missingCaption_attr = false;
                
        if (m_missingCaption_attr)
        {
            delete m_missingCaption_attr;
            m_missingCaption_attr = NULL;
        }
    
            
                m_has_showMissing_attr = false;
                m_showMissing_attr = false;
            
                m_has_pageStyle_attr = false;
                
        if (m_pageStyle_attr)
        {
            delete m_pageStyle_attr;
            m_pageStyle_attr = NULL;
        }
    
            
                m_has_pivotTableStyle_attr = false;
                
        if (m_pivotTableStyle_attr)
        {
            delete m_pivotTableStyle_attr;
            m_pivotTableStyle_attr = NULL;
        }
    
            
                m_has_vacatedStyle_attr = false;
                
        if (m_vacatedStyle_attr)
        {
            delete m_vacatedStyle_attr;
            m_vacatedStyle_attr = NULL;
        }
    
            
                m_has_tag_attr = false;
                
        if (m_tag_attr)
        {
            delete m_tag_attr;
            m_tag_attr = NULL;
        }
    
            
                m_has_updatedVersion_attr = false;
                m_updatedVersion_attr = 0;
            
                m_has_minRefreshableVersion_attr = false;
                m_minRefreshableVersion_attr = 0;
            
                m_has_asteriskTotals_attr = false;
                m_asteriskTotals_attr = false;
            
                m_has_showItems_attr = false;
                m_showItems_attr = false;
            
                m_has_editData_attr = false;
                m_editData_attr = false;
            
                m_has_disableFieldList_attr = false;
                m_disableFieldList_attr = false;
            
                m_has_showCalcMbrs_attr = false;
                m_showCalcMbrs_attr = false;
            
                m_has_visualTotals_attr = false;
                m_visualTotals_attr = false;
            
                m_has_showMultipleLabel_attr = false;
                m_showMultipleLabel_attr = false;
            
                m_has_showDataDropDown_attr = false;
                m_showDataDropDown_attr = false;
            
                m_has_showDrill_attr = false;
                m_showDrill_attr = false;
            
                m_has_printDrill_attr = false;
                m_printDrill_attr = false;
            
                m_has_showMemberPropertyTips_attr = false;
                m_showMemberPropertyTips_attr = false;
            
                m_has_showDataTips_attr = false;
                m_showDataTips_attr = false;
            
                m_has_enableWizard_attr = false;
                m_enableWizard_attr = false;
            
                m_has_enableDrill_attr = false;
                m_enableDrill_attr = false;
            
                m_has_enableFieldProperties_attr = false;
                m_enableFieldProperties_attr = false;
            
                m_has_preserveFormatting_attr = false;
                m_preserveFormatting_attr = false;
            
                m_has_useAutoFormatting_attr = false;
                m_useAutoFormatting_attr = false;
            
                m_has_pageWrap_attr = false;
                m_pageWrap_attr = 0;
            
                m_has_pageOverThenDown_attr = false;
                m_pageOverThenDown_attr = false;
            
                m_has_subtotalHiddenItems_attr = false;
                m_subtotalHiddenItems_attr = false;
            
                m_has_rowGrandTotals_attr = false;
                m_rowGrandTotals_attr = false;
            
                m_has_colGrandTotals_attr = false;
                m_colGrandTotals_attr = false;
            
                m_has_fieldPrintTitles_attr = false;
                m_fieldPrintTitles_attr = false;
            
                m_has_itemPrintTitles_attr = false;
                m_itemPrintTitles_attr = false;
            
                m_has_mergeItem_attr = false;
                m_mergeItem_attr = false;
            
                m_has_showDropZones_attr = false;
                m_showDropZones_attr = false;
            
                m_has_createdVersion_attr = false;
                m_createdVersion_attr = 0;
            
                m_has_indent_attr = false;
                m_indent_attr = 0;
            
                m_has_showEmptyRow_attr = false;
                m_showEmptyRow_attr = false;
            
                m_has_showEmptyCol_attr = false;
                m_showEmptyCol_attr = false;
            
                m_has_showHeaders_attr = false;
                m_showHeaders_attr = false;
            
                m_has_compact_attr = false;
                m_compact_attr = false;
            
                m_has_outline_attr = false;
                m_outline_attr = false;
            
                m_has_outlineData_attr = false;
                m_outlineData_attr = false;
            
                m_has_compactData_attr = false;
                m_compactData_attr = false;
            
                m_has_published_attr = false;
                m_published_attr = false;
            
                m_has_gridDropZones_attr = false;
                m_gridDropZones_attr = false;
            
                m_has_immersive_attr = false;
                m_immersive_attr = false;
            
                m_has_multipleFieldFilters_attr = false;
                m_multipleFieldFilters_attr = false;
            
                m_has_chartFormat_attr = false;
                m_chartFormat_attr = 0;
            
                m_has_rowHeaderCaption_attr = false;
                
        if (m_rowHeaderCaption_attr)
        {
            delete m_rowHeaderCaption_attr;
            m_rowHeaderCaption_attr = NULL;
        }
    
            
                m_has_colHeaderCaption_attr = false;
                
        if (m_colHeaderCaption_attr)
        {
            delete m_colHeaderCaption_attr;
            m_colHeaderCaption_attr = NULL;
        }
    
            
                m_has_fieldListSortAscending_attr = false;
                m_fieldListSortAscending_attr = false;
            
                m_has_mdxSubqueries_attr = false;
                m_mdxSubqueries_attr = false;
            
                m_has_customListSort_attr = false;
                m_customListSort_attr = false;
            
                m_has_location = false;
                
        if (m_location)
        {
            delete m_location;
            m_location = NULL;
        }
    
            
                m_has_pivotFields = false;
                
        if (m_pivotFields)
        {
            delete m_pivotFields;
            m_pivotFields = NULL;
        }
    
            
                m_has_rowFields = false;
                
        if (m_rowFields)
        {
            delete m_rowFields;
            m_rowFields = NULL;
        }
    
            
                m_has_rowItems = false;
                
        if (m_rowItems)
        {
            delete m_rowItems;
            m_rowItems = NULL;
        }
    
            
                m_has_colFields = false;
                
        if (m_colFields)
        {
            delete m_colFields;
            m_colFields = NULL;
        }
    
            
                m_has_colItems = false;
                
        if (m_colItems)
        {
            delete m_colItems;
            m_colItems = NULL;
        }
    
            
                m_has_pageFields = false;
                
        if (m_pageFields)
        {
            delete m_pageFields;
            m_pageFields = NULL;
        }
    
            
                m_has_dataFields = false;
                
        if (m_dataFields)
        {
            delete m_dataFields;
            m_dataFields = NULL;
        }
    
            
                m_has_formats = false;
                
        if (m_formats)
        {
            delete m_formats;
            m_formats = NULL;
        }
    
            
                m_has_conditionalFormats = false;
                
        if (m_conditionalFormats)
        {
            delete m_conditionalFormats;
            m_conditionalFormats = NULL;
        }
    
            
                m_has_chartFormats = false;
                
        if (m_chartFormats)
        {
            delete m_chartFormats;
            m_chartFormats = NULL;
        }
    
            
                m_has_pivotHierarchies = false;
                
        if (m_pivotHierarchies)
        {
            delete m_pivotHierarchies;
            m_pivotHierarchies = NULL;
        }
    
            
                m_has_pivotTableStyleInfo = false;
                
        if (m_pivotTableStyleInfo)
        {
            delete m_pivotTableStyleInfo;
            m_pivotTableStyleInfo = NULL;
        }
    
            
                m_has_filters = false;
                
        if (m_filters)
        {
            delete m_filters;
            m_filters = NULL;
        }
    
            
                m_has_rowHierarchiesUsage = false;
                
        if (m_rowHierarchiesUsage)
        {
            delete m_rowHierarchiesUsage;
            m_rowHierarchiesUsage = NULL;
        }
    
            
                m_has_colHierarchiesUsage = false;
                
        if (m_colHierarchiesUsage)
        {
            delete m_colHierarchiesUsage;
            m_colHierarchiesUsage = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_name_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_cacheId_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_dataOnRows_attr) << \\\;
_outStream << _attrName << \=\\ << m_dataPosition_attr << \\\;
_outStream << _attrName << \=\\ << m_autoFormatId_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_applyNumberFormats_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_applyBorderFormats_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_applyFontFormats_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_applyPatternFormats_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_applyAlignmentFormats_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_applyWidthHeightFormats_attr) << \\\;
m_dataCaption_attr->toXml(_attrName, _outStream);
m_grandTotalCaption_attr->toXml(_attrName, _outStream);
m_errorCaption_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showError_attr) << \\\;
m_missingCaption_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showMissing_attr) << \\\;
m_pageStyle_attr->toXml(_attrName, _outStream);
m_pivotTableStyle_attr->toXml(_attrName, _outStream);
m_vacatedStyle_attr->toXml(_attrName, _outStream);
m_tag_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_updatedVersion_attr << \\\;
_outStream << _attrName << \=\\ << m_minRefreshableVersion_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_asteriskTotals_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showItems_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_editData_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_disableFieldList_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showCalcMbrs_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_visualTotals_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showMultipleLabel_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showDataDropDown_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showDrill_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_printDrill_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showMemberPropertyTips_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showDataTips_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_enableWizard_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_enableDrill_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_enableFieldProperties_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_preserveFormatting_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_useAutoFormatting_attr) << \\\;
_outStream << _attrName << \=\\ << m_pageWrap_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_pageOverThenDown_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_subtotalHiddenItems_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_rowGrandTotals_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_colGrandTotals_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_fieldPrintTitles_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_itemPrintTitles_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_mergeItem_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showDropZones_attr) << \\\;
_outStream << _attrName << \=\\ << m_createdVersion_attr << \\\;
_outStream << _attrName << \=\\ << m_indent_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showEmptyRow_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showEmptyCol_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showHeaders_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_compact_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_outline_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_outlineData_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_compactData_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_published_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_gridDropZones_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_immersive_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_multipleFieldFilters_attr) << \\\;
_outStream << _attrName << \=\\ << m_chartFormat_attr << \\\;
m_rowHeaderCaption_attr->toXml(_attrName, _outStream);
m_colHeaderCaption_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_fieldListSortAscending_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_mdxSubqueries_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_customListSort_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_location)
                {
                    m_location->toXml(location, _outStream);;
                }
            
                if (m_has_pivotFields)
                {
                    m_location->toXml(pivotFields, _outStream);;
                }
            
                if (m_has_rowFields)
                {
                    m_location->toXml(rowFields, _outStream);;
                }
            
                if (m_has_rowItems)
                {
                    m_location->toXml(rowItems, _outStream);;
                }
            
                if (m_has_colFields)
                {
                    m_location->toXml(colFields, _outStream);;
                }
            
                if (m_has_colItems)
                {
                    m_location->toXml(colItems, _outStream);;
                }
            
                if (m_has_pageFields)
                {
                    m_location->toXml(pageFields, _outStream);;
                }
            
                if (m_has_dataFields)
                {
                    m_location->toXml(dataFields, _outStream);;
                }
            
                if (m_has_formats)
                {
                    m_location->toXml(formats, _outStream);;
                }
            
                if (m_has_conditionalFormats)
                {
                    m_location->toXml(conditionalFormats, _outStream);;
                }
            
                if (m_has_chartFormats)
                {
                    m_location->toXml(chartFormats, _outStream);;
                }
            
                if (m_has_pivotHierarchies)
                {
                    m_location->toXml(pivotHierarchies, _outStream);;
                }
            
                if (m_has_pivotTableStyleInfo)
                {
                    m_location->toXml(pivotTableStyleInfo, _outStream);;
                }
            
                if (m_has_filters)
                {
                    m_location->toXml(filters, _outStream);;
                }
            
                if (m_has_rowHierarchiesUsage)
                {
                    m_location->toXml(rowHierarchiesUsage, _outStream);;
                }
            
                if (m_has_colHierarchiesUsage)
                {
                    m_location->toXml(colHierarchiesUsage, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_location->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_pivotTableDefinition& default_instance(){

    if (!CT_pivotTableDefinition::default_instance_)
    {
        CT_pivotTableDefinition::default_instance_ = new CT_pivotTableDefinition();
    }
    return *CT_pivotTableDefinition::default_instance_;

        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_cacheId_attr(){

            return m_has_cacheId_attr;
        
        }
        void set_cacheId_attr(const unsignedInt& _cacheId_attr ){

        m_has_cacheId_attr = true;
        m_cacheId_attr = _cacheId_attr;
        
        }
        const unsignedInt& cacheId_attr(){

            return type: \unsignedInt\nname: \m_cacheId_attr\n;
        
        }
        bool has_dataOnRows_attr(){

            return m_has_dataOnRows_attr;
        
        }
        void set_dataOnRows_attr(const boolean& _dataOnRows_attr ){

        m_has_dataOnRows_attr = true;
        m_dataOnRows_attr = _dataOnRows_attr;
        
        }
        const boolean& dataOnRows_attr(){

            return type: oolean\nname: \m_dataOnRows_attr\n;
        
        }
        bool has_dataPosition_attr(){

            return m_has_dataPosition_attr;
        
        }
        void set_dataPosition_attr(const unsignedInt& _dataPosition_attr ){

        m_has_dataPosition_attr = true;
        m_dataPosition_attr = _dataPosition_attr;
        
        }
        const unsignedInt& dataPosition_attr(){

            return type: \unsignedInt\nname: \m_dataPosition_attr\n;
        
        }
        bool has_autoFormatId_attr(){

            return m_has_autoFormatId_attr;
        
        }
        void set_autoFormatId_attr(const unsignedInt& _autoFormatId_attr ){

        m_has_autoFormatId_attr = true;
        m_autoFormatId_attr = _autoFormatId_attr;
        
        }
        const unsignedInt& autoFormatId_attr(){

            return type: \unsignedInt\nname: \m_autoFormatId_attr\n;
        
        }
        bool has_applyNumberFormats_attr(){

            return m_has_applyNumberFormats_attr;
        
        }
        void set_applyNumberFormats_attr(const boolean& _applyNumberFormats_attr ){

        m_has_applyNumberFormats_attr = true;
        m_applyNumberFormats_attr = _applyNumberFormats_attr;
        
        }
        const boolean& applyNumberFormats_attr(){

            return type: oolean\nname: \m_applyNumberFormats_attr\n;
        
        }
        bool has_applyBorderFormats_attr(){

            return m_has_applyBorderFormats_attr;
        
        }
        void set_applyBorderFormats_attr(const boolean& _applyBorderFormats_attr ){

        m_has_applyBorderFormats_attr = true;
        m_applyBorderFormats_attr = _applyBorderFormats_attr;
        
        }
        const boolean& applyBorderFormats_attr(){

            return type: oolean\nname: \m_applyBorderFormats_attr\n;
        
        }
        bool has_applyFontFormats_attr(){

            return m_has_applyFontFormats_attr;
        
        }
        void set_applyFontFormats_attr(const boolean& _applyFontFormats_attr ){

        m_has_applyFontFormats_attr = true;
        m_applyFontFormats_attr = _applyFontFormats_attr;
        
        }
        const boolean& applyFontFormats_attr(){

            return type: oolean\nname: \m_applyFontFormats_attr\n;
        
        }
        bool has_applyPatternFormats_attr(){

            return m_has_applyPatternFormats_attr;
        
        }
        void set_applyPatternFormats_attr(const boolean& _applyPatternFormats_attr ){

        m_has_applyPatternFormats_attr = true;
        m_applyPatternFormats_attr = _applyPatternFormats_attr;
        
        }
        const boolean& applyPatternFormats_attr(){

            return type: oolean\nname: \m_applyPatternFormats_attr\n;
        
        }
        bool has_applyAlignmentFormats_attr(){

            return m_has_applyAlignmentFormats_attr;
        
        }
        void set_applyAlignmentFormats_attr(const boolean& _applyAlignmentFormats_attr ){

        m_has_applyAlignmentFormats_attr = true;
        m_applyAlignmentFormats_attr = _applyAlignmentFormats_attr;
        
        }
        const boolean& applyAlignmentFormats_attr(){

            return type: oolean\nname: \m_applyAlignmentFormats_attr\n;
        
        }
        bool has_applyWidthHeightFormats_attr(){

            return m_has_applyWidthHeightFormats_attr;
        
        }
        void set_applyWidthHeightFormats_attr(const boolean& _applyWidthHeightFormats_attr ){

        m_has_applyWidthHeightFormats_attr = true;
        m_applyWidthHeightFormats_attr = _applyWidthHeightFormats_attr;
        
        }
        const boolean& applyWidthHeightFormats_attr(){

            return type: oolean\nname: \m_applyWidthHeightFormats_attr\n;
        
        }
        bool has_dataCaption_attr(){

            return m_has_dataCaption_attr;
        
        }
        void set_dataCaption_attr(const ns_s::ST_Xstring& _dataCaption_attr ){

            m_has_dataCaption_attr = true;
            m_dataCaption_attr = new ns_s::ST_Xstring(_dataCaption_attr);
        
        }
        const ns_s::ST_Xstring& dataCaption_attr(){

            if (m_dataCaption_attr)
            {
                return *m_dataCaption_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_grandTotalCaption_attr(){

            return m_has_grandTotalCaption_attr;
        
        }
        void set_grandTotalCaption_attr(const ns_s::ST_Xstring& _grandTotalCaption_attr ){

            m_has_grandTotalCaption_attr = true;
            m_grandTotalCaption_attr = new ns_s::ST_Xstring(_grandTotalCaption_attr);
        
        }
        const ns_s::ST_Xstring& grandTotalCaption_attr(){

            if (m_grandTotalCaption_attr)
            {
                return *m_grandTotalCaption_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_errorCaption_attr(){

            return m_has_errorCaption_attr;
        
        }
        void set_errorCaption_attr(const ns_s::ST_Xstring& _errorCaption_attr ){

            m_has_errorCaption_attr = true;
            m_errorCaption_attr = new ns_s::ST_Xstring(_errorCaption_attr);
        
        }
        const ns_s::ST_Xstring& errorCaption_attr(){

            if (m_errorCaption_attr)
            {
                return *m_errorCaption_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_showError_attr(){

            return m_has_showError_attr;
        
        }
        void set_showError_attr(const boolean& _showError_attr ){

        m_has_showError_attr = true;
        m_showError_attr = _showError_attr;
        
        }
        const boolean& showError_attr(){

            return type: oolean\nname: \m_showError_attr\n;
        
        }
        bool has_missingCaption_attr(){

            return m_has_missingCaption_attr;
        
        }
        void set_missingCaption_attr(const ns_s::ST_Xstring& _missingCaption_attr ){

            m_has_missingCaption_attr = true;
            m_missingCaption_attr = new ns_s::ST_Xstring(_missingCaption_attr);
        
        }
        const ns_s::ST_Xstring& missingCaption_attr(){

            if (m_missingCaption_attr)
            {
                return *m_missingCaption_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_showMissing_attr(){

            return m_has_showMissing_attr;
        
        }
        void set_showMissing_attr(const boolean& _showMissing_attr ){

        m_has_showMissing_attr = true;
        m_showMissing_attr = _showMissing_attr;
        
        }
        const boolean& showMissing_attr(){

            return type: oolean\nname: \m_showMissing_attr\n;
        
        }
        bool has_pageStyle_attr(){

            return m_has_pageStyle_attr;
        
        }
        void set_pageStyle_attr(const ns_s::ST_Xstring& _pageStyle_attr ){

            m_has_pageStyle_attr = true;
            m_pageStyle_attr = new ns_s::ST_Xstring(_pageStyle_attr);
        
        }
        const ns_s::ST_Xstring& pageStyle_attr(){

            if (m_pageStyle_attr)
            {
                return *m_pageStyle_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_pivotTableStyle_attr(){

            return m_has_pivotTableStyle_attr;
        
        }
        void set_pivotTableStyle_attr(const ns_s::ST_Xstring& _pivotTableStyle_attr ){

            m_has_pivotTableStyle_attr = true;
            m_pivotTableStyle_attr = new ns_s::ST_Xstring(_pivotTableStyle_attr);
        
        }
        const ns_s::ST_Xstring& pivotTableStyle_attr(){

            if (m_pivotTableStyle_attr)
            {
                return *m_pivotTableStyle_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_vacatedStyle_attr(){

            return m_has_vacatedStyle_attr;
        
        }
        void set_vacatedStyle_attr(const ns_s::ST_Xstring& _vacatedStyle_attr ){

            m_has_vacatedStyle_attr = true;
            m_vacatedStyle_attr = new ns_s::ST_Xstring(_vacatedStyle_attr);
        
        }
        const ns_s::ST_Xstring& vacatedStyle_attr(){

            if (m_vacatedStyle_attr)
            {
                return *m_vacatedStyle_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_tag_attr(){

            return m_has_tag_attr;
        
        }
        void set_tag_attr(const ns_s::ST_Xstring& _tag_attr ){

            m_has_tag_attr = true;
            m_tag_attr = new ns_s::ST_Xstring(_tag_attr);
        
        }
        const ns_s::ST_Xstring& tag_attr(){

            if (m_tag_attr)
            {
                return *m_tag_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_updatedVersion_attr(){

            return m_has_updatedVersion_attr;
        
        }
        void set_updatedVersion_attr(const unsignedByte& _updatedVersion_attr ){

        m_has_updatedVersion_attr = true;
        m_updatedVersion_attr = _updatedVersion_attr;
        
        }
        const unsignedByte& updatedVersion_attr(){

            return type: \unsignedByte\nname: \m_updatedVersion_attr\n;
        
        }
        bool has_minRefreshableVersion_attr(){

            return m_has_minRefreshableVersion_attr;
        
        }
        void set_minRefreshableVersion_attr(const unsignedByte& _minRefreshableVersion_attr ){

        m_has_minRefreshableVersion_attr = true;
        m_minRefreshableVersion_attr = _minRefreshableVersion_attr;
        
        }
        const unsignedByte& minRefreshableVersion_attr(){

            return type: \unsignedByte\nname: \m_minRefreshableVersion_attr\n;
        
        }
        bool has_asteriskTotals_attr(){

            return m_has_asteriskTotals_attr;
        
        }
        void set_asteriskTotals_attr(const boolean& _asteriskTotals_attr ){

        m_has_asteriskTotals_attr = true;
        m_asteriskTotals_attr = _asteriskTotals_attr;
        
        }
        const boolean& asteriskTotals_attr(){

            return type: oolean\nname: \m_asteriskTotals_attr\n;
        
        }
        bool has_showItems_attr(){

            return m_has_showItems_attr;
        
        }
        void set_showItems_attr(const boolean& _showItems_attr ){

        m_has_showItems_attr = true;
        m_showItems_attr = _showItems_attr;
        
        }
        const boolean& showItems_attr(){

            return type: oolean\nname: \m_showItems_attr\n;
        
        }
        bool has_editData_attr(){

            return m_has_editData_attr;
        
        }
        void set_editData_attr(const boolean& _editData_attr ){

        m_has_editData_attr = true;
        m_editData_attr = _editData_attr;
        
        }
        const boolean& editData_attr(){

            return type: oolean\nname: \m_editData_attr\n;
        
        }
        bool has_disableFieldList_attr(){

            return m_has_disableFieldList_attr;
        
        }
        void set_disableFieldList_attr(const boolean& _disableFieldList_attr ){

        m_has_disableFieldList_attr = true;
        m_disableFieldList_attr = _disableFieldList_attr;
        
        }
        const boolean& disableFieldList_attr(){

            return type: oolean\nname: \m_disableFieldList_attr\n;
        
        }
        bool has_showCalcMbrs_attr(){

            return m_has_showCalcMbrs_attr;
        
        }
        void set_showCalcMbrs_attr(const boolean& _showCalcMbrs_attr ){

        m_has_showCalcMbrs_attr = true;
        m_showCalcMbrs_attr = _showCalcMbrs_attr;
        
        }
        const boolean& showCalcMbrs_attr(){

            return type: oolean\nname: \m_showCalcMbrs_attr\n;
        
        }
        bool has_visualTotals_attr(){

            return m_has_visualTotals_attr;
        
        }
        void set_visualTotals_attr(const boolean& _visualTotals_attr ){

        m_has_visualTotals_attr = true;
        m_visualTotals_attr = _visualTotals_attr;
        
        }
        const boolean& visualTotals_attr(){

            return type: oolean\nname: \m_visualTotals_attr\n;
        
        }
        bool has_showMultipleLabel_attr(){

            return m_has_showMultipleLabel_attr;
        
        }
        void set_showMultipleLabel_attr(const boolean& _showMultipleLabel_attr ){

        m_has_showMultipleLabel_attr = true;
        m_showMultipleLabel_attr = _showMultipleLabel_attr;
        
        }
        const boolean& showMultipleLabel_attr(){

            return type: oolean\nname: \m_showMultipleLabel_attr\n;
        
        }
        bool has_showDataDropDown_attr(){

            return m_has_showDataDropDown_attr;
        
        }
        void set_showDataDropDown_attr(const boolean& _showDataDropDown_attr ){

        m_has_showDataDropDown_attr = true;
        m_showDataDropDown_attr = _showDataDropDown_attr;
        
        }
        const boolean& showDataDropDown_attr(){

            return type: oolean\nname: \m_showDataDropDown_attr\n;
        
        }
        bool has_showDrill_attr(){

            return m_has_showDrill_attr;
        
        }
        void set_showDrill_attr(const boolean& _showDrill_attr ){

        m_has_showDrill_attr = true;
        m_showDrill_attr = _showDrill_attr;
        
        }
        const boolean& showDrill_attr(){

            return type: oolean\nname: \m_showDrill_attr\n;
        
        }
        bool has_printDrill_attr(){

            return m_has_printDrill_attr;
        
        }
        void set_printDrill_attr(const boolean& _printDrill_attr ){

        m_has_printDrill_attr = true;
        m_printDrill_attr = _printDrill_attr;
        
        }
        const boolean& printDrill_attr(){

            return type: oolean\nname: \m_printDrill_attr\n;
        
        }
        bool has_showMemberPropertyTips_attr(){

            return m_has_showMemberPropertyTips_attr;
        
        }
        void set_showMemberPropertyTips_attr(const boolean& _showMemberPropertyTips_attr ){

        m_has_showMemberPropertyTips_attr = true;
        m_showMemberPropertyTips_attr = _showMemberPropertyTips_attr;
        
        }
        const boolean& showMemberPropertyTips_attr(){

            return type: oolean\nname: \m_showMemberPropertyTips_attr\n;
        
        }
        bool has_showDataTips_attr(){

            return m_has_showDataTips_attr;
        
        }
        void set_showDataTips_attr(const boolean& _showDataTips_attr ){

        m_has_showDataTips_attr = true;
        m_showDataTips_attr = _showDataTips_attr;
        
        }
        const boolean& showDataTips_attr(){

            return type: oolean\nname: \m_showDataTips_attr\n;
        
        }
        bool has_enableWizard_attr(){

            return m_has_enableWizard_attr;
        
        }
        void set_enableWizard_attr(const boolean& _enableWizard_attr ){

        m_has_enableWizard_attr = true;
        m_enableWizard_attr = _enableWizard_attr;
        
        }
        const boolean& enableWizard_attr(){

            return type: oolean\nname: \m_enableWizard_attr\n;
        
        }
        bool has_enableDrill_attr(){

            return m_has_enableDrill_attr;
        
        }
        void set_enableDrill_attr(const boolean& _enableDrill_attr ){

        m_has_enableDrill_attr = true;
        m_enableDrill_attr = _enableDrill_attr;
        
        }
        const boolean& enableDrill_attr(){

            return type: oolean\nname: \m_enableDrill_attr\n;
        
        }
        bool has_enableFieldProperties_attr(){

            return m_has_enableFieldProperties_attr;
        
        }
        void set_enableFieldProperties_attr(const boolean& _enableFieldProperties_attr ){

        m_has_enableFieldProperties_attr = true;
        m_enableFieldProperties_attr = _enableFieldProperties_attr;
        
        }
        const boolean& enableFieldProperties_attr(){

            return type: oolean\nname: \m_enableFieldProperties_attr\n;
        
        }
        bool has_preserveFormatting_attr(){

            return m_has_preserveFormatting_attr;
        
        }
        void set_preserveFormatting_attr(const boolean& _preserveFormatting_attr ){

        m_has_preserveFormatting_attr = true;
        m_preserveFormatting_attr = _preserveFormatting_attr;
        
        }
        const boolean& preserveFormatting_attr(){

            return type: oolean\nname: \m_preserveFormatting_attr\n;
        
        }
        bool has_useAutoFormatting_attr(){

            return m_has_useAutoFormatting_attr;
        
        }
        void set_useAutoFormatting_attr(const boolean& _useAutoFormatting_attr ){

        m_has_useAutoFormatting_attr = true;
        m_useAutoFormatting_attr = _useAutoFormatting_attr;
        
        }
        const boolean& useAutoFormatting_attr(){

            return type: oolean\nname: \m_useAutoFormatting_attr\n;
        
        }
        bool has_pageWrap_attr(){

            return m_has_pageWrap_attr;
        
        }
        void set_pageWrap_attr(const unsignedInt& _pageWrap_attr ){

        m_has_pageWrap_attr = true;
        m_pageWrap_attr = _pageWrap_attr;
        
        }
        const unsignedInt& pageWrap_attr(){

            return type: \unsignedInt\nname: \m_pageWrap_attr\n;
        
        }
        bool has_pageOverThenDown_attr(){

            return m_has_pageOverThenDown_attr;
        
        }
        void set_pageOverThenDown_attr(const boolean& _pageOverThenDown_attr ){

        m_has_pageOverThenDown_attr = true;
        m_pageOverThenDown_attr = _pageOverThenDown_attr;
        
        }
        const boolean& pageOverThenDown_attr(){

            return type: oolean\nname: \m_pageOverThenDown_attr\n;
        
        }
        bool has_subtotalHiddenItems_attr(){

            return m_has_subtotalHiddenItems_attr;
        
        }
        void set_subtotalHiddenItems_attr(const boolean& _subtotalHiddenItems_attr ){

        m_has_subtotalHiddenItems_attr = true;
        m_subtotalHiddenItems_attr = _subtotalHiddenItems_attr;
        
        }
        const boolean& subtotalHiddenItems_attr(){

            return type: oolean\nname: \m_subtotalHiddenItems_attr\n;
        
        }
        bool has_rowGrandTotals_attr(){

            return m_has_rowGrandTotals_attr;
        
        }
        void set_rowGrandTotals_attr(const boolean& _rowGrandTotals_attr ){

        m_has_rowGrandTotals_attr = true;
        m_rowGrandTotals_attr = _rowGrandTotals_attr;
        
        }
        const boolean& rowGrandTotals_attr(){

            return type: oolean\nname: \m_rowGrandTotals_attr\n;
        
        }
        bool has_colGrandTotals_attr(){

            return m_has_colGrandTotals_attr;
        
        }
        void set_colGrandTotals_attr(const boolean& _colGrandTotals_attr ){

        m_has_colGrandTotals_attr = true;
        m_colGrandTotals_attr = _colGrandTotals_attr;
        
        }
        const boolean& colGrandTotals_attr(){

            return type: oolean\nname: \m_colGrandTotals_attr\n;
        
        }
        bool has_fieldPrintTitles_attr(){

            return m_has_fieldPrintTitles_attr;
        
        }
        void set_fieldPrintTitles_attr(const boolean& _fieldPrintTitles_attr ){

        m_has_fieldPrintTitles_attr = true;
        m_fieldPrintTitles_attr = _fieldPrintTitles_attr;
        
        }
        const boolean& fieldPrintTitles_attr(){

            return type: oolean\nname: \m_fieldPrintTitles_attr\n;
        
        }
        bool has_itemPrintTitles_attr(){

            return m_has_itemPrintTitles_attr;
        
        }
        void set_itemPrintTitles_attr(const boolean& _itemPrintTitles_attr ){

        m_has_itemPrintTitles_attr = true;
        m_itemPrintTitles_attr = _itemPrintTitles_attr;
        
        }
        const boolean& itemPrintTitles_attr(){

            return type: oolean\nname: \m_itemPrintTitles_attr\n;
        
        }
        bool has_mergeItem_attr(){

            return m_has_mergeItem_attr;
        
        }
        void set_mergeItem_attr(const boolean& _mergeItem_attr ){

        m_has_mergeItem_attr = true;
        m_mergeItem_attr = _mergeItem_attr;
        
        }
        const boolean& mergeItem_attr(){

            return type: oolean\nname: \m_mergeItem_attr\n;
        
        }
        bool has_showDropZones_attr(){

            return m_has_showDropZones_attr;
        
        }
        void set_showDropZones_attr(const boolean& _showDropZones_attr ){

        m_has_showDropZones_attr = true;
        m_showDropZones_attr = _showDropZones_attr;
        
        }
        const boolean& showDropZones_attr(){

            return type: oolean\nname: \m_showDropZones_attr\n;
        
        }
        bool has_createdVersion_attr(){

            return m_has_createdVersion_attr;
        
        }
        void set_createdVersion_attr(const unsignedByte& _createdVersion_attr ){

        m_has_createdVersion_attr = true;
        m_createdVersion_attr = _createdVersion_attr;
        
        }
        const unsignedByte& createdVersion_attr(){

            return type: \unsignedByte\nname: \m_createdVersion_attr\n;
        
        }
        bool has_indent_attr(){

            return m_has_indent_attr;
        
        }
        void set_indent_attr(const unsignedInt& _indent_attr ){

        m_has_indent_attr = true;
        m_indent_attr = _indent_attr;
        
        }
        const unsignedInt& indent_attr(){

            return type: \unsignedInt\nname: \m_indent_attr\n;
        
        }
        bool has_showEmptyRow_attr(){

            return m_has_showEmptyRow_attr;
        
        }
        void set_showEmptyRow_attr(const boolean& _showEmptyRow_attr ){

        m_has_showEmptyRow_attr = true;
        m_showEmptyRow_attr = _showEmptyRow_attr;
        
        }
        const boolean& showEmptyRow_attr(){

            return type: oolean\nname: \m_showEmptyRow_attr\n;
        
        }
        bool has_showEmptyCol_attr(){

            return m_has_showEmptyCol_attr;
        
        }
        void set_showEmptyCol_attr(const boolean& _showEmptyCol_attr ){

        m_has_showEmptyCol_attr = true;
        m_showEmptyCol_attr = _showEmptyCol_attr;
        
        }
        const boolean& showEmptyCol_attr(){

            return type: oolean\nname: \m_showEmptyCol_attr\n;
        
        }
        bool has_showHeaders_attr(){

            return m_has_showHeaders_attr;
        
        }
        void set_showHeaders_attr(const boolean& _showHeaders_attr ){

        m_has_showHeaders_attr = true;
        m_showHeaders_attr = _showHeaders_attr;
        
        }
        const boolean& showHeaders_attr(){

            return type: oolean\nname: \m_showHeaders_attr\n;
        
        }
        bool has_compact_attr(){

            return m_has_compact_attr;
        
        }
        void set_compact_attr(const boolean& _compact_attr ){

        m_has_compact_attr = true;
        m_compact_attr = _compact_attr;
        
        }
        const boolean& compact_attr(){

            return type: oolean\nname: \m_compact_attr\n;
        
        }
        bool has_outline_attr(){

            return m_has_outline_attr;
        
        }
        void set_outline_attr(const boolean& _outline_attr ){

        m_has_outline_attr = true;
        m_outline_attr = _outline_attr;
        
        }
        const boolean& outline_attr(){

            return type: oolean\nname: \m_outline_attr\n;
        
        }
        bool has_outlineData_attr(){

            return m_has_outlineData_attr;
        
        }
        void set_outlineData_attr(const boolean& _outlineData_attr ){

        m_has_outlineData_attr = true;
        m_outlineData_attr = _outlineData_attr;
        
        }
        const boolean& outlineData_attr(){

            return type: oolean\nname: \m_outlineData_attr\n;
        
        }
        bool has_compactData_attr(){

            return m_has_compactData_attr;
        
        }
        void set_compactData_attr(const boolean& _compactData_attr ){

        m_has_compactData_attr = true;
        m_compactData_attr = _compactData_attr;
        
        }
        const boolean& compactData_attr(){

            return type: oolean\nname: \m_compactData_attr\n;
        
        }
        bool has_published_attr(){

            return m_has_published_attr;
        
        }
        void set_published_attr(const boolean& _published_attr ){

        m_has_published_attr = true;
        m_published_attr = _published_attr;
        
        }
        const boolean& published_attr(){

            return type: oolean\nname: \m_published_attr\n;
        
        }
        bool has_gridDropZones_attr(){

            return m_has_gridDropZones_attr;
        
        }
        void set_gridDropZones_attr(const boolean& _gridDropZones_attr ){

        m_has_gridDropZones_attr = true;
        m_gridDropZones_attr = _gridDropZones_attr;
        
        }
        const boolean& gridDropZones_attr(){

            return type: oolean\nname: \m_gridDropZones_attr\n;
        
        }
        bool has_immersive_attr(){

            return m_has_immersive_attr;
        
        }
        void set_immersive_attr(const boolean& _immersive_attr ){

        m_has_immersive_attr = true;
        m_immersive_attr = _immersive_attr;
        
        }
        const boolean& immersive_attr(){

            return type: oolean\nname: \m_immersive_attr\n;
        
        }
        bool has_multipleFieldFilters_attr(){

            return m_has_multipleFieldFilters_attr;
        
        }
        void set_multipleFieldFilters_attr(const boolean& _multipleFieldFilters_attr ){

        m_has_multipleFieldFilters_attr = true;
        m_multipleFieldFilters_attr = _multipleFieldFilters_attr;
        
        }
        const boolean& multipleFieldFilters_attr(){

            return type: oolean\nname: \m_multipleFieldFilters_attr\n;
        
        }
        bool has_chartFormat_attr(){

            return m_has_chartFormat_attr;
        
        }
        void set_chartFormat_attr(const unsignedInt& _chartFormat_attr ){

        m_has_chartFormat_attr = true;
        m_chartFormat_attr = _chartFormat_attr;
        
        }
        const unsignedInt& chartFormat_attr(){

            return type: \unsignedInt\nname: \m_chartFormat_attr\n;
        
        }
        bool has_rowHeaderCaption_attr(){

            return m_has_rowHeaderCaption_attr;
        
        }
        void set_rowHeaderCaption_attr(const ns_s::ST_Xstring& _rowHeaderCaption_attr ){

            m_has_rowHeaderCaption_attr = true;
            m_rowHeaderCaption_attr = new ns_s::ST_Xstring(_rowHeaderCaption_attr);
        
        }
        const ns_s::ST_Xstring& rowHeaderCaption_attr(){

            if (m_rowHeaderCaption_attr)
            {
                return *m_rowHeaderCaption_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_colHeaderCaption_attr(){

            return m_has_colHeaderCaption_attr;
        
        }
        void set_colHeaderCaption_attr(const ns_s::ST_Xstring& _colHeaderCaption_attr ){

            m_has_colHeaderCaption_attr = true;
            m_colHeaderCaption_attr = new ns_s::ST_Xstring(_colHeaderCaption_attr);
        
        }
        const ns_s::ST_Xstring& colHeaderCaption_attr(){

            if (m_colHeaderCaption_attr)
            {
                return *m_colHeaderCaption_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_fieldListSortAscending_attr(){

            return m_has_fieldListSortAscending_attr;
        
        }
        void set_fieldListSortAscending_attr(const boolean& _fieldListSortAscending_attr ){

        m_has_fieldListSortAscending_attr = true;
        m_fieldListSortAscending_attr = _fieldListSortAscending_attr;
        
        }
        const boolean& fieldListSortAscending_attr(){

            return type: oolean\nname: \m_fieldListSortAscending_attr\n;
        
        }
        bool has_mdxSubqueries_attr(){

            return m_has_mdxSubqueries_attr;
        
        }
        void set_mdxSubqueries_attr(const boolean& _mdxSubqueries_attr ){

        m_has_mdxSubqueries_attr = true;
        m_mdxSubqueries_attr = _mdxSubqueries_attr;
        
        }
        const boolean& mdxSubqueries_attr(){

            return type: oolean\nname: \m_mdxSubqueries_attr\n;
        
        }
        bool has_customListSort_attr(){

            return m_has_customListSort_attr;
        
        }
        void set_customListSort_attr(const boolean& _customListSort_attr ){

        m_has_customListSort_attr = true;
        m_customListSort_attr = _customListSort_attr;
        
        }
        const boolean& customListSort_attr(){

            return type: oolean\nname: \m_customListSort_attr\n;
        
        }

    private:
        bool m_has_location ;
        CT_Location* m_location ;
        bool m_has_pivotFields ;
        CT_PivotFields* m_pivotFields ;
        bool m_has_rowFields ;
        CT_RowFields* m_rowFields ;
        bool m_has_rowItems ;
        CT_rowItems* m_rowItems ;
        bool m_has_colFields ;
        CT_ColFields* m_colFields ;
        bool m_has_colItems ;
        CT_colItems* m_colItems ;
        bool m_has_pageFields ;
        CT_PageFields* m_pageFields ;
        bool m_has_dataFields ;
        CT_DataFields* m_dataFields ;
        bool m_has_formats ;
        CT_Formats* m_formats ;
        bool m_has_conditionalFormats ;
        CT_ConditionalFormats* m_conditionalFormats ;
        bool m_has_chartFormats ;
        CT_ChartFormats* m_chartFormats ;
        bool m_has_pivotHierarchies ;
        CT_PivotHierarchies* m_pivotHierarchies ;
        bool m_has_pivotTableStyleInfo ;
        CT_PivotTableStyle* m_pivotTableStyleInfo ;
        bool m_has_filters ;
        CT_PivotFilters* m_filters ;
        bool m_has_rowHierarchiesUsage ;
        CT_RowHierarchiesUsage* m_rowHierarchiesUsage ;
        bool m_has_colHierarchiesUsage ;
        CT_ColHierarchiesUsage* m_colHierarchiesUsage ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_pivotTableDefinition* default_instance_ ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;
        bool m_has_cacheId_attr ;
        unsignedInt m_cacheId_attr ;
        bool m_has_dataOnRows_attr ;
        boolean m_dataOnRows_attr ;
        bool m_has_dataPosition_attr ;
        unsignedInt m_dataPosition_attr ;
        bool m_has_autoFormatId_attr ;
        unsignedInt m_autoFormatId_attr ;
        bool m_has_applyNumberFormats_attr ;
        boolean m_applyNumberFormats_attr ;
        bool m_has_applyBorderFormats_attr ;
        boolean m_applyBorderFormats_attr ;
        bool m_has_applyFontFormats_attr ;
        boolean m_applyFontFormats_attr ;
        bool m_has_applyPatternFormats_attr ;
        boolean m_applyPatternFormats_attr ;
        bool m_has_applyAlignmentFormats_attr ;
        boolean m_applyAlignmentFormats_attr ;
        bool m_has_applyWidthHeightFormats_attr ;
        boolean m_applyWidthHeightFormats_attr ;
        bool m_has_dataCaption_attr ;
        ns_s::ST_Xstring* m_dataCaption_attr ;
        bool m_has_grandTotalCaption_attr ;
        ns_s::ST_Xstring* m_grandTotalCaption_attr ;
        bool m_has_errorCaption_attr ;
        ns_s::ST_Xstring* m_errorCaption_attr ;
        bool m_has_showError_attr ;
        boolean m_showError_attr ;
        bool m_has_missingCaption_attr ;
        ns_s::ST_Xstring* m_missingCaption_attr ;
        bool m_has_showMissing_attr ;
        boolean m_showMissing_attr ;
        bool m_has_pageStyle_attr ;
        ns_s::ST_Xstring* m_pageStyle_attr ;
        bool m_has_pivotTableStyle_attr ;
        ns_s::ST_Xstring* m_pivotTableStyle_attr ;
        bool m_has_vacatedStyle_attr ;
        ns_s::ST_Xstring* m_vacatedStyle_attr ;
        bool m_has_tag_attr ;
        ns_s::ST_Xstring* m_tag_attr ;
        bool m_has_updatedVersion_attr ;
        unsignedByte m_updatedVersion_attr ;
        bool m_has_minRefreshableVersion_attr ;
        unsignedByte m_minRefreshableVersion_attr ;
        bool m_has_asteriskTotals_attr ;
        boolean m_asteriskTotals_attr ;
        bool m_has_showItems_attr ;
        boolean m_showItems_attr ;
        bool m_has_editData_attr ;
        boolean m_editData_attr ;
        bool m_has_disableFieldList_attr ;
        boolean m_disableFieldList_attr ;
        bool m_has_showCalcMbrs_attr ;
        boolean m_showCalcMbrs_attr ;
        bool m_has_visualTotals_attr ;
        boolean m_visualTotals_attr ;
        bool m_has_showMultipleLabel_attr ;
        boolean m_showMultipleLabel_attr ;
        bool m_has_showDataDropDown_attr ;
        boolean m_showDataDropDown_attr ;
        bool m_has_showDrill_attr ;
        boolean m_showDrill_attr ;
        bool m_has_printDrill_attr ;
        boolean m_printDrill_attr ;
        bool m_has_showMemberPropertyTips_attr ;
        boolean m_showMemberPropertyTips_attr ;
        bool m_has_showDataTips_attr ;
        boolean m_showDataTips_attr ;
        bool m_has_enableWizard_attr ;
        boolean m_enableWizard_attr ;
        bool m_has_enableDrill_attr ;
        boolean m_enableDrill_attr ;
        bool m_has_enableFieldProperties_attr ;
        boolean m_enableFieldProperties_attr ;
        bool m_has_preserveFormatting_attr ;
        boolean m_preserveFormatting_attr ;
        bool m_has_useAutoFormatting_attr ;
        boolean m_useAutoFormatting_attr ;
        bool m_has_pageWrap_attr ;
        unsignedInt m_pageWrap_attr ;
        bool m_has_pageOverThenDown_attr ;
        boolean m_pageOverThenDown_attr ;
        bool m_has_subtotalHiddenItems_attr ;
        boolean m_subtotalHiddenItems_attr ;
        bool m_has_rowGrandTotals_attr ;
        boolean m_rowGrandTotals_attr ;
        bool m_has_colGrandTotals_attr ;
        boolean m_colGrandTotals_attr ;
        bool m_has_fieldPrintTitles_attr ;
        boolean m_fieldPrintTitles_attr ;
        bool m_has_itemPrintTitles_attr ;
        boolean m_itemPrintTitles_attr ;
        bool m_has_mergeItem_attr ;
        boolean m_mergeItem_attr ;
        bool m_has_showDropZones_attr ;
        boolean m_showDropZones_attr ;
        bool m_has_createdVersion_attr ;
        unsignedByte m_createdVersion_attr ;
        bool m_has_indent_attr ;
        unsignedInt m_indent_attr ;
        bool m_has_showEmptyRow_attr ;
        boolean m_showEmptyRow_attr ;
        bool m_has_showEmptyCol_attr ;
        boolean m_showEmptyCol_attr ;
        bool m_has_showHeaders_attr ;
        boolean m_showHeaders_attr ;
        bool m_has_compact_attr ;
        boolean m_compact_attr ;
        bool m_has_outline_attr ;
        boolean m_outline_attr ;
        bool m_has_outlineData_attr ;
        boolean m_outlineData_attr ;
        bool m_has_compactData_attr ;
        boolean m_compactData_attr ;
        bool m_has_published_attr ;
        boolean m_published_attr ;
        bool m_has_gridDropZones_attr ;
        boolean m_gridDropZones_attr ;
        bool m_has_immersive_attr ;
        boolean m_immersive_attr ;
        bool m_has_multipleFieldFilters_attr ;
        boolean m_multipleFieldFilters_attr ;
        bool m_has_chartFormat_attr ;
        unsignedInt m_chartFormat_attr ;
        bool m_has_rowHeaderCaption_attr ;
        ns_s::ST_Xstring* m_rowHeaderCaption_attr ;
        bool m_has_colHeaderCaption_attr ;
        ns_s::ST_Xstring* m_colHeaderCaption_attr ;
        bool m_has_fieldListSortAscending_attr ;
        boolean m_fieldListSortAscending_attr ;
        bool m_has_mdxSubqueries_attr ;
        boolean m_mdxSubqueries_attr ;
        bool m_has_customListSort_attr ;
        boolean m_customListSort_attr ;

    }

    class CT_Location : public XSD::ComplexType{
    public:
        void clear(){

                m_has_ref_attr = false;
                
        if (m_ref_attr)
        {
            delete m_ref_attr;
            m_ref_attr = NULL;
        }
    
            
                m_has_firstHeaderRow_attr = false;
                m_firstHeaderRow_attr = 0;
            
                m_has_firstDataRow_attr = false;
                m_firstDataRow_attr = 0;
            
                m_has_firstDataCol_attr = false;
                m_firstDataCol_attr = 0;
            
                m_has_rowPageCount_attr = false;
                m_rowPageCount_attr = 0;
            
                m_has_colPageCount_attr = false;
                m_colPageCount_attr = 0;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_ref_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_firstHeaderRow_attr << \\\;
_outStream << _attrName << \=\\ << m_firstDataRow_attr << \\\;
_outStream << _attrName << \=\\ << m_firstDataCol_attr << \\\;
_outStream << _attrName << \=\\ << m_rowPageCount_attr << \\\;
_outStream << _attrName << \=\\ << m_colPageCount_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Location& default_instance(){

    if (!CT_Location::default_instance_)
    {
        CT_Location::default_instance_ = new CT_Location();
    }
    return *CT_Location::default_instance_;

        }
        bool has_ref_attr(){

            return m_has_ref_attr;
        
        }
        void set_ref_attr(const ST_Ref& _ref_attr ){

            m_has_ref_attr = true;
            m_ref_attr = new ST_Ref(_ref_attr);
        
        }
        const ST_Ref& ref_attr(){

            if (m_ref_attr)
            {
                return *m_ref_attr;
            }
            return ST_Ref::default_instance();
        
        }
        bool has_firstHeaderRow_attr(){

            return m_has_firstHeaderRow_attr;
        
        }
        void set_firstHeaderRow_attr(const unsignedInt& _firstHeaderRow_attr ){

        m_has_firstHeaderRow_attr = true;
        m_firstHeaderRow_attr = _firstHeaderRow_attr;
        
        }
        const unsignedInt& firstHeaderRow_attr(){

            return type: \unsignedInt\nname: \m_firstHeaderRow_attr\n;
        
        }
        bool has_firstDataRow_attr(){

            return m_has_firstDataRow_attr;
        
        }
        void set_firstDataRow_attr(const unsignedInt& _firstDataRow_attr ){

        m_has_firstDataRow_attr = true;
        m_firstDataRow_attr = _firstDataRow_attr;
        
        }
        const unsignedInt& firstDataRow_attr(){

            return type: \unsignedInt\nname: \m_firstDataRow_attr\n;
        
        }
        bool has_firstDataCol_attr(){

            return m_has_firstDataCol_attr;
        
        }
        void set_firstDataCol_attr(const unsignedInt& _firstDataCol_attr ){

        m_has_firstDataCol_attr = true;
        m_firstDataCol_attr = _firstDataCol_attr;
        
        }
        const unsignedInt& firstDataCol_attr(){

            return type: \unsignedInt\nname: \m_firstDataCol_attr\n;
        
        }
        bool has_rowPageCount_attr(){

            return m_has_rowPageCount_attr;
        
        }
        void set_rowPageCount_attr(const unsignedInt& _rowPageCount_attr ){

        m_has_rowPageCount_attr = true;
        m_rowPageCount_attr = _rowPageCount_attr;
        
        }
        const unsignedInt& rowPageCount_attr(){

            return type: \unsignedInt\nname: \m_rowPageCount_attr\n;
        
        }
        bool has_colPageCount_attr(){

            return m_has_colPageCount_attr;
        
        }
        void set_colPageCount_attr(const unsignedInt& _colPageCount_attr ){

        m_has_colPageCount_attr = true;
        m_colPageCount_attr = _colPageCount_attr;
        
        }
        const unsignedInt& colPageCount_attr(){

            return type: \unsignedInt\nname: \m_colPageCount_attr\n;
        
        }

    private:
        static CT_Location* default_instance_ ;
        bool m_has_ref_attr ;
        ST_Ref* m_ref_attr ;
        bool m_has_firstHeaderRow_attr ;
        unsignedInt m_firstHeaderRow_attr ;
        bool m_has_firstDataRow_attr ;
        unsignedInt m_firstDataRow_attr ;
        bool m_has_firstDataCol_attr ;
        unsignedInt m_firstDataCol_attr ;
        bool m_has_rowPageCount_attr ;
        unsignedInt m_rowPageCount_attr ;
        bool m_has_colPageCount_attr ;
        unsignedInt m_colPageCount_attr ;

    }

    class CT_PivotFields : public XSD::ComplexType{
    public:
        bool has_pivotField(){

            return m_has_pivotField;
        
        }
        CT_PivotField* mutable_pivotField(){

                m_has_pivotField = true;
                if (!m_pivotField)
                {
                    m_pivotField = new CT_PivotField();
                }
                return m_pivotField;
            
        }
        const CT_PivotField& pivotField(){

            if (m_pivotField)
            {
                return *m_pivotField;
            }
            return CT_PivotField::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_pivotField = false;
                
        if (m_pivotField)
        {
            delete m_pivotField;
            m_pivotField = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_pivotField)
                {
                    m_pivotField->toXml(pivotField, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_PivotFields& default_instance(){

    if (!CT_PivotFields::default_instance_)
    {
        CT_PivotFields::default_instance_ = new CT_PivotFields();
    }
    return *CT_PivotFields::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_pivotField ;
        CT_PivotField* m_pivotField ;
        static CT_PivotFields* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_PivotField : public XSD::ComplexType{
    public:
        bool has_items(){

            return m_has_items;
        
        }
        CT_Items* mutable_items(){

                m_has_items = true;
                if (!m_items)
                {
                    m_items = new CT_Items();
                }
                return m_items;
            
        }
        const CT_Items& items(){

            if (m_items)
            {
                return *m_items;
            }
            return CT_Items::default_instance();
        
        }
        bool has_autoSortScope(){

            return m_has_autoSortScope;
        
        }
        CT_AutoSortScope* mutable_autoSortScope(){

                m_has_autoSortScope = true;
                if (!m_autoSortScope)
                {
                    m_autoSortScope = new CT_AutoSortScope();
                }
                return m_autoSortScope;
            
        }
        const CT_AutoSortScope& autoSortScope(){

            if (m_autoSortScope)
            {
                return *m_autoSortScope;
            }
            return CT_AutoSortScope::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
                m_has_axis_attr = false;
                
        if (m_axis_attr)
        {
            delete m_axis_attr;
            m_axis_attr = NULL;
        }
    
            
                m_has_dataField_attr = false;
                m_dataField_attr = false;
            
                m_has_subtotalCaption_attr = false;
                
        if (m_subtotalCaption_attr)
        {
            delete m_subtotalCaption_attr;
            m_subtotalCaption_attr = NULL;
        }
    
            
                m_has_showDropDowns_attr = false;
                m_showDropDowns_attr = false;
            
                m_has_hiddenLevel_attr = false;
                m_hiddenLevel_attr = false;
            
                m_has_uniqueMemberProperty_attr = false;
                
        if (m_uniqueMemberProperty_attr)
        {
            delete m_uniqueMemberProperty_attr;
            m_uniqueMemberProperty_attr = NULL;
        }
    
            
                m_has_compact_attr = false;
                m_compact_attr = false;
            
                m_has_allDrilled_attr = false;
                m_allDrilled_attr = false;
            
                m_has_numFmtId_attr = false;
                
        if (m_numFmtId_attr)
        {
            delete m_numFmtId_attr;
            m_numFmtId_attr = NULL;
        }
    
            
                m_has_outline_attr = false;
                m_outline_attr = false;
            
                m_has_subtotalTop_attr = false;
                m_subtotalTop_attr = false;
            
                m_has_dragToRow_attr = false;
                m_dragToRow_attr = false;
            
                m_has_dragToCol_attr = false;
                m_dragToCol_attr = false;
            
                m_has_multipleItemSelectionAllowed_attr = false;
                m_multipleItemSelectionAllowed_attr = false;
            
                m_has_dragToPage_attr = false;
                m_dragToPage_attr = false;
            
                m_has_dragToData_attr = false;
                m_dragToData_attr = false;
            
                m_has_dragOff_attr = false;
                m_dragOff_attr = false;
            
                m_has_showAll_attr = false;
                m_showAll_attr = false;
            
                m_has_insertBlankRow_attr = false;
                m_insertBlankRow_attr = false;
            
                m_has_serverField_attr = false;
                m_serverField_attr = false;
            
                m_has_insertPageBreak_attr = false;
                m_insertPageBreak_attr = false;
            
                m_has_autoShow_attr = false;
                m_autoShow_attr = false;
            
                m_has_topAutoShow_attr = false;
                m_topAutoShow_attr = false;
            
                m_has_hideNewItems_attr = false;
                m_hideNewItems_attr = false;
            
                m_has_measureFilter_attr = false;
                m_measureFilter_attr = false;
            
                m_has_includeNewItemsInFilter_attr = false;
                m_includeNewItemsInFilter_attr = false;
            
                m_has_itemPageCount_attr = false;
                m_itemPageCount_attr = 0;
            
                m_has_sortType_attr = false;
                
        if (m_sortType_attr)
        {
            delete m_sortType_attr;
            m_sortType_attr = NULL;
        }
    
            
                m_has_dataSourceSort_attr = false;
                m_dataSourceSort_attr = false;
            
                m_has_nonAutoSortDefault_attr = false;
                m_nonAutoSortDefault_attr = false;
            
                m_has_rankBy_attr = false;
                m_rankBy_attr = 0;
            
                m_has_defaultSubtotal_attr = false;
                m_defaultSubtotal_attr = false;
            
                m_has_sumSubtotal_attr = false;
                m_sumSubtotal_attr = false;
            
                m_has_countASubtotal_attr = false;
                m_countASubtotal_attr = false;
            
                m_has_avgSubtotal_attr = false;
                m_avgSubtotal_attr = false;
            
                m_has_maxSubtotal_attr = false;
                m_maxSubtotal_attr = false;
            
                m_has_minSubtotal_attr = false;
                m_minSubtotal_attr = false;
            
                m_has_productSubtotal_attr = false;
                m_productSubtotal_attr = false;
            
                m_has_countSubtotal_attr = false;
                m_countSubtotal_attr = false;
            
                m_has_stdDevSubtotal_attr = false;
                m_stdDevSubtotal_attr = false;
            
                m_has_stdDevPSubtotal_attr = false;
                m_stdDevPSubtotal_attr = false;
            
                m_has_varSubtotal_attr = false;
                m_varSubtotal_attr = false;
            
                m_has_varPSubtotal_attr = false;
                m_varPSubtotal_attr = false;
            
                m_has_showPropCell_attr = false;
                m_showPropCell_attr = false;
            
                m_has_showPropTip_attr = false;
                m_showPropTip_attr = false;
            
                m_has_showPropAsCaption_attr = false;
                m_showPropAsCaption_attr = false;
            
                m_has_defaultAttributeDrillState_attr = false;
                m_defaultAttributeDrillState_attr = false;
            
                m_has_items = false;
                
        if (m_items)
        {
            delete m_items;
            m_items = NULL;
        }
    
            
                m_has_autoSortScope = false;
                
        if (m_autoSortScope)
        {
            delete m_autoSortScope;
            m_autoSortScope = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_name_attr->toXml(_attrName, _outStream);
m_axis_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_dataField_attr) << \\\;
m_subtotalCaption_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showDropDowns_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_hiddenLevel_attr) << \\\;
m_uniqueMemberProperty_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_compact_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_allDrilled_attr) << \\\;
m_numFmtId_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_outline_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_subtotalTop_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_dragToRow_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_dragToCol_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_multipleItemSelectionAllowed_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_dragToPage_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_dragToData_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_dragOff_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showAll_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_insertBlankRow_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_serverField_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_insertPageBreak_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_autoShow_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_topAutoShow_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_hideNewItems_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_measureFilter_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_includeNewItemsInFilter_attr) << \\\;
_outStream << _attrName << \=\\ << m_itemPageCount_attr << \\\;
m_sortType_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_dataSourceSort_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_nonAutoSortDefault_attr) << \\\;
_outStream << _attrName << \=\\ << m_rankBy_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_defaultSubtotal_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_sumSubtotal_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_countASubtotal_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_avgSubtotal_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_maxSubtotal_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_minSubtotal_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_productSubtotal_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_countSubtotal_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_stdDevSubtotal_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_stdDevPSubtotal_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_varSubtotal_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_varPSubtotal_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showPropCell_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showPropTip_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showPropAsCaption_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_defaultAttributeDrillState_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_items)
                {
                    m_items->toXml(items, _outStream);;
                }
            
                if (m_has_autoSortScope)
                {
                    m_items->toXml(autoSortScope, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_items->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_PivotField& default_instance(){

    if (!CT_PivotField::default_instance_)
    {
        CT_PivotField::default_instance_ = new CT_PivotField();
    }
    return *CT_PivotField::default_instance_;

        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_axis_attr(){

            return m_has_axis_attr;
        
        }
        void set_axis_attr(const ST_Axis& _axis_attr ){

            m_has_axis_attr = true;
            m_axis_attr = new ST_Axis(_axis_attr);
        
        }
        const ST_Axis& axis_attr(){

            if (m_axis_attr)
            {
                return *m_axis_attr;
            }
            return ST_Axis::default_instance();
        
        }
        bool has_dataField_attr(){

            return m_has_dataField_attr;
        
        }
        void set_dataField_attr(const boolean& _dataField_attr ){

        m_has_dataField_attr = true;
        m_dataField_attr = _dataField_attr;
        
        }
        const boolean& dataField_attr(){

            return type: oolean\nname: \m_dataField_attr\n;
        
        }
        bool has_subtotalCaption_attr(){

            return m_has_subtotalCaption_attr;
        
        }
        void set_subtotalCaption_attr(const ns_s::ST_Xstring& _subtotalCaption_attr ){

            m_has_subtotalCaption_attr = true;
            m_subtotalCaption_attr = new ns_s::ST_Xstring(_subtotalCaption_attr);
        
        }
        const ns_s::ST_Xstring& subtotalCaption_attr(){

            if (m_subtotalCaption_attr)
            {
                return *m_subtotalCaption_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_showDropDowns_attr(){

            return m_has_showDropDowns_attr;
        
        }
        void set_showDropDowns_attr(const boolean& _showDropDowns_attr ){

        m_has_showDropDowns_attr = true;
        m_showDropDowns_attr = _showDropDowns_attr;
        
        }
        const boolean& showDropDowns_attr(){

            return type: oolean\nname: \m_showDropDowns_attr\n;
        
        }
        bool has_hiddenLevel_attr(){

            return m_has_hiddenLevel_attr;
        
        }
        void set_hiddenLevel_attr(const boolean& _hiddenLevel_attr ){

        m_has_hiddenLevel_attr = true;
        m_hiddenLevel_attr = _hiddenLevel_attr;
        
        }
        const boolean& hiddenLevel_attr(){

            return type: oolean\nname: \m_hiddenLevel_attr\n;
        
        }
        bool has_uniqueMemberProperty_attr(){

            return m_has_uniqueMemberProperty_attr;
        
        }
        void set_uniqueMemberProperty_attr(const ns_s::ST_Xstring& _uniqueMemberProperty_attr ){

            m_has_uniqueMemberProperty_attr = true;
            m_uniqueMemberProperty_attr = new ns_s::ST_Xstring(_uniqueMemberProperty_attr);
        
        }
        const ns_s::ST_Xstring& uniqueMemberProperty_attr(){

            if (m_uniqueMemberProperty_attr)
            {
                return *m_uniqueMemberProperty_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_compact_attr(){

            return m_has_compact_attr;
        
        }
        void set_compact_attr(const boolean& _compact_attr ){

        m_has_compact_attr = true;
        m_compact_attr = _compact_attr;
        
        }
        const boolean& compact_attr(){

            return type: oolean\nname: \m_compact_attr\n;
        
        }
        bool has_allDrilled_attr(){

            return m_has_allDrilled_attr;
        
        }
        void set_allDrilled_attr(const boolean& _allDrilled_attr ){

        m_has_allDrilled_attr = true;
        m_allDrilled_attr = _allDrilled_attr;
        
        }
        const boolean& allDrilled_attr(){

            return type: oolean\nname: \m_allDrilled_attr\n;
        
        }
        bool has_numFmtId_attr(){

            return m_has_numFmtId_attr;
        
        }
        void set_numFmtId_attr(const ST_NumFmtId& _numFmtId_attr ){

            m_has_numFmtId_attr = true;
            m_numFmtId_attr = new ST_NumFmtId(_numFmtId_attr);
        
        }
        const ST_NumFmtId& numFmtId_attr(){

            if (m_numFmtId_attr)
            {
                return *m_numFmtId_attr;
            }
            return ST_NumFmtId::default_instance();
        
        }
        bool has_outline_attr(){

            return m_has_outline_attr;
        
        }
        void set_outline_attr(const boolean& _outline_attr ){

        m_has_outline_attr = true;
        m_outline_attr = _outline_attr;
        
        }
        const boolean& outline_attr(){

            return type: oolean\nname: \m_outline_attr\n;
        
        }
        bool has_subtotalTop_attr(){

            return m_has_subtotalTop_attr;
        
        }
        void set_subtotalTop_attr(const boolean& _subtotalTop_attr ){

        m_has_subtotalTop_attr = true;
        m_subtotalTop_attr = _subtotalTop_attr;
        
        }
        const boolean& subtotalTop_attr(){

            return type: oolean\nname: \m_subtotalTop_attr\n;
        
        }
        bool has_dragToRow_attr(){

            return m_has_dragToRow_attr;
        
        }
        void set_dragToRow_attr(const boolean& _dragToRow_attr ){

        m_has_dragToRow_attr = true;
        m_dragToRow_attr = _dragToRow_attr;
        
        }
        const boolean& dragToRow_attr(){

            return type: oolean\nname: \m_dragToRow_attr\n;
        
        }
        bool has_dragToCol_attr(){

            return m_has_dragToCol_attr;
        
        }
        void set_dragToCol_attr(const boolean& _dragToCol_attr ){

        m_has_dragToCol_attr = true;
        m_dragToCol_attr = _dragToCol_attr;
        
        }
        const boolean& dragToCol_attr(){

            return type: oolean\nname: \m_dragToCol_attr\n;
        
        }
        bool has_multipleItemSelectionAllowed_attr(){

            return m_has_multipleItemSelectionAllowed_attr;
        
        }
        void set_multipleItemSelectionAllowed_attr(const boolean& _multipleItemSelectionAllowed_attr ){

        m_has_multipleItemSelectionAllowed_attr = true;
        m_multipleItemSelectionAllowed_attr = _multipleItemSelectionAllowed_attr;
        
        }
        const boolean& multipleItemSelectionAllowed_attr(){

            return type: oolean\nname: \m_multipleItemSelectionAllowed_attr\n;
        
        }
        bool has_dragToPage_attr(){

            return m_has_dragToPage_attr;
        
        }
        void set_dragToPage_attr(const boolean& _dragToPage_attr ){

        m_has_dragToPage_attr = true;
        m_dragToPage_attr = _dragToPage_attr;
        
        }
        const boolean& dragToPage_attr(){

            return type: oolean\nname: \m_dragToPage_attr\n;
        
        }
        bool has_dragToData_attr(){

            return m_has_dragToData_attr;
        
        }
        void set_dragToData_attr(const boolean& _dragToData_attr ){

        m_has_dragToData_attr = true;
        m_dragToData_attr = _dragToData_attr;
        
        }
        const boolean& dragToData_attr(){

            return type: oolean\nname: \m_dragToData_attr\n;
        
        }
        bool has_dragOff_attr(){

            return m_has_dragOff_attr;
        
        }
        void set_dragOff_attr(const boolean& _dragOff_attr ){

        m_has_dragOff_attr = true;
        m_dragOff_attr = _dragOff_attr;
        
        }
        const boolean& dragOff_attr(){

            return type: oolean\nname: \m_dragOff_attr\n;
        
        }
        bool has_showAll_attr(){

            return m_has_showAll_attr;
        
        }
        void set_showAll_attr(const boolean& _showAll_attr ){

        m_has_showAll_attr = true;
        m_showAll_attr = _showAll_attr;
        
        }
        const boolean& showAll_attr(){

            return type: oolean\nname: \m_showAll_attr\n;
        
        }
        bool has_insertBlankRow_attr(){

            return m_has_insertBlankRow_attr;
        
        }
        void set_insertBlankRow_attr(const boolean& _insertBlankRow_attr ){

        m_has_insertBlankRow_attr = true;
        m_insertBlankRow_attr = _insertBlankRow_attr;
        
        }
        const boolean& insertBlankRow_attr(){

            return type: oolean\nname: \m_insertBlankRow_attr\n;
        
        }
        bool has_serverField_attr(){

            return m_has_serverField_attr;
        
        }
        void set_serverField_attr(const boolean& _serverField_attr ){

        m_has_serverField_attr = true;
        m_serverField_attr = _serverField_attr;
        
        }
        const boolean& serverField_attr(){

            return type: oolean\nname: \m_serverField_attr\n;
        
        }
        bool has_insertPageBreak_attr(){

            return m_has_insertPageBreak_attr;
        
        }
        void set_insertPageBreak_attr(const boolean& _insertPageBreak_attr ){

        m_has_insertPageBreak_attr = true;
        m_insertPageBreak_attr = _insertPageBreak_attr;
        
        }
        const boolean& insertPageBreak_attr(){

            return type: oolean\nname: \m_insertPageBreak_attr\n;
        
        }
        bool has_autoShow_attr(){

            return m_has_autoShow_attr;
        
        }
        void set_autoShow_attr(const boolean& _autoShow_attr ){

        m_has_autoShow_attr = true;
        m_autoShow_attr = _autoShow_attr;
        
        }
        const boolean& autoShow_attr(){

            return type: oolean\nname: \m_autoShow_attr\n;
        
        }
        bool has_topAutoShow_attr(){

            return m_has_topAutoShow_attr;
        
        }
        void set_topAutoShow_attr(const boolean& _topAutoShow_attr ){

        m_has_topAutoShow_attr = true;
        m_topAutoShow_attr = _topAutoShow_attr;
        
        }
        const boolean& topAutoShow_attr(){

            return type: oolean\nname: \m_topAutoShow_attr\n;
        
        }
        bool has_hideNewItems_attr(){

            return m_has_hideNewItems_attr;
        
        }
        void set_hideNewItems_attr(const boolean& _hideNewItems_attr ){

        m_has_hideNewItems_attr = true;
        m_hideNewItems_attr = _hideNewItems_attr;
        
        }
        const boolean& hideNewItems_attr(){

            return type: oolean\nname: \m_hideNewItems_attr\n;
        
        }
        bool has_measureFilter_attr(){

            return m_has_measureFilter_attr;
        
        }
        void set_measureFilter_attr(const boolean& _measureFilter_attr ){

        m_has_measureFilter_attr = true;
        m_measureFilter_attr = _measureFilter_attr;
        
        }
        const boolean& measureFilter_attr(){

            return type: oolean\nname: \m_measureFilter_attr\n;
        
        }
        bool has_includeNewItemsInFilter_attr(){

            return m_has_includeNewItemsInFilter_attr;
        
        }
        void set_includeNewItemsInFilter_attr(const boolean& _includeNewItemsInFilter_attr ){

        m_has_includeNewItemsInFilter_attr = true;
        m_includeNewItemsInFilter_attr = _includeNewItemsInFilter_attr;
        
        }
        const boolean& includeNewItemsInFilter_attr(){

            return type: oolean\nname: \m_includeNewItemsInFilter_attr\n;
        
        }
        bool has_itemPageCount_attr(){

            return m_has_itemPageCount_attr;
        
        }
        void set_itemPageCount_attr(const unsignedInt& _itemPageCount_attr ){

        m_has_itemPageCount_attr = true;
        m_itemPageCount_attr = _itemPageCount_attr;
        
        }
        const unsignedInt& itemPageCount_attr(){

            return type: \unsignedInt\nname: \m_itemPageCount_attr\n;
        
        }
        bool has_sortType_attr(){

            return m_has_sortType_attr;
        
        }
        void set_sortType_attr(const ST_FieldSortType& _sortType_attr ){

            m_has_sortType_attr = true;
            m_sortType_attr = new ST_FieldSortType(_sortType_attr);
        
        }
        const ST_FieldSortType& sortType_attr(){

            if (m_sortType_attr)
            {
                return *m_sortType_attr;
            }
            return ST_FieldSortType::default_instance();
        
        }
        bool has_dataSourceSort_attr(){

            return m_has_dataSourceSort_attr;
        
        }
        void set_dataSourceSort_attr(const boolean& _dataSourceSort_attr ){

        m_has_dataSourceSort_attr = true;
        m_dataSourceSort_attr = _dataSourceSort_attr;
        
        }
        const boolean& dataSourceSort_attr(){

            return type: oolean\nname: \m_dataSourceSort_attr\n;
        
        }
        bool has_nonAutoSortDefault_attr(){

            return m_has_nonAutoSortDefault_attr;
        
        }
        void set_nonAutoSortDefault_attr(const boolean& _nonAutoSortDefault_attr ){

        m_has_nonAutoSortDefault_attr = true;
        m_nonAutoSortDefault_attr = _nonAutoSortDefault_attr;
        
        }
        const boolean& nonAutoSortDefault_attr(){

            return type: oolean\nname: \m_nonAutoSortDefault_attr\n;
        
        }
        bool has_rankBy_attr(){

            return m_has_rankBy_attr;
        
        }
        void set_rankBy_attr(const unsignedInt& _rankBy_attr ){

        m_has_rankBy_attr = true;
        m_rankBy_attr = _rankBy_attr;
        
        }
        const unsignedInt& rankBy_attr(){

            return type: \unsignedInt\nname: \m_rankBy_attr\n;
        
        }
        bool has_defaultSubtotal_attr(){

            return m_has_defaultSubtotal_attr;
        
        }
        void set_defaultSubtotal_attr(const boolean& _defaultSubtotal_attr ){

        m_has_defaultSubtotal_attr = true;
        m_defaultSubtotal_attr = _defaultSubtotal_attr;
        
        }
        const boolean& defaultSubtotal_attr(){

            return type: oolean\nname: \m_defaultSubtotal_attr\n;
        
        }
        bool has_sumSubtotal_attr(){

            return m_has_sumSubtotal_attr;
        
        }
        void set_sumSubtotal_attr(const boolean& _sumSubtotal_attr ){

        m_has_sumSubtotal_attr = true;
        m_sumSubtotal_attr = _sumSubtotal_attr;
        
        }
        const boolean& sumSubtotal_attr(){

            return type: oolean\nname: \m_sumSubtotal_attr\n;
        
        }
        bool has_countASubtotal_attr(){

            return m_has_countASubtotal_attr;
        
        }
        void set_countASubtotal_attr(const boolean& _countASubtotal_attr ){

        m_has_countASubtotal_attr = true;
        m_countASubtotal_attr = _countASubtotal_attr;
        
        }
        const boolean& countASubtotal_attr(){

            return type: oolean\nname: \m_countASubtotal_attr\n;
        
        }
        bool has_avgSubtotal_attr(){

            return m_has_avgSubtotal_attr;
        
        }
        void set_avgSubtotal_attr(const boolean& _avgSubtotal_attr ){

        m_has_avgSubtotal_attr = true;
        m_avgSubtotal_attr = _avgSubtotal_attr;
        
        }
        const boolean& avgSubtotal_attr(){

            return type: oolean\nname: \m_avgSubtotal_attr\n;
        
        }
        bool has_maxSubtotal_attr(){

            return m_has_maxSubtotal_attr;
        
        }
        void set_maxSubtotal_attr(const boolean& _maxSubtotal_attr ){

        m_has_maxSubtotal_attr = true;
        m_maxSubtotal_attr = _maxSubtotal_attr;
        
        }
        const boolean& maxSubtotal_attr(){

            return type: oolean\nname: \m_maxSubtotal_attr\n;
        
        }
        bool has_minSubtotal_attr(){

            return m_has_minSubtotal_attr;
        
        }
        void set_minSubtotal_attr(const boolean& _minSubtotal_attr ){

        m_has_minSubtotal_attr = true;
        m_minSubtotal_attr = _minSubtotal_attr;
        
        }
        const boolean& minSubtotal_attr(){

            return type: oolean\nname: \m_minSubtotal_attr\n;
        
        }
        bool has_productSubtotal_attr(){

            return m_has_productSubtotal_attr;
        
        }
        void set_productSubtotal_attr(const boolean& _productSubtotal_attr ){

        m_has_productSubtotal_attr = true;
        m_productSubtotal_attr = _productSubtotal_attr;
        
        }
        const boolean& productSubtotal_attr(){

            return type: oolean\nname: \m_productSubtotal_attr\n;
        
        }
        bool has_countSubtotal_attr(){

            return m_has_countSubtotal_attr;
        
        }
        void set_countSubtotal_attr(const boolean& _countSubtotal_attr ){

        m_has_countSubtotal_attr = true;
        m_countSubtotal_attr = _countSubtotal_attr;
        
        }
        const boolean& countSubtotal_attr(){

            return type: oolean\nname: \m_countSubtotal_attr\n;
        
        }
        bool has_stdDevSubtotal_attr(){

            return m_has_stdDevSubtotal_attr;
        
        }
        void set_stdDevSubtotal_attr(const boolean& _stdDevSubtotal_attr ){

        m_has_stdDevSubtotal_attr = true;
        m_stdDevSubtotal_attr = _stdDevSubtotal_attr;
        
        }
        const boolean& stdDevSubtotal_attr(){

            return type: oolean\nname: \m_stdDevSubtotal_attr\n;
        
        }
        bool has_stdDevPSubtotal_attr(){

            return m_has_stdDevPSubtotal_attr;
        
        }
        void set_stdDevPSubtotal_attr(const boolean& _stdDevPSubtotal_attr ){

        m_has_stdDevPSubtotal_attr = true;
        m_stdDevPSubtotal_attr = _stdDevPSubtotal_attr;
        
        }
        const boolean& stdDevPSubtotal_attr(){

            return type: oolean\nname: \m_stdDevPSubtotal_attr\n;
        
        }
        bool has_varSubtotal_attr(){

            return m_has_varSubtotal_attr;
        
        }
        void set_varSubtotal_attr(const boolean& _varSubtotal_attr ){

        m_has_varSubtotal_attr = true;
        m_varSubtotal_attr = _varSubtotal_attr;
        
        }
        const boolean& varSubtotal_attr(){

            return type: oolean\nname: \m_varSubtotal_attr\n;
        
        }
        bool has_varPSubtotal_attr(){

            return m_has_varPSubtotal_attr;
        
        }
        void set_varPSubtotal_attr(const boolean& _varPSubtotal_attr ){

        m_has_varPSubtotal_attr = true;
        m_varPSubtotal_attr = _varPSubtotal_attr;
        
        }
        const boolean& varPSubtotal_attr(){

            return type: oolean\nname: \m_varPSubtotal_attr\n;
        
        }
        bool has_showPropCell_attr(){

            return m_has_showPropCell_attr;
        
        }
        void set_showPropCell_attr(const boolean& _showPropCell_attr ){

        m_has_showPropCell_attr = true;
        m_showPropCell_attr = _showPropCell_attr;
        
        }
        const boolean& showPropCell_attr(){

            return type: oolean\nname: \m_showPropCell_attr\n;
        
        }
        bool has_showPropTip_attr(){

            return m_has_showPropTip_attr;
        
        }
        void set_showPropTip_attr(const boolean& _showPropTip_attr ){

        m_has_showPropTip_attr = true;
        m_showPropTip_attr = _showPropTip_attr;
        
        }
        const boolean& showPropTip_attr(){

            return type: oolean\nname: \m_showPropTip_attr\n;
        
        }
        bool has_showPropAsCaption_attr(){

            return m_has_showPropAsCaption_attr;
        
        }
        void set_showPropAsCaption_attr(const boolean& _showPropAsCaption_attr ){

        m_has_showPropAsCaption_attr = true;
        m_showPropAsCaption_attr = _showPropAsCaption_attr;
        
        }
        const boolean& showPropAsCaption_attr(){

            return type: oolean\nname: \m_showPropAsCaption_attr\n;
        
        }
        bool has_defaultAttributeDrillState_attr(){

            return m_has_defaultAttributeDrillState_attr;
        
        }
        void set_defaultAttributeDrillState_attr(const boolean& _defaultAttributeDrillState_attr ){

        m_has_defaultAttributeDrillState_attr = true;
        m_defaultAttributeDrillState_attr = _defaultAttributeDrillState_attr;
        
        }
        const boolean& defaultAttributeDrillState_attr(){

            return type: oolean\nname: \m_defaultAttributeDrillState_attr\n;
        
        }

    private:
        bool m_has_items ;
        CT_Items* m_items ;
        bool m_has_autoSortScope ;
        CT_AutoSortScope* m_autoSortScope ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_PivotField* default_instance_ ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;
        bool m_has_axis_attr ;
        ST_Axis* m_axis_attr ;
        bool m_has_dataField_attr ;
        boolean m_dataField_attr ;
        bool m_has_subtotalCaption_attr ;
        ns_s::ST_Xstring* m_subtotalCaption_attr ;
        bool m_has_showDropDowns_attr ;
        boolean m_showDropDowns_attr ;
        bool m_has_hiddenLevel_attr ;
        boolean m_hiddenLevel_attr ;
        bool m_has_uniqueMemberProperty_attr ;
        ns_s::ST_Xstring* m_uniqueMemberProperty_attr ;
        bool m_has_compact_attr ;
        boolean m_compact_attr ;
        bool m_has_allDrilled_attr ;
        boolean m_allDrilled_attr ;
        bool m_has_numFmtId_attr ;
        ST_NumFmtId* m_numFmtId_attr ;
        bool m_has_outline_attr ;
        boolean m_outline_attr ;
        bool m_has_subtotalTop_attr ;
        boolean m_subtotalTop_attr ;
        bool m_has_dragToRow_attr ;
        boolean m_dragToRow_attr ;
        bool m_has_dragToCol_attr ;
        boolean m_dragToCol_attr ;
        bool m_has_multipleItemSelectionAllowed_attr ;
        boolean m_multipleItemSelectionAllowed_attr ;
        bool m_has_dragToPage_attr ;
        boolean m_dragToPage_attr ;
        bool m_has_dragToData_attr ;
        boolean m_dragToData_attr ;
        bool m_has_dragOff_attr ;
        boolean m_dragOff_attr ;
        bool m_has_showAll_attr ;
        boolean m_showAll_attr ;
        bool m_has_insertBlankRow_attr ;
        boolean m_insertBlankRow_attr ;
        bool m_has_serverField_attr ;
        boolean m_serverField_attr ;
        bool m_has_insertPageBreak_attr ;
        boolean m_insertPageBreak_attr ;
        bool m_has_autoShow_attr ;
        boolean m_autoShow_attr ;
        bool m_has_topAutoShow_attr ;
        boolean m_topAutoShow_attr ;
        bool m_has_hideNewItems_attr ;
        boolean m_hideNewItems_attr ;
        bool m_has_measureFilter_attr ;
        boolean m_measureFilter_attr ;
        bool m_has_includeNewItemsInFilter_attr ;
        boolean m_includeNewItemsInFilter_attr ;
        bool m_has_itemPageCount_attr ;
        unsignedInt m_itemPageCount_attr ;
        bool m_has_sortType_attr ;
        ST_FieldSortType* m_sortType_attr ;
        bool m_has_dataSourceSort_attr ;
        boolean m_dataSourceSort_attr ;
        bool m_has_nonAutoSortDefault_attr ;
        boolean m_nonAutoSortDefault_attr ;
        bool m_has_rankBy_attr ;
        unsignedInt m_rankBy_attr ;
        bool m_has_defaultSubtotal_attr ;
        boolean m_defaultSubtotal_attr ;
        bool m_has_sumSubtotal_attr ;
        boolean m_sumSubtotal_attr ;
        bool m_has_countASubtotal_attr ;
        boolean m_countASubtotal_attr ;
        bool m_has_avgSubtotal_attr ;
        boolean m_avgSubtotal_attr ;
        bool m_has_maxSubtotal_attr ;
        boolean m_maxSubtotal_attr ;
        bool m_has_minSubtotal_attr ;
        boolean m_minSubtotal_attr ;
        bool m_has_productSubtotal_attr ;
        boolean m_productSubtotal_attr ;
        bool m_has_countSubtotal_attr ;
        boolean m_countSubtotal_attr ;
        bool m_has_stdDevSubtotal_attr ;
        boolean m_stdDevSubtotal_attr ;
        bool m_has_stdDevPSubtotal_attr ;
        boolean m_stdDevPSubtotal_attr ;
        bool m_has_varSubtotal_attr ;
        boolean m_varSubtotal_attr ;
        bool m_has_varPSubtotal_attr ;
        boolean m_varPSubtotal_attr ;
        bool m_has_showPropCell_attr ;
        boolean m_showPropCell_attr ;
        bool m_has_showPropTip_attr ;
        boolean m_showPropTip_attr ;
        bool m_has_showPropAsCaption_attr ;
        boolean m_showPropAsCaption_attr ;
        bool m_has_defaultAttributeDrillState_attr ;
        boolean m_defaultAttributeDrillState_attr ;

    }

    class CT_AutoSortScope : public XSD::ComplexType{
    public:
        bool has_pivotArea(){

            return m_has_pivotArea;
        
        }
        CT_PivotArea* mutable_pivotArea(){

                m_has_pivotArea = true;
                if (!m_pivotArea)
                {
                    m_pivotArea = new CT_PivotArea();
                }
                return m_pivotArea;
            
        }
        const CT_PivotArea& pivotArea(){

            if (m_pivotArea)
            {
                return *m_pivotArea;
            }
            return CT_PivotArea::default_instance();
        
        }
        void clear(){

                m_has_pivotArea = false;
                
        if (m_pivotArea)
        {
            delete m_pivotArea;
            m_pivotArea = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_pivotArea)
                {
                    m_pivotArea->toXml(pivotArea, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_AutoSortScope& default_instance(){

    if (!CT_AutoSortScope::default_instance_)
    {
        CT_AutoSortScope::default_instance_ = new CT_AutoSortScope();
    }
    return *CT_AutoSortScope::default_instance_;

        }

    private:
        bool m_has_pivotArea ;
        CT_PivotArea* m_pivotArea ;
        static CT_AutoSortScope* default_instance_ ;

    }

    class CT_Items : public XSD::ComplexType{
    public:
        bool has_item(){

            return m_has_item;
        
        }
        CT_Item* mutable_item(){

                m_has_item = true;
                if (!m_item)
                {
                    m_item = new CT_Item();
                }
                return m_item;
            
        }
        const CT_Item& item(){

            if (m_item)
            {
                return *m_item;
            }
            return CT_Item::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_item = false;
                
        if (m_item)
        {
            delete m_item;
            m_item = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_item)
                {
                    m_item->toXml(item, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Items& default_instance(){

    if (!CT_Items::default_instance_)
    {
        CT_Items::default_instance_ = new CT_Items();
    }
    return *CT_Items::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_item ;
        CT_Item* m_item ;
        static CT_Items* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_Item : public XSD::ComplexType{
    public:
        void clear(){

                m_has_n_attr = false;
                
        if (m_n_attr)
        {
            delete m_n_attr;
            m_n_attr = NULL;
        }
    
            
                m_has_t_attr = false;
                
        if (m_t_attr)
        {
            delete m_t_attr;
            m_t_attr = NULL;
        }
    
            
                m_has_h_attr = false;
                m_h_attr = false;
            
                m_has_s_attr = false;
                m_s_attr = false;
            
                m_has_sd_attr = false;
                m_sd_attr = false;
            
                m_has_f_attr = false;
                m_f_attr = false;
            
                m_has_m_attr = false;
                m_m_attr = false;
            
                m_has_c_attr = false;
                m_c_attr = false;
            
                m_has_x_attr = false;
                m_x_attr = 0;
            
                m_has_d_attr = false;
                m_d_attr = false;
            
                m_has_e_attr = false;
                m_e_attr = false;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_n_attr->toXml(_attrName, _outStream);
m_t_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_h_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_s_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_sd_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_f_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_m_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_c_attr) << \\\;
_outStream << _attrName << \=\\ << m_x_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_d_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_e_attr) << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Item& default_instance(){

    if (!CT_Item::default_instance_)
    {
        CT_Item::default_instance_ = new CT_Item();
    }
    return *CT_Item::default_instance_;

        }
        bool has_n_attr(){

            return m_has_n_attr;
        
        }
        void set_n_attr(const ns_s::ST_Xstring& _n_attr ){

            m_has_n_attr = true;
            m_n_attr = new ns_s::ST_Xstring(_n_attr);
        
        }
        const ns_s::ST_Xstring& n_attr(){

            if (m_n_attr)
            {
                return *m_n_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_t_attr(){

            return m_has_t_attr;
        
        }
        void set_t_attr(const ST_ItemType& _t_attr ){

            m_has_t_attr = true;
            m_t_attr = new ST_ItemType(_t_attr);
        
        }
        const ST_ItemType& t_attr(){

            if (m_t_attr)
            {
                return *m_t_attr;
            }
            return ST_ItemType::default_instance();
        
        }
        bool has_h_attr(){

            return m_has_h_attr;
        
        }
        void set_h_attr(const boolean& _h_attr ){

        m_has_h_attr = true;
        m_h_attr = _h_attr;
        
        }
        const boolean& h_attr(){

            return type: oolean\nname: \m_h_attr\n;
        
        }
        bool has_s_attr(){

            return m_has_s_attr;
        
        }
        void set_s_attr(const boolean& _s_attr ){

        m_has_s_attr = true;
        m_s_attr = _s_attr;
        
        }
        const boolean& s_attr(){

            return type: oolean\nname: \m_s_attr\n;
        
        }
        bool has_sd_attr(){

            return m_has_sd_attr;
        
        }
        void set_sd_attr(const boolean& _sd_attr ){

        m_has_sd_attr = true;
        m_sd_attr = _sd_attr;
        
        }
        const boolean& sd_attr(){

            return type: oolean\nname: \m_sd_attr\n;
        
        }
        bool has_f_attr(){

            return m_has_f_attr;
        
        }
        void set_f_attr(const boolean& _f_attr ){

        m_has_f_attr = true;
        m_f_attr = _f_attr;
        
        }
        const boolean& f_attr(){

            return type: oolean\nname: \m_f_attr\n;
        
        }
        bool has_m_attr(){

            return m_has_m_attr;
        
        }
        void set_m_attr(const boolean& _m_attr ){

        m_has_m_attr = true;
        m_m_attr = _m_attr;
        
        }
        const boolean& m_attr(){

            return type: oolean\nname: \m_m_attr\n;
        
        }
        bool has_c_attr(){

            return m_has_c_attr;
        
        }
        void set_c_attr(const boolean& _c_attr ){

        m_has_c_attr = true;
        m_c_attr = _c_attr;
        
        }
        const boolean& c_attr(){

            return type: oolean\nname: \m_c_attr\n;
        
        }
        bool has_x_attr(){

            return m_has_x_attr;
        
        }
        void set_x_attr(const unsignedInt& _x_attr ){

        m_has_x_attr = true;
        m_x_attr = _x_attr;
        
        }
        const unsignedInt& x_attr(){

            return type: \unsignedInt\nname: \m_x_attr\n;
        
        }
        bool has_d_attr(){

            return m_has_d_attr;
        
        }
        void set_d_attr(const boolean& _d_attr ){

        m_has_d_attr = true;
        m_d_attr = _d_attr;
        
        }
        const boolean& d_attr(){

            return type: oolean\nname: \m_d_attr\n;
        
        }
        bool has_e_attr(){

            return m_has_e_attr;
        
        }
        void set_e_attr(const boolean& _e_attr ){

        m_has_e_attr = true;
        m_e_attr = _e_attr;
        
        }
        const boolean& e_attr(){

            return type: oolean\nname: \m_e_attr\n;
        
        }

    private:
        static CT_Item* default_instance_ ;
        bool m_has_n_attr ;
        ns_s::ST_Xstring* m_n_attr ;
        bool m_has_t_attr ;
        ST_ItemType* m_t_attr ;
        bool m_has_h_attr ;
        boolean m_h_attr ;
        bool m_has_s_attr ;
        boolean m_s_attr ;
        bool m_has_sd_attr ;
        boolean m_sd_attr ;
        bool m_has_f_attr ;
        boolean m_f_attr ;
        bool m_has_m_attr ;
        boolean m_m_attr ;
        bool m_has_c_attr ;
        boolean m_c_attr ;
        bool m_has_x_attr ;
        unsignedInt m_x_attr ;
        bool m_has_d_attr ;
        boolean m_d_attr ;
        bool m_has_e_attr ;
        boolean m_e_attr ;

    }

    class CT_PageFields : public XSD::ComplexType{
    public:
        bool has_pageField(){

            return m_has_pageField;
        
        }
        CT_PageField* mutable_pageField(){

                m_has_pageField = true;
                if (!m_pageField)
                {
                    m_pageField = new CT_PageField();
                }
                return m_pageField;
            
        }
        const CT_PageField& pageField(){

            if (m_pageField)
            {
                return *m_pageField;
            }
            return CT_PageField::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_pageField = false;
                
        if (m_pageField)
        {
            delete m_pageField;
            m_pageField = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_pageField)
                {
                    m_pageField->toXml(pageField, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_PageFields& default_instance(){

    if (!CT_PageFields::default_instance_)
    {
        CT_PageFields::default_instance_ = new CT_PageFields();
    }
    return *CT_PageFields::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_pageField ;
        CT_PageField* m_pageField ;
        static CT_PageFields* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_PageField : public XSD::ComplexType{
    public:
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_fld_attr = false;
                m_fld_attr = 0;
            
                m_has_item_attr = false;
                m_item_attr = 0;
            
                m_has_hier_attr = false;
                m_hier_attr = 0;
            
                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
                m_has_cap_attr = false;
                
        if (m_cap_attr)
        {
            delete m_cap_attr;
            m_cap_attr = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_fld_attr << \\\;
_outStream << _attrName << \=\\ << m_item_attr << \\\;
_outStream << _attrName << \=\\ << m_hier_attr << \\\;
m_name_attr->toXml(_attrName, _outStream);
m_cap_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_extLst)
                {
                    m_extLst->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_PageField& default_instance(){

    if (!CT_PageField::default_instance_)
    {
        CT_PageField::default_instance_ = new CT_PageField();
    }
    return *CT_PageField::default_instance_;

        }
        bool has_fld_attr(){

            return m_has_fld_attr;
        
        }
        void set_fld_attr(const int& _fld_attr ){

        m_has_fld_attr = true;
        m_fld_attr = _fld_attr;
        
        }
        const int& fld_attr(){

            return type: \int\nname: \m_fld_attr\n;
        
        }
        bool has_item_attr(){

            return m_has_item_attr;
        
        }
        void set_item_attr(const unsignedInt& _item_attr ){

        m_has_item_attr = true;
        m_item_attr = _item_attr;
        
        }
        const unsignedInt& item_attr(){

            return type: \unsignedInt\nname: \m_item_attr\n;
        
        }
        bool has_hier_attr(){

            return m_has_hier_attr;
        
        }
        void set_hier_attr(const int& _hier_attr ){

        m_has_hier_attr = true;
        m_hier_attr = _hier_attr;
        
        }
        const int& hier_attr(){

            return type: \int\nname: \m_hier_attr\n;
        
        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_cap_attr(){

            return m_has_cap_attr;
        
        }
        void set_cap_attr(const ns_s::ST_Xstring& _cap_attr ){

            m_has_cap_attr = true;
            m_cap_attr = new ns_s::ST_Xstring(_cap_attr);
        
        }
        const ns_s::ST_Xstring& cap_attr(){

            if (m_cap_attr)
            {
                return *m_cap_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }

    private:
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_PageField* default_instance_ ;
        bool m_has_fld_attr ;
        int m_fld_attr ;
        bool m_has_item_attr ;
        unsignedInt m_item_attr ;
        bool m_has_hier_attr ;
        int m_hier_attr ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;
        bool m_has_cap_attr ;
        ns_s::ST_Xstring* m_cap_attr ;

    }

    class CT_DataFields : public XSD::ComplexType{
    public:
        bool has_dataField(){

            return m_has_dataField;
        
        }
        CT_DataField* mutable_dataField(){

                m_has_dataField = true;
                if (!m_dataField)
                {
                    m_dataField = new CT_DataField();
                }
                return m_dataField;
            
        }
        const CT_DataField& dataField(){

            if (m_dataField)
            {
                return *m_dataField;
            }
            return CT_DataField::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_dataField = false;
                
        if (m_dataField)
        {
            delete m_dataField;
            m_dataField = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_dataField)
                {
                    m_dataField->toXml(dataField, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_DataFields& default_instance(){

    if (!CT_DataFields::default_instance_)
    {
        CT_DataFields::default_instance_ = new CT_DataFields();
    }
    return *CT_DataFields::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_dataField ;
        CT_DataField* m_dataField ;
        static CT_DataFields* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_DataField : public XSD::ComplexType{
    public:
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
                m_has_fld_attr = false;
                m_fld_attr = 0;
            
                m_has_subtotal_attr = false;
                
        if (m_subtotal_attr)
        {
            delete m_subtotal_attr;
            m_subtotal_attr = NULL;
        }
    
            
                m_has_showDataAs_attr = false;
                
        if (m_showDataAs_attr)
        {
            delete m_showDataAs_attr;
            m_showDataAs_attr = NULL;
        }
    
            
                m_has_baseField_attr = false;
                m_baseField_attr = 0;
            
                m_has_baseItem_attr = false;
                m_baseItem_attr = 0;
            
                m_has_numFmtId_attr = false;
                
        if (m_numFmtId_attr)
        {
            delete m_numFmtId_attr;
            m_numFmtId_attr = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_name_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_fld_attr << \\\;
m_subtotal_attr->toXml(_attrName, _outStream);
m_showDataAs_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_baseField_attr << \\\;
_outStream << _attrName << \=\\ << m_baseItem_attr << \\\;
m_numFmtId_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_extLst)
                {
                    m_extLst->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_DataField& default_instance(){

    if (!CT_DataField::default_instance_)
    {
        CT_DataField::default_instance_ = new CT_DataField();
    }
    return *CT_DataField::default_instance_;

        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_fld_attr(){

            return m_has_fld_attr;
        
        }
        void set_fld_attr(const unsignedInt& _fld_attr ){

        m_has_fld_attr = true;
        m_fld_attr = _fld_attr;
        
        }
        const unsignedInt& fld_attr(){

            return type: \unsignedInt\nname: \m_fld_attr\n;
        
        }
        bool has_subtotal_attr(){

            return m_has_subtotal_attr;
        
        }
        void set_subtotal_attr(const ST_DataConsolidateFunction& _subtotal_attr ){

            m_has_subtotal_attr = true;
            m_subtotal_attr = new ST_DataConsolidateFunction(_subtotal_attr);
        
        }
        const ST_DataConsolidateFunction& subtotal_attr(){

            if (m_subtotal_attr)
            {
                return *m_subtotal_attr;
            }
            return ST_DataConsolidateFunction::default_instance();
        
        }
        bool has_showDataAs_attr(){

            return m_has_showDataAs_attr;
        
        }
        void set_showDataAs_attr(const ST_ShowDataAs& _showDataAs_attr ){

            m_has_showDataAs_attr = true;
            m_showDataAs_attr = new ST_ShowDataAs(_showDataAs_attr);
        
        }
        const ST_ShowDataAs& showDataAs_attr(){

            if (m_showDataAs_attr)
            {
                return *m_showDataAs_attr;
            }
            return ST_ShowDataAs::default_instance();
        
        }
        bool has_baseField_attr(){

            return m_has_baseField_attr;
        
        }
        void set_baseField_attr(const int& _baseField_attr ){

        m_has_baseField_attr = true;
        m_baseField_attr = _baseField_attr;
        
        }
        const int& baseField_attr(){

            return type: \int\nname: \m_baseField_attr\n;
        
        }
        bool has_baseItem_attr(){

            return m_has_baseItem_attr;
        
        }
        void set_baseItem_attr(const unsignedInt& _baseItem_attr ){

        m_has_baseItem_attr = true;
        m_baseItem_attr = _baseItem_attr;
        
        }
        const unsignedInt& baseItem_attr(){

            return type: \unsignedInt\nname: \m_baseItem_attr\n;
        
        }
        bool has_numFmtId_attr(){

            return m_has_numFmtId_attr;
        
        }
        void set_numFmtId_attr(const ST_NumFmtId& _numFmtId_attr ){

            m_has_numFmtId_attr = true;
            m_numFmtId_attr = new ST_NumFmtId(_numFmtId_attr);
        
        }
        const ST_NumFmtId& numFmtId_attr(){

            if (m_numFmtId_attr)
            {
                return *m_numFmtId_attr;
            }
            return ST_NumFmtId::default_instance();
        
        }

    private:
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_DataField* default_instance_ ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;
        bool m_has_fld_attr ;
        unsignedInt m_fld_attr ;
        bool m_has_subtotal_attr ;
        ST_DataConsolidateFunction* m_subtotal_attr ;
        bool m_has_showDataAs_attr ;
        ST_ShowDataAs* m_showDataAs_attr ;
        bool m_has_baseField_attr ;
        int m_baseField_attr ;
        bool m_has_baseItem_attr ;
        unsignedInt m_baseItem_attr ;
        bool m_has_numFmtId_attr ;
        ST_NumFmtId* m_numFmtId_attr ;

    }

    class CT_rowItems : public XSD::ComplexType{
    public:
        bool has_i(){

            return m_has_i;
        
        }
        CT_I* mutable_i(){

                m_has_i = true;
                if (!m_i)
                {
                    m_i = new CT_I();
                }
                return m_i;
            
        }
        const CT_I& i(){

            if (m_i)
            {
                return *m_i;
            }
            return CT_I::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_i = false;
                
        if (m_i)
        {
            delete m_i;
            m_i = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_i)
                {
                    m_i->toXml(i, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_rowItems& default_instance(){

    if (!CT_rowItems::default_instance_)
    {
        CT_rowItems::default_instance_ = new CT_rowItems();
    }
    return *CT_rowItems::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_i ;
        CT_I* m_i ;
        static CT_rowItems* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_colItems : public XSD::ComplexType{
    public:
        bool has_i(){

            return m_has_i;
        
        }
        CT_I* mutable_i(){

                m_has_i = true;
                if (!m_i)
                {
                    m_i = new CT_I();
                }
                return m_i;
            
        }
        const CT_I& i(){

            if (m_i)
            {
                return *m_i;
            }
            return CT_I::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_i = false;
                
        if (m_i)
        {
            delete m_i;
            m_i = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_i)
                {
                    m_i->toXml(i, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_colItems& default_instance(){

    if (!CT_colItems::default_instance_)
    {
        CT_colItems::default_instance_ = new CT_colItems();
    }
    return *CT_colItems::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_i ;
        CT_I* m_i ;
        static CT_colItems* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_I : public XSD::ComplexType{
    public:
        bool has_x(){

            return m_has_x;
        
        }
        CT_X* mutable_x(){

                m_has_x = true;
                if (!m_x)
                {
                    m_x = new CT_X();
                }
                return m_x;
            
        }
        const CT_X& x(){

            if (m_x)
            {
                return *m_x;
            }
            return CT_X::default_instance();
        
        }
        void clear(){

                m_has_t_attr = false;
                
        if (m_t_attr)
        {
            delete m_t_attr;
            m_t_attr = NULL;
        }
    
            
                m_has_r_attr = false;
                m_r_attr = 0;
            
                m_has_i_attr = false;
                m_i_attr = 0;
            
                m_has_x = false;
                
        if (m_x)
        {
            delete m_x;
            m_x = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_t_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_r_attr << \\\;
_outStream << _attrName << \=\\ << m_i_attr << \\\;
        _outStream << \>\;
    
                if (m_has_x)
                {
                    m_x->toXml(x, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_I& default_instance(){

    if (!CT_I::default_instance_)
    {
        CT_I::default_instance_ = new CT_I();
    }
    return *CT_I::default_instance_;

        }
        bool has_t_attr(){

            return m_has_t_attr;
        
        }
        void set_t_attr(const ST_ItemType& _t_attr ){

            m_has_t_attr = true;
            m_t_attr = new ST_ItemType(_t_attr);
        
        }
        const ST_ItemType& t_attr(){

            if (m_t_attr)
            {
                return *m_t_attr;
            }
            return ST_ItemType::default_instance();
        
        }
        bool has_r_attr(){

            return m_has_r_attr;
        
        }
        void set_r_attr(const unsignedInt& _r_attr ){

        m_has_r_attr = true;
        m_r_attr = _r_attr;
        
        }
        const unsignedInt& r_attr(){

            return type: \unsignedInt\nname: \m_r_attr\n;
        
        }
        bool has_i_attr(){

            return m_has_i_attr;
        
        }
        void set_i_attr(const unsignedInt& _i_attr ){

        m_has_i_attr = true;
        m_i_attr = _i_attr;
        
        }
        const unsignedInt& i_attr(){

            return type: \unsignedInt\nname: \m_i_attr\n;
        
        }

    private:
        bool m_has_x ;
        CT_X* m_x ;
        static CT_I* default_instance_ ;
        bool m_has_t_attr ;
        ST_ItemType* m_t_attr ;
        bool m_has_r_attr ;
        unsignedInt m_r_attr ;
        bool m_has_i_attr ;
        unsignedInt m_i_attr ;

    }

    class CT_X : public XSD::ComplexType{
    public:
        void clear(){

                m_has_v_attr = false;
                m_v_attr = 0;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_v_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_X& default_instance(){

    if (!CT_X::default_instance_)
    {
        CT_X::default_instance_ = new CT_X();
    }
    return *CT_X::default_instance_;

        }
        bool has_v_attr(){

            return m_has_v_attr;
        
        }
        void set_v_attr(const int& _v_attr ){

        m_has_v_attr = true;
        m_v_attr = _v_attr;
        
        }
        const int& v_attr(){

            return type: \int\nname: \m_v_attr\n;
        
        }

    private:
        static CT_X* default_instance_ ;
        bool m_has_v_attr ;
        int m_v_attr ;

    }

    class CT_RowFields : public XSD::ComplexType{
    public:
        bool has_field(){

            return m_has_field;
        
        }
        CT_Field* mutable_field(){

                m_has_field = true;
                if (!m_field)
                {
                    m_field = new CT_Field();
                }
                return m_field;
            
        }
        const CT_Field& field(){

            if (m_field)
            {
                return *m_field;
            }
            return CT_Field::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_field = false;
                
        if (m_field)
        {
            delete m_field;
            m_field = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_field)
                {
                    m_field->toXml(field, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_RowFields& default_instance(){

    if (!CT_RowFields::default_instance_)
    {
        CT_RowFields::default_instance_ = new CT_RowFields();
    }
    return *CT_RowFields::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_field ;
        CT_Field* m_field ;
        static CT_RowFields* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_ColFields : public XSD::ComplexType{
    public:
        bool has_field(){

            return m_has_field;
        
        }
        CT_Field* mutable_field(){

                m_has_field = true;
                if (!m_field)
                {
                    m_field = new CT_Field();
                }
                return m_field;
            
        }
        const CT_Field& field(){

            if (m_field)
            {
                return *m_field;
            }
            return CT_Field::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_field = false;
                
        if (m_field)
        {
            delete m_field;
            m_field = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_field)
                {
                    m_field->toXml(field, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_ColFields& default_instance(){

    if (!CT_ColFields::default_instance_)
    {
        CT_ColFields::default_instance_ = new CT_ColFields();
    }
    return *CT_ColFields::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_field ;
        CT_Field* m_field ;
        static CT_ColFields* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_Field : public XSD::ComplexType{
    public:
        void clear(){

                m_has_x_attr = false;
                m_x_attr = 0;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_x_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Field& default_instance(){

    if (!CT_Field::default_instance_)
    {
        CT_Field::default_instance_ = new CT_Field();
    }
    return *CT_Field::default_instance_;

        }
        bool has_x_attr(){

            return m_has_x_attr;
        
        }
        void set_x_attr(const int& _x_attr ){

        m_has_x_attr = true;
        m_x_attr = _x_attr;
        
        }
        const int& x_attr(){

            return type: \int\nname: \m_x_attr\n;
        
        }

    private:
        static CT_Field* default_instance_ ;
        bool m_has_x_attr ;
        int m_x_attr ;

    }

    class CT_Formats : public XSD::ComplexType{
    public:
        bool has_format(){

            return m_has_format;
        
        }
        CT_Format* mutable_format(){

                m_has_format = true;
                if (!m_format)
                {
                    m_format = new CT_Format();
                }
                return m_format;
            
        }
        const CT_Format& format(){

            if (m_format)
            {
                return *m_format;
            }
            return CT_Format::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_format = false;
                
        if (m_format)
        {
            delete m_format;
            m_format = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_format)
                {
                    m_format->toXml(format, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Formats& default_instance(){

    if (!CT_Formats::default_instance_)
    {
        CT_Formats::default_instance_ = new CT_Formats();
    }
    return *CT_Formats::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_format ;
        CT_Format* m_format ;
        static CT_Formats* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_Format : public XSD::ComplexType{
    public:
        bool has_pivotArea(){

            return m_has_pivotArea;
        
        }
        CT_PivotArea* mutable_pivotArea(){

                m_has_pivotArea = true;
                if (!m_pivotArea)
                {
                    m_pivotArea = new CT_PivotArea();
                }
                return m_pivotArea;
            
        }
        const CT_PivotArea& pivotArea(){

            if (m_pivotArea)
            {
                return *m_pivotArea;
            }
            return CT_PivotArea::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_action_attr = false;
                
        if (m_action_attr)
        {
            delete m_action_attr;
            m_action_attr = NULL;
        }
    
            
                m_has_dxfId_attr = false;
                
        if (m_dxfId_attr)
        {
            delete m_dxfId_attr;
            m_dxfId_attr = NULL;
        }
    
            
                m_has_pivotArea = false;
                
        if (m_pivotArea)
        {
            delete m_pivotArea;
            m_pivotArea = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_action_attr->toXml(_attrName, _outStream);
m_dxfId_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_pivotArea)
                {
                    m_pivotArea->toXml(pivotArea, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_pivotArea->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Format& default_instance(){

    if (!CT_Format::default_instance_)
    {
        CT_Format::default_instance_ = new CT_Format();
    }
    return *CT_Format::default_instance_;

        }
        bool has_action_attr(){

            return m_has_action_attr;
        
        }
        void set_action_attr(const ST_FormatAction& _action_attr ){

            m_has_action_attr = true;
            m_action_attr = new ST_FormatAction(_action_attr);
        
        }
        const ST_FormatAction& action_attr(){

            if (m_action_attr)
            {
                return *m_action_attr;
            }
            return ST_FormatAction::default_instance();
        
        }
        bool has_dxfId_attr(){

            return m_has_dxfId_attr;
        
        }
        void set_dxfId_attr(const ST_DxfId& _dxfId_attr ){

            m_has_dxfId_attr = true;
            m_dxfId_attr = new ST_DxfId(_dxfId_attr);
        
        }
        const ST_DxfId& dxfId_attr(){

            if (m_dxfId_attr)
            {
                return *m_dxfId_attr;
            }
            return ST_DxfId::default_instance();
        
        }

    private:
        bool m_has_pivotArea ;
        CT_PivotArea* m_pivotArea ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_Format* default_instance_ ;
        bool m_has_action_attr ;
        ST_FormatAction* m_action_attr ;
        bool m_has_dxfId_attr ;
        ST_DxfId* m_dxfId_attr ;

    }

    class CT_ConditionalFormats : public XSD::ComplexType{
    public:
        bool has_conditionalFormat(){

            return m_has_conditionalFormat;
        
        }
        CT_ConditionalFormat* mutable_conditionalFormat(){

                m_has_conditionalFormat = true;
                if (!m_conditionalFormat)
                {
                    m_conditionalFormat = new CT_ConditionalFormat();
                }
                return m_conditionalFormat;
            
        }
        const CT_ConditionalFormat& conditionalFormat(){

            if (m_conditionalFormat)
            {
                return *m_conditionalFormat;
            }
            return CT_ConditionalFormat::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_conditionalFormat = false;
                
        if (m_conditionalFormat)
        {
            delete m_conditionalFormat;
            m_conditionalFormat = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_conditionalFormat)
                {
                    m_conditionalFormat->toXml(conditionalFormat, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_ConditionalFormats& default_instance(){

    if (!CT_ConditionalFormats::default_instance_)
    {
        CT_ConditionalFormats::default_instance_ = new CT_ConditionalFormats();
    }
    return *CT_ConditionalFormats::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_conditionalFormat ;
        CT_ConditionalFormat* m_conditionalFormat ;
        static CT_ConditionalFormats* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_ConditionalFormat : public XSD::ComplexType{
    public:
        bool has_pivotAreas(){

            return m_has_pivotAreas;
        
        }
        CT_PivotAreas* mutable_pivotAreas(){

                m_has_pivotAreas = true;
                if (!m_pivotAreas)
                {
                    m_pivotAreas = new CT_PivotAreas();
                }
                return m_pivotAreas;
            
        }
        const CT_PivotAreas& pivotAreas(){

            if (m_pivotAreas)
            {
                return *m_pivotAreas;
            }
            return CT_PivotAreas::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_scope_attr = false;
                
        if (m_scope_attr)
        {
            delete m_scope_attr;
            m_scope_attr = NULL;
        }
    
            
                m_has_type_attr = false;
                
        if (m_type_attr)
        {
            delete m_type_attr;
            m_type_attr = NULL;
        }
    
            
                m_has_priority_attr = false;
                m_priority_attr = 0;
            
                m_has_pivotAreas = false;
                
        if (m_pivotAreas)
        {
            delete m_pivotAreas;
            m_pivotAreas = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_scope_attr->toXml(_attrName, _outStream);
m_type_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_priority_attr << \\\;
        _outStream << \>\;
    
                if (m_has_pivotAreas)
                {
                    m_pivotAreas->toXml(pivotAreas, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_pivotAreas->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_ConditionalFormat& default_instance(){

    if (!CT_ConditionalFormat::default_instance_)
    {
        CT_ConditionalFormat::default_instance_ = new CT_ConditionalFormat();
    }
    return *CT_ConditionalFormat::default_instance_;

        }
        bool has_scope_attr(){

            return m_has_scope_attr;
        
        }
        void set_scope_attr(const ST_Scope& _scope_attr ){

            m_has_scope_attr = true;
            m_scope_attr = new ST_Scope(_scope_attr);
        
        }
        const ST_Scope& scope_attr(){

            if (m_scope_attr)
            {
                return *m_scope_attr;
            }
            return ST_Scope::default_instance();
        
        }
        bool has_type_attr(){

            return m_has_type_attr;
        
        }
        void set_type_attr(const ST_Type& _type_attr ){

            m_has_type_attr = true;
            m_type_attr = new ST_Type(_type_attr);
        
        }
        const ST_Type& type_attr(){

            if (m_type_attr)
            {
                return *m_type_attr;
            }
            return ST_Type::default_instance();
        
        }
        bool has_priority_attr(){

            return m_has_priority_attr;
        
        }
        void set_priority_attr(const unsignedInt& _priority_attr ){

        m_has_priority_attr = true;
        m_priority_attr = _priority_attr;
        
        }
        const unsignedInt& priority_attr(){

            return type: \unsignedInt\nname: \m_priority_attr\n;
        
        }

    private:
        bool m_has_pivotAreas ;
        CT_PivotAreas* m_pivotAreas ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_ConditionalFormat* default_instance_ ;
        bool m_has_scope_attr ;
        ST_Scope* m_scope_attr ;
        bool m_has_type_attr ;
        ST_Type* m_type_attr ;
        bool m_has_priority_attr ;
        unsignedInt m_priority_attr ;

    }

    class CT_PivotAreas : public XSD::ComplexType{
    public:
        bool has_pivotArea(){

            return m_has_pivotArea;
        
        }
        CT_PivotArea* mutable_pivotArea(){

                m_has_pivotArea = true;
                if (!m_pivotArea)
                {
                    m_pivotArea = new CT_PivotArea();
                }
                return m_pivotArea;
            
        }
        const CT_PivotArea& pivotArea(){

            if (m_pivotArea)
            {
                return *m_pivotArea;
            }
            return CT_PivotArea::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_pivotArea = false;
                
        if (m_pivotArea)
        {
            delete m_pivotArea;
            m_pivotArea = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_pivotArea)
                {
                    m_pivotArea->toXml(pivotArea, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_PivotAreas& default_instance(){

    if (!CT_PivotAreas::default_instance_)
    {
        CT_PivotAreas::default_instance_ = new CT_PivotAreas();
    }
    return *CT_PivotAreas::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_pivotArea ;
        CT_PivotArea* m_pivotArea ;
        static CT_PivotAreas* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_ChartFormats : public XSD::ComplexType{
    public:
        bool has_chartFormat(){

            return m_has_chartFormat;
        
        }
        CT_ChartFormat* mutable_chartFormat(){

                m_has_chartFormat = true;
                if (!m_chartFormat)
                {
                    m_chartFormat = new CT_ChartFormat();
                }
                return m_chartFormat;
            
        }
        const CT_ChartFormat& chartFormat(){

            if (m_chartFormat)
            {
                return *m_chartFormat;
            }
            return CT_ChartFormat::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_chartFormat = false;
                
        if (m_chartFormat)
        {
            delete m_chartFormat;
            m_chartFormat = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_chartFormat)
                {
                    m_chartFormat->toXml(chartFormat, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_ChartFormats& default_instance(){

    if (!CT_ChartFormats::default_instance_)
    {
        CT_ChartFormats::default_instance_ = new CT_ChartFormats();
    }
    return *CT_ChartFormats::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_chartFormat ;
        CT_ChartFormat* m_chartFormat ;
        static CT_ChartFormats* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_ChartFormat : public XSD::ComplexType{
    public:
        bool has_pivotArea(){

            return m_has_pivotArea;
        
        }
        CT_PivotArea* mutable_pivotArea(){

                m_has_pivotArea = true;
                if (!m_pivotArea)
                {
                    m_pivotArea = new CT_PivotArea();
                }
                return m_pivotArea;
            
        }
        const CT_PivotArea& pivotArea(){

            if (m_pivotArea)
            {
                return *m_pivotArea;
            }
            return CT_PivotArea::default_instance();
        
        }
        void clear(){

                m_has_chart_attr = false;
                m_chart_attr = 0;
            
                m_has_format_attr = false;
                m_format_attr = 0;
            
                m_has_series_attr = false;
                m_series_attr = false;
            
                m_has_pivotArea = false;
                
        if (m_pivotArea)
        {
            delete m_pivotArea;
            m_pivotArea = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_chart_attr << \\\;
_outStream << _attrName << \=\\ << m_format_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_series_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_pivotArea)
                {
                    m_pivotArea->toXml(pivotArea, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_ChartFormat& default_instance(){

    if (!CT_ChartFormat::default_instance_)
    {
        CT_ChartFormat::default_instance_ = new CT_ChartFormat();
    }
    return *CT_ChartFormat::default_instance_;

        }
        bool has_chart_attr(){

            return m_has_chart_attr;
        
        }
        void set_chart_attr(const unsignedInt& _chart_attr ){

        m_has_chart_attr = true;
        m_chart_attr = _chart_attr;
        
        }
        const unsignedInt& chart_attr(){

            return type: \unsignedInt\nname: \m_chart_attr\n;
        
        }
        bool has_format_attr(){

            return m_has_format_attr;
        
        }
        void set_format_attr(const unsignedInt& _format_attr ){

        m_has_format_attr = true;
        m_format_attr = _format_attr;
        
        }
        const unsignedInt& format_attr(){

            return type: \unsignedInt\nname: \m_format_attr\n;
        
        }
        bool has_series_attr(){

            return m_has_series_attr;
        
        }
        void set_series_attr(const boolean& _series_attr ){

        m_has_series_attr = true;
        m_series_attr = _series_attr;
        
        }
        const boolean& series_attr(){

            return type: oolean\nname: \m_series_attr\n;
        
        }

    private:
        bool m_has_pivotArea ;
        CT_PivotArea* m_pivotArea ;
        static CT_ChartFormat* default_instance_ ;
        bool m_has_chart_attr ;
        unsignedInt m_chart_attr ;
        bool m_has_format_attr ;
        unsignedInt m_format_attr ;
        bool m_has_series_attr ;
        boolean m_series_attr ;

    }

    class CT_PivotHierarchies : public XSD::ComplexType{
    public:
        bool has_pivotHierarchy(){

            return m_has_pivotHierarchy;
        
        }
        CT_PivotHierarchy* mutable_pivotHierarchy(){

                m_has_pivotHierarchy = true;
                if (!m_pivotHierarchy)
                {
                    m_pivotHierarchy = new CT_PivotHierarchy();
                }
                return m_pivotHierarchy;
            
        }
        const CT_PivotHierarchy& pivotHierarchy(){

            if (m_pivotHierarchy)
            {
                return *m_pivotHierarchy;
            }
            return CT_PivotHierarchy::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_pivotHierarchy = false;
                
        if (m_pivotHierarchy)
        {
            delete m_pivotHierarchy;
            m_pivotHierarchy = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_pivotHierarchy)
                {
                    m_pivotHierarchy->toXml(pivotHierarchy, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_PivotHierarchies& default_instance(){

    if (!CT_PivotHierarchies::default_instance_)
    {
        CT_PivotHierarchies::default_instance_ = new CT_PivotHierarchies();
    }
    return *CT_PivotHierarchies::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_pivotHierarchy ;
        CT_PivotHierarchy* m_pivotHierarchy ;
        static CT_PivotHierarchies* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_PivotHierarchy : public XSD::ComplexType{
    public:
        bool has_mps(){

            return m_has_mps;
        
        }
        CT_MemberProperties* mutable_mps(){

                m_has_mps = true;
                if (!m_mps)
                {
                    m_mps = new CT_MemberProperties();
                }
                return m_mps;
            
        }
        const CT_MemberProperties& mps(){

            if (m_mps)
            {
                return *m_mps;
            }
            return CT_MemberProperties::default_instance();
        
        }
        bool has_members(){

            return m_has_members;
        
        }
        CT_Members* mutable_members(){

                m_has_members = true;
                if (!m_members)
                {
                    m_members = new CT_Members();
                }
                return m_members;
            
        }
        const CT_Members& members(){

            if (m_members)
            {
                return *m_members;
            }
            return CT_Members::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_outline_attr = false;
                m_outline_attr = false;
            
                m_has_multipleItemSelectionAllowed_attr = false;
                m_multipleItemSelectionAllowed_attr = false;
            
                m_has_subtotalTop_attr = false;
                m_subtotalTop_attr = false;
            
                m_has_showInFieldList_attr = false;
                m_showInFieldList_attr = false;
            
                m_has_dragToRow_attr = false;
                m_dragToRow_attr = false;
            
                m_has_dragToCol_attr = false;
                m_dragToCol_attr = false;
            
                m_has_dragToPage_attr = false;
                m_dragToPage_attr = false;
            
                m_has_dragToData_attr = false;
                m_dragToData_attr = false;
            
                m_has_dragOff_attr = false;
                m_dragOff_attr = false;
            
                m_has_includeNewItemsInFilter_attr = false;
                m_includeNewItemsInFilter_attr = false;
            
                m_has_caption_attr = false;
                
        if (m_caption_attr)
        {
            delete m_caption_attr;
            m_caption_attr = NULL;
        }
    
            
                m_has_mps = false;
                
        if (m_mps)
        {
            delete m_mps;
            m_mps = NULL;
        }
    
            
                m_has_members = false;
                
        if (m_members)
        {
            delete m_members;
            m_members = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_outline_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_multipleItemSelectionAllowed_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_subtotalTop_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showInFieldList_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_dragToRow_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_dragToCol_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_dragToPage_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_dragToData_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_dragOff_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_includeNewItemsInFilter_attr) << \\\;
m_caption_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_mps)
                {
                    m_mps->toXml(mps, _outStream);;
                }
            
                if (m_has_members)
                {
                    m_mps->toXml(members, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_mps->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_PivotHierarchy& default_instance(){

    if (!CT_PivotHierarchy::default_instance_)
    {
        CT_PivotHierarchy::default_instance_ = new CT_PivotHierarchy();
    }
    return *CT_PivotHierarchy::default_instance_;

        }
        bool has_outline_attr(){

            return m_has_outline_attr;
        
        }
        void set_outline_attr(const boolean& _outline_attr ){

        m_has_outline_attr = true;
        m_outline_attr = _outline_attr;
        
        }
        const boolean& outline_attr(){

            return type: oolean\nname: \m_outline_attr\n;
        
        }
        bool has_multipleItemSelectionAllowed_attr(){

            return m_has_multipleItemSelectionAllowed_attr;
        
        }
        void set_multipleItemSelectionAllowed_attr(const boolean& _multipleItemSelectionAllowed_attr ){

        m_has_multipleItemSelectionAllowed_attr = true;
        m_multipleItemSelectionAllowed_attr = _multipleItemSelectionAllowed_attr;
        
        }
        const boolean& multipleItemSelectionAllowed_attr(){

            return type: oolean\nname: \m_multipleItemSelectionAllowed_attr\n;
        
        }
        bool has_subtotalTop_attr(){

            return m_has_subtotalTop_attr;
        
        }
        void set_subtotalTop_attr(const boolean& _subtotalTop_attr ){

        m_has_subtotalTop_attr = true;
        m_subtotalTop_attr = _subtotalTop_attr;
        
        }
        const boolean& subtotalTop_attr(){

            return type: oolean\nname: \m_subtotalTop_attr\n;
        
        }
        bool has_showInFieldList_attr(){

            return m_has_showInFieldList_attr;
        
        }
        void set_showInFieldList_attr(const boolean& _showInFieldList_attr ){

        m_has_showInFieldList_attr = true;
        m_showInFieldList_attr = _showInFieldList_attr;
        
        }
        const boolean& showInFieldList_attr(){

            return type: oolean\nname: \m_showInFieldList_attr\n;
        
        }
        bool has_dragToRow_attr(){

            return m_has_dragToRow_attr;
        
        }
        void set_dragToRow_attr(const boolean& _dragToRow_attr ){

        m_has_dragToRow_attr = true;
        m_dragToRow_attr = _dragToRow_attr;
        
        }
        const boolean& dragToRow_attr(){

            return type: oolean\nname: \m_dragToRow_attr\n;
        
        }
        bool has_dragToCol_attr(){

            return m_has_dragToCol_attr;
        
        }
        void set_dragToCol_attr(const boolean& _dragToCol_attr ){

        m_has_dragToCol_attr = true;
        m_dragToCol_attr = _dragToCol_attr;
        
        }
        const boolean& dragToCol_attr(){

            return type: oolean\nname: \m_dragToCol_attr\n;
        
        }
        bool has_dragToPage_attr(){

            return m_has_dragToPage_attr;
        
        }
        void set_dragToPage_attr(const boolean& _dragToPage_attr ){

        m_has_dragToPage_attr = true;
        m_dragToPage_attr = _dragToPage_attr;
        
        }
        const boolean& dragToPage_attr(){

            return type: oolean\nname: \m_dragToPage_attr\n;
        
        }
        bool has_dragToData_attr(){

            return m_has_dragToData_attr;
        
        }
        void set_dragToData_attr(const boolean& _dragToData_attr ){

        m_has_dragToData_attr = true;
        m_dragToData_attr = _dragToData_attr;
        
        }
        const boolean& dragToData_attr(){

            return type: oolean\nname: \m_dragToData_attr\n;
        
        }
        bool has_dragOff_attr(){

            return m_has_dragOff_attr;
        
        }
        void set_dragOff_attr(const boolean& _dragOff_attr ){

        m_has_dragOff_attr = true;
        m_dragOff_attr = _dragOff_attr;
        
        }
        const boolean& dragOff_attr(){

            return type: oolean\nname: \m_dragOff_attr\n;
        
        }
        bool has_includeNewItemsInFilter_attr(){

            return m_has_includeNewItemsInFilter_attr;
        
        }
        void set_includeNewItemsInFilter_attr(const boolean& _includeNewItemsInFilter_attr ){

        m_has_includeNewItemsInFilter_attr = true;
        m_includeNewItemsInFilter_attr = _includeNewItemsInFilter_attr;
        
        }
        const boolean& includeNewItemsInFilter_attr(){

            return type: oolean\nname: \m_includeNewItemsInFilter_attr\n;
        
        }
        bool has_caption_attr(){

            return m_has_caption_attr;
        
        }
        void set_caption_attr(const ns_s::ST_Xstring& _caption_attr ){

            m_has_caption_attr = true;
            m_caption_attr = new ns_s::ST_Xstring(_caption_attr);
        
        }
        const ns_s::ST_Xstring& caption_attr(){

            if (m_caption_attr)
            {
                return *m_caption_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }

    private:
        bool m_has_mps ;
        CT_MemberProperties* m_mps ;
        bool m_has_members ;
        CT_Members* m_members ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_PivotHierarchy* default_instance_ ;
        bool m_has_outline_attr ;
        boolean m_outline_attr ;
        bool m_has_multipleItemSelectionAllowed_attr ;
        boolean m_multipleItemSelectionAllowed_attr ;
        bool m_has_subtotalTop_attr ;
        boolean m_subtotalTop_attr ;
        bool m_has_showInFieldList_attr ;
        boolean m_showInFieldList_attr ;
        bool m_has_dragToRow_attr ;
        boolean m_dragToRow_attr ;
        bool m_has_dragToCol_attr ;
        boolean m_dragToCol_attr ;
        bool m_has_dragToPage_attr ;
        boolean m_dragToPage_attr ;
        bool m_has_dragToData_attr ;
        boolean m_dragToData_attr ;
        bool m_has_dragOff_attr ;
        boolean m_dragOff_attr ;
        bool m_has_includeNewItemsInFilter_attr ;
        boolean m_includeNewItemsInFilter_attr ;
        bool m_has_caption_attr ;
        ns_s::ST_Xstring* m_caption_attr ;

    }

    class CT_RowHierarchiesUsage : public XSD::ComplexType{
    public:
        bool has_rowHierarchyUsage(){

            return m_has_rowHierarchyUsage;
        
        }
        CT_HierarchyUsage* mutable_rowHierarchyUsage(){

                m_has_rowHierarchyUsage = true;
                if (!m_rowHierarchyUsage)
                {
                    m_rowHierarchyUsage = new CT_HierarchyUsage();
                }
                return m_rowHierarchyUsage;
            
        }
        const CT_HierarchyUsage& rowHierarchyUsage(){

            if (m_rowHierarchyUsage)
            {
                return *m_rowHierarchyUsage;
            }
            return CT_HierarchyUsage::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_rowHierarchyUsage = false;
                
        if (m_rowHierarchyUsage)
        {
            delete m_rowHierarchyUsage;
            m_rowHierarchyUsage = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_rowHierarchyUsage)
                {
                    m_rowHierarchyUsage->toXml(rowHierarchyUsage, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_RowHierarchiesUsage& default_instance(){

    if (!CT_RowHierarchiesUsage::default_instance_)
    {
        CT_RowHierarchiesUsage::default_instance_ = new CT_RowHierarchiesUsage();
    }
    return *CT_RowHierarchiesUsage::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_rowHierarchyUsage ;
        CT_HierarchyUsage* m_rowHierarchyUsage ;
        static CT_RowHierarchiesUsage* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_ColHierarchiesUsage : public XSD::ComplexType{
    public:
        bool has_colHierarchyUsage(){

            return m_has_colHierarchyUsage;
        
        }
        CT_HierarchyUsage* mutable_colHierarchyUsage(){

                m_has_colHierarchyUsage = true;
                if (!m_colHierarchyUsage)
                {
                    m_colHierarchyUsage = new CT_HierarchyUsage();
                }
                return m_colHierarchyUsage;
            
        }
        const CT_HierarchyUsage& colHierarchyUsage(){

            if (m_colHierarchyUsage)
            {
                return *m_colHierarchyUsage;
            }
            return CT_HierarchyUsage::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_colHierarchyUsage = false;
                
        if (m_colHierarchyUsage)
        {
            delete m_colHierarchyUsage;
            m_colHierarchyUsage = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_colHierarchyUsage)
                {
                    m_colHierarchyUsage->toXml(colHierarchyUsage, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_ColHierarchiesUsage& default_instance(){

    if (!CT_ColHierarchiesUsage::default_instance_)
    {
        CT_ColHierarchiesUsage::default_instance_ = new CT_ColHierarchiesUsage();
    }
    return *CT_ColHierarchiesUsage::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_colHierarchyUsage ;
        CT_HierarchyUsage* m_colHierarchyUsage ;
        static CT_ColHierarchiesUsage* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_HierarchyUsage : public XSD::ComplexType{
    public:
        void clear(){

                m_has_hierarchyUsage_attr = false;
                m_hierarchyUsage_attr = 0;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_hierarchyUsage_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_HierarchyUsage& default_instance(){

    if (!CT_HierarchyUsage::default_instance_)
    {
        CT_HierarchyUsage::default_instance_ = new CT_HierarchyUsage();
    }
    return *CT_HierarchyUsage::default_instance_;

        }
        bool has_hierarchyUsage_attr(){

            return m_has_hierarchyUsage_attr;
        
        }
        void set_hierarchyUsage_attr(const int& _hierarchyUsage_attr ){

        m_has_hierarchyUsage_attr = true;
        m_hierarchyUsage_attr = _hierarchyUsage_attr;
        
        }
        const int& hierarchyUsage_attr(){

            return type: \int\nname: \m_hierarchyUsage_attr\n;
        
        }

    private:
        static CT_HierarchyUsage* default_instance_ ;
        bool m_has_hierarchyUsage_attr ;
        int m_hierarchyUsage_attr ;

    }

    class CT_MemberProperties : public XSD::ComplexType{
    public:
        bool has_mp(){

            return m_has_mp;
        
        }
        CT_MemberProperty* mutable_mp(){

                m_has_mp = true;
                if (!m_mp)
                {
                    m_mp = new CT_MemberProperty();
                }
                return m_mp;
            
        }
        const CT_MemberProperty& mp(){

            if (m_mp)
            {
                return *m_mp;
            }
            return CT_MemberProperty::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_mp = false;
                
        if (m_mp)
        {
            delete m_mp;
            m_mp = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_mp)
                {
                    m_mp->toXml(mp, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_MemberProperties& default_instance(){

    if (!CT_MemberProperties::default_instance_)
    {
        CT_MemberProperties::default_instance_ = new CT_MemberProperties();
    }
    return *CT_MemberProperties::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_mp ;
        CT_MemberProperty* m_mp ;
        static CT_MemberProperties* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_MemberProperty : public XSD::ComplexType{
    public:
        void clear(){

                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
                m_has_showCell_attr = false;
                m_showCell_attr = false;
            
                m_has_showTip_attr = false;
                m_showTip_attr = false;
            
                m_has_showAsCaption_attr = false;
                m_showAsCaption_attr = false;
            
                m_has_nameLen_attr = false;
                m_nameLen_attr = 0;
            
                m_has_pPos_attr = false;
                m_pPos_attr = 0;
            
                m_has_pLen_attr = false;
                m_pLen_attr = 0;
            
                m_has_level_attr = false;
                m_level_attr = 0;
            
                m_has_field_attr = false;
                m_field_attr = 0;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_name_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showCell_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showTip_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showAsCaption_attr) << \\\;
_outStream << _attrName << \=\\ << m_nameLen_attr << \\\;
_outStream << _attrName << \=\\ << m_pPos_attr << \\\;
_outStream << _attrName << \=\\ << m_pLen_attr << \\\;
_outStream << _attrName << \=\\ << m_level_attr << \\\;
_outStream << _attrName << \=\\ << m_field_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_MemberProperty& default_instance(){

    if (!CT_MemberProperty::default_instance_)
    {
        CT_MemberProperty::default_instance_ = new CT_MemberProperty();
    }
    return *CT_MemberProperty::default_instance_;

        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_showCell_attr(){

            return m_has_showCell_attr;
        
        }
        void set_showCell_attr(const boolean& _showCell_attr ){

        m_has_showCell_attr = true;
        m_showCell_attr = _showCell_attr;
        
        }
        const boolean& showCell_attr(){

            return type: oolean\nname: \m_showCell_attr\n;
        
        }
        bool has_showTip_attr(){

            return m_has_showTip_attr;
        
        }
        void set_showTip_attr(const boolean& _showTip_attr ){

        m_has_showTip_attr = true;
        m_showTip_attr = _showTip_attr;
        
        }
        const boolean& showTip_attr(){

            return type: oolean\nname: \m_showTip_attr\n;
        
        }
        bool has_showAsCaption_attr(){

            return m_has_showAsCaption_attr;
        
        }
        void set_showAsCaption_attr(const boolean& _showAsCaption_attr ){

        m_has_showAsCaption_attr = true;
        m_showAsCaption_attr = _showAsCaption_attr;
        
        }
        const boolean& showAsCaption_attr(){

            return type: oolean\nname: \m_showAsCaption_attr\n;
        
        }
        bool has_nameLen_attr(){

            return m_has_nameLen_attr;
        
        }
        void set_nameLen_attr(const unsignedInt& _nameLen_attr ){

        m_has_nameLen_attr = true;
        m_nameLen_attr = _nameLen_attr;
        
        }
        const unsignedInt& nameLen_attr(){

            return type: \unsignedInt\nname: \m_nameLen_attr\n;
        
        }
        bool has_pPos_attr(){

            return m_has_pPos_attr;
        
        }
        void set_pPos_attr(const unsignedInt& _pPos_attr ){

        m_has_pPos_attr = true;
        m_pPos_attr = _pPos_attr;
        
        }
        const unsignedInt& pPos_attr(){

            return type: \unsignedInt\nname: \m_pPos_attr\n;
        
        }
        bool has_pLen_attr(){

            return m_has_pLen_attr;
        
        }
        void set_pLen_attr(const unsignedInt& _pLen_attr ){

        m_has_pLen_attr = true;
        m_pLen_attr = _pLen_attr;
        
        }
        const unsignedInt& pLen_attr(){

            return type: \unsignedInt\nname: \m_pLen_attr\n;
        
        }
        bool has_level_attr(){

            return m_has_level_attr;
        
        }
        void set_level_attr(const unsignedInt& _level_attr ){

        m_has_level_attr = true;
        m_level_attr = _level_attr;
        
        }
        const unsignedInt& level_attr(){

            return type: \unsignedInt\nname: \m_level_attr\n;
        
        }
        bool has_field_attr(){

            return m_has_field_attr;
        
        }
        void set_field_attr(const unsignedInt& _field_attr ){

        m_has_field_attr = true;
        m_field_attr = _field_attr;
        
        }
        const unsignedInt& field_attr(){

            return type: \unsignedInt\nname: \m_field_attr\n;
        
        }

    private:
        static CT_MemberProperty* default_instance_ ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;
        bool m_has_showCell_attr ;
        boolean m_showCell_attr ;
        bool m_has_showTip_attr ;
        boolean m_showTip_attr ;
        bool m_has_showAsCaption_attr ;
        boolean m_showAsCaption_attr ;
        bool m_has_nameLen_attr ;
        unsignedInt m_nameLen_attr ;
        bool m_has_pPos_attr ;
        unsignedInt m_pPos_attr ;
        bool m_has_pLen_attr ;
        unsignedInt m_pLen_attr ;
        bool m_has_level_attr ;
        unsignedInt m_level_attr ;
        bool m_has_field_attr ;
        unsignedInt m_field_attr ;

    }

    class CT_Members : public XSD::ComplexType{
    public:
        bool has_member(){

            return m_has_member;
        
        }
        CT_Member* mutable_member(){

                m_has_member = true;
                if (!m_member)
                {
                    m_member = new CT_Member();
                }
                return m_member;
            
        }
        const CT_Member& member(){

            if (m_member)
            {
                return *m_member;
            }
            return CT_Member::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_level_attr = false;
                m_level_attr = 0;
            
                m_has_member = false;
                
        if (m_member)
        {
            delete m_member;
            m_member = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
_outStream << _attrName << \=\\ << m_level_attr << \\\;
        _outStream << \>\;
    
                if (m_has_member)
                {
                    m_member->toXml(member, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Members& default_instance(){

    if (!CT_Members::default_instance_)
    {
        CT_Members::default_instance_ = new CT_Members();
    }
    return *CT_Members::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }
        bool has_level_attr(){

            return m_has_level_attr;
        
        }
        void set_level_attr(const unsignedInt& _level_attr ){

        m_has_level_attr = true;
        m_level_attr = _level_attr;
        
        }
        const unsignedInt& level_attr(){

            return type: \unsignedInt\nname: \m_level_attr\n;
        
        }

    private:
        bool m_has_member ;
        CT_Member* m_member ;
        static CT_Members* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;
        bool m_has_level_attr ;
        unsignedInt m_level_attr ;

    }

    class CT_Member : public XSD::ComplexType{
    public:
        void clear(){

                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_name_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Member& default_instance(){

    if (!CT_Member::default_instance_)
    {
        CT_Member::default_instance_ = new CT_Member();
    }
    return *CT_Member::default_instance_;

        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }

    private:
        static CT_Member* default_instance_ ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;

    }

    class CT_Dimensions : public XSD::ComplexType{
    public:
        bool has_dimension(){

            return m_has_dimension;
        
        }
        CT_PivotDimension* mutable_dimension(){

                m_has_dimension = true;
                if (!m_dimension)
                {
                    m_dimension = new CT_PivotDimension();
                }
                return m_dimension;
            
        }
        const CT_PivotDimension& dimension(){

            if (m_dimension)
            {
                return *m_dimension;
            }
            return CT_PivotDimension::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_dimension = false;
                
        if (m_dimension)
        {
            delete m_dimension;
            m_dimension = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_dimension)
                {
                    m_dimension->toXml(dimension, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Dimensions& default_instance(){

    if (!CT_Dimensions::default_instance_)
    {
        CT_Dimensions::default_instance_ = new CT_Dimensions();
    }
    return *CT_Dimensions::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_dimension ;
        CT_PivotDimension* m_dimension ;
        static CT_Dimensions* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_PivotDimension : public XSD::ComplexType{
    public:
        void clear(){

                m_has_measure_attr = false;
                m_measure_attr = false;
            
                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
                m_has_uniqueName_attr = false;
                
        if (m_uniqueName_attr)
        {
            delete m_uniqueName_attr;
            m_uniqueName_attr = NULL;
        }
    
            
                m_has_caption_attr = false;
                
        if (m_caption_attr)
        {
            delete m_caption_attr;
            m_caption_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_measure_attr) << \\\;
m_name_attr->toXml(_attrName, _outStream);
m_uniqueName_attr->toXml(_attrName, _outStream);
m_caption_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_PivotDimension& default_instance(){

    if (!CT_PivotDimension::default_instance_)
    {
        CT_PivotDimension::default_instance_ = new CT_PivotDimension();
    }
    return *CT_PivotDimension::default_instance_;

        }
        bool has_measure_attr(){

            return m_has_measure_attr;
        
        }
        void set_measure_attr(const boolean& _measure_attr ){

        m_has_measure_attr = true;
        m_measure_attr = _measure_attr;
        
        }
        const boolean& measure_attr(){

            return type: oolean\nname: \m_measure_attr\n;
        
        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_uniqueName_attr(){

            return m_has_uniqueName_attr;
        
        }
        void set_uniqueName_attr(const ns_s::ST_Xstring& _uniqueName_attr ){

            m_has_uniqueName_attr = true;
            m_uniqueName_attr = new ns_s::ST_Xstring(_uniqueName_attr);
        
        }
        const ns_s::ST_Xstring& uniqueName_attr(){

            if (m_uniqueName_attr)
            {
                return *m_uniqueName_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_caption_attr(){

            return m_has_caption_attr;
        
        }
        void set_caption_attr(const ns_s::ST_Xstring& _caption_attr ){

            m_has_caption_attr = true;
            m_caption_attr = new ns_s::ST_Xstring(_caption_attr);
        
        }
        const ns_s::ST_Xstring& caption_attr(){

            if (m_caption_attr)
            {
                return *m_caption_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }

    private:
        static CT_PivotDimension* default_instance_ ;
        bool m_has_measure_attr ;
        boolean m_measure_attr ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;
        bool m_has_uniqueName_attr ;
        ns_s::ST_Xstring* m_uniqueName_attr ;
        bool m_has_caption_attr ;
        ns_s::ST_Xstring* m_caption_attr ;

    }

    class CT_MeasureGroups : public XSD::ComplexType{
    public:
        bool has_measureGroup(){

            return m_has_measureGroup;
        
        }
        CT_MeasureGroup* mutable_measureGroup(){

                m_has_measureGroup = true;
                if (!m_measureGroup)
                {
                    m_measureGroup = new CT_MeasureGroup();
                }
                return m_measureGroup;
            
        }
        const CT_MeasureGroup& measureGroup(){

            if (m_measureGroup)
            {
                return *m_measureGroup;
            }
            return CT_MeasureGroup::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_measureGroup = false;
                
        if (m_measureGroup)
        {
            delete m_measureGroup;
            m_measureGroup = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_measureGroup)
                {
                    m_measureGroup->toXml(measureGroup, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_MeasureGroups& default_instance(){

    if (!CT_MeasureGroups::default_instance_)
    {
        CT_MeasureGroups::default_instance_ = new CT_MeasureGroups();
    }
    return *CT_MeasureGroups::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_measureGroup ;
        CT_MeasureGroup* m_measureGroup ;
        static CT_MeasureGroups* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_MeasureDimensionMaps : public XSD::ComplexType{
    public:
        bool has_map(){

            return m_has_map;
        
        }
        CT_MeasureDimensionMap* mutable_map(){

                m_has_map = true;
                if (!m_map)
                {
                    m_map = new CT_MeasureDimensionMap();
                }
                return m_map;
            
        }
        const CT_MeasureDimensionMap& map(){

            if (m_map)
            {
                return *m_map;
            }
            return CT_MeasureDimensionMap::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_map = false;
                
        if (m_map)
        {
            delete m_map;
            m_map = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_map)
                {
                    m_map->toXml(map, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_MeasureDimensionMaps& default_instance(){

    if (!CT_MeasureDimensionMaps::default_instance_)
    {
        CT_MeasureDimensionMaps::default_instance_ = new CT_MeasureDimensionMaps();
    }
    return *CT_MeasureDimensionMaps::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_map ;
        CT_MeasureDimensionMap* m_map ;
        static CT_MeasureDimensionMaps* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_MeasureGroup : public XSD::ComplexType{
    public:
        void clear(){

                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
                m_has_caption_attr = false;
                
        if (m_caption_attr)
        {
            delete m_caption_attr;
            m_caption_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_name_attr->toXml(_attrName, _outStream);
m_caption_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_MeasureGroup& default_instance(){

    if (!CT_MeasureGroup::default_instance_)
    {
        CT_MeasureGroup::default_instance_ = new CT_MeasureGroup();
    }
    return *CT_MeasureGroup::default_instance_;

        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_caption_attr(){

            return m_has_caption_attr;
        
        }
        void set_caption_attr(const ns_s::ST_Xstring& _caption_attr ){

            m_has_caption_attr = true;
            m_caption_attr = new ns_s::ST_Xstring(_caption_attr);
        
        }
        const ns_s::ST_Xstring& caption_attr(){

            if (m_caption_attr)
            {
                return *m_caption_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }

    private:
        static CT_MeasureGroup* default_instance_ ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;
        bool m_has_caption_attr ;
        ns_s::ST_Xstring* m_caption_attr ;

    }

    class CT_MeasureDimensionMap : public XSD::ComplexType{
    public:
        void clear(){

                m_has_measureGroup_attr = false;
                m_measureGroup_attr = 0;
            
                m_has_dimension_attr = false;
                m_dimension_attr = 0;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_measureGroup_attr << \\\;
_outStream << _attrName << \=\\ << m_dimension_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_MeasureDimensionMap& default_instance(){

    if (!CT_MeasureDimensionMap::default_instance_)
    {
        CT_MeasureDimensionMap::default_instance_ = new CT_MeasureDimensionMap();
    }
    return *CT_MeasureDimensionMap::default_instance_;

        }
        bool has_measureGroup_attr(){

            return m_has_measureGroup_attr;
        
        }
        void set_measureGroup_attr(const unsignedInt& _measureGroup_attr ){

        m_has_measureGroup_attr = true;
        m_measureGroup_attr = _measureGroup_attr;
        
        }
        const unsignedInt& measureGroup_attr(){

            return type: \unsignedInt\nname: \m_measureGroup_attr\n;
        
        }
        bool has_dimension_attr(){

            return m_has_dimension_attr;
        
        }
        void set_dimension_attr(const unsignedInt& _dimension_attr ){

        m_has_dimension_attr = true;
        m_dimension_attr = _dimension_attr;
        
        }
        const unsignedInt& dimension_attr(){

            return type: \unsignedInt\nname: \m_dimension_attr\n;
        
        }

    private:
        static CT_MeasureDimensionMap* default_instance_ ;
        bool m_has_measureGroup_attr ;
        unsignedInt m_measureGroup_attr ;
        bool m_has_dimension_attr ;
        unsignedInt m_dimension_attr ;

    }

    class CT_PivotTableStyle : public XSD::ComplexType{
    public:
        void clear(){

                m_has_name_attr = false;
                m_name_attr.clear();
            
                m_has_showRowHeaders_attr = false;
                m_showRowHeaders_attr = false;
            
                m_has_showColHeaders_attr = false;
                m_showColHeaders_attr = false;
            
                m_has_showRowStripes_attr = false;
                m_showRowStripes_attr = false;
            
                m_has_showColStripes_attr = false;
                m_showColStripes_attr = false;
            
                m_has_showLastColumn_attr = false;
                m_showLastColumn_attr = false;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_name_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showRowHeaders_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showColHeaders_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showRowStripes_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showColStripes_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showLastColumn_attr) << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_PivotTableStyle& default_instance(){

    if (!CT_PivotTableStyle::default_instance_)
    {
        CT_PivotTableStyle::default_instance_ = new CT_PivotTableStyle();
    }
    return *CT_PivotTableStyle::default_instance_;

        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const string& _name_attr ){

        m_has_name_attr = true;
        m_name_attr = _name_attr;
        
        }
        const string& name_attr(){

            return type: \string\nname: \m_name_attr\n;
        
        }
        bool has_showRowHeaders_attr(){

            return m_has_showRowHeaders_attr;
        
        }
        void set_showRowHeaders_attr(const boolean& _showRowHeaders_attr ){

        m_has_showRowHeaders_attr = true;
        m_showRowHeaders_attr = _showRowHeaders_attr;
        
        }
        const boolean& showRowHeaders_attr(){

            return type: oolean\nname: \m_showRowHeaders_attr\n;
        
        }
        bool has_showColHeaders_attr(){

            return m_has_showColHeaders_attr;
        
        }
        void set_showColHeaders_attr(const boolean& _showColHeaders_attr ){

        m_has_showColHeaders_attr = true;
        m_showColHeaders_attr = _showColHeaders_attr;
        
        }
        const boolean& showColHeaders_attr(){

            return type: oolean\nname: \m_showColHeaders_attr\n;
        
        }
        bool has_showRowStripes_attr(){

            return m_has_showRowStripes_attr;
        
        }
        void set_showRowStripes_attr(const boolean& _showRowStripes_attr ){

        m_has_showRowStripes_attr = true;
        m_showRowStripes_attr = _showRowStripes_attr;
        
        }
        const boolean& showRowStripes_attr(){

            return type: oolean\nname: \m_showRowStripes_attr\n;
        
        }
        bool has_showColStripes_attr(){

            return m_has_showColStripes_attr;
        
        }
        void set_showColStripes_attr(const boolean& _showColStripes_attr ){

        m_has_showColStripes_attr = true;
        m_showColStripes_attr = _showColStripes_attr;
        
        }
        const boolean& showColStripes_attr(){

            return type: oolean\nname: \m_showColStripes_attr\n;
        
        }
        bool has_showLastColumn_attr(){

            return m_has_showLastColumn_attr;
        
        }
        void set_showLastColumn_attr(const boolean& _showLastColumn_attr ){

        m_has_showLastColumn_attr = true;
        m_showLastColumn_attr = _showLastColumn_attr;
        
        }
        const boolean& showLastColumn_attr(){

            return type: oolean\nname: \m_showLastColumn_attr\n;
        
        }

    private:
        static CT_PivotTableStyle* default_instance_ ;
        bool m_has_name_attr ;
        string m_name_attr ;
        bool m_has_showRowHeaders_attr ;
        boolean m_showRowHeaders_attr ;
        bool m_has_showColHeaders_attr ;
        boolean m_showColHeaders_attr ;
        bool m_has_showRowStripes_attr ;
        boolean m_showRowStripes_attr ;
        bool m_has_showColStripes_attr ;
        boolean m_showColStripes_attr ;
        bool m_has_showLastColumn_attr ;
        boolean m_showLastColumn_attr ;

    }

    class CT_PivotFilters : public XSD::ComplexType{
    public:
        bool has_filter(){

            return m_has_filter;
        
        }
        CT_PivotFilter* mutable_filter(){

                m_has_filter = true;
                if (!m_filter)
                {
                    m_filter = new CT_PivotFilter();
                }
                return m_filter;
            
        }
        const CT_PivotFilter& filter(){

            if (m_filter)
            {
                return *m_filter;
            }
            return CT_PivotFilter::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_filter = false;
                
        if (m_filter)
        {
            delete m_filter;
            m_filter = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_filter)
                {
                    m_filter->toXml(filter, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_PivotFilters& default_instance(){

    if (!CT_PivotFilters::default_instance_)
    {
        CT_PivotFilters::default_instance_ = new CT_PivotFilters();
    }
    return *CT_PivotFilters::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_filter ;
        CT_PivotFilter* m_filter ;
        static CT_PivotFilters* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_PivotFilter : public XSD::ComplexType{
    public:
        bool has_autoFilter(){

            return m_has_autoFilter;
        
        }
        CT_AutoFilter* mutable_autoFilter(){

                m_has_autoFilter = true;
                if (!m_autoFilter)
                {
                    m_autoFilter = new CT_AutoFilter();
                }
                return m_autoFilter;
            
        }
        const CT_AutoFilter& autoFilter(){

            if (m_autoFilter)
            {
                return *m_autoFilter;
            }
            return CT_AutoFilter::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_fld_attr = false;
                m_fld_attr = 0;
            
                m_has_mpFld_attr = false;
                m_mpFld_attr = 0;
            
                m_has_type_attr = false;
                
        if (m_type_attr)
        {
            delete m_type_attr;
            m_type_attr = NULL;
        }
    
            
                m_has_evalOrder_attr = false;
                m_evalOrder_attr = 0;
            
                m_has_id_attr = false;
                m_id_attr = 0;
            
                m_has_iMeasureHier_attr = false;
                m_iMeasureHier_attr = 0;
            
                m_has_iMeasureFld_attr = false;
                m_iMeasureFld_attr = 0;
            
                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
                m_has_description_attr = false;
                
        if (m_description_attr)
        {
            delete m_description_attr;
            m_description_attr = NULL;
        }
    
            
                m_has_stringValue1_attr = false;
                
        if (m_stringValue1_attr)
        {
            delete m_stringValue1_attr;
            m_stringValue1_attr = NULL;
        }
    
            
                m_has_stringValue2_attr = false;
                
        if (m_stringValue2_attr)
        {
            delete m_stringValue2_attr;
            m_stringValue2_attr = NULL;
        }
    
            
                m_has_autoFilter = false;
                
        if (m_autoFilter)
        {
            delete m_autoFilter;
            m_autoFilter = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_fld_attr << \\\;
_outStream << _attrName << \=\\ << m_mpFld_attr << \\\;
m_type_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_evalOrder_attr << \\\;
_outStream << _attrName << \=\\ << m_id_attr << \\\;
_outStream << _attrName << \=\\ << m_iMeasureHier_attr << \\\;
_outStream << _attrName << \=\\ << m_iMeasureFld_attr << \\\;
m_name_attr->toXml(_attrName, _outStream);
m_description_attr->toXml(_attrName, _outStream);
m_stringValue1_attr->toXml(_attrName, _outStream);
m_stringValue2_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_autoFilter)
                {
                    m_autoFilter->toXml(autoFilter, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_autoFilter->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_PivotFilter& default_instance(){

    if (!CT_PivotFilter::default_instance_)
    {
        CT_PivotFilter::default_instance_ = new CT_PivotFilter();
    }
    return *CT_PivotFilter::default_instance_;

        }
        bool has_fld_attr(){

            return m_has_fld_attr;
        
        }
        void set_fld_attr(const unsignedInt& _fld_attr ){

        m_has_fld_attr = true;
        m_fld_attr = _fld_attr;
        
        }
        const unsignedInt& fld_attr(){

            return type: \unsignedInt\nname: \m_fld_attr\n;
        
        }
        bool has_mpFld_attr(){

            return m_has_mpFld_attr;
        
        }
        void set_mpFld_attr(const unsignedInt& _mpFld_attr ){

        m_has_mpFld_attr = true;
        m_mpFld_attr = _mpFld_attr;
        
        }
        const unsignedInt& mpFld_attr(){

            return type: \unsignedInt\nname: \m_mpFld_attr\n;
        
        }
        bool has_type_attr(){

            return m_has_type_attr;
        
        }
        void set_type_attr(const ST_PivotFilterType& _type_attr ){

            m_has_type_attr = true;
            m_type_attr = new ST_PivotFilterType(_type_attr);
        
        }
        const ST_PivotFilterType& type_attr(){

            if (m_type_attr)
            {
                return *m_type_attr;
            }
            return ST_PivotFilterType::default_instance();
        
        }
        bool has_evalOrder_attr(){

            return m_has_evalOrder_attr;
        
        }
        void set_evalOrder_attr(const int& _evalOrder_attr ){

        m_has_evalOrder_attr = true;
        m_evalOrder_attr = _evalOrder_attr;
        
        }
        const int& evalOrder_attr(){

            return type: \int\nname: \m_evalOrder_attr\n;
        
        }
        bool has_id_attr(){

            return m_has_id_attr;
        
        }
        void set_id_attr(const unsignedInt& _id_attr ){

        m_has_id_attr = true;
        m_id_attr = _id_attr;
        
        }
        const unsignedInt& id_attr(){

            return type: \unsignedInt\nname: \m_id_attr\n;
        
        }
        bool has_iMeasureHier_attr(){

            return m_has_iMeasureHier_attr;
        
        }
        void set_iMeasureHier_attr(const unsignedInt& _iMeasureHier_attr ){

        m_has_iMeasureHier_attr = true;
        m_iMeasureHier_attr = _iMeasureHier_attr;
        
        }
        const unsignedInt& iMeasureHier_attr(){

            return type: \unsignedInt\nname: \m_iMeasureHier_attr\n;
        
        }
        bool has_iMeasureFld_attr(){

            return m_has_iMeasureFld_attr;
        
        }
        void set_iMeasureFld_attr(const unsignedInt& _iMeasureFld_attr ){

        m_has_iMeasureFld_attr = true;
        m_iMeasureFld_attr = _iMeasureFld_attr;
        
        }
        const unsignedInt& iMeasureFld_attr(){

            return type: \unsignedInt\nname: \m_iMeasureFld_attr\n;
        
        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_description_attr(){

            return m_has_description_attr;
        
        }
        void set_description_attr(const ns_s::ST_Xstring& _description_attr ){

            m_has_description_attr = true;
            m_description_attr = new ns_s::ST_Xstring(_description_attr);
        
        }
        const ns_s::ST_Xstring& description_attr(){

            if (m_description_attr)
            {
                return *m_description_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_stringValue1_attr(){

            return m_has_stringValue1_attr;
        
        }
        void set_stringValue1_attr(const ns_s::ST_Xstring& _stringValue1_attr ){

            m_has_stringValue1_attr = true;
            m_stringValue1_attr = new ns_s::ST_Xstring(_stringValue1_attr);
        
        }
        const ns_s::ST_Xstring& stringValue1_attr(){

            if (m_stringValue1_attr)
            {
                return *m_stringValue1_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_stringValue2_attr(){

            return m_has_stringValue2_attr;
        
        }
        void set_stringValue2_attr(const ns_s::ST_Xstring& _stringValue2_attr ){

            m_has_stringValue2_attr = true;
            m_stringValue2_attr = new ns_s::ST_Xstring(_stringValue2_attr);
        
        }
        const ns_s::ST_Xstring& stringValue2_attr(){

            if (m_stringValue2_attr)
            {
                return *m_stringValue2_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }

    private:
        bool m_has_autoFilter ;
        CT_AutoFilter* m_autoFilter ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_PivotFilter* default_instance_ ;
        bool m_has_fld_attr ;
        unsignedInt m_fld_attr ;
        bool m_has_mpFld_attr ;
        unsignedInt m_mpFld_attr ;
        bool m_has_type_attr ;
        ST_PivotFilterType* m_type_attr ;
        bool m_has_evalOrder_attr ;
        int m_evalOrder_attr ;
        bool m_has_id_attr ;
        unsignedInt m_id_attr ;
        bool m_has_iMeasureHier_attr ;
        unsignedInt m_iMeasureHier_attr ;
        bool m_has_iMeasureFld_attr ;
        unsignedInt m_iMeasureFld_attr ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;
        bool m_has_description_attr ;
        ns_s::ST_Xstring* m_description_attr ;
        bool m_has_stringValue1_attr ;
        ns_s::ST_Xstring* m_stringValue1_attr ;
        bool m_has_stringValue2_attr ;
        ns_s::ST_Xstring* m_stringValue2_attr ;

    }

    class CT_PivotArea : public XSD::ComplexType{
    public:
        bool has_references(){

            return m_has_references;
        
        }
        CT_PivotAreaReferences* mutable_references(){

                m_has_references = true;
                if (!m_references)
                {
                    m_references = new CT_PivotAreaReferences();
                }
                return m_references;
            
        }
        const CT_PivotAreaReferences& references(){

            if (m_references)
            {
                return *m_references;
            }
            return CT_PivotAreaReferences::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_field_attr = false;
                m_field_attr = 0;
            
                m_has_type_attr = false;
                
        if (m_type_attr)
        {
            delete m_type_attr;
            m_type_attr = NULL;
        }
    
            
                m_has_dataOnly_attr = false;
                m_dataOnly_attr = false;
            
                m_has_labelOnly_attr = false;
                m_labelOnly_attr = false;
            
                m_has_grandRow_attr = false;
                m_grandRow_attr = false;
            
                m_has_grandCol_attr = false;
                m_grandCol_attr = false;
            
                m_has_cacheIndex_attr = false;
                m_cacheIndex_attr = false;
            
                m_has_outline_attr = false;
                m_outline_attr = false;
            
                m_has_offset_attr = false;
                
        if (m_offset_attr)
        {
            delete m_offset_attr;
            m_offset_attr = NULL;
        }
    
            
                m_has_collapsedLevelsAreSubtotals_attr = false;
                m_collapsedLevelsAreSubtotals_attr = false;
            
                m_has_axis_attr = false;
                
        if (m_axis_attr)
        {
            delete m_axis_attr;
            m_axis_attr = NULL;
        }
    
            
                m_has_fieldPosition_attr = false;
                m_fieldPosition_attr = 0;
            
                m_has_references = false;
                
        if (m_references)
        {
            delete m_references;
            m_references = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_field_attr << \\\;
m_type_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_dataOnly_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_labelOnly_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_grandRow_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_grandCol_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_cacheIndex_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_outline_attr) << \\\;
m_offset_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_collapsedLevelsAreSubtotals_attr) << \\\;
m_axis_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_fieldPosition_attr << \\\;
        _outStream << \>\;
    
                if (m_has_references)
                {
                    m_references->toXml(references, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_references->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_PivotArea& default_instance(){

    if (!CT_PivotArea::default_instance_)
    {
        CT_PivotArea::default_instance_ = new CT_PivotArea();
    }
    return *CT_PivotArea::default_instance_;

        }
        bool has_field_attr(){

            return m_has_field_attr;
        
        }
        void set_field_attr(const int& _field_attr ){

        m_has_field_attr = true;
        m_field_attr = _field_attr;
        
        }
        const int& field_attr(){

            return type: \int\nname: \m_field_attr\n;
        
        }
        bool has_type_attr(){

            return m_has_type_attr;
        
        }
        void set_type_attr(const ST_PivotAreaType& _type_attr ){

            m_has_type_attr = true;
            m_type_attr = new ST_PivotAreaType(_type_attr);
        
        }
        const ST_PivotAreaType& type_attr(){

            if (m_type_attr)
            {
                return *m_type_attr;
            }
            return ST_PivotAreaType::default_instance();
        
        }
        bool has_dataOnly_attr(){

            return m_has_dataOnly_attr;
        
        }
        void set_dataOnly_attr(const boolean& _dataOnly_attr ){

        m_has_dataOnly_attr = true;
        m_dataOnly_attr = _dataOnly_attr;
        
        }
        const boolean& dataOnly_attr(){

            return type: oolean\nname: \m_dataOnly_attr\n;
        
        }
        bool has_labelOnly_attr(){

            return m_has_labelOnly_attr;
        
        }
        void set_labelOnly_attr(const boolean& _labelOnly_attr ){

        m_has_labelOnly_attr = true;
        m_labelOnly_attr = _labelOnly_attr;
        
        }
        const boolean& labelOnly_attr(){

            return type: oolean\nname: \m_labelOnly_attr\n;
        
        }
        bool has_grandRow_attr(){

            return m_has_grandRow_attr;
        
        }
        void set_grandRow_attr(const boolean& _grandRow_attr ){

        m_has_grandRow_attr = true;
        m_grandRow_attr = _grandRow_attr;
        
        }
        const boolean& grandRow_attr(){

            return type: oolean\nname: \m_grandRow_attr\n;
        
        }
        bool has_grandCol_attr(){

            return m_has_grandCol_attr;
        
        }
        void set_grandCol_attr(const boolean& _grandCol_attr ){

        m_has_grandCol_attr = true;
        m_grandCol_attr = _grandCol_attr;
        
        }
        const boolean& grandCol_attr(){

            return type: oolean\nname: \m_grandCol_attr\n;
        
        }
        bool has_cacheIndex_attr(){

            return m_has_cacheIndex_attr;
        
        }
        void set_cacheIndex_attr(const boolean& _cacheIndex_attr ){

        m_has_cacheIndex_attr = true;
        m_cacheIndex_attr = _cacheIndex_attr;
        
        }
        const boolean& cacheIndex_attr(){

            return type: oolean\nname: \m_cacheIndex_attr\n;
        
        }
        bool has_outline_attr(){

            return m_has_outline_attr;
        
        }
        void set_outline_attr(const boolean& _outline_attr ){

        m_has_outline_attr = true;
        m_outline_attr = _outline_attr;
        
        }
        const boolean& outline_attr(){

            return type: oolean\nname: \m_outline_attr\n;
        
        }
        bool has_offset_attr(){

            return m_has_offset_attr;
        
        }
        void set_offset_attr(const ST_Ref& _offset_attr ){

            m_has_offset_attr = true;
            m_offset_attr = new ST_Ref(_offset_attr);
        
        }
        const ST_Ref& offset_attr(){

            if (m_offset_attr)
            {
                return *m_offset_attr;
            }
            return ST_Ref::default_instance();
        
        }
        bool has_collapsedLevelsAreSubtotals_attr(){

            return m_has_collapsedLevelsAreSubtotals_attr;
        
        }
        void set_collapsedLevelsAreSubtotals_attr(const boolean& _collapsedLevelsAreSubtotals_attr ){

        m_has_collapsedLevelsAreSubtotals_attr = true;
        m_collapsedLevelsAreSubtotals_attr = _collapsedLevelsAreSubtotals_attr;
        
        }
        const boolean& collapsedLevelsAreSubtotals_attr(){

            return type: oolean\nname: \m_collapsedLevelsAreSubtotals_attr\n;
        
        }
        bool has_axis_attr(){

            return m_has_axis_attr;
        
        }
        void set_axis_attr(const ST_Axis& _axis_attr ){

            m_has_axis_attr = true;
            m_axis_attr = new ST_Axis(_axis_attr);
        
        }
        const ST_Axis& axis_attr(){

            if (m_axis_attr)
            {
                return *m_axis_attr;
            }
            return ST_Axis::default_instance();
        
        }
        bool has_fieldPosition_attr(){

            return m_has_fieldPosition_attr;
        
        }
        void set_fieldPosition_attr(const unsignedInt& _fieldPosition_attr ){

        m_has_fieldPosition_attr = true;
        m_fieldPosition_attr = _fieldPosition_attr;
        
        }
        const unsignedInt& fieldPosition_attr(){

            return type: \unsignedInt\nname: \m_fieldPosition_attr\n;
        
        }

    private:
        bool m_has_references ;
        CT_PivotAreaReferences* m_references ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_PivotArea* default_instance_ ;
        bool m_has_field_attr ;
        int m_field_attr ;
        bool m_has_type_attr ;
        ST_PivotAreaType* m_type_attr ;
        bool m_has_dataOnly_attr ;
        boolean m_dataOnly_attr ;
        bool m_has_labelOnly_attr ;
        boolean m_labelOnly_attr ;
        bool m_has_grandRow_attr ;
        boolean m_grandRow_attr ;
        bool m_has_grandCol_attr ;
        boolean m_grandCol_attr ;
        bool m_has_cacheIndex_attr ;
        boolean m_cacheIndex_attr ;
        bool m_has_outline_attr ;
        boolean m_outline_attr ;
        bool m_has_offset_attr ;
        ST_Ref* m_offset_attr ;
        bool m_has_collapsedLevelsAreSubtotals_attr ;
        boolean m_collapsedLevelsAreSubtotals_attr ;
        bool m_has_axis_attr ;
        ST_Axis* m_axis_attr ;
        bool m_has_fieldPosition_attr ;
        unsignedInt m_fieldPosition_attr ;

    }

    class CT_PivotAreaReferences : public XSD::ComplexType{
    public:
        bool has_reference(){

            return m_has_reference;
        
        }
        CT_PivotAreaReference* mutable_reference(){

                m_has_reference = true;
                if (!m_reference)
                {
                    m_reference = new CT_PivotAreaReference();
                }
                return m_reference;
            
        }
        const CT_PivotAreaReference& reference(){

            if (m_reference)
            {
                return *m_reference;
            }
            return CT_PivotAreaReference::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_reference = false;
                
        if (m_reference)
        {
            delete m_reference;
            m_reference = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_reference)
                {
                    m_reference->toXml(reference, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_PivotAreaReferences& default_instance(){

    if (!CT_PivotAreaReferences::default_instance_)
    {
        CT_PivotAreaReferences::default_instance_ = new CT_PivotAreaReferences();
    }
    return *CT_PivotAreaReferences::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_reference ;
        CT_PivotAreaReference* m_reference ;
        static CT_PivotAreaReferences* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_PivotAreaReference : public XSD::ComplexType{
    public:
        bool has_x(){

            return m_has_x;
        
        }
        CT_Index* mutable_x(){

                m_has_x = true;
                if (!m_x)
                {
                    m_x = new CT_Index();
                }
                return m_x;
            
        }
        const CT_Index& x(){

            if (m_x)
            {
                return *m_x;
            }
            return CT_Index::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_field_attr = false;
                m_field_attr = 0;
            
                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_selected_attr = false;
                m_selected_attr = false;
            
                m_has_byPosition_attr = false;
                m_byPosition_attr = false;
            
                m_has_relative_attr = false;
                m_relative_attr = false;
            
                m_has_defaultSubtotal_attr = false;
                m_defaultSubtotal_attr = false;
            
                m_has_sumSubtotal_attr = false;
                m_sumSubtotal_attr = false;
            
                m_has_countASubtotal_attr = false;
                m_countASubtotal_attr = false;
            
                m_has_avgSubtotal_attr = false;
                m_avgSubtotal_attr = false;
            
                m_has_maxSubtotal_attr = false;
                m_maxSubtotal_attr = false;
            
                m_has_minSubtotal_attr = false;
                m_minSubtotal_attr = false;
            
                m_has_productSubtotal_attr = false;
                m_productSubtotal_attr = false;
            
                m_has_countSubtotal_attr = false;
                m_countSubtotal_attr = false;
            
                m_has_stdDevSubtotal_attr = false;
                m_stdDevSubtotal_attr = false;
            
                m_has_stdDevPSubtotal_attr = false;
                m_stdDevPSubtotal_attr = false;
            
                m_has_varSubtotal_attr = false;
                m_varSubtotal_attr = false;
            
                m_has_varPSubtotal_attr = false;
                m_varPSubtotal_attr = false;
            
                m_has_x = false;
                
        if (m_x)
        {
            delete m_x;
            m_x = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_field_attr << \\\;
_outStream << _attrName << \=\\ << m_count_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_selected_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_byPosition_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_relative_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_defaultSubtotal_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_sumSubtotal_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_countASubtotal_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_avgSubtotal_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_maxSubtotal_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_minSubtotal_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_productSubtotal_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_countSubtotal_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_stdDevSubtotal_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_stdDevPSubtotal_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_varSubtotal_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_varPSubtotal_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_x)
                {
                    m_x->toXml(x, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_x->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_PivotAreaReference& default_instance(){

    if (!CT_PivotAreaReference::default_instance_)
    {
        CT_PivotAreaReference::default_instance_ = new CT_PivotAreaReference();
    }
    return *CT_PivotAreaReference::default_instance_;

        }
        bool has_field_attr(){

            return m_has_field_attr;
        
        }
        void set_field_attr(const unsignedInt& _field_attr ){

        m_has_field_attr = true;
        m_field_attr = _field_attr;
        
        }
        const unsignedInt& field_attr(){

            return type: \unsignedInt\nname: \m_field_attr\n;
        
        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }
        bool has_selected_attr(){

            return m_has_selected_attr;
        
        }
        void set_selected_attr(const boolean& _selected_attr ){

        m_has_selected_attr = true;
        m_selected_attr = _selected_attr;
        
        }
        const boolean& selected_attr(){

            return type: oolean\nname: \m_selected_attr\n;
        
        }
        bool has_byPosition_attr(){

            return m_has_byPosition_attr;
        
        }
        void set_byPosition_attr(const boolean& _byPosition_attr ){

        m_has_byPosition_attr = true;
        m_byPosition_attr = _byPosition_attr;
        
        }
        const boolean& byPosition_attr(){

            return type: oolean\nname: \m_byPosition_attr\n;
        
        }
        bool has_relative_attr(){

            return m_has_relative_attr;
        
        }
        void set_relative_attr(const boolean& _relative_attr ){

        m_has_relative_attr = true;
        m_relative_attr = _relative_attr;
        
        }
        const boolean& relative_attr(){

            return type: oolean\nname: \m_relative_attr\n;
        
        }
        bool has_defaultSubtotal_attr(){

            return m_has_defaultSubtotal_attr;
        
        }
        void set_defaultSubtotal_attr(const boolean& _defaultSubtotal_attr ){

        m_has_defaultSubtotal_attr = true;
        m_defaultSubtotal_attr = _defaultSubtotal_attr;
        
        }
        const boolean& defaultSubtotal_attr(){

            return type: oolean\nname: \m_defaultSubtotal_attr\n;
        
        }
        bool has_sumSubtotal_attr(){

            return m_has_sumSubtotal_attr;
        
        }
        void set_sumSubtotal_attr(const boolean& _sumSubtotal_attr ){

        m_has_sumSubtotal_attr = true;
        m_sumSubtotal_attr = _sumSubtotal_attr;
        
        }
        const boolean& sumSubtotal_attr(){

            return type: oolean\nname: \m_sumSubtotal_attr\n;
        
        }
        bool has_countASubtotal_attr(){

            return m_has_countASubtotal_attr;
        
        }
        void set_countASubtotal_attr(const boolean& _countASubtotal_attr ){

        m_has_countASubtotal_attr = true;
        m_countASubtotal_attr = _countASubtotal_attr;
        
        }
        const boolean& countASubtotal_attr(){

            return type: oolean\nname: \m_countASubtotal_attr\n;
        
        }
        bool has_avgSubtotal_attr(){

            return m_has_avgSubtotal_attr;
        
        }
        void set_avgSubtotal_attr(const boolean& _avgSubtotal_attr ){

        m_has_avgSubtotal_attr = true;
        m_avgSubtotal_attr = _avgSubtotal_attr;
        
        }
        const boolean& avgSubtotal_attr(){

            return type: oolean\nname: \m_avgSubtotal_attr\n;
        
        }
        bool has_maxSubtotal_attr(){

            return m_has_maxSubtotal_attr;
        
        }
        void set_maxSubtotal_attr(const boolean& _maxSubtotal_attr ){

        m_has_maxSubtotal_attr = true;
        m_maxSubtotal_attr = _maxSubtotal_attr;
        
        }
        const boolean& maxSubtotal_attr(){

            return type: oolean\nname: \m_maxSubtotal_attr\n;
        
        }
        bool has_minSubtotal_attr(){

            return m_has_minSubtotal_attr;
        
        }
        void set_minSubtotal_attr(const boolean& _minSubtotal_attr ){

        m_has_minSubtotal_attr = true;
        m_minSubtotal_attr = _minSubtotal_attr;
        
        }
        const boolean& minSubtotal_attr(){

            return type: oolean\nname: \m_minSubtotal_attr\n;
        
        }
        bool has_productSubtotal_attr(){

            return m_has_productSubtotal_attr;
        
        }
        void set_productSubtotal_attr(const boolean& _productSubtotal_attr ){

        m_has_productSubtotal_attr = true;
        m_productSubtotal_attr = _productSubtotal_attr;
        
        }
        const boolean& productSubtotal_attr(){

            return type: oolean\nname: \m_productSubtotal_attr\n;
        
        }
        bool has_countSubtotal_attr(){

            return m_has_countSubtotal_attr;
        
        }
        void set_countSubtotal_attr(const boolean& _countSubtotal_attr ){

        m_has_countSubtotal_attr = true;
        m_countSubtotal_attr = _countSubtotal_attr;
        
        }
        const boolean& countSubtotal_attr(){

            return type: oolean\nname: \m_countSubtotal_attr\n;
        
        }
        bool has_stdDevSubtotal_attr(){

            return m_has_stdDevSubtotal_attr;
        
        }
        void set_stdDevSubtotal_attr(const boolean& _stdDevSubtotal_attr ){

        m_has_stdDevSubtotal_attr = true;
        m_stdDevSubtotal_attr = _stdDevSubtotal_attr;
        
        }
        const boolean& stdDevSubtotal_attr(){

            return type: oolean\nname: \m_stdDevSubtotal_attr\n;
        
        }
        bool has_stdDevPSubtotal_attr(){

            return m_has_stdDevPSubtotal_attr;
        
        }
        void set_stdDevPSubtotal_attr(const boolean& _stdDevPSubtotal_attr ){

        m_has_stdDevPSubtotal_attr = true;
        m_stdDevPSubtotal_attr = _stdDevPSubtotal_attr;
        
        }
        const boolean& stdDevPSubtotal_attr(){

            return type: oolean\nname: \m_stdDevPSubtotal_attr\n;
        
        }
        bool has_varSubtotal_attr(){

            return m_has_varSubtotal_attr;
        
        }
        void set_varSubtotal_attr(const boolean& _varSubtotal_attr ){

        m_has_varSubtotal_attr = true;
        m_varSubtotal_attr = _varSubtotal_attr;
        
        }
        const boolean& varSubtotal_attr(){

            return type: oolean\nname: \m_varSubtotal_attr\n;
        
        }
        bool has_varPSubtotal_attr(){

            return m_has_varPSubtotal_attr;
        
        }
        void set_varPSubtotal_attr(const boolean& _varPSubtotal_attr ){

        m_has_varPSubtotal_attr = true;
        m_varPSubtotal_attr = _varPSubtotal_attr;
        
        }
        const boolean& varPSubtotal_attr(){

            return type: oolean\nname: \m_varPSubtotal_attr\n;
        
        }

    private:
        bool m_has_x ;
        CT_Index* m_x ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_PivotAreaReference* default_instance_ ;
        bool m_has_field_attr ;
        unsignedInt m_field_attr ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;
        bool m_has_selected_attr ;
        boolean m_selected_attr ;
        bool m_has_byPosition_attr ;
        boolean m_byPosition_attr ;
        bool m_has_relative_attr ;
        boolean m_relative_attr ;
        bool m_has_defaultSubtotal_attr ;
        boolean m_defaultSubtotal_attr ;
        bool m_has_sumSubtotal_attr ;
        boolean m_sumSubtotal_attr ;
        bool m_has_countASubtotal_attr ;
        boolean m_countASubtotal_attr ;
        bool m_has_avgSubtotal_attr ;
        boolean m_avgSubtotal_attr ;
        bool m_has_maxSubtotal_attr ;
        boolean m_maxSubtotal_attr ;
        bool m_has_minSubtotal_attr ;
        boolean m_minSubtotal_attr ;
        bool m_has_productSubtotal_attr ;
        boolean m_productSubtotal_attr ;
        bool m_has_countSubtotal_attr ;
        boolean m_countSubtotal_attr ;
        bool m_has_stdDevSubtotal_attr ;
        boolean m_stdDevSubtotal_attr ;
        bool m_has_stdDevPSubtotal_attr ;
        boolean m_stdDevPSubtotal_attr ;
        bool m_has_varSubtotal_attr ;
        boolean m_varSubtotal_attr ;
        bool m_has_varPSubtotal_attr ;
        boolean m_varPSubtotal_attr ;

    }

    class CT_Index : public XSD::ComplexType{
    public:
        void clear(){

                m_has_v_attr = false;
                m_v_attr = 0;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_v_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Index& default_instance(){

    if (!CT_Index::default_instance_)
    {
        CT_Index::default_instance_ = new CT_Index();
    }
    return *CT_Index::default_instance_;

        }
        bool has_v_attr(){

            return m_has_v_attr;
        
        }
        void set_v_attr(const unsignedInt& _v_attr ){

        m_has_v_attr = true;
        m_v_attr = _v_attr;
        
        }
        const unsignedInt& v_attr(){

            return type: \unsignedInt\nname: \m_v_attr\n;
        
        }

    private:
        static CT_Index* default_instance_ ;
        bool m_has_v_attr ;
        unsignedInt m_v_attr ;

    }

    class CT_QueryTable : public XSD::ComplexType{
    public:
        bool has_queryTableRefresh(){

            return m_has_queryTableRefresh;
        
        }
        CT_QueryTableRefresh* mutable_queryTableRefresh(){

                m_has_queryTableRefresh = true;
                if (!m_queryTableRefresh)
                {
                    m_queryTableRefresh = new CT_QueryTableRefresh();
                }
                return m_queryTableRefresh;
            
        }
        const CT_QueryTableRefresh& queryTableRefresh(){

            if (m_queryTableRefresh)
            {
                return *m_queryTableRefresh;
            }
            return CT_QueryTableRefresh::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
                m_has_headers_attr = false;
                m_headers_attr = false;
            
                m_has_rowNumbers_attr = false;
                m_rowNumbers_attr = false;
            
                m_has_disableRefresh_attr = false;
                m_disableRefresh_attr = false;
            
                m_has_backgroundRefresh_attr = false;
                m_backgroundRefresh_attr = false;
            
                m_has_firstBackgroundRefresh_attr = false;
                m_firstBackgroundRefresh_attr = false;
            
                m_has_refreshOnLoad_attr = false;
                m_refreshOnLoad_attr = false;
            
                m_has_growShrinkType_attr = false;
                
        if (m_growShrinkType_attr)
        {
            delete m_growShrinkType_attr;
            m_growShrinkType_attr = NULL;
        }
    
            
                m_has_fillFormulas_attr = false;
                m_fillFormulas_attr = false;
            
                m_has_removeDataOnSave_attr = false;
                m_removeDataOnSave_attr = false;
            
                m_has_disableEdit_attr = false;
                m_disableEdit_attr = false;
            
                m_has_preserveFormatting_attr = false;
                m_preserveFormatting_attr = false;
            
                m_has_adjustColumnWidth_attr = false;
                m_adjustColumnWidth_attr = false;
            
                m_has_intermediate_attr = false;
                m_intermediate_attr = false;
            
                m_has_connectionId_attr = false;
                m_connectionId_attr = 0;
            
                m_has_autoFormatId_attr = false;
                m_autoFormatId_attr = 0;
            
                m_has_applyNumberFormats_attr = false;
                m_applyNumberFormats_attr = false;
            
                m_has_applyBorderFormats_attr = false;
                m_applyBorderFormats_attr = false;
            
                m_has_applyFontFormats_attr = false;
                m_applyFontFormats_attr = false;
            
                m_has_applyPatternFormats_attr = false;
                m_applyPatternFormats_attr = false;
            
                m_has_applyAlignmentFormats_attr = false;
                m_applyAlignmentFormats_attr = false;
            
                m_has_applyWidthHeightFormats_attr = false;
                m_applyWidthHeightFormats_attr = false;
            
                m_has_queryTableRefresh = false;
                
        if (m_queryTableRefresh)
        {
            delete m_queryTableRefresh;
            m_queryTableRefresh = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_name_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_headers_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_rowNumbers_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_disableRefresh_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_backgroundRefresh_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_firstBackgroundRefresh_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_refreshOnLoad_attr) << \\\;
m_growShrinkType_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_fillFormulas_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_removeDataOnSave_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_disableEdit_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_preserveFormatting_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_adjustColumnWidth_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_intermediate_attr) << \\\;
_outStream << _attrName << \=\\ << m_connectionId_attr << \\\;
_outStream << _attrName << \=\\ << m_autoFormatId_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_applyNumberFormats_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_applyBorderFormats_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_applyFontFormats_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_applyPatternFormats_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_applyAlignmentFormats_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_applyWidthHeightFormats_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_queryTableRefresh)
                {
                    m_queryTableRefresh->toXml(queryTableRefresh, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_queryTableRefresh->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_QueryTable& default_instance(){

    if (!CT_QueryTable::default_instance_)
    {
        CT_QueryTable::default_instance_ = new CT_QueryTable();
    }
    return *CT_QueryTable::default_instance_;

        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_headers_attr(){

            return m_has_headers_attr;
        
        }
        void set_headers_attr(const boolean& _headers_attr ){

        m_has_headers_attr = true;
        m_headers_attr = _headers_attr;
        
        }
        const boolean& headers_attr(){

            return type: oolean\nname: \m_headers_attr\n;
        
        }
        bool has_rowNumbers_attr(){

            return m_has_rowNumbers_attr;
        
        }
        void set_rowNumbers_attr(const boolean& _rowNumbers_attr ){

        m_has_rowNumbers_attr = true;
        m_rowNumbers_attr = _rowNumbers_attr;
        
        }
        const boolean& rowNumbers_attr(){

            return type: oolean\nname: \m_rowNumbers_attr\n;
        
        }
        bool has_disableRefresh_attr(){

            return m_has_disableRefresh_attr;
        
        }
        void set_disableRefresh_attr(const boolean& _disableRefresh_attr ){

        m_has_disableRefresh_attr = true;
        m_disableRefresh_attr = _disableRefresh_attr;
        
        }
        const boolean& disableRefresh_attr(){

            return type: oolean\nname: \m_disableRefresh_attr\n;
        
        }
        bool has_backgroundRefresh_attr(){

            return m_has_backgroundRefresh_attr;
        
        }
        void set_backgroundRefresh_attr(const boolean& _backgroundRefresh_attr ){

        m_has_backgroundRefresh_attr = true;
        m_backgroundRefresh_attr = _backgroundRefresh_attr;
        
        }
        const boolean& backgroundRefresh_attr(){

            return type: oolean\nname: \m_backgroundRefresh_attr\n;
        
        }
        bool has_firstBackgroundRefresh_attr(){

            return m_has_firstBackgroundRefresh_attr;
        
        }
        void set_firstBackgroundRefresh_attr(const boolean& _firstBackgroundRefresh_attr ){

        m_has_firstBackgroundRefresh_attr = true;
        m_firstBackgroundRefresh_attr = _firstBackgroundRefresh_attr;
        
        }
        const boolean& firstBackgroundRefresh_attr(){

            return type: oolean\nname: \m_firstBackgroundRefresh_attr\n;
        
        }
        bool has_refreshOnLoad_attr(){

            return m_has_refreshOnLoad_attr;
        
        }
        void set_refreshOnLoad_attr(const boolean& _refreshOnLoad_attr ){

        m_has_refreshOnLoad_attr = true;
        m_refreshOnLoad_attr = _refreshOnLoad_attr;
        
        }
        const boolean& refreshOnLoad_attr(){

            return type: oolean\nname: \m_refreshOnLoad_attr\n;
        
        }
        bool has_growShrinkType_attr(){

            return m_has_growShrinkType_attr;
        
        }
        void set_growShrinkType_attr(const ST_GrowShrinkType& _growShrinkType_attr ){

            m_has_growShrinkType_attr = true;
            m_growShrinkType_attr = new ST_GrowShrinkType(_growShrinkType_attr);
        
        }
        const ST_GrowShrinkType& growShrinkType_attr(){

            if (m_growShrinkType_attr)
            {
                return *m_growShrinkType_attr;
            }
            return ST_GrowShrinkType::default_instance();
        
        }
        bool has_fillFormulas_attr(){

            return m_has_fillFormulas_attr;
        
        }
        void set_fillFormulas_attr(const boolean& _fillFormulas_attr ){

        m_has_fillFormulas_attr = true;
        m_fillFormulas_attr = _fillFormulas_attr;
        
        }
        const boolean& fillFormulas_attr(){

            return type: oolean\nname: \m_fillFormulas_attr\n;
        
        }
        bool has_removeDataOnSave_attr(){

            return m_has_removeDataOnSave_attr;
        
        }
        void set_removeDataOnSave_attr(const boolean& _removeDataOnSave_attr ){

        m_has_removeDataOnSave_attr = true;
        m_removeDataOnSave_attr = _removeDataOnSave_attr;
        
        }
        const boolean& removeDataOnSave_attr(){

            return type: oolean\nname: \m_removeDataOnSave_attr\n;
        
        }
        bool has_disableEdit_attr(){

            return m_has_disableEdit_attr;
        
        }
        void set_disableEdit_attr(const boolean& _disableEdit_attr ){

        m_has_disableEdit_attr = true;
        m_disableEdit_attr = _disableEdit_attr;
        
        }
        const boolean& disableEdit_attr(){

            return type: oolean\nname: \m_disableEdit_attr\n;
        
        }
        bool has_preserveFormatting_attr(){

            return m_has_preserveFormatting_attr;
        
        }
        void set_preserveFormatting_attr(const boolean& _preserveFormatting_attr ){

        m_has_preserveFormatting_attr = true;
        m_preserveFormatting_attr = _preserveFormatting_attr;
        
        }
        const boolean& preserveFormatting_attr(){

            return type: oolean\nname: \m_preserveFormatting_attr\n;
        
        }
        bool has_adjustColumnWidth_attr(){

            return m_has_adjustColumnWidth_attr;
        
        }
        void set_adjustColumnWidth_attr(const boolean& _adjustColumnWidth_attr ){

        m_has_adjustColumnWidth_attr = true;
        m_adjustColumnWidth_attr = _adjustColumnWidth_attr;
        
        }
        const boolean& adjustColumnWidth_attr(){

            return type: oolean\nname: \m_adjustColumnWidth_attr\n;
        
        }
        bool has_intermediate_attr(){

            return m_has_intermediate_attr;
        
        }
        void set_intermediate_attr(const boolean& _intermediate_attr ){

        m_has_intermediate_attr = true;
        m_intermediate_attr = _intermediate_attr;
        
        }
        const boolean& intermediate_attr(){

            return type: oolean\nname: \m_intermediate_attr\n;
        
        }
        bool has_connectionId_attr(){

            return m_has_connectionId_attr;
        
        }
        void set_connectionId_attr(const unsignedInt& _connectionId_attr ){

        m_has_connectionId_attr = true;
        m_connectionId_attr = _connectionId_attr;
        
        }
        const unsignedInt& connectionId_attr(){

            return type: \unsignedInt\nname: \m_connectionId_attr\n;
        
        }
        bool has_autoFormatId_attr(){

            return m_has_autoFormatId_attr;
        
        }
        void set_autoFormatId_attr(const unsignedInt& _autoFormatId_attr ){

        m_has_autoFormatId_attr = true;
        m_autoFormatId_attr = _autoFormatId_attr;
        
        }
        const unsignedInt& autoFormatId_attr(){

            return type: \unsignedInt\nname: \m_autoFormatId_attr\n;
        
        }
        bool has_applyNumberFormats_attr(){

            return m_has_applyNumberFormats_attr;
        
        }
        void set_applyNumberFormats_attr(const boolean& _applyNumberFormats_attr ){

        m_has_applyNumberFormats_attr = true;
        m_applyNumberFormats_attr = _applyNumberFormats_attr;
        
        }
        const boolean& applyNumberFormats_attr(){

            return type: oolean\nname: \m_applyNumberFormats_attr\n;
        
        }
        bool has_applyBorderFormats_attr(){

            return m_has_applyBorderFormats_attr;
        
        }
        void set_applyBorderFormats_attr(const boolean& _applyBorderFormats_attr ){

        m_has_applyBorderFormats_attr = true;
        m_applyBorderFormats_attr = _applyBorderFormats_attr;
        
        }
        const boolean& applyBorderFormats_attr(){

            return type: oolean\nname: \m_applyBorderFormats_attr\n;
        
        }
        bool has_applyFontFormats_attr(){

            return m_has_applyFontFormats_attr;
        
        }
        void set_applyFontFormats_attr(const boolean& _applyFontFormats_attr ){

        m_has_applyFontFormats_attr = true;
        m_applyFontFormats_attr = _applyFontFormats_attr;
        
        }
        const boolean& applyFontFormats_attr(){

            return type: oolean\nname: \m_applyFontFormats_attr\n;
        
        }
        bool has_applyPatternFormats_attr(){

            return m_has_applyPatternFormats_attr;
        
        }
        void set_applyPatternFormats_attr(const boolean& _applyPatternFormats_attr ){

        m_has_applyPatternFormats_attr = true;
        m_applyPatternFormats_attr = _applyPatternFormats_attr;
        
        }
        const boolean& applyPatternFormats_attr(){

            return type: oolean\nname: \m_applyPatternFormats_attr\n;
        
        }
        bool has_applyAlignmentFormats_attr(){

            return m_has_applyAlignmentFormats_attr;
        
        }
        void set_applyAlignmentFormats_attr(const boolean& _applyAlignmentFormats_attr ){

        m_has_applyAlignmentFormats_attr = true;
        m_applyAlignmentFormats_attr = _applyAlignmentFormats_attr;
        
        }
        const boolean& applyAlignmentFormats_attr(){

            return type: oolean\nname: \m_applyAlignmentFormats_attr\n;
        
        }
        bool has_applyWidthHeightFormats_attr(){

            return m_has_applyWidthHeightFormats_attr;
        
        }
        void set_applyWidthHeightFormats_attr(const boolean& _applyWidthHeightFormats_attr ){

        m_has_applyWidthHeightFormats_attr = true;
        m_applyWidthHeightFormats_attr = _applyWidthHeightFormats_attr;
        
        }
        const boolean& applyWidthHeightFormats_attr(){

            return type: oolean\nname: \m_applyWidthHeightFormats_attr\n;
        
        }

    private:
        bool m_has_queryTableRefresh ;
        CT_QueryTableRefresh* m_queryTableRefresh ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_QueryTable* default_instance_ ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;
        bool m_has_headers_attr ;
        boolean m_headers_attr ;
        bool m_has_rowNumbers_attr ;
        boolean m_rowNumbers_attr ;
        bool m_has_disableRefresh_attr ;
        boolean m_disableRefresh_attr ;
        bool m_has_backgroundRefresh_attr ;
        boolean m_backgroundRefresh_attr ;
        bool m_has_firstBackgroundRefresh_attr ;
        boolean m_firstBackgroundRefresh_attr ;
        bool m_has_refreshOnLoad_attr ;
        boolean m_refreshOnLoad_attr ;
        bool m_has_growShrinkType_attr ;
        ST_GrowShrinkType* m_growShrinkType_attr ;
        bool m_has_fillFormulas_attr ;
        boolean m_fillFormulas_attr ;
        bool m_has_removeDataOnSave_attr ;
        boolean m_removeDataOnSave_attr ;
        bool m_has_disableEdit_attr ;
        boolean m_disableEdit_attr ;
        bool m_has_preserveFormatting_attr ;
        boolean m_preserveFormatting_attr ;
        bool m_has_adjustColumnWidth_attr ;
        boolean m_adjustColumnWidth_attr ;
        bool m_has_intermediate_attr ;
        boolean m_intermediate_attr ;
        bool m_has_connectionId_attr ;
        unsignedInt m_connectionId_attr ;
        bool m_has_autoFormatId_attr ;
        unsignedInt m_autoFormatId_attr ;
        bool m_has_applyNumberFormats_attr ;
        boolean m_applyNumberFormats_attr ;
        bool m_has_applyBorderFormats_attr ;
        boolean m_applyBorderFormats_attr ;
        bool m_has_applyFontFormats_attr ;
        boolean m_applyFontFormats_attr ;
        bool m_has_applyPatternFormats_attr ;
        boolean m_applyPatternFormats_attr ;
        bool m_has_applyAlignmentFormats_attr ;
        boolean m_applyAlignmentFormats_attr ;
        bool m_has_applyWidthHeightFormats_attr ;
        boolean m_applyWidthHeightFormats_attr ;

    }

    class CT_QueryTableRefresh : public XSD::ComplexType{
    public:
        bool has_queryTableFields(){

            return m_has_queryTableFields;
        
        }
        CT_QueryTableFields* mutable_queryTableFields(){

                m_has_queryTableFields = true;
                if (!m_queryTableFields)
                {
                    m_queryTableFields = new CT_QueryTableFields();
                }
                return m_queryTableFields;
            
        }
        const CT_QueryTableFields& queryTableFields(){

            if (m_queryTableFields)
            {
                return *m_queryTableFields;
            }
            return CT_QueryTableFields::default_instance();
        
        }
        bool has_queryTableDeletedFields(){

            return m_has_queryTableDeletedFields;
        
        }
        CT_QueryTableDeletedFields* mutable_queryTableDeletedFields(){

                m_has_queryTableDeletedFields = true;
                if (!m_queryTableDeletedFields)
                {
                    m_queryTableDeletedFields = new CT_QueryTableDeletedFields();
                }
                return m_queryTableDeletedFields;
            
        }
        const CT_QueryTableDeletedFields& queryTableDeletedFields(){

            if (m_queryTableDeletedFields)
            {
                return *m_queryTableDeletedFields;
            }
            return CT_QueryTableDeletedFields::default_instance();
        
        }
        bool has_sortState(){

            return m_has_sortState;
        
        }
        CT_SortState* mutable_sortState(){

                m_has_sortState = true;
                if (!m_sortState)
                {
                    m_sortState = new CT_SortState();
                }
                return m_sortState;
            
        }
        const CT_SortState& sortState(){

            if (m_sortState)
            {
                return *m_sortState;
            }
            return CT_SortState::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_preserveSortFilterLayout_attr = false;
                m_preserveSortFilterLayout_attr = false;
            
                m_has_fieldIdWrapped_attr = false;
                m_fieldIdWrapped_attr = false;
            
                m_has_headersInLastRefresh_attr = false;
                m_headersInLastRefresh_attr = false;
            
                m_has_minimumVersion_attr = false;
                m_minimumVersion_attr = 0;
            
                m_has_nextId_attr = false;
                m_nextId_attr = 0;
            
                m_has_unboundColumnsLeft_attr = false;
                m_unboundColumnsLeft_attr = 0;
            
                m_has_unboundColumnsRight_attr = false;
                m_unboundColumnsRight_attr = 0;
            
                m_has_queryTableFields = false;
                
        if (m_queryTableFields)
        {
            delete m_queryTableFields;
            m_queryTableFields = NULL;
        }
    
            
                m_has_queryTableDeletedFields = false;
                
        if (m_queryTableDeletedFields)
        {
            delete m_queryTableDeletedFields;
            m_queryTableDeletedFields = NULL;
        }
    
            
                m_has_sortState = false;
                
        if (m_sortState)
        {
            delete m_sortState;
            m_sortState = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_preserveSortFilterLayout_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_fieldIdWrapped_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_headersInLastRefresh_attr) << \\\;
_outStream << _attrName << \=\\ << m_minimumVersion_attr << \\\;
_outStream << _attrName << \=\\ << m_nextId_attr << \\\;
_outStream << _attrName << \=\\ << m_unboundColumnsLeft_attr << \\\;
_outStream << _attrName << \=\\ << m_unboundColumnsRight_attr << \\\;
        _outStream << \>\;
    
                if (m_has_queryTableFields)
                {
                    m_queryTableFields->toXml(queryTableFields, _outStream);;
                }
            
                if (m_has_queryTableDeletedFields)
                {
                    m_queryTableFields->toXml(queryTableDeletedFields, _outStream);;
                }
            
                if (m_has_sortState)
                {
                    m_queryTableFields->toXml(sortState, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_queryTableFields->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_QueryTableRefresh& default_instance(){

    if (!CT_QueryTableRefresh::default_instance_)
    {
        CT_QueryTableRefresh::default_instance_ = new CT_QueryTableRefresh();
    }
    return *CT_QueryTableRefresh::default_instance_;

        }
        bool has_preserveSortFilterLayout_attr(){

            return m_has_preserveSortFilterLayout_attr;
        
        }
        void set_preserveSortFilterLayout_attr(const boolean& _preserveSortFilterLayout_attr ){

        m_has_preserveSortFilterLayout_attr = true;
        m_preserveSortFilterLayout_attr = _preserveSortFilterLayout_attr;
        
        }
        const boolean& preserveSortFilterLayout_attr(){

            return type: oolean\nname: \m_preserveSortFilterLayout_attr\n;
        
        }
        bool has_fieldIdWrapped_attr(){

            return m_has_fieldIdWrapped_attr;
        
        }
        void set_fieldIdWrapped_attr(const boolean& _fieldIdWrapped_attr ){

        m_has_fieldIdWrapped_attr = true;
        m_fieldIdWrapped_attr = _fieldIdWrapped_attr;
        
        }
        const boolean& fieldIdWrapped_attr(){

            return type: oolean\nname: \m_fieldIdWrapped_attr\n;
        
        }
        bool has_headersInLastRefresh_attr(){

            return m_has_headersInLastRefresh_attr;
        
        }
        void set_headersInLastRefresh_attr(const boolean& _headersInLastRefresh_attr ){

        m_has_headersInLastRefresh_attr = true;
        m_headersInLastRefresh_attr = _headersInLastRefresh_attr;
        
        }
        const boolean& headersInLastRefresh_attr(){

            return type: oolean\nname: \m_headersInLastRefresh_attr\n;
        
        }
        bool has_minimumVersion_attr(){

            return m_has_minimumVersion_attr;
        
        }
        void set_minimumVersion_attr(const unsignedByte& _minimumVersion_attr ){

        m_has_minimumVersion_attr = true;
        m_minimumVersion_attr = _minimumVersion_attr;
        
        }
        const unsignedByte& minimumVersion_attr(){

            return type: \unsignedByte\nname: \m_minimumVersion_attr\n;
        
        }
        bool has_nextId_attr(){

            return m_has_nextId_attr;
        
        }
        void set_nextId_attr(const unsignedInt& _nextId_attr ){

        m_has_nextId_attr = true;
        m_nextId_attr = _nextId_attr;
        
        }
        const unsignedInt& nextId_attr(){

            return type: \unsignedInt\nname: \m_nextId_attr\n;
        
        }
        bool has_unboundColumnsLeft_attr(){

            return m_has_unboundColumnsLeft_attr;
        
        }
        void set_unboundColumnsLeft_attr(const unsignedInt& _unboundColumnsLeft_attr ){

        m_has_unboundColumnsLeft_attr = true;
        m_unboundColumnsLeft_attr = _unboundColumnsLeft_attr;
        
        }
        const unsignedInt& unboundColumnsLeft_attr(){

            return type: \unsignedInt\nname: \m_unboundColumnsLeft_attr\n;
        
        }
        bool has_unboundColumnsRight_attr(){

            return m_has_unboundColumnsRight_attr;
        
        }
        void set_unboundColumnsRight_attr(const unsignedInt& _unboundColumnsRight_attr ){

        m_has_unboundColumnsRight_attr = true;
        m_unboundColumnsRight_attr = _unboundColumnsRight_attr;
        
        }
        const unsignedInt& unboundColumnsRight_attr(){

            return type: \unsignedInt\nname: \m_unboundColumnsRight_attr\n;
        
        }

    private:
        bool m_has_queryTableFields ;
        CT_QueryTableFields* m_queryTableFields ;
        bool m_has_queryTableDeletedFields ;
        CT_QueryTableDeletedFields* m_queryTableDeletedFields ;
        bool m_has_sortState ;
        CT_SortState* m_sortState ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_QueryTableRefresh* default_instance_ ;
        bool m_has_preserveSortFilterLayout_attr ;
        boolean m_preserveSortFilterLayout_attr ;
        bool m_has_fieldIdWrapped_attr ;
        boolean m_fieldIdWrapped_attr ;
        bool m_has_headersInLastRefresh_attr ;
        boolean m_headersInLastRefresh_attr ;
        bool m_has_minimumVersion_attr ;
        unsignedByte m_minimumVersion_attr ;
        bool m_has_nextId_attr ;
        unsignedInt m_nextId_attr ;
        bool m_has_unboundColumnsLeft_attr ;
        unsignedInt m_unboundColumnsLeft_attr ;
        bool m_has_unboundColumnsRight_attr ;
        unsignedInt m_unboundColumnsRight_attr ;

    }

    class CT_QueryTableDeletedFields : public XSD::ComplexType{
    public:
        bool has_deletedField(){

            return m_has_deletedField;
        
        }
        CT_DeletedField* mutable_deletedField(){

                m_has_deletedField = true;
                if (!m_deletedField)
                {
                    m_deletedField = new CT_DeletedField();
                }
                return m_deletedField;
            
        }
        const CT_DeletedField& deletedField(){

            if (m_deletedField)
            {
                return *m_deletedField;
            }
            return CT_DeletedField::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_deletedField = false;
                
        if (m_deletedField)
        {
            delete m_deletedField;
            m_deletedField = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_deletedField)
                {
                    m_deletedField->toXml(deletedField, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_QueryTableDeletedFields& default_instance(){

    if (!CT_QueryTableDeletedFields::default_instance_)
    {
        CT_QueryTableDeletedFields::default_instance_ = new CT_QueryTableDeletedFields();
    }
    return *CT_QueryTableDeletedFields::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_deletedField ;
        CT_DeletedField* m_deletedField ;
        static CT_QueryTableDeletedFields* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_DeletedField : public XSD::ComplexType{
    public:
        void clear(){

                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_name_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_DeletedField& default_instance(){

    if (!CT_DeletedField::default_instance_)
    {
        CT_DeletedField::default_instance_ = new CT_DeletedField();
    }
    return *CT_DeletedField::default_instance_;

        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }

    private:
        static CT_DeletedField* default_instance_ ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;

    }

    class CT_QueryTableFields : public XSD::ComplexType{
    public:
        bool has_queryTableField(){

            return m_has_queryTableField;
        
        }
        CT_QueryTableField* mutable_queryTableField(){

                m_has_queryTableField = true;
                if (!m_queryTableField)
                {
                    m_queryTableField = new CT_QueryTableField();
                }
                return m_queryTableField;
            
        }
        const CT_QueryTableField& queryTableField(){

            if (m_queryTableField)
            {
                return *m_queryTableField;
            }
            return CT_QueryTableField::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_queryTableField = false;
                
        if (m_queryTableField)
        {
            delete m_queryTableField;
            m_queryTableField = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_queryTableField)
                {
                    m_queryTableField->toXml(queryTableField, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_QueryTableFields& default_instance(){

    if (!CT_QueryTableFields::default_instance_)
    {
        CT_QueryTableFields::default_instance_ = new CT_QueryTableFields();
    }
    return *CT_QueryTableFields::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_queryTableField ;
        CT_QueryTableField* m_queryTableField ;
        static CT_QueryTableFields* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_QueryTableField : public XSD::ComplexType{
    public:
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_id_attr = false;
                m_id_attr = 0;
            
                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
                m_has_dataBound_attr = false;
                m_dataBound_attr = false;
            
                m_has_rowNumbers_attr = false;
                m_rowNumbers_attr = false;
            
                m_has_fillFormulas_attr = false;
                m_fillFormulas_attr = false;
            
                m_has_clipped_attr = false;
                m_clipped_attr = false;
            
                m_has_tableColumnId_attr = false;
                m_tableColumnId_attr = 0;
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_id_attr << \\\;
m_name_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_dataBound_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_rowNumbers_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_fillFormulas_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_clipped_attr) << \\\;
_outStream << _attrName << \=\\ << m_tableColumnId_attr << \\\;
        _outStream << \>\;
    
                if (m_has_extLst)
                {
                    m_extLst->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_QueryTableField& default_instance(){

    if (!CT_QueryTableField::default_instance_)
    {
        CT_QueryTableField::default_instance_ = new CT_QueryTableField();
    }
    return *CT_QueryTableField::default_instance_;

        }
        bool has_id_attr(){

            return m_has_id_attr;
        
        }
        void set_id_attr(const unsignedInt& _id_attr ){

        m_has_id_attr = true;
        m_id_attr = _id_attr;
        
        }
        const unsignedInt& id_attr(){

            return type: \unsignedInt\nname: \m_id_attr\n;
        
        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_dataBound_attr(){

            return m_has_dataBound_attr;
        
        }
        void set_dataBound_attr(const boolean& _dataBound_attr ){

        m_has_dataBound_attr = true;
        m_dataBound_attr = _dataBound_attr;
        
        }
        const boolean& dataBound_attr(){

            return type: oolean\nname: \m_dataBound_attr\n;
        
        }
        bool has_rowNumbers_attr(){

            return m_has_rowNumbers_attr;
        
        }
        void set_rowNumbers_attr(const boolean& _rowNumbers_attr ){

        m_has_rowNumbers_attr = true;
        m_rowNumbers_attr = _rowNumbers_attr;
        
        }
        const boolean& rowNumbers_attr(){

            return type: oolean\nname: \m_rowNumbers_attr\n;
        
        }
        bool has_fillFormulas_attr(){

            return m_has_fillFormulas_attr;
        
        }
        void set_fillFormulas_attr(const boolean& _fillFormulas_attr ){

        m_has_fillFormulas_attr = true;
        m_fillFormulas_attr = _fillFormulas_attr;
        
        }
        const boolean& fillFormulas_attr(){

            return type: oolean\nname: \m_fillFormulas_attr\n;
        
        }
        bool has_clipped_attr(){

            return m_has_clipped_attr;
        
        }
        void set_clipped_attr(const boolean& _clipped_attr ){

        m_has_clipped_attr = true;
        m_clipped_attr = _clipped_attr;
        
        }
        const boolean& clipped_attr(){

            return type: oolean\nname: \m_clipped_attr\n;
        
        }
        bool has_tableColumnId_attr(){

            return m_has_tableColumnId_attr;
        
        }
        void set_tableColumnId_attr(const unsignedInt& _tableColumnId_attr ){

        m_has_tableColumnId_attr = true;
        m_tableColumnId_attr = _tableColumnId_attr;
        
        }
        const unsignedInt& tableColumnId_attr(){

            return type: \unsignedInt\nname: \m_tableColumnId_attr\n;
        
        }

    private:
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_QueryTableField* default_instance_ ;
        bool m_has_id_attr ;
        unsignedInt m_id_attr ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;
        bool m_has_dataBound_attr ;
        boolean m_dataBound_attr ;
        bool m_has_rowNumbers_attr ;
        boolean m_rowNumbers_attr ;
        bool m_has_fillFormulas_attr ;
        boolean m_fillFormulas_attr ;
        bool m_has_clipped_attr ;
        boolean m_clipped_attr ;
        bool m_has_tableColumnId_attr ;
        unsignedInt m_tableColumnId_attr ;

    }

    class CT_Sst : public XSD::ComplexType{
    public:
        bool has_si(){

            return m_has_si;
        
        }
        CT_Rst* mutable_si(){

                m_has_si = true;
                if (!m_si)
                {
                    m_si = new CT_Rst();
                }
                return m_si;
            
        }
        const CT_Rst& si(){

            if (m_si)
            {
                return *m_si;
            }
            return CT_Rst::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_uniqueCount_attr = false;
                m_uniqueCount_attr = 0;
            
                m_has_si = false;
                
        if (m_si)
        {
            delete m_si;
            m_si = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
_outStream << _attrName << \=\\ << m_uniqueCount_attr << \\\;
        _outStream << \>\;
    
                if (m_has_si)
                {
                    m_si->toXml(si, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_si->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Sst& default_instance(){

    if (!CT_Sst::default_instance_)
    {
        CT_Sst::default_instance_ = new CT_Sst();
    }
    return *CT_Sst::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }
        bool has_uniqueCount_attr(){

            return m_has_uniqueCount_attr;
        
        }
        void set_uniqueCount_attr(const unsignedInt& _uniqueCount_attr ){

        m_has_uniqueCount_attr = true;
        m_uniqueCount_attr = _uniqueCount_attr;
        
        }
        const unsignedInt& uniqueCount_attr(){

            return type: \unsignedInt\nname: \m_uniqueCount_attr\n;
        
        }

    private:
        bool m_has_si ;
        CT_Rst* m_si ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_Sst* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;
        bool m_has_uniqueCount_attr ;
        unsignedInt m_uniqueCount_attr ;

    }

    class CT_PhoneticRun : public XSD::ComplexType{
    public:
        bool has_t(){

            return m_has_t;
        
        }
        ns_s::ST_Xstring* mutable_t(){

                m_has_t = true;
                if (!m_t)
                {
                    m_t = new ns_s::ST_Xstring();
                }
                return m_t;
            
        }
        const ns_s::ST_Xstring& t(){

            if (m_t)
            {
                return *m_t;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        void clear(){

                m_has_sb_attr = false;
                m_sb_attr = 0;
            
                m_has_eb_attr = false;
                m_eb_attr = 0;
            
                m_has_t = false;
                
        if (m_t)
        {
            delete m_t;
            m_t = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_sb_attr << \\\;
_outStream << _attrName << \=\\ << m_eb_attr << \\\;
        _outStream << \>\;
    
                if (m_has_t)
                {
                    _outStream << \<t>\ << m_t->toString() << \</t>\;;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_PhoneticRun& default_instance(){

    if (!CT_PhoneticRun::default_instance_)
    {
        CT_PhoneticRun::default_instance_ = new CT_PhoneticRun();
    }
    return *CT_PhoneticRun::default_instance_;

        }
        bool has_sb_attr(){

            return m_has_sb_attr;
        
        }
        void set_sb_attr(const unsignedInt& _sb_attr ){

        m_has_sb_attr = true;
        m_sb_attr = _sb_attr;
        
        }
        const unsignedInt& sb_attr(){

            return type: \unsignedInt\nname: \m_sb_attr\n;
        
        }
        bool has_eb_attr(){

            return m_has_eb_attr;
        
        }
        void set_eb_attr(const unsignedInt& _eb_attr ){

        m_has_eb_attr = true;
        m_eb_attr = _eb_attr;
        
        }
        const unsignedInt& eb_attr(){

            return type: \unsignedInt\nname: \m_eb_attr\n;
        
        }

    private:
        bool m_has_t ;
        ns_s::ST_Xstring* m_t ;
        static CT_PhoneticRun* default_instance_ ;
        bool m_has_sb_attr ;
        unsignedInt m_sb_attr ;
        bool m_has_eb_attr ;
        unsignedInt m_eb_attr ;

    }

    class CT_RElt : public XSD::ComplexType{
    public:
        bool has_rPr(){

            return m_has_rPr;
        
        }
        CT_RPrElt* mutable_rPr(){

                m_has_rPr = true;
                if (!m_rPr)
                {
                    m_rPr = new CT_RPrElt();
                }
                return m_rPr;
            
        }
        const CT_RPrElt& rPr(){

            if (m_rPr)
            {
                return *m_rPr;
            }
            return CT_RPrElt::default_instance();
        
        }
        bool has_t(){

            return m_has_t;
        
        }
        ns_s::ST_Xstring* mutable_t(){

                m_has_t = true;
                if (!m_t)
                {
                    m_t = new ns_s::ST_Xstring();
                }
                return m_t;
            
        }
        const ns_s::ST_Xstring& t(){

            if (m_t)
            {
                return *m_t;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        void clear(){

                m_has_rPr = false;
                
        if (m_rPr)
        {
            delete m_rPr;
            m_rPr = NULL;
        }
    
            
                m_has_t = false;
                
        if (m_t)
        {
            delete m_t;
            m_t = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_rPr)
                {
                    m_rPr->toXml(rPr, _outStream);;
                }
            
                if (m_has_t)
                {
                    _outStream << \<t>\ << m_rPr->toString() << \</t>\;;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_RElt& default_instance(){

    if (!CT_RElt::default_instance_)
    {
        CT_RElt::default_instance_ = new CT_RElt();
    }
    return *CT_RElt::default_instance_;

        }

    private:
        bool m_has_rPr ;
        CT_RPrElt* m_rPr ;
        bool m_has_t ;
        ns_s::ST_Xstring* m_t ;
        static CT_RElt* default_instance_ ;

    }

    class CT_RPrElt : public XSD::ComplexType{
    public:
        CT_FontName* add_rFont(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_FontName* pNewChild = pChildGroup->mutable_rFont();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_IntProperty* add_charset(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_IntProperty* pNewChild = pChildGroup->mutable_charset();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_IntProperty* add_family(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_IntProperty* pNewChild = pChildGroup->mutable_family();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_BooleanProperty* add_b(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_BooleanProperty* pNewChild = pChildGroup->mutable_b();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_BooleanProperty* add_i(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_BooleanProperty* pNewChild = pChildGroup->mutable_i();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_BooleanProperty* add_strike(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_BooleanProperty* pNewChild = pChildGroup->mutable_strike();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_BooleanProperty* add_outline(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_BooleanProperty* pNewChild = pChildGroup->mutable_outline();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_BooleanProperty* add_shadow(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_BooleanProperty* pNewChild = pChildGroup->mutable_shadow();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_BooleanProperty* add_condense(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_BooleanProperty* pNewChild = pChildGroup->mutable_condense();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_BooleanProperty* add_extend(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_BooleanProperty* pNewChild = pChildGroup->mutable_extend();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_Color* add_color(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_Color* pNewChild = pChildGroup->mutable_color();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_FontSize* add_sz(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_FontSize* pNewChild = pChildGroup->mutable_sz();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_UnderlineProperty* add_u(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_UnderlineProperty* pNewChild = pChildGroup->mutable_u();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_VerticalAlignFontProperty* add_vertAlign(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_VerticalAlignFontProperty* pNewChild = pChildGroup->mutable_vertAlign();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_FontScheme* add_scheme(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_FontScheme* pNewChild = pChildGroup->mutable_scheme();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        void clear(){

            vector<ChildGroup_1*>::iterator iter;
            for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
            {
                delete *iter;
            }
            m_childGroupList_1.clear();
        
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_rFont())
            {
                (*iter)->toXml(rFont, _outStream);
            }
            else if ((*iter)->has_charset())
            {
                (*iter)->toXml(charset, _outStream);
            }
            else if ((*iter)->has_family())
            {
                (*iter)->toXml(family, _outStream);
            }
            else if ((*iter)->has_b())
            {
                (*iter)->toXml(b, _outStream);
            }
            else if ((*iter)->has_i())
            {
                (*iter)->toXml(i, _outStream);
            }
            else if ((*iter)->has_strike())
            {
                (*iter)->toXml(strike, _outStream);
            }
            else if ((*iter)->has_outline())
            {
                (*iter)->toXml(outline, _outStream);
            }
            else if ((*iter)->has_shadow())
            {
                (*iter)->toXml(shadow, _outStream);
            }
            else if ((*iter)->has_condense())
            {
                (*iter)->toXml(condense, _outStream);
            }
            else if ((*iter)->has_extend())
            {
                (*iter)->toXml(extend, _outStream);
            }
            else if ((*iter)->has_color())
            {
                (*iter)->toXml(color, _outStream);
            }
            else if ((*iter)->has_sz())
            {
                (*iter)->toXml(sz, _outStream);
            }
            else if ((*iter)->has_u())
            {
                (*iter)->toXml(u, _outStream);
            }
            else if ((*iter)->has_vertAlign())
            {
                (*iter)->toXml(vertAlign, _outStream);
            }
            else if ((*iter)->has_scheme())
            {
                (*iter)->toXml(scheme, _outStream);
            }
        }
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_RPrElt& default_instance(){

    if (!CT_RPrElt::default_instance_)
    {
        CT_RPrElt::default_instance_ = new CT_RPrElt();
    }
    return *CT_RPrElt::default_instance_;

        }

    private:
        vector<ChildGroup_1*> m_childGroupList_1 ;
        static CT_RPrElt* default_instance_ ;
        class ChildGroup_1{
        public:
            bool has_rFont(){

            return m_has_rFont;
        
            }
            CT_FontName* mutable_rFont(){

                
                m_has_charset = false;
                
        if (m_charset)
        {
            delete m_charset;
            m_charset = NULL;
        }
    ;
            
                m_has_family = false;
                
        if (m_family)
        {
            delete m_family;
            m_family = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_i = false;
                
        if (m_i)
        {
            delete m_i;
            m_i = NULL;
        }
    ;
            
                m_has_strike = false;
                
        if (m_strike)
        {
            delete m_strike;
            m_strike = NULL;
        }
    ;
            
                m_has_outline = false;
                
        if (m_outline)
        {
            delete m_outline;
            m_outline = NULL;
        }
    ;
            
                m_has_shadow = false;
                
        if (m_shadow)
        {
            delete m_shadow;
            m_shadow = NULL;
        }
    ;
            
                m_has_condense = false;
                
        if (m_condense)
        {
            delete m_condense;
            m_condense = NULL;
        }
    ;
            
                m_has_extend = false;
                
        if (m_extend)
        {
            delete m_extend;
            m_extend = NULL;
        }
    ;
            
                m_has_color = false;
                
        if (m_color)
        {
            delete m_color;
            m_color = NULL;
        }
    ;
            
                m_has_sz = false;
                
        if (m_sz)
        {
            delete m_sz;
            m_sz = NULL;
        }
    ;
            
                m_has_u = false;
                
        if (m_u)
        {
            delete m_u;
            m_u = NULL;
        }
    ;
            
                m_has_vertAlign = false;
                
        if (m_vertAlign)
        {
            delete m_vertAlign;
            m_vertAlign = NULL;
        }
    ;
            
                m_has_scheme = false;
                
        if (m_scheme)
        {
            delete m_scheme;
            m_scheme = NULL;
        }
    ;
            
                m_has_rFont = true;
                if (!m_rFont)
                {
                    m_rFont = new CT_FontName();
                }
                return m_rFont;
            
            }
            const CT_FontName& rFont(){

            if (m_rFont)
            {
                return *m_rFont;
            }
            return CT_FontName::default_instance();
        
            }
            bool has_charset(){

            return m_has_charset;
        
            }
            CT_IntProperty* mutable_charset(){

                
                m_has_rFont = false;
                
        if (m_rFont)
        {
            delete m_rFont;
            m_rFont = NULL;
        }
    ;
            
                m_has_family = false;
                
        if (m_family)
        {
            delete m_family;
            m_family = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_i = false;
                
        if (m_i)
        {
            delete m_i;
            m_i = NULL;
        }
    ;
            
                m_has_strike = false;
                
        if (m_strike)
        {
            delete m_strike;
            m_strike = NULL;
        }
    ;
            
                m_has_outline = false;
                
        if (m_outline)
        {
            delete m_outline;
            m_outline = NULL;
        }
    ;
            
                m_has_shadow = false;
                
        if (m_shadow)
        {
            delete m_shadow;
            m_shadow = NULL;
        }
    ;
            
                m_has_condense = false;
                
        if (m_condense)
        {
            delete m_condense;
            m_condense = NULL;
        }
    ;
            
                m_has_extend = false;
                
        if (m_extend)
        {
            delete m_extend;
            m_extend = NULL;
        }
    ;
            
                m_has_color = false;
                
        if (m_color)
        {
            delete m_color;
            m_color = NULL;
        }
    ;
            
                m_has_sz = false;
                
        if (m_sz)
        {
            delete m_sz;
            m_sz = NULL;
        }
    ;
            
                m_has_u = false;
                
        if (m_u)
        {
            delete m_u;
            m_u = NULL;
        }
    ;
            
                m_has_vertAlign = false;
                
        if (m_vertAlign)
        {
            delete m_vertAlign;
            m_vertAlign = NULL;
        }
    ;
            
                m_has_scheme = false;
                
        if (m_scheme)
        {
            delete m_scheme;
            m_scheme = NULL;
        }
    ;
            
                m_has_charset = true;
                if (!m_charset)
                {
                    m_charset = new CT_IntProperty();
                }
                return m_charset;
            
            }
            const CT_IntProperty& charset(){

            if (m_charset)
            {
                return *m_charset;
            }
            return CT_IntProperty::default_instance();
        
            }
            bool has_family(){

            return m_has_family;
        
            }
            CT_IntProperty* mutable_family(){

                
                m_has_rFont = false;
                
        if (m_rFont)
        {
            delete m_rFont;
            m_rFont = NULL;
        }
    ;
            
                m_has_charset = false;
                
        if (m_charset)
        {
            delete m_charset;
            m_charset = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_i = false;
                
        if (m_i)
        {
            delete m_i;
            m_i = NULL;
        }
    ;
            
                m_has_strike = false;
                
        if (m_strike)
        {
            delete m_strike;
            m_strike = NULL;
        }
    ;
            
                m_has_outline = false;
                
        if (m_outline)
        {
            delete m_outline;
            m_outline = NULL;
        }
    ;
            
                m_has_shadow = false;
                
        if (m_shadow)
        {
            delete m_shadow;
            m_shadow = NULL;
        }
    ;
            
                m_has_condense = false;
                
        if (m_condense)
        {
            delete m_condense;
            m_condense = NULL;
        }
    ;
            
                m_has_extend = false;
                
        if (m_extend)
        {
            delete m_extend;
            m_extend = NULL;
        }
    ;
            
                m_has_color = false;
                
        if (m_color)
        {
            delete m_color;
            m_color = NULL;
        }
    ;
            
                m_has_sz = false;
                
        if (m_sz)
        {
            delete m_sz;
            m_sz = NULL;
        }
    ;
            
                m_has_u = false;
                
        if (m_u)
        {
            delete m_u;
            m_u = NULL;
        }
    ;
            
                m_has_vertAlign = false;
                
        if (m_vertAlign)
        {
            delete m_vertAlign;
            m_vertAlign = NULL;
        }
    ;
            
                m_has_scheme = false;
                
        if (m_scheme)
        {
            delete m_scheme;
            m_scheme = NULL;
        }
    ;
            
                m_has_family = true;
                if (!m_family)
                {
                    m_family = new CT_IntProperty();
                }
                return m_family;
            
            }
            const CT_IntProperty& family(){

            if (m_family)
            {
                return *m_family;
            }
            return CT_IntProperty::default_instance();
        
            }
            bool has_b(){

            return m_has_b;
        
            }
            CT_BooleanProperty* mutable_b(){

                
                m_has_rFont = false;
                
        if (m_rFont)
        {
            delete m_rFont;
            m_rFont = NULL;
        }
    ;
            
                m_has_charset = false;
                
        if (m_charset)
        {
            delete m_charset;
            m_charset = NULL;
        }
    ;
            
                m_has_family = false;
                
        if (m_family)
        {
            delete m_family;
            m_family = NULL;
        }
    ;
            
                m_has_i = false;
                
        if (m_i)
        {
            delete m_i;
            m_i = NULL;
        }
    ;
            
                m_has_strike = false;
                
        if (m_strike)
        {
            delete m_strike;
            m_strike = NULL;
        }
    ;
            
                m_has_outline = false;
                
        if (m_outline)
        {
            delete m_outline;
            m_outline = NULL;
        }
    ;
            
                m_has_shadow = false;
                
        if (m_shadow)
        {
            delete m_shadow;
            m_shadow = NULL;
        }
    ;
            
                m_has_condense = false;
                
        if (m_condense)
        {
            delete m_condense;
            m_condense = NULL;
        }
    ;
            
                m_has_extend = false;
                
        if (m_extend)
        {
            delete m_extend;
            m_extend = NULL;
        }
    ;
            
                m_has_color = false;
                
        if (m_color)
        {
            delete m_color;
            m_color = NULL;
        }
    ;
            
                m_has_sz = false;
                
        if (m_sz)
        {
            delete m_sz;
            m_sz = NULL;
        }
    ;
            
                m_has_u = false;
                
        if (m_u)
        {
            delete m_u;
            m_u = NULL;
        }
    ;
            
                m_has_vertAlign = false;
                
        if (m_vertAlign)
        {
            delete m_vertAlign;
            m_vertAlign = NULL;
        }
    ;
            
                m_has_scheme = false;
                
        if (m_scheme)
        {
            delete m_scheme;
            m_scheme = NULL;
        }
    ;
            
                m_has_b = true;
                if (!m_b)
                {
                    m_b = new CT_BooleanProperty();
                }
                return m_b;
            
            }
            const CT_BooleanProperty& b(){

            if (m_b)
            {
                return *m_b;
            }
            return CT_BooleanProperty::default_instance();
        
            }
            bool has_i(){

            return m_has_i;
        
            }
            CT_BooleanProperty* mutable_i(){

                
                m_has_rFont = false;
                
        if (m_rFont)
        {
            delete m_rFont;
            m_rFont = NULL;
        }
    ;
            
                m_has_charset = false;
                
        if (m_charset)
        {
            delete m_charset;
            m_charset = NULL;
        }
    ;
            
                m_has_family = false;
                
        if (m_family)
        {
            delete m_family;
            m_family = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_strike = false;
                
        if (m_strike)
        {
            delete m_strike;
            m_strike = NULL;
        }
    ;
            
                m_has_outline = false;
                
        if (m_outline)
        {
            delete m_outline;
            m_outline = NULL;
        }
    ;
            
                m_has_shadow = false;
                
        if (m_shadow)
        {
            delete m_shadow;
            m_shadow = NULL;
        }
    ;
            
                m_has_condense = false;
                
        if (m_condense)
        {
            delete m_condense;
            m_condense = NULL;
        }
    ;
            
                m_has_extend = false;
                
        if (m_extend)
        {
            delete m_extend;
            m_extend = NULL;
        }
    ;
            
                m_has_color = false;
                
        if (m_color)
        {
            delete m_color;
            m_color = NULL;
        }
    ;
            
                m_has_sz = false;
                
        if (m_sz)
        {
            delete m_sz;
            m_sz = NULL;
        }
    ;
            
                m_has_u = false;
                
        if (m_u)
        {
            delete m_u;
            m_u = NULL;
        }
    ;
            
                m_has_vertAlign = false;
                
        if (m_vertAlign)
        {
            delete m_vertAlign;
            m_vertAlign = NULL;
        }
    ;
            
                m_has_scheme = false;
                
        if (m_scheme)
        {
            delete m_scheme;
            m_scheme = NULL;
        }
    ;
            
                m_has_i = true;
                if (!m_i)
                {
                    m_i = new CT_BooleanProperty();
                }
                return m_i;
            
            }
            const CT_BooleanProperty& i(){

            if (m_i)
            {
                return *m_i;
            }
            return CT_BooleanProperty::default_instance();
        
            }
            bool has_strike(){

            return m_has_strike;
        
            }
            CT_BooleanProperty* mutable_strike(){

                
                m_has_rFont = false;
                
        if (m_rFont)
        {
            delete m_rFont;
            m_rFont = NULL;
        }
    ;
            
                m_has_charset = false;
                
        if (m_charset)
        {
            delete m_charset;
            m_charset = NULL;
        }
    ;
            
                m_has_family = false;
                
        if (m_family)
        {
            delete m_family;
            m_family = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_i = false;
                
        if (m_i)
        {
            delete m_i;
            m_i = NULL;
        }
    ;
            
                m_has_outline = false;
                
        if (m_outline)
        {
            delete m_outline;
            m_outline = NULL;
        }
    ;
            
                m_has_shadow = false;
                
        if (m_shadow)
        {
            delete m_shadow;
            m_shadow = NULL;
        }
    ;
            
                m_has_condense = false;
                
        if (m_condense)
        {
            delete m_condense;
            m_condense = NULL;
        }
    ;
            
                m_has_extend = false;
                
        if (m_extend)
        {
            delete m_extend;
            m_extend = NULL;
        }
    ;
            
                m_has_color = false;
                
        if (m_color)
        {
            delete m_color;
            m_color = NULL;
        }
    ;
            
                m_has_sz = false;
                
        if (m_sz)
        {
            delete m_sz;
            m_sz = NULL;
        }
    ;
            
                m_has_u = false;
                
        if (m_u)
        {
            delete m_u;
            m_u = NULL;
        }
    ;
            
                m_has_vertAlign = false;
                
        if (m_vertAlign)
        {
            delete m_vertAlign;
            m_vertAlign = NULL;
        }
    ;
            
                m_has_scheme = false;
                
        if (m_scheme)
        {
            delete m_scheme;
            m_scheme = NULL;
        }
    ;
            
                m_has_strike = true;
                if (!m_strike)
                {
                    m_strike = new CT_BooleanProperty();
                }
                return m_strike;
            
            }
            const CT_BooleanProperty& strike(){

            if (m_strike)
            {
                return *m_strike;
            }
            return CT_BooleanProperty::default_instance();
        
            }
            bool has_outline(){

            return m_has_outline;
        
            }
            CT_BooleanProperty* mutable_outline(){

                
                m_has_rFont = false;
                
        if (m_rFont)
        {
            delete m_rFont;
            m_rFont = NULL;
        }
    ;
            
                m_has_charset = false;
                
        if (m_charset)
        {
            delete m_charset;
            m_charset = NULL;
        }
    ;
            
                m_has_family = false;
                
        if (m_family)
        {
            delete m_family;
            m_family = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_i = false;
                
        if (m_i)
        {
            delete m_i;
            m_i = NULL;
        }
    ;
            
                m_has_strike = false;
                
        if (m_strike)
        {
            delete m_strike;
            m_strike = NULL;
        }
    ;
            
                m_has_shadow = false;
                
        if (m_shadow)
        {
            delete m_shadow;
            m_shadow = NULL;
        }
    ;
            
                m_has_condense = false;
                
        if (m_condense)
        {
            delete m_condense;
            m_condense = NULL;
        }
    ;
            
                m_has_extend = false;
                
        if (m_extend)
        {
            delete m_extend;
            m_extend = NULL;
        }
    ;
            
                m_has_color = false;
                
        if (m_color)
        {
            delete m_color;
            m_color = NULL;
        }
    ;
            
                m_has_sz = false;
                
        if (m_sz)
        {
            delete m_sz;
            m_sz = NULL;
        }
    ;
            
                m_has_u = false;
                
        if (m_u)
        {
            delete m_u;
            m_u = NULL;
        }
    ;
            
                m_has_vertAlign = false;
                
        if (m_vertAlign)
        {
            delete m_vertAlign;
            m_vertAlign = NULL;
        }
    ;
            
                m_has_scheme = false;
                
        if (m_scheme)
        {
            delete m_scheme;
            m_scheme = NULL;
        }
    ;
            
                m_has_outline = true;
                if (!m_outline)
                {
                    m_outline = new CT_BooleanProperty();
                }
                return m_outline;
            
            }
            const CT_BooleanProperty& outline(){

            if (m_outline)
            {
                return *m_outline;
            }
            return CT_BooleanProperty::default_instance();
        
            }
            bool has_shadow(){

            return m_has_shadow;
        
            }
            CT_BooleanProperty* mutable_shadow(){

                
                m_has_rFont = false;
                
        if (m_rFont)
        {
            delete m_rFont;
            m_rFont = NULL;
        }
    ;
            
                m_has_charset = false;
                
        if (m_charset)
        {
            delete m_charset;
            m_charset = NULL;
        }
    ;
            
                m_has_family = false;
                
        if (m_family)
        {
            delete m_family;
            m_family = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_i = false;
                
        if (m_i)
        {
            delete m_i;
            m_i = NULL;
        }
    ;
            
                m_has_strike = false;
                
        if (m_strike)
        {
            delete m_strike;
            m_strike = NULL;
        }
    ;
            
                m_has_outline = false;
                
        if (m_outline)
        {
            delete m_outline;
            m_outline = NULL;
        }
    ;
            
                m_has_condense = false;
                
        if (m_condense)
        {
            delete m_condense;
            m_condense = NULL;
        }
    ;
            
                m_has_extend = false;
                
        if (m_extend)
        {
            delete m_extend;
            m_extend = NULL;
        }
    ;
            
                m_has_color = false;
                
        if (m_color)
        {
            delete m_color;
            m_color = NULL;
        }
    ;
            
                m_has_sz = false;
                
        if (m_sz)
        {
            delete m_sz;
            m_sz = NULL;
        }
    ;
            
                m_has_u = false;
                
        if (m_u)
        {
            delete m_u;
            m_u = NULL;
        }
    ;
            
                m_has_vertAlign = false;
                
        if (m_vertAlign)
        {
            delete m_vertAlign;
            m_vertAlign = NULL;
        }
    ;
            
                m_has_scheme = false;
                
        if (m_scheme)
        {
            delete m_scheme;
            m_scheme = NULL;
        }
    ;
            
                m_has_shadow = true;
                if (!m_shadow)
                {
                    m_shadow = new CT_BooleanProperty();
                }
                return m_shadow;
            
            }
            const CT_BooleanProperty& shadow(){

            if (m_shadow)
            {
                return *m_shadow;
            }
            return CT_BooleanProperty::default_instance();
        
            }
            bool has_condense(){

            return m_has_condense;
        
            }
            CT_BooleanProperty* mutable_condense(){

                
                m_has_rFont = false;
                
        if (m_rFont)
        {
            delete m_rFont;
            m_rFont = NULL;
        }
    ;
            
                m_has_charset = false;
                
        if (m_charset)
        {
            delete m_charset;
            m_charset = NULL;
        }
    ;
            
                m_has_family = false;
                
        if (m_family)
        {
            delete m_family;
            m_family = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_i = false;
                
        if (m_i)
        {
            delete m_i;
            m_i = NULL;
        }
    ;
            
                m_has_strike = false;
                
        if (m_strike)
        {
            delete m_strike;
            m_strike = NULL;
        }
    ;
            
                m_has_outline = false;
                
        if (m_outline)
        {
            delete m_outline;
            m_outline = NULL;
        }
    ;
            
                m_has_shadow = false;
                
        if (m_shadow)
        {
            delete m_shadow;
            m_shadow = NULL;
        }
    ;
            
                m_has_extend = false;
                
        if (m_extend)
        {
            delete m_extend;
            m_extend = NULL;
        }
    ;
            
                m_has_color = false;
                
        if (m_color)
        {
            delete m_color;
            m_color = NULL;
        }
    ;
            
                m_has_sz = false;
                
        if (m_sz)
        {
            delete m_sz;
            m_sz = NULL;
        }
    ;
            
                m_has_u = false;
                
        if (m_u)
        {
            delete m_u;
            m_u = NULL;
        }
    ;
            
                m_has_vertAlign = false;
                
        if (m_vertAlign)
        {
            delete m_vertAlign;
            m_vertAlign = NULL;
        }
    ;
            
                m_has_scheme = false;
                
        if (m_scheme)
        {
            delete m_scheme;
            m_scheme = NULL;
        }
    ;
            
                m_has_condense = true;
                if (!m_condense)
                {
                    m_condense = new CT_BooleanProperty();
                }
                return m_condense;
            
            }
            const CT_BooleanProperty& condense(){

            if (m_condense)
            {
                return *m_condense;
            }
            return CT_BooleanProperty::default_instance();
        
            }
            bool has_extend(){

            return m_has_extend;
        
            }
            CT_BooleanProperty* mutable_extend(){

                
                m_has_rFont = false;
                
        if (m_rFont)
        {
            delete m_rFont;
            m_rFont = NULL;
        }
    ;
            
                m_has_charset = false;
                
        if (m_charset)
        {
            delete m_charset;
            m_charset = NULL;
        }
    ;
            
                m_has_family = false;
                
        if (m_family)
        {
            delete m_family;
            m_family = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_i = false;
                
        if (m_i)
        {
            delete m_i;
            m_i = NULL;
        }
    ;
            
                m_has_strike = false;
                
        if (m_strike)
        {
            delete m_strike;
            m_strike = NULL;
        }
    ;
            
                m_has_outline = false;
                
        if (m_outline)
        {
            delete m_outline;
            m_outline = NULL;
        }
    ;
            
                m_has_shadow = false;
                
        if (m_shadow)
        {
            delete m_shadow;
            m_shadow = NULL;
        }
    ;
            
                m_has_condense = false;
                
        if (m_condense)
        {
            delete m_condense;
            m_condense = NULL;
        }
    ;
            
                m_has_color = false;
                
        if (m_color)
        {
            delete m_color;
            m_color = NULL;
        }
    ;
            
                m_has_sz = false;
                
        if (m_sz)
        {
            delete m_sz;
            m_sz = NULL;
        }
    ;
            
                m_has_u = false;
                
        if (m_u)
        {
            delete m_u;
            m_u = NULL;
        }
    ;
            
                m_has_vertAlign = false;
                
        if (m_vertAlign)
        {
            delete m_vertAlign;
            m_vertAlign = NULL;
        }
    ;
            
                m_has_scheme = false;
                
        if (m_scheme)
        {
            delete m_scheme;
            m_scheme = NULL;
        }
    ;
            
                m_has_extend = true;
                if (!m_extend)
                {
                    m_extend = new CT_BooleanProperty();
                }
                return m_extend;
            
            }
            const CT_BooleanProperty& extend(){

            if (m_extend)
            {
                return *m_extend;
            }
            return CT_BooleanProperty::default_instance();
        
            }
            bool has_color(){

            return m_has_color;
        
            }
            CT_Color* mutable_color(){

                
                m_has_rFont = false;
                
        if (m_rFont)
        {
            delete m_rFont;
            m_rFont = NULL;
        }
    ;
            
                m_has_charset = false;
                
        if (m_charset)
        {
            delete m_charset;
            m_charset = NULL;
        }
    ;
            
                m_has_family = false;
                
        if (m_family)
        {
            delete m_family;
            m_family = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_i = false;
                
        if (m_i)
        {
            delete m_i;
            m_i = NULL;
        }
    ;
            
                m_has_strike = false;
                
        if (m_strike)
        {
            delete m_strike;
            m_strike = NULL;
        }
    ;
            
                m_has_outline = false;
                
        if (m_outline)
        {
            delete m_outline;
            m_outline = NULL;
        }
    ;
            
                m_has_shadow = false;
                
        if (m_shadow)
        {
            delete m_shadow;
            m_shadow = NULL;
        }
    ;
            
                m_has_condense = false;
                
        if (m_condense)
        {
            delete m_condense;
            m_condense = NULL;
        }
    ;
            
                m_has_extend = false;
                
        if (m_extend)
        {
            delete m_extend;
            m_extend = NULL;
        }
    ;
            
                m_has_sz = false;
                
        if (m_sz)
        {
            delete m_sz;
            m_sz = NULL;
        }
    ;
            
                m_has_u = false;
                
        if (m_u)
        {
            delete m_u;
            m_u = NULL;
        }
    ;
            
                m_has_vertAlign = false;
                
        if (m_vertAlign)
        {
            delete m_vertAlign;
            m_vertAlign = NULL;
        }
    ;
            
                m_has_scheme = false;
                
        if (m_scheme)
        {
            delete m_scheme;
            m_scheme = NULL;
        }
    ;
            
                m_has_color = true;
                if (!m_color)
                {
                    m_color = new CT_Color();
                }
                return m_color;
            
            }
            const CT_Color& color(){

            if (m_color)
            {
                return *m_color;
            }
            return CT_Color::default_instance();
        
            }
            bool has_sz(){

            return m_has_sz;
        
            }
            CT_FontSize* mutable_sz(){

                
                m_has_rFont = false;
                
        if (m_rFont)
        {
            delete m_rFont;
            m_rFont = NULL;
        }
    ;
            
                m_has_charset = false;
                
        if (m_charset)
        {
            delete m_charset;
            m_charset = NULL;
        }
    ;
            
                m_has_family = false;
                
        if (m_family)
        {
            delete m_family;
            m_family = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_i = false;
                
        if (m_i)
        {
            delete m_i;
            m_i = NULL;
        }
    ;
            
                m_has_strike = false;
                
        if (m_strike)
        {
            delete m_strike;
            m_strike = NULL;
        }
    ;
            
                m_has_outline = false;
                
        if (m_outline)
        {
            delete m_outline;
            m_outline = NULL;
        }
    ;
            
                m_has_shadow = false;
                
        if (m_shadow)
        {
            delete m_shadow;
            m_shadow = NULL;
        }
    ;
            
                m_has_condense = false;
                
        if (m_condense)
        {
            delete m_condense;
            m_condense = NULL;
        }
    ;
            
                m_has_extend = false;
                
        if (m_extend)
        {
            delete m_extend;
            m_extend = NULL;
        }
    ;
            
                m_has_color = false;
                
        if (m_color)
        {
            delete m_color;
            m_color = NULL;
        }
    ;
            
                m_has_u = false;
                
        if (m_u)
        {
            delete m_u;
            m_u = NULL;
        }
    ;
            
                m_has_vertAlign = false;
                
        if (m_vertAlign)
        {
            delete m_vertAlign;
            m_vertAlign = NULL;
        }
    ;
            
                m_has_scheme = false;
                
        if (m_scheme)
        {
            delete m_scheme;
            m_scheme = NULL;
        }
    ;
            
                m_has_sz = true;
                if (!m_sz)
                {
                    m_sz = new CT_FontSize();
                }
                return m_sz;
            
            }
            const CT_FontSize& sz(){

            if (m_sz)
            {
                return *m_sz;
            }
            return CT_FontSize::default_instance();
        
            }
            bool has_u(){

            return m_has_u;
        
            }
            CT_UnderlineProperty* mutable_u(){

                
                m_has_rFont = false;
                
        if (m_rFont)
        {
            delete m_rFont;
            m_rFont = NULL;
        }
    ;
            
                m_has_charset = false;
                
        if (m_charset)
        {
            delete m_charset;
            m_charset = NULL;
        }
    ;
            
                m_has_family = false;
                
        if (m_family)
        {
            delete m_family;
            m_family = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_i = false;
                
        if (m_i)
        {
            delete m_i;
            m_i = NULL;
        }
    ;
            
                m_has_strike = false;
                
        if (m_strike)
        {
            delete m_strike;
            m_strike = NULL;
        }
    ;
            
                m_has_outline = false;
                
        if (m_outline)
        {
            delete m_outline;
            m_outline = NULL;
        }
    ;
            
                m_has_shadow = false;
                
        if (m_shadow)
        {
            delete m_shadow;
            m_shadow = NULL;
        }
    ;
            
                m_has_condense = false;
                
        if (m_condense)
        {
            delete m_condense;
            m_condense = NULL;
        }
    ;
            
                m_has_extend = false;
                
        if (m_extend)
        {
            delete m_extend;
            m_extend = NULL;
        }
    ;
            
                m_has_color = false;
                
        if (m_color)
        {
            delete m_color;
            m_color = NULL;
        }
    ;
            
                m_has_sz = false;
                
        if (m_sz)
        {
            delete m_sz;
            m_sz = NULL;
        }
    ;
            
                m_has_vertAlign = false;
                
        if (m_vertAlign)
        {
            delete m_vertAlign;
            m_vertAlign = NULL;
        }
    ;
            
                m_has_scheme = false;
                
        if (m_scheme)
        {
            delete m_scheme;
            m_scheme = NULL;
        }
    ;
            
                m_has_u = true;
                if (!m_u)
                {
                    m_u = new CT_UnderlineProperty();
                }
                return m_u;
            
            }
            const CT_UnderlineProperty& u(){

            if (m_u)
            {
                return *m_u;
            }
            return CT_UnderlineProperty::default_instance();
        
            }
            bool has_vertAlign(){

            return m_has_vertAlign;
        
            }
            CT_VerticalAlignFontProperty* mutable_vertAlign(){

                
                m_has_rFont = false;
                
        if (m_rFont)
        {
            delete m_rFont;
            m_rFont = NULL;
        }
    ;
            
                m_has_charset = false;
                
        if (m_charset)
        {
            delete m_charset;
            m_charset = NULL;
        }
    ;
            
                m_has_family = false;
                
        if (m_family)
        {
            delete m_family;
            m_family = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_i = false;
                
        if (m_i)
        {
            delete m_i;
            m_i = NULL;
        }
    ;
            
                m_has_strike = false;
                
        if (m_strike)
        {
            delete m_strike;
            m_strike = NULL;
        }
    ;
            
                m_has_outline = false;
                
        if (m_outline)
        {
            delete m_outline;
            m_outline = NULL;
        }
    ;
            
                m_has_shadow = false;
                
        if (m_shadow)
        {
            delete m_shadow;
            m_shadow = NULL;
        }
    ;
            
                m_has_condense = false;
                
        if (m_condense)
        {
            delete m_condense;
            m_condense = NULL;
        }
    ;
            
                m_has_extend = false;
                
        if (m_extend)
        {
            delete m_extend;
            m_extend = NULL;
        }
    ;
            
                m_has_color = false;
                
        if (m_color)
        {
            delete m_color;
            m_color = NULL;
        }
    ;
            
                m_has_sz = false;
                
        if (m_sz)
        {
            delete m_sz;
            m_sz = NULL;
        }
    ;
            
                m_has_u = false;
                
        if (m_u)
        {
            delete m_u;
            m_u = NULL;
        }
    ;
            
                m_has_scheme = false;
                
        if (m_scheme)
        {
            delete m_scheme;
            m_scheme = NULL;
        }
    ;
            
                m_has_vertAlign = true;
                if (!m_vertAlign)
                {
                    m_vertAlign = new CT_VerticalAlignFontProperty();
                }
                return m_vertAlign;
            
            }
            const CT_VerticalAlignFontProperty& vertAlign(){

            if (m_vertAlign)
            {
                return *m_vertAlign;
            }
            return CT_VerticalAlignFontProperty::default_instance();
        
            }
            bool has_scheme(){

            return m_has_scheme;
        
            }
            CT_FontScheme* mutable_scheme(){

                
                m_has_rFont = false;
                
        if (m_rFont)
        {
            delete m_rFont;
            m_rFont = NULL;
        }
    ;
            
                m_has_charset = false;
                
        if (m_charset)
        {
            delete m_charset;
            m_charset = NULL;
        }
    ;
            
                m_has_family = false;
                
        if (m_family)
        {
            delete m_family;
            m_family = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_i = false;
                
        if (m_i)
        {
            delete m_i;
            m_i = NULL;
        }
    ;
            
                m_has_strike = false;
                
        if (m_strike)
        {
            delete m_strike;
            m_strike = NULL;
        }
    ;
            
                m_has_outline = false;
                
        if (m_outline)
        {
            delete m_outline;
            m_outline = NULL;
        }
    ;
            
                m_has_shadow = false;
                
        if (m_shadow)
        {
            delete m_shadow;
            m_shadow = NULL;
        }
    ;
            
                m_has_condense = false;
                
        if (m_condense)
        {
            delete m_condense;
            m_condense = NULL;
        }
    ;
            
                m_has_extend = false;
                
        if (m_extend)
        {
            delete m_extend;
            m_extend = NULL;
        }
    ;
            
                m_has_color = false;
                
        if (m_color)
        {
            delete m_color;
            m_color = NULL;
        }
    ;
            
                m_has_sz = false;
                
        if (m_sz)
        {
            delete m_sz;
            m_sz = NULL;
        }
    ;
            
                m_has_u = false;
                
        if (m_u)
        {
            delete m_u;
            m_u = NULL;
        }
    ;
            
                m_has_vertAlign = false;
                
        if (m_vertAlign)
        {
            delete m_vertAlign;
            m_vertAlign = NULL;
        }
    ;
            
                m_has_scheme = true;
                if (!m_scheme)
                {
                    m_scheme = new CT_FontScheme();
                }
                return m_scheme;
            
            }
            const CT_FontScheme& scheme(){

            if (m_scheme)
            {
                return *m_scheme;
            }
            return CT_FontScheme::default_instance();
        
            }

        private:
            bool m_has_rFont ;
            CT_FontName* m_rFont ;
            bool m_has_charset ;
            CT_IntProperty* m_charset ;
            bool m_has_family ;
            CT_IntProperty* m_family ;
            bool m_has_b ;
            CT_BooleanProperty* m_b ;
            bool m_has_i ;
            CT_BooleanProperty* m_i ;
            bool m_has_strike ;
            CT_BooleanProperty* m_strike ;
            bool m_has_outline ;
            CT_BooleanProperty* m_outline ;
            bool m_has_shadow ;
            CT_BooleanProperty* m_shadow ;
            bool m_has_condense ;
            CT_BooleanProperty* m_condense ;
            bool m_has_extend ;
            CT_BooleanProperty* m_extend ;
            bool m_has_color ;
            CT_Color* m_color ;
            bool m_has_sz ;
            CT_FontSize* m_sz ;
            bool m_has_u ;
            CT_UnderlineProperty* m_u ;
            bool m_has_vertAlign ;
            CT_VerticalAlignFontProperty* m_vertAlign ;
            bool m_has_scheme ;
            CT_FontScheme* m_scheme ;

        }


    }

    class CT_Rst : public XSD::ComplexType{
    public:
        bool has_t(){

            return m_has_t;
        
        }
        ns_s::ST_Xstring* mutable_t(){

                m_has_t = true;
                if (!m_t)
                {
                    m_t = new ns_s::ST_Xstring();
                }
                return m_t;
            
        }
        const ns_s::ST_Xstring& t(){

            if (m_t)
            {
                return *m_t;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_r(){

            return m_has_r;
        
        }
        CT_RElt* mutable_r(){

                m_has_r = true;
                if (!m_r)
                {
                    m_r = new CT_RElt();
                }
                return m_r;
            
        }
        const CT_RElt& r(){

            if (m_r)
            {
                return *m_r;
            }
            return CT_RElt::default_instance();
        
        }
        bool has_rPh(){

            return m_has_rPh;
        
        }
        CT_PhoneticRun* mutable_rPh(){

                m_has_rPh = true;
                if (!m_rPh)
                {
                    m_rPh = new CT_PhoneticRun();
                }
                return m_rPh;
            
        }
        const CT_PhoneticRun& rPh(){

            if (m_rPh)
            {
                return *m_rPh;
            }
            return CT_PhoneticRun::default_instance();
        
        }
        bool has_phoneticPr(){

            return m_has_phoneticPr;
        
        }
        CT_PhoneticPr* mutable_phoneticPr(){

                m_has_phoneticPr = true;
                if (!m_phoneticPr)
                {
                    m_phoneticPr = new CT_PhoneticPr();
                }
                return m_phoneticPr;
            
        }
        const CT_PhoneticPr& phoneticPr(){

            if (m_phoneticPr)
            {
                return *m_phoneticPr;
            }
            return CT_PhoneticPr::default_instance();
        
        }
        void clear(){

                m_has_t = false;
                
        if (m_t)
        {
            delete m_t;
            m_t = NULL;
        }
    
            
                m_has_r = false;
                
        if (m_r)
        {
            delete m_r;
            m_r = NULL;
        }
    
            
                m_has_rPh = false;
                
        if (m_rPh)
        {
            delete m_rPh;
            m_rPh = NULL;
        }
    
            
                m_has_phoneticPr = false;
                
        if (m_phoneticPr)
        {
            delete m_phoneticPr;
            m_phoneticPr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_t)
                {
                    _outStream << \<t>\ << m_t->toString() << \</t>\;;
                }
            
                if (m_has_r)
                {
                    m_t->toXml(r, _outStream);;
                }
            
                if (m_has_rPh)
                {
                    m_t->toXml(rPh, _outStream);;
                }
            
                if (m_has_phoneticPr)
                {
                    m_t->toXml(phoneticPr, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Rst& default_instance(){

    if (!CT_Rst::default_instance_)
    {
        CT_Rst::default_instance_ = new CT_Rst();
    }
    return *CT_Rst::default_instance_;

        }

    private:
        bool m_has_t ;
        ns_s::ST_Xstring* m_t ;
        bool m_has_r ;
        CT_RElt* m_r ;
        bool m_has_rPh ;
        CT_PhoneticRun* m_rPh ;
        bool m_has_phoneticPr ;
        CT_PhoneticPr* m_phoneticPr ;
        static CT_Rst* default_instance_ ;

    }

    class CT_PhoneticPr : public XSD::ComplexType{
    public:
        void clear(){

                m_has_fontId_attr = false;
                
        if (m_fontId_attr)
        {
            delete m_fontId_attr;
            m_fontId_attr = NULL;
        }
    
            
                m_has_type_attr = false;
                
        if (m_type_attr)
        {
            delete m_type_attr;
            m_type_attr = NULL;
        }
    
            
                m_has_alignment_attr = false;
                
        if (m_alignment_attr)
        {
            delete m_alignment_attr;
            m_alignment_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_fontId_attr->toXml(_attrName, _outStream);
m_type_attr->toXml(_attrName, _outStream);
m_alignment_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_PhoneticPr& default_instance(){

    if (!CT_PhoneticPr::default_instance_)
    {
        CT_PhoneticPr::default_instance_ = new CT_PhoneticPr();
    }
    return *CT_PhoneticPr::default_instance_;

        }
        bool has_fontId_attr(){

            return m_has_fontId_attr;
        
        }
        void set_fontId_attr(const ST_FontId& _fontId_attr ){

            m_has_fontId_attr = true;
            m_fontId_attr = new ST_FontId(_fontId_attr);
        
        }
        const ST_FontId& fontId_attr(){

            if (m_fontId_attr)
            {
                return *m_fontId_attr;
            }
            return ST_FontId::default_instance();
        
        }
        bool has_type_attr(){

            return m_has_type_attr;
        
        }
        void set_type_attr(const ST_PhoneticType& _type_attr ){

            m_has_type_attr = true;
            m_type_attr = new ST_PhoneticType(_type_attr);
        
        }
        const ST_PhoneticType& type_attr(){

            if (m_type_attr)
            {
                return *m_type_attr;
            }
            return ST_PhoneticType::default_instance();
        
        }
        bool has_alignment_attr(){

            return m_has_alignment_attr;
        
        }
        void set_alignment_attr(const ST_PhoneticAlignment& _alignment_attr ){

            m_has_alignment_attr = true;
            m_alignment_attr = new ST_PhoneticAlignment(_alignment_attr);
        
        }
        const ST_PhoneticAlignment& alignment_attr(){

            if (m_alignment_attr)
            {
                return *m_alignment_attr;
            }
            return ST_PhoneticAlignment::default_instance();
        
        }

    private:
        static CT_PhoneticPr* default_instance_ ;
        bool m_has_fontId_attr ;
        ST_FontId* m_fontId_attr ;
        bool m_has_type_attr ;
        ST_PhoneticType* m_type_attr ;
        bool m_has_alignment_attr ;
        ST_PhoneticAlignment* m_alignment_attr ;

    }

    class CT_RevisionHeaders : public XSD::ComplexType{
    public:
        bool has_header(){

            return m_has_header;
        
        }
        CT_RevisionHeader* mutable_header(){

                m_has_header = true;
                if (!m_header)
                {
                    m_header = new CT_RevisionHeader();
                }
                return m_header;
            
        }
        const CT_RevisionHeader& header(){

            if (m_header)
            {
                return *m_header;
            }
            return CT_RevisionHeader::default_instance();
        
        }
        void clear(){

                m_has_guid_attr = false;
                
        if (m_guid_attr)
        {
            delete m_guid_attr;
            m_guid_attr = NULL;
        }
    
            
                m_has_lastGuid_attr = false;
                
        if (m_lastGuid_attr)
        {
            delete m_lastGuid_attr;
            m_lastGuid_attr = NULL;
        }
    
            
                m_has_shared_attr = false;
                m_shared_attr = false;
            
                m_has_diskRevisions_attr = false;
                m_diskRevisions_attr = false;
            
                m_has_history_attr = false;
                m_history_attr = false;
            
                m_has_trackRevisions_attr = false;
                m_trackRevisions_attr = false;
            
                m_has_exclusive_attr = false;
                m_exclusive_attr = false;
            
                m_has_revisionId_attr = false;
                m_revisionId_attr = 0;
            
                m_has_version_attr = false;
                m_version_attr = 0;
            
                m_has_keepChangeHistory_attr = false;
                m_keepChangeHistory_attr = false;
            
                m_has_protected_attr = false;
                m_protected_attr = false;
            
                m_has_preserveHistory_attr = false;
                m_preserveHistory_attr = 0;
            
                m_has_header = false;
                
        if (m_header)
        {
            delete m_header;
            m_header = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_guid_attr->toXml(_attrName, _outStream);
m_lastGuid_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_shared_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_diskRevisions_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_history_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_trackRevisions_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_exclusive_attr) << \\\;
_outStream << _attrName << \=\\ << m_revisionId_attr << \\\;
_outStream << _attrName << \=\\ << m_version_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_keepChangeHistory_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_protected_attr) << \\\;
_outStream << _attrName << \=\\ << m_preserveHistory_attr << \\\;
        _outStream << \>\;
    
                if (m_has_header)
                {
                    m_header->toXml(header, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_RevisionHeaders& default_instance(){

    if (!CT_RevisionHeaders::default_instance_)
    {
        CT_RevisionHeaders::default_instance_ = new CT_RevisionHeaders();
    }
    return *CT_RevisionHeaders::default_instance_;

        }
        bool has_guid_attr(){

            return m_has_guid_attr;
        
        }
        void set_guid_attr(const ns_s::ST_Guid& _guid_attr ){

            m_has_guid_attr = true;
            m_guid_attr = new ns_s::ST_Guid(_guid_attr);
        
        }
        const ns_s::ST_Guid& guid_attr(){

            if (m_guid_attr)
            {
                return *m_guid_attr;
            }
            return ns_s::ST_Guid::default_instance();
        
        }
        bool has_lastGuid_attr(){

            return m_has_lastGuid_attr;
        
        }
        void set_lastGuid_attr(const ns_s::ST_Guid& _lastGuid_attr ){

            m_has_lastGuid_attr = true;
            m_lastGuid_attr = new ns_s::ST_Guid(_lastGuid_attr);
        
        }
        const ns_s::ST_Guid& lastGuid_attr(){

            if (m_lastGuid_attr)
            {
                return *m_lastGuid_attr;
            }
            return ns_s::ST_Guid::default_instance();
        
        }
        bool has_shared_attr(){

            return m_has_shared_attr;
        
        }
        void set_shared_attr(const boolean& _shared_attr ){

        m_has_shared_attr = true;
        m_shared_attr = _shared_attr;
        
        }
        const boolean& shared_attr(){

            return type: oolean\nname: \m_shared_attr\n;
        
        }
        bool has_diskRevisions_attr(){

            return m_has_diskRevisions_attr;
        
        }
        void set_diskRevisions_attr(const boolean& _diskRevisions_attr ){

        m_has_diskRevisions_attr = true;
        m_diskRevisions_attr = _diskRevisions_attr;
        
        }
        const boolean& diskRevisions_attr(){

            return type: oolean\nname: \m_diskRevisions_attr\n;
        
        }
        bool has_history_attr(){

            return m_has_history_attr;
        
        }
        void set_history_attr(const boolean& _history_attr ){

        m_has_history_attr = true;
        m_history_attr = _history_attr;
        
        }
        const boolean& history_attr(){

            return type: oolean\nname: \m_history_attr\n;
        
        }
        bool has_trackRevisions_attr(){

            return m_has_trackRevisions_attr;
        
        }
        void set_trackRevisions_attr(const boolean& _trackRevisions_attr ){

        m_has_trackRevisions_attr = true;
        m_trackRevisions_attr = _trackRevisions_attr;
        
        }
        const boolean& trackRevisions_attr(){

            return type: oolean\nname: \m_trackRevisions_attr\n;
        
        }
        bool has_exclusive_attr(){

            return m_has_exclusive_attr;
        
        }
        void set_exclusive_attr(const boolean& _exclusive_attr ){

        m_has_exclusive_attr = true;
        m_exclusive_attr = _exclusive_attr;
        
        }
        const boolean& exclusive_attr(){

            return type: oolean\nname: \m_exclusive_attr\n;
        
        }
        bool has_revisionId_attr(){

            return m_has_revisionId_attr;
        
        }
        void set_revisionId_attr(const unsignedInt& _revisionId_attr ){

        m_has_revisionId_attr = true;
        m_revisionId_attr = _revisionId_attr;
        
        }
        const unsignedInt& revisionId_attr(){

            return type: \unsignedInt\nname: \m_revisionId_attr\n;
        
        }
        bool has_version_attr(){

            return m_has_version_attr;
        
        }
        void set_version_attr(const int& _version_attr ){

        m_has_version_attr = true;
        m_version_attr = _version_attr;
        
        }
        const int& version_attr(){

            return type: \int\nname: \m_version_attr\n;
        
        }
        bool has_keepChangeHistory_attr(){

            return m_has_keepChangeHistory_attr;
        
        }
        void set_keepChangeHistory_attr(const boolean& _keepChangeHistory_attr ){

        m_has_keepChangeHistory_attr = true;
        m_keepChangeHistory_attr = _keepChangeHistory_attr;
        
        }
        const boolean& keepChangeHistory_attr(){

            return type: oolean\nname: \m_keepChangeHistory_attr\n;
        
        }
        bool has_protected_attr(){

            return m_has_protected_attr;
        
        }
        void set_protected_attr(const boolean& _protected_attr ){

        m_has_protected_attr = true;
        m_protected_attr = _protected_attr;
        
        }
        const boolean& protected_attr(){

            return type: oolean\nname: \m_protected_attr\n;
        
        }
        bool has_preserveHistory_attr(){

            return m_has_preserveHistory_attr;
        
        }
        void set_preserveHistory_attr(const unsignedInt& _preserveHistory_attr ){

        m_has_preserveHistory_attr = true;
        m_preserveHistory_attr = _preserveHistory_attr;
        
        }
        const unsignedInt& preserveHistory_attr(){

            return type: \unsignedInt\nname: \m_preserveHistory_attr\n;
        
        }

    private:
        bool m_has_header ;
        CT_RevisionHeader* m_header ;
        static CT_RevisionHeaders* default_instance_ ;
        bool m_has_guid_attr ;
        ns_s::ST_Guid* m_guid_attr ;
        bool m_has_lastGuid_attr ;
        ns_s::ST_Guid* m_lastGuid_attr ;
        bool m_has_shared_attr ;
        boolean m_shared_attr ;
        bool m_has_diskRevisions_attr ;
        boolean m_diskRevisions_attr ;
        bool m_has_history_attr ;
        boolean m_history_attr ;
        bool m_has_trackRevisions_attr ;
        boolean m_trackRevisions_attr ;
        bool m_has_exclusive_attr ;
        boolean m_exclusive_attr ;
        bool m_has_revisionId_attr ;
        unsignedInt m_revisionId_attr ;
        bool m_has_version_attr ;
        int m_version_attr ;
        bool m_has_keepChangeHistory_attr ;
        boolean m_keepChangeHistory_attr ;
        bool m_has_protected_attr ;
        boolean m_protected_attr ;
        bool m_has_preserveHistory_attr ;
        unsignedInt m_preserveHistory_attr ;

    }

    class CT_Revisions : public XSD::ComplexType{
    public:
        CT_RevisionRowColumn* add_rrc(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_RevisionRowColumn* pNewChild = pChildGroup->mutable_rrc();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_RevisionMove* add_rm(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_RevisionMove* pNewChild = pChildGroup->mutable_rm();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_RevisionCustomView* add_rcv(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_RevisionCustomView* pNewChild = pChildGroup->mutable_rcv();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_RevisionSheetRename* add_rsnm(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_RevisionSheetRename* pNewChild = pChildGroup->mutable_rsnm();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_RevisionInsertSheet* add_ris(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_RevisionInsertSheet* pNewChild = pChildGroup->mutable_ris();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_RevisionCellChange* add_rcc(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_RevisionCellChange* pNewChild = pChildGroup->mutable_rcc();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_RevisionFormatting* add_rfmt(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_RevisionFormatting* pNewChild = pChildGroup->mutable_rfmt();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_RevisionAutoFormatting* add_raf(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_RevisionAutoFormatting* pNewChild = pChildGroup->mutable_raf();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_RevisionDefinedName* add_rdn(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_RevisionDefinedName* pNewChild = pChildGroup->mutable_rdn();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_RevisionComment* add_rcmt(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_RevisionComment* pNewChild = pChildGroup->mutable_rcmt();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_RevisionQueryTableField* add_rqt(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_RevisionQueryTableField* pNewChild = pChildGroup->mutable_rqt();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_RevisionConflict* add_rcft(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_RevisionConflict* pNewChild = pChildGroup->mutable_rcft();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        void clear(){

            vector<ChildGroup_1*>::iterator iter;
            for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
            {
                delete *iter;
            }
            m_childGroupList_1.clear();
        
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_rrc())
            {
                (*iter)->toXml(rrc, _outStream);
            }
            else if ((*iter)->has_rm())
            {
                (*iter)->toXml(rm, _outStream);
            }
            else if ((*iter)->has_rcv())
            {
                (*iter)->toXml(rcv, _outStream);
            }
            else if ((*iter)->has_rsnm())
            {
                (*iter)->toXml(rsnm, _outStream);
            }
            else if ((*iter)->has_ris())
            {
                (*iter)->toXml(ris, _outStream);
            }
            else if ((*iter)->has_rcc())
            {
                (*iter)->toXml(rcc, _outStream);
            }
            else if ((*iter)->has_rfmt())
            {
                (*iter)->toXml(rfmt, _outStream);
            }
            else if ((*iter)->has_raf())
            {
                (*iter)->toXml(raf, _outStream);
            }
            else if ((*iter)->has_rdn())
            {
                (*iter)->toXml(rdn, _outStream);
            }
            else if ((*iter)->has_rcmt())
            {
                (*iter)->toXml(rcmt, _outStream);
            }
            else if ((*iter)->has_rqt())
            {
                (*iter)->toXml(rqt, _outStream);
            }
            else if ((*iter)->has_rcft())
            {
                (*iter)->toXml(rcft, _outStream);
            }
        }
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Revisions& default_instance(){

    if (!CT_Revisions::default_instance_)
    {
        CT_Revisions::default_instance_ = new CT_Revisions();
    }
    return *CT_Revisions::default_instance_;

        }

    private:
        vector<ChildGroup_1*> m_childGroupList_1 ;
        static CT_Revisions* default_instance_ ;
        class ChildGroup_1{
        public:
            bool has_rrc(){

            return m_has_rrc;
        
            }
            CT_RevisionRowColumn* mutable_rrc(){

                
                m_has_rm = false;
                
        if (m_rm)
        {
            delete m_rm;
            m_rm = NULL;
        }
    ;
            
                m_has_rcv = false;
                
        if (m_rcv)
        {
            delete m_rcv;
            m_rcv = NULL;
        }
    ;
            
                m_has_rsnm = false;
                
        if (m_rsnm)
        {
            delete m_rsnm;
            m_rsnm = NULL;
        }
    ;
            
                m_has_ris = false;
                
        if (m_ris)
        {
            delete m_ris;
            m_ris = NULL;
        }
    ;
            
                m_has_rcc = false;
                
        if (m_rcc)
        {
            delete m_rcc;
            m_rcc = NULL;
        }
    ;
            
                m_has_rfmt = false;
                
        if (m_rfmt)
        {
            delete m_rfmt;
            m_rfmt = NULL;
        }
    ;
            
                m_has_raf = false;
                
        if (m_raf)
        {
            delete m_raf;
            m_raf = NULL;
        }
    ;
            
                m_has_rdn = false;
                
        if (m_rdn)
        {
            delete m_rdn;
            m_rdn = NULL;
        }
    ;
            
                m_has_rcmt = false;
                
        if (m_rcmt)
        {
            delete m_rcmt;
            m_rcmt = NULL;
        }
    ;
            
                m_has_rqt = false;
                
        if (m_rqt)
        {
            delete m_rqt;
            m_rqt = NULL;
        }
    ;
            
                m_has_rcft = false;
                
        if (m_rcft)
        {
            delete m_rcft;
            m_rcft = NULL;
        }
    ;
            
                m_has_rrc = true;
                if (!m_rrc)
                {
                    m_rrc = new CT_RevisionRowColumn();
                }
                return m_rrc;
            
            }
            const CT_RevisionRowColumn& rrc(){

            if (m_rrc)
            {
                return *m_rrc;
            }
            return CT_RevisionRowColumn::default_instance();
        
            }
            bool has_rm(){

            return m_has_rm;
        
            }
            CT_RevisionMove* mutable_rm(){

                
                m_has_rrc = false;
                
        if (m_rrc)
        {
            delete m_rrc;
            m_rrc = NULL;
        }
    ;
            
                m_has_rcv = false;
                
        if (m_rcv)
        {
            delete m_rcv;
            m_rcv = NULL;
        }
    ;
            
                m_has_rsnm = false;
                
        if (m_rsnm)
        {
            delete m_rsnm;
            m_rsnm = NULL;
        }
    ;
            
                m_has_ris = false;
                
        if (m_ris)
        {
            delete m_ris;
            m_ris = NULL;
        }
    ;
            
                m_has_rcc = false;
                
        if (m_rcc)
        {
            delete m_rcc;
            m_rcc = NULL;
        }
    ;
            
                m_has_rfmt = false;
                
        if (m_rfmt)
        {
            delete m_rfmt;
            m_rfmt = NULL;
        }
    ;
            
                m_has_raf = false;
                
        if (m_raf)
        {
            delete m_raf;
            m_raf = NULL;
        }
    ;
            
                m_has_rdn = false;
                
        if (m_rdn)
        {
            delete m_rdn;
            m_rdn = NULL;
        }
    ;
            
                m_has_rcmt = false;
                
        if (m_rcmt)
        {
            delete m_rcmt;
            m_rcmt = NULL;
        }
    ;
            
                m_has_rqt = false;
                
        if (m_rqt)
        {
            delete m_rqt;
            m_rqt = NULL;
        }
    ;
            
                m_has_rcft = false;
                
        if (m_rcft)
        {
            delete m_rcft;
            m_rcft = NULL;
        }
    ;
            
                m_has_rm = true;
                if (!m_rm)
                {
                    m_rm = new CT_RevisionMove();
                }
                return m_rm;
            
            }
            const CT_RevisionMove& rm(){

            if (m_rm)
            {
                return *m_rm;
            }
            return CT_RevisionMove::default_instance();
        
            }
            bool has_rcv(){

            return m_has_rcv;
        
            }
            CT_RevisionCustomView* mutable_rcv(){

                
                m_has_rrc = false;
                
        if (m_rrc)
        {
            delete m_rrc;
            m_rrc = NULL;
        }
    ;
            
                m_has_rm = false;
                
        if (m_rm)
        {
            delete m_rm;
            m_rm = NULL;
        }
    ;
            
                m_has_rsnm = false;
                
        if (m_rsnm)
        {
            delete m_rsnm;
            m_rsnm = NULL;
        }
    ;
            
                m_has_ris = false;
                
        if (m_ris)
        {
            delete m_ris;
            m_ris = NULL;
        }
    ;
            
                m_has_rcc = false;
                
        if (m_rcc)
        {
            delete m_rcc;
            m_rcc = NULL;
        }
    ;
            
                m_has_rfmt = false;
                
        if (m_rfmt)
        {
            delete m_rfmt;
            m_rfmt = NULL;
        }
    ;
            
                m_has_raf = false;
                
        if (m_raf)
        {
            delete m_raf;
            m_raf = NULL;
        }
    ;
            
                m_has_rdn = false;
                
        if (m_rdn)
        {
            delete m_rdn;
            m_rdn = NULL;
        }
    ;
            
                m_has_rcmt = false;
                
        if (m_rcmt)
        {
            delete m_rcmt;
            m_rcmt = NULL;
        }
    ;
            
                m_has_rqt = false;
                
        if (m_rqt)
        {
            delete m_rqt;
            m_rqt = NULL;
        }
    ;
            
                m_has_rcft = false;
                
        if (m_rcft)
        {
            delete m_rcft;
            m_rcft = NULL;
        }
    ;
            
                m_has_rcv = true;
                if (!m_rcv)
                {
                    m_rcv = new CT_RevisionCustomView();
                }
                return m_rcv;
            
            }
            const CT_RevisionCustomView& rcv(){

            if (m_rcv)
            {
                return *m_rcv;
            }
            return CT_RevisionCustomView::default_instance();
        
            }
            bool has_rsnm(){

            return m_has_rsnm;
        
            }
            CT_RevisionSheetRename* mutable_rsnm(){

                
                m_has_rrc = false;
                
        if (m_rrc)
        {
            delete m_rrc;
            m_rrc = NULL;
        }
    ;
            
                m_has_rm = false;
                
        if (m_rm)
        {
            delete m_rm;
            m_rm = NULL;
        }
    ;
            
                m_has_rcv = false;
                
        if (m_rcv)
        {
            delete m_rcv;
            m_rcv = NULL;
        }
    ;
            
                m_has_ris = false;
                
        if (m_ris)
        {
            delete m_ris;
            m_ris = NULL;
        }
    ;
            
                m_has_rcc = false;
                
        if (m_rcc)
        {
            delete m_rcc;
            m_rcc = NULL;
        }
    ;
            
                m_has_rfmt = false;
                
        if (m_rfmt)
        {
            delete m_rfmt;
            m_rfmt = NULL;
        }
    ;
            
                m_has_raf = false;
                
        if (m_raf)
        {
            delete m_raf;
            m_raf = NULL;
        }
    ;
            
                m_has_rdn = false;
                
        if (m_rdn)
        {
            delete m_rdn;
            m_rdn = NULL;
        }
    ;
            
                m_has_rcmt = false;
                
        if (m_rcmt)
        {
            delete m_rcmt;
            m_rcmt = NULL;
        }
    ;
            
                m_has_rqt = false;
                
        if (m_rqt)
        {
            delete m_rqt;
            m_rqt = NULL;
        }
    ;
            
                m_has_rcft = false;
                
        if (m_rcft)
        {
            delete m_rcft;
            m_rcft = NULL;
        }
    ;
            
                m_has_rsnm = true;
                if (!m_rsnm)
                {
                    m_rsnm = new CT_RevisionSheetRename();
                }
                return m_rsnm;
            
            }
            const CT_RevisionSheetRename& rsnm(){

            if (m_rsnm)
            {
                return *m_rsnm;
            }
            return CT_RevisionSheetRename::default_instance();
        
            }
            bool has_ris(){

            return m_has_ris;
        
            }
            CT_RevisionInsertSheet* mutable_ris(){

                
                m_has_rrc = false;
                
        if (m_rrc)
        {
            delete m_rrc;
            m_rrc = NULL;
        }
    ;
            
                m_has_rm = false;
                
        if (m_rm)
        {
            delete m_rm;
            m_rm = NULL;
        }
    ;
            
                m_has_rcv = false;
                
        if (m_rcv)
        {
            delete m_rcv;
            m_rcv = NULL;
        }
    ;
            
                m_has_rsnm = false;
                
        if (m_rsnm)
        {
            delete m_rsnm;
            m_rsnm = NULL;
        }
    ;
            
                m_has_rcc = false;
                
        if (m_rcc)
        {
            delete m_rcc;
            m_rcc = NULL;
        }
    ;
            
                m_has_rfmt = false;
                
        if (m_rfmt)
        {
            delete m_rfmt;
            m_rfmt = NULL;
        }
    ;
            
                m_has_raf = false;
                
        if (m_raf)
        {
            delete m_raf;
            m_raf = NULL;
        }
    ;
            
                m_has_rdn = false;
                
        if (m_rdn)
        {
            delete m_rdn;
            m_rdn = NULL;
        }
    ;
            
                m_has_rcmt = false;
                
        if (m_rcmt)
        {
            delete m_rcmt;
            m_rcmt = NULL;
        }
    ;
            
                m_has_rqt = false;
                
        if (m_rqt)
        {
            delete m_rqt;
            m_rqt = NULL;
        }
    ;
            
                m_has_rcft = false;
                
        if (m_rcft)
        {
            delete m_rcft;
            m_rcft = NULL;
        }
    ;
            
                m_has_ris = true;
                if (!m_ris)
                {
                    m_ris = new CT_RevisionInsertSheet();
                }
                return m_ris;
            
            }
            const CT_RevisionInsertSheet& ris(){

            if (m_ris)
            {
                return *m_ris;
            }
            return CT_RevisionInsertSheet::default_instance();
        
            }
            bool has_rcc(){

            return m_has_rcc;
        
            }
            CT_RevisionCellChange* mutable_rcc(){

                
                m_has_rrc = false;
                
        if (m_rrc)
        {
            delete m_rrc;
            m_rrc = NULL;
        }
    ;
            
                m_has_rm = false;
                
        if (m_rm)
        {
            delete m_rm;
            m_rm = NULL;
        }
    ;
            
                m_has_rcv = false;
                
        if (m_rcv)
        {
            delete m_rcv;
            m_rcv = NULL;
        }
    ;
            
                m_has_rsnm = false;
                
        if (m_rsnm)
        {
            delete m_rsnm;
            m_rsnm = NULL;
        }
    ;
            
                m_has_ris = false;
                
        if (m_ris)
        {
            delete m_ris;
            m_ris = NULL;
        }
    ;
            
                m_has_rfmt = false;
                
        if (m_rfmt)
        {
            delete m_rfmt;
            m_rfmt = NULL;
        }
    ;
            
                m_has_raf = false;
                
        if (m_raf)
        {
            delete m_raf;
            m_raf = NULL;
        }
    ;
            
                m_has_rdn = false;
                
        if (m_rdn)
        {
            delete m_rdn;
            m_rdn = NULL;
        }
    ;
            
                m_has_rcmt = false;
                
        if (m_rcmt)
        {
            delete m_rcmt;
            m_rcmt = NULL;
        }
    ;
            
                m_has_rqt = false;
                
        if (m_rqt)
        {
            delete m_rqt;
            m_rqt = NULL;
        }
    ;
            
                m_has_rcft = false;
                
        if (m_rcft)
        {
            delete m_rcft;
            m_rcft = NULL;
        }
    ;
            
                m_has_rcc = true;
                if (!m_rcc)
                {
                    m_rcc = new CT_RevisionCellChange();
                }
                return m_rcc;
            
            }
            const CT_RevisionCellChange& rcc(){

            if (m_rcc)
            {
                return *m_rcc;
            }
            return CT_RevisionCellChange::default_instance();
        
            }
            bool has_rfmt(){

            return m_has_rfmt;
        
            }
            CT_RevisionFormatting* mutable_rfmt(){

                
                m_has_rrc = false;
                
        if (m_rrc)
        {
            delete m_rrc;
            m_rrc = NULL;
        }
    ;
            
                m_has_rm = false;
                
        if (m_rm)
        {
            delete m_rm;
            m_rm = NULL;
        }
    ;
            
                m_has_rcv = false;
                
        if (m_rcv)
        {
            delete m_rcv;
            m_rcv = NULL;
        }
    ;
            
                m_has_rsnm = false;
                
        if (m_rsnm)
        {
            delete m_rsnm;
            m_rsnm = NULL;
        }
    ;
            
                m_has_ris = false;
                
        if (m_ris)
        {
            delete m_ris;
            m_ris = NULL;
        }
    ;
            
                m_has_rcc = false;
                
        if (m_rcc)
        {
            delete m_rcc;
            m_rcc = NULL;
        }
    ;
            
                m_has_raf = false;
                
        if (m_raf)
        {
            delete m_raf;
            m_raf = NULL;
        }
    ;
            
                m_has_rdn = false;
                
        if (m_rdn)
        {
            delete m_rdn;
            m_rdn = NULL;
        }
    ;
            
                m_has_rcmt = false;
                
        if (m_rcmt)
        {
            delete m_rcmt;
            m_rcmt = NULL;
        }
    ;
            
                m_has_rqt = false;
                
        if (m_rqt)
        {
            delete m_rqt;
            m_rqt = NULL;
        }
    ;
            
                m_has_rcft = false;
                
        if (m_rcft)
        {
            delete m_rcft;
            m_rcft = NULL;
        }
    ;
            
                m_has_rfmt = true;
                if (!m_rfmt)
                {
                    m_rfmt = new CT_RevisionFormatting();
                }
                return m_rfmt;
            
            }
            const CT_RevisionFormatting& rfmt(){

            if (m_rfmt)
            {
                return *m_rfmt;
            }
            return CT_RevisionFormatting::default_instance();
        
            }
            bool has_raf(){

            return m_has_raf;
        
            }
            CT_RevisionAutoFormatting* mutable_raf(){

                
                m_has_rrc = false;
                
        if (m_rrc)
        {
            delete m_rrc;
            m_rrc = NULL;
        }
    ;
            
                m_has_rm = false;
                
        if (m_rm)
        {
            delete m_rm;
            m_rm = NULL;
        }
    ;
            
                m_has_rcv = false;
                
        if (m_rcv)
        {
            delete m_rcv;
            m_rcv = NULL;
        }
    ;
            
                m_has_rsnm = false;
                
        if (m_rsnm)
        {
            delete m_rsnm;
            m_rsnm = NULL;
        }
    ;
            
                m_has_ris = false;
                
        if (m_ris)
        {
            delete m_ris;
            m_ris = NULL;
        }
    ;
            
                m_has_rcc = false;
                
        if (m_rcc)
        {
            delete m_rcc;
            m_rcc = NULL;
        }
    ;
            
                m_has_rfmt = false;
                
        if (m_rfmt)
        {
            delete m_rfmt;
            m_rfmt = NULL;
        }
    ;
            
                m_has_rdn = false;
                
        if (m_rdn)
        {
            delete m_rdn;
            m_rdn = NULL;
        }
    ;
            
                m_has_rcmt = false;
                
        if (m_rcmt)
        {
            delete m_rcmt;
            m_rcmt = NULL;
        }
    ;
            
                m_has_rqt = false;
                
        if (m_rqt)
        {
            delete m_rqt;
            m_rqt = NULL;
        }
    ;
            
                m_has_rcft = false;
                
        if (m_rcft)
        {
            delete m_rcft;
            m_rcft = NULL;
        }
    ;
            
                m_has_raf = true;
                if (!m_raf)
                {
                    m_raf = new CT_RevisionAutoFormatting();
                }
                return m_raf;
            
            }
            const CT_RevisionAutoFormatting& raf(){

            if (m_raf)
            {
                return *m_raf;
            }
            return CT_RevisionAutoFormatting::default_instance();
        
            }
            bool has_rdn(){

            return m_has_rdn;
        
            }
            CT_RevisionDefinedName* mutable_rdn(){

                
                m_has_rrc = false;
                
        if (m_rrc)
        {
            delete m_rrc;
            m_rrc = NULL;
        }
    ;
            
                m_has_rm = false;
                
        if (m_rm)
        {
            delete m_rm;
            m_rm = NULL;
        }
    ;
            
                m_has_rcv = false;
                
        if (m_rcv)
        {
            delete m_rcv;
            m_rcv = NULL;
        }
    ;
            
                m_has_rsnm = false;
                
        if (m_rsnm)
        {
            delete m_rsnm;
            m_rsnm = NULL;
        }
    ;
            
                m_has_ris = false;
                
        if (m_ris)
        {
            delete m_ris;
            m_ris = NULL;
        }
    ;
            
                m_has_rcc = false;
                
        if (m_rcc)
        {
            delete m_rcc;
            m_rcc = NULL;
        }
    ;
            
                m_has_rfmt = false;
                
        if (m_rfmt)
        {
            delete m_rfmt;
            m_rfmt = NULL;
        }
    ;
            
                m_has_raf = false;
                
        if (m_raf)
        {
            delete m_raf;
            m_raf = NULL;
        }
    ;
            
                m_has_rcmt = false;
                
        if (m_rcmt)
        {
            delete m_rcmt;
            m_rcmt = NULL;
        }
    ;
            
                m_has_rqt = false;
                
        if (m_rqt)
        {
            delete m_rqt;
            m_rqt = NULL;
        }
    ;
            
                m_has_rcft = false;
                
        if (m_rcft)
        {
            delete m_rcft;
            m_rcft = NULL;
        }
    ;
            
                m_has_rdn = true;
                if (!m_rdn)
                {
                    m_rdn = new CT_RevisionDefinedName();
                }
                return m_rdn;
            
            }
            const CT_RevisionDefinedName& rdn(){

            if (m_rdn)
            {
                return *m_rdn;
            }
            return CT_RevisionDefinedName::default_instance();
        
            }
            bool has_rcmt(){

            return m_has_rcmt;
        
            }
            CT_RevisionComment* mutable_rcmt(){

                
                m_has_rrc = false;
                
        if (m_rrc)
        {
            delete m_rrc;
            m_rrc = NULL;
        }
    ;
            
                m_has_rm = false;
                
        if (m_rm)
        {
            delete m_rm;
            m_rm = NULL;
        }
    ;
            
                m_has_rcv = false;
                
        if (m_rcv)
        {
            delete m_rcv;
            m_rcv = NULL;
        }
    ;
            
                m_has_rsnm = false;
                
        if (m_rsnm)
        {
            delete m_rsnm;
            m_rsnm = NULL;
        }
    ;
            
                m_has_ris = false;
                
        if (m_ris)
        {
            delete m_ris;
            m_ris = NULL;
        }
    ;
            
                m_has_rcc = false;
                
        if (m_rcc)
        {
            delete m_rcc;
            m_rcc = NULL;
        }
    ;
            
                m_has_rfmt = false;
                
        if (m_rfmt)
        {
            delete m_rfmt;
            m_rfmt = NULL;
        }
    ;
            
                m_has_raf = false;
                
        if (m_raf)
        {
            delete m_raf;
            m_raf = NULL;
        }
    ;
            
                m_has_rdn = false;
                
        if (m_rdn)
        {
            delete m_rdn;
            m_rdn = NULL;
        }
    ;
            
                m_has_rqt = false;
                
        if (m_rqt)
        {
            delete m_rqt;
            m_rqt = NULL;
        }
    ;
            
                m_has_rcft = false;
                
        if (m_rcft)
        {
            delete m_rcft;
            m_rcft = NULL;
        }
    ;
            
                m_has_rcmt = true;
                if (!m_rcmt)
                {
                    m_rcmt = new CT_RevisionComment();
                }
                return m_rcmt;
            
            }
            const CT_RevisionComment& rcmt(){

            if (m_rcmt)
            {
                return *m_rcmt;
            }
            return CT_RevisionComment::default_instance();
        
            }
            bool has_rqt(){

            return m_has_rqt;
        
            }
            CT_RevisionQueryTableField* mutable_rqt(){

                
                m_has_rrc = false;
                
        if (m_rrc)
        {
            delete m_rrc;
            m_rrc = NULL;
        }
    ;
            
                m_has_rm = false;
                
        if (m_rm)
        {
            delete m_rm;
            m_rm = NULL;
        }
    ;
            
                m_has_rcv = false;
                
        if (m_rcv)
        {
            delete m_rcv;
            m_rcv = NULL;
        }
    ;
            
                m_has_rsnm = false;
                
        if (m_rsnm)
        {
            delete m_rsnm;
            m_rsnm = NULL;
        }
    ;
            
                m_has_ris = false;
                
        if (m_ris)
        {
            delete m_ris;
            m_ris = NULL;
        }
    ;
            
                m_has_rcc = false;
                
        if (m_rcc)
        {
            delete m_rcc;
            m_rcc = NULL;
        }
    ;
            
                m_has_rfmt = false;
                
        if (m_rfmt)
        {
            delete m_rfmt;
            m_rfmt = NULL;
        }
    ;
            
                m_has_raf = false;
                
        if (m_raf)
        {
            delete m_raf;
            m_raf = NULL;
        }
    ;
            
                m_has_rdn = false;
                
        if (m_rdn)
        {
            delete m_rdn;
            m_rdn = NULL;
        }
    ;
            
                m_has_rcmt = false;
                
        if (m_rcmt)
        {
            delete m_rcmt;
            m_rcmt = NULL;
        }
    ;
            
                m_has_rcft = false;
                
        if (m_rcft)
        {
            delete m_rcft;
            m_rcft = NULL;
        }
    ;
            
                m_has_rqt = true;
                if (!m_rqt)
                {
                    m_rqt = new CT_RevisionQueryTableField();
                }
                return m_rqt;
            
            }
            const CT_RevisionQueryTableField& rqt(){

            if (m_rqt)
            {
                return *m_rqt;
            }
            return CT_RevisionQueryTableField::default_instance();
        
            }
            bool has_rcft(){

            return m_has_rcft;
        
            }
            CT_RevisionConflict* mutable_rcft(){

                
                m_has_rrc = false;
                
        if (m_rrc)
        {
            delete m_rrc;
            m_rrc = NULL;
        }
    ;
            
                m_has_rm = false;
                
        if (m_rm)
        {
            delete m_rm;
            m_rm = NULL;
        }
    ;
            
                m_has_rcv = false;
                
        if (m_rcv)
        {
            delete m_rcv;
            m_rcv = NULL;
        }
    ;
            
                m_has_rsnm = false;
                
        if (m_rsnm)
        {
            delete m_rsnm;
            m_rsnm = NULL;
        }
    ;
            
                m_has_ris = false;
                
        if (m_ris)
        {
            delete m_ris;
            m_ris = NULL;
        }
    ;
            
                m_has_rcc = false;
                
        if (m_rcc)
        {
            delete m_rcc;
            m_rcc = NULL;
        }
    ;
            
                m_has_rfmt = false;
                
        if (m_rfmt)
        {
            delete m_rfmt;
            m_rfmt = NULL;
        }
    ;
            
                m_has_raf = false;
                
        if (m_raf)
        {
            delete m_raf;
            m_raf = NULL;
        }
    ;
            
                m_has_rdn = false;
                
        if (m_rdn)
        {
            delete m_rdn;
            m_rdn = NULL;
        }
    ;
            
                m_has_rcmt = false;
                
        if (m_rcmt)
        {
            delete m_rcmt;
            m_rcmt = NULL;
        }
    ;
            
                m_has_rqt = false;
                
        if (m_rqt)
        {
            delete m_rqt;
            m_rqt = NULL;
        }
    ;
            
                m_has_rcft = true;
                if (!m_rcft)
                {
                    m_rcft = new CT_RevisionConflict();
                }
                return m_rcft;
            
            }
            const CT_RevisionConflict& rcft(){

            if (m_rcft)
            {
                return *m_rcft;
            }
            return CT_RevisionConflict::default_instance();
        
            }

        private:
            bool m_has_rrc ;
            CT_RevisionRowColumn* m_rrc ;
            bool m_has_rm ;
            CT_RevisionMove* m_rm ;
            bool m_has_rcv ;
            CT_RevisionCustomView* m_rcv ;
            bool m_has_rsnm ;
            CT_RevisionSheetRename* m_rsnm ;
            bool m_has_ris ;
            CT_RevisionInsertSheet* m_ris ;
            bool m_has_rcc ;
            CT_RevisionCellChange* m_rcc ;
            bool m_has_rfmt ;
            CT_RevisionFormatting* m_rfmt ;
            bool m_has_raf ;
            CT_RevisionAutoFormatting* m_raf ;
            bool m_has_rdn ;
            CT_RevisionDefinedName* m_rdn ;
            bool m_has_rcmt ;
            CT_RevisionComment* m_rcmt ;
            bool m_has_rqt ;
            CT_RevisionQueryTableField* m_rqt ;
            bool m_has_rcft ;
            CT_RevisionConflict* m_rcft ;

        }


    }

    class CT_RevisionHeader : public XSD::ComplexType{
    public:
        bool has_sheetIdMap(){

            return m_has_sheetIdMap;
        
        }
        CT_SheetIdMap* mutable_sheetIdMap(){

                m_has_sheetIdMap = true;
                if (!m_sheetIdMap)
                {
                    m_sheetIdMap = new CT_SheetIdMap();
                }
                return m_sheetIdMap;
            
        }
        const CT_SheetIdMap& sheetIdMap(){

            if (m_sheetIdMap)
            {
                return *m_sheetIdMap;
            }
            return CT_SheetIdMap::default_instance();
        
        }
        bool has_reviewedList(){

            return m_has_reviewedList;
        
        }
        CT_ReviewedRevisions* mutable_reviewedList(){

                m_has_reviewedList = true;
                if (!m_reviewedList)
                {
                    m_reviewedList = new CT_ReviewedRevisions();
                }
                return m_reviewedList;
            
        }
        const CT_ReviewedRevisions& reviewedList(){

            if (m_reviewedList)
            {
                return *m_reviewedList;
            }
            return CT_ReviewedRevisions::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_guid_attr = false;
                
        if (m_guid_attr)
        {
            delete m_guid_attr;
            m_guid_attr = NULL;
        }
    
            
                m_has_dateTime_attr = false;
                m_dateTime_attr.clear();
            
                m_has_maxSheetId_attr = false;
                m_maxSheetId_attr = 0;
            
                m_has_userName_attr = false;
                
        if (m_userName_attr)
        {
            delete m_userName_attr;
            m_userName_attr = NULL;
        }
    
            
                m_has_id_attr = false;
                
        if (m_id_attr)
        {
            delete m_id_attr;
            m_id_attr = NULL;
        }
    
            
                m_has_minRId_attr = false;
                m_minRId_attr = 0;
            
                m_has_maxRId_attr = false;
                m_maxRId_attr = 0;
            
                m_has_sheetIdMap = false;
                
        if (m_sheetIdMap)
        {
            delete m_sheetIdMap;
            m_sheetIdMap = NULL;
        }
    
            
                m_has_reviewedList = false;
                
        if (m_reviewedList)
        {
            delete m_reviewedList;
            m_reviewedList = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_guid_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_dateTime_attr << \\\;
_outStream << _attrName << \=\\ << m_maxSheetId_attr << \\\;
m_userName_attr->toXml(_attrName, _outStream);
m_id_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_minRId_attr << \\\;
_outStream << _attrName << \=\\ << m_maxRId_attr << \\\;
        _outStream << \>\;
    
                if (m_has_sheetIdMap)
                {
                    m_sheetIdMap->toXml(sheetIdMap, _outStream);;
                }
            
                if (m_has_reviewedList)
                {
                    m_sheetIdMap->toXml(reviewedList, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_sheetIdMap->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_RevisionHeader& default_instance(){

    if (!CT_RevisionHeader::default_instance_)
    {
        CT_RevisionHeader::default_instance_ = new CT_RevisionHeader();
    }
    return *CT_RevisionHeader::default_instance_;

        }
        bool has_guid_attr(){

            return m_has_guid_attr;
        
        }
        void set_guid_attr(const ns_s::ST_Guid& _guid_attr ){

            m_has_guid_attr = true;
            m_guid_attr = new ns_s::ST_Guid(_guid_attr);
        
        }
        const ns_s::ST_Guid& guid_attr(){

            if (m_guid_attr)
            {
                return *m_guid_attr;
            }
            return ns_s::ST_Guid::default_instance();
        
        }
        bool has_dateTime_attr(){

            return m_has_dateTime_attr;
        
        }
        void set_dateTime_attr(const dateTime& _dateTime_attr ){

        m_has_dateTime_attr = true;
        m_dateTime_attr = _dateTime_attr;
        
        }
        const dateTime& dateTime_attr(){

            return type: \dateTime\nname: \m_dateTime_attr\n;
        
        }
        bool has_maxSheetId_attr(){

            return m_has_maxSheetId_attr;
        
        }
        void set_maxSheetId_attr(const unsignedInt& _maxSheetId_attr ){

        m_has_maxSheetId_attr = true;
        m_maxSheetId_attr = _maxSheetId_attr;
        
        }
        const unsignedInt& maxSheetId_attr(){

            return type: \unsignedInt\nname: \m_maxSheetId_attr\n;
        
        }
        bool has_userName_attr(){

            return m_has_userName_attr;
        
        }
        void set_userName_attr(const ns_s::ST_Xstring& _userName_attr ){

            m_has_userName_attr = true;
            m_userName_attr = new ns_s::ST_Xstring(_userName_attr);
        
        }
        const ns_s::ST_Xstring& userName_attr(){

            if (m_userName_attr)
            {
                return *m_userName_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_id_attr(){

            return m_has_id_attr;
        
        }
        void set_id_attr(const ST_RelationshipId& _id_attr ){

            m_has_id_attr = true;
            m_id_attr = new ST_RelationshipId(_id_attr);
        
        }
        const ST_RelationshipId& id_attr(){

            if (m_id_attr)
            {
                return *m_id_attr;
            }
            return ST_RelationshipId::default_instance();
        
        }
        bool has_minRId_attr(){

            return m_has_minRId_attr;
        
        }
        void set_minRId_attr(const unsignedInt& _minRId_attr ){

        m_has_minRId_attr = true;
        m_minRId_attr = _minRId_attr;
        
        }
        const unsignedInt& minRId_attr(){

            return type: \unsignedInt\nname: \m_minRId_attr\n;
        
        }
        bool has_maxRId_attr(){

            return m_has_maxRId_attr;
        
        }
        void set_maxRId_attr(const unsignedInt& _maxRId_attr ){

        m_has_maxRId_attr = true;
        m_maxRId_attr = _maxRId_attr;
        
        }
        const unsignedInt& maxRId_attr(){

            return type: \unsignedInt\nname: \m_maxRId_attr\n;
        
        }

    private:
        bool m_has_sheetIdMap ;
        CT_SheetIdMap* m_sheetIdMap ;
        bool m_has_reviewedList ;
        CT_ReviewedRevisions* m_reviewedList ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_RevisionHeader* default_instance_ ;
        bool m_has_guid_attr ;
        ns_s::ST_Guid* m_guid_attr ;
        bool m_has_dateTime_attr ;
        dateTime m_dateTime_attr ;
        bool m_has_maxSheetId_attr ;
        unsignedInt m_maxSheetId_attr ;
        bool m_has_userName_attr ;
        ns_s::ST_Xstring* m_userName_attr ;
        bool m_has_id_attr ;
        ST_RelationshipId* m_id_attr ;
        bool m_has_minRId_attr ;
        unsignedInt m_minRId_attr ;
        bool m_has_maxRId_attr ;
        unsignedInt m_maxRId_attr ;

    }

    class CT_SheetIdMap : public XSD::ComplexType{
    public:
        bool has_sheetId(){

            return m_has_sheetId;
        
        }
        CT_SheetId* mutable_sheetId(){

                m_has_sheetId = true;
                if (!m_sheetId)
                {
                    m_sheetId = new CT_SheetId();
                }
                return m_sheetId;
            
        }
        const CT_SheetId& sheetId(){

            if (m_sheetId)
            {
                return *m_sheetId;
            }
            return CT_SheetId::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_sheetId = false;
                
        if (m_sheetId)
        {
            delete m_sheetId;
            m_sheetId = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_sheetId)
                {
                    m_sheetId->toXml(sheetId, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_SheetIdMap& default_instance(){

    if (!CT_SheetIdMap::default_instance_)
    {
        CT_SheetIdMap::default_instance_ = new CT_SheetIdMap();
    }
    return *CT_SheetIdMap::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_sheetId ;
        CT_SheetId* m_sheetId ;
        static CT_SheetIdMap* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_SheetId : public XSD::ComplexType{
    public:
        void clear(){

                m_has_val_attr = false;
                m_val_attr = 0;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_val_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_SheetId& default_instance(){

    if (!CT_SheetId::default_instance_)
    {
        CT_SheetId::default_instance_ = new CT_SheetId();
    }
    return *CT_SheetId::default_instance_;

        }
        bool has_val_attr(){

            return m_has_val_attr;
        
        }
        void set_val_attr(const unsignedInt& _val_attr ){

        m_has_val_attr = true;
        m_val_attr = _val_attr;
        
        }
        const unsignedInt& val_attr(){

            return type: \unsignedInt\nname: \m_val_attr\n;
        
        }

    private:
        static CT_SheetId* default_instance_ ;
        bool m_has_val_attr ;
        unsignedInt m_val_attr ;

    }

    class CT_ReviewedRevisions : public XSD::ComplexType{
    public:
        bool has_reviewed(){

            return m_has_reviewed;
        
        }
        CT_Reviewed* mutable_reviewed(){

                m_has_reviewed = true;
                if (!m_reviewed)
                {
                    m_reviewed = new CT_Reviewed();
                }
                return m_reviewed;
            
        }
        const CT_Reviewed& reviewed(){

            if (m_reviewed)
            {
                return *m_reviewed;
            }
            return CT_Reviewed::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_reviewed = false;
                
        if (m_reviewed)
        {
            delete m_reviewed;
            m_reviewed = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_reviewed)
                {
                    m_reviewed->toXml(reviewed, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_ReviewedRevisions& default_instance(){

    if (!CT_ReviewedRevisions::default_instance_)
    {
        CT_ReviewedRevisions::default_instance_ = new CT_ReviewedRevisions();
    }
    return *CT_ReviewedRevisions::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_reviewed ;
        CT_Reviewed* m_reviewed ;
        static CT_ReviewedRevisions* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_Reviewed : public XSD::ComplexType{
    public:
        void clear(){

                m_has_rId_attr = false;
                m_rId_attr = 0;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_rId_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Reviewed& default_instance(){

    if (!CT_Reviewed::default_instance_)
    {
        CT_Reviewed::default_instance_ = new CT_Reviewed();
    }
    return *CT_Reviewed::default_instance_;

        }
        bool has_rId_attr(){

            return m_has_rId_attr;
        
        }
        void set_rId_attr(const unsignedInt& _rId_attr ){

        m_has_rId_attr = true;
        m_rId_attr = _rId_attr;
        
        }
        const unsignedInt& rId_attr(){

            return type: \unsignedInt\nname: \m_rId_attr\n;
        
        }

    private:
        static CT_Reviewed* default_instance_ ;
        bool m_has_rId_attr ;
        unsignedInt m_rId_attr ;

    }

    class CT_UndoInfo : public XSD::ComplexType{
    public:
        void clear(){

                m_has_index_attr = false;
                m_index_attr = 0;
            
                m_has_exp_attr = false;
                
        if (m_exp_attr)
        {
            delete m_exp_attr;
            m_exp_attr = NULL;
        }
    
            
                m_has_ref3D_attr = false;
                m_ref3D_attr = false;
            
                m_has_array_attr = false;
                m_array_attr = false;
            
                m_has_v_attr = false;
                m_v_attr = false;
            
                m_has_nf_attr = false;
                m_nf_attr = false;
            
                m_has_cs_attr = false;
                m_cs_attr = false;
            
                m_has_dr_attr = false;
                
        if (m_dr_attr)
        {
            delete m_dr_attr;
            m_dr_attr = NULL;
        }
    
            
                m_has_dn_attr = false;
                
        if (m_dn_attr)
        {
            delete m_dn_attr;
            m_dn_attr = NULL;
        }
    
            
                m_has_r_attr = false;
                
        if (m_r_attr)
        {
            delete m_r_attr;
            m_r_attr = NULL;
        }
    
            
                m_has_sId_attr = false;
                m_sId_attr = 0;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_index_attr << \\\;
m_exp_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_ref3D_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_array_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_v_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_nf_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_cs_attr) << \\\;
m_dr_attr->toXml(_attrName, _outStream);
m_dn_attr->toXml(_attrName, _outStream);
m_r_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_sId_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_UndoInfo& default_instance(){

    if (!CT_UndoInfo::default_instance_)
    {
        CT_UndoInfo::default_instance_ = new CT_UndoInfo();
    }
    return *CT_UndoInfo::default_instance_;

        }
        bool has_index_attr(){

            return m_has_index_attr;
        
        }
        void set_index_attr(const unsignedInt& _index_attr ){

        m_has_index_attr = true;
        m_index_attr = _index_attr;
        
        }
        const unsignedInt& index_attr(){

            return type: \unsignedInt\nname: \m_index_attr\n;
        
        }
        bool has_exp_attr(){

            return m_has_exp_attr;
        
        }
        void set_exp_attr(const ST_FormulaExpression& _exp_attr ){

            m_has_exp_attr = true;
            m_exp_attr = new ST_FormulaExpression(_exp_attr);
        
        }
        const ST_FormulaExpression& exp_attr(){

            if (m_exp_attr)
            {
                return *m_exp_attr;
            }
            return ST_FormulaExpression::default_instance();
        
        }
        bool has_ref3D_attr(){

            return m_has_ref3D_attr;
        
        }
        void set_ref3D_attr(const boolean& _ref3D_attr ){

        m_has_ref3D_attr = true;
        m_ref3D_attr = _ref3D_attr;
        
        }
        const boolean& ref3D_attr(){

            return type: oolean\nname: \m_ref3D_attr\n;
        
        }
        bool has_array_attr(){

            return m_has_array_attr;
        
        }
        void set_array_attr(const boolean& _array_attr ){

        m_has_array_attr = true;
        m_array_attr = _array_attr;
        
        }
        const boolean& array_attr(){

            return type: oolean\nname: \m_array_attr\n;
        
        }
        bool has_v_attr(){

            return m_has_v_attr;
        
        }
        void set_v_attr(const boolean& _v_attr ){

        m_has_v_attr = true;
        m_v_attr = _v_attr;
        
        }
        const boolean& v_attr(){

            return type: oolean\nname: \m_v_attr\n;
        
        }
        bool has_nf_attr(){

            return m_has_nf_attr;
        
        }
        void set_nf_attr(const boolean& _nf_attr ){

        m_has_nf_attr = true;
        m_nf_attr = _nf_attr;
        
        }
        const boolean& nf_attr(){

            return type: oolean\nname: \m_nf_attr\n;
        
        }
        bool has_cs_attr(){

            return m_has_cs_attr;
        
        }
        void set_cs_attr(const boolean& _cs_attr ){

        m_has_cs_attr = true;
        m_cs_attr = _cs_attr;
        
        }
        const boolean& cs_attr(){

            return type: oolean\nname: \m_cs_attr\n;
        
        }
        bool has_dr_attr(){

            return m_has_dr_attr;
        
        }
        void set_dr_attr(const ST_RefA& _dr_attr ){

            m_has_dr_attr = true;
            m_dr_attr = new ST_RefA(_dr_attr);
        
        }
        const ST_RefA& dr_attr(){

            if (m_dr_attr)
            {
                return *m_dr_attr;
            }
            return ST_RefA::default_instance();
        
        }
        bool has_dn_attr(){

            return m_has_dn_attr;
        
        }
        void set_dn_attr(const ns_s::ST_Xstring& _dn_attr ){

            m_has_dn_attr = true;
            m_dn_attr = new ns_s::ST_Xstring(_dn_attr);
        
        }
        const ns_s::ST_Xstring& dn_attr(){

            if (m_dn_attr)
            {
                return *m_dn_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_r_attr(){

            return m_has_r_attr;
        
        }
        void set_r_attr(const ST_CellRef& _r_attr ){

            m_has_r_attr = true;
            m_r_attr = new ST_CellRef(_r_attr);
        
        }
        const ST_CellRef& r_attr(){

            if (m_r_attr)
            {
                return *m_r_attr;
            }
            return ST_CellRef::default_instance();
        
        }
        bool has_sId_attr(){

            return m_has_sId_attr;
        
        }
        void set_sId_attr(const unsignedInt& _sId_attr ){

        m_has_sId_attr = true;
        m_sId_attr = _sId_attr;
        
        }
        const unsignedInt& sId_attr(){

            return type: \unsignedInt\nname: \m_sId_attr\n;
        
        }

    private:
        static CT_UndoInfo* default_instance_ ;
        bool m_has_index_attr ;
        unsignedInt m_index_attr ;
        bool m_has_exp_attr ;
        ST_FormulaExpression* m_exp_attr ;
        bool m_has_ref3D_attr ;
        boolean m_ref3D_attr ;
        bool m_has_array_attr ;
        boolean m_array_attr ;
        bool m_has_v_attr ;
        boolean m_v_attr ;
        bool m_has_nf_attr ;
        boolean m_nf_attr ;
        bool m_has_cs_attr ;
        boolean m_cs_attr ;
        bool m_has_dr_attr ;
        ST_RefA* m_dr_attr ;
        bool m_has_dn_attr ;
        ns_s::ST_Xstring* m_dn_attr ;
        bool m_has_r_attr ;
        ST_CellRef* m_r_attr ;
        bool m_has_sId_attr ;
        unsignedInt m_sId_attr ;

    }

    class CT_RevisionRowColumn : public XSD::ComplexType{
    public:
        CT_UndoInfo* add_undo(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_UndoInfo* pNewChild = pChildGroup->mutable_undo();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_RevisionCellChange* add_rcc(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_RevisionCellChange* pNewChild = pChildGroup->mutable_rcc();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_RevisionFormatting* add_rfmt(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_RevisionFormatting* pNewChild = pChildGroup->mutable_rfmt();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        void clear(){

                m_has_rId_attr = false;
                m_rId_attr = 0;
            
                m_has_ua_attr = false;
                m_ua_attr = false;
            
                m_has_ra_attr = false;
                m_ra_attr = false;
            
                m_has_sId_attr = false;
                m_sId_attr = 0;
            
                m_has_eol_attr = false;
                m_eol_attr = false;
            
                m_has_ref_attr = false;
                
        if (m_ref_attr)
        {
            delete m_ref_attr;
            m_ref_attr = NULL;
        }
    
            
                m_has_action_attr = false;
                
        if (m_action_attr)
        {
            delete m_action_attr;
            m_action_attr = NULL;
        }
    
            
                m_has_edge_attr = false;
                m_edge_attr = false;
            
            vector<ChildGroup_1*>::iterator iter;
            for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
            {
                delete *iter;
            }
            m_childGroupList_1.clear();
        
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_rId_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_ua_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_ra_attr) << \\\;
_outStream << _attrName << \=\\ << m_sId_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_eol_attr) << \\\;
m_ref_attr->toXml(_attrName, _outStream);
m_action_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_edge_attr) << \\\;
        _outStream << \>\;
    
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_undo())
            {
                (*iter)->toXml(undo, _outStream);
            }
            else if ((*iter)->has_rcc())
            {
                (*iter)->toXml(rcc, _outStream);
            }
            else if ((*iter)->has_rfmt())
            {
                (*iter)->toXml(rfmt, _outStream);
            }
        }
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_RevisionRowColumn& default_instance(){

    if (!CT_RevisionRowColumn::default_instance_)
    {
        CT_RevisionRowColumn::default_instance_ = new CT_RevisionRowColumn();
    }
    return *CT_RevisionRowColumn::default_instance_;

        }
        bool has_rId_attr(){

            return m_has_rId_attr;
        
        }
        void set_rId_attr(const unsignedInt& _rId_attr ){

        m_has_rId_attr = true;
        m_rId_attr = _rId_attr;
        
        }
        const unsignedInt& rId_attr(){

            return type: \unsignedInt\nname: \m_rId_attr\n;
        
        }
        bool has_ua_attr(){

            return m_has_ua_attr;
        
        }
        void set_ua_attr(const boolean& _ua_attr ){

        m_has_ua_attr = true;
        m_ua_attr = _ua_attr;
        
        }
        const boolean& ua_attr(){

            return type: oolean\nname: \m_ua_attr\n;
        
        }
        bool has_ra_attr(){

            return m_has_ra_attr;
        
        }
        void set_ra_attr(const boolean& _ra_attr ){

        m_has_ra_attr = true;
        m_ra_attr = _ra_attr;
        
        }
        const boolean& ra_attr(){

            return type: oolean\nname: \m_ra_attr\n;
        
        }
        bool has_sId_attr(){

            return m_has_sId_attr;
        
        }
        void set_sId_attr(const unsignedInt& _sId_attr ){

        m_has_sId_attr = true;
        m_sId_attr = _sId_attr;
        
        }
        const unsignedInt& sId_attr(){

            return type: \unsignedInt\nname: \m_sId_attr\n;
        
        }
        bool has_eol_attr(){

            return m_has_eol_attr;
        
        }
        void set_eol_attr(const boolean& _eol_attr ){

        m_has_eol_attr = true;
        m_eol_attr = _eol_attr;
        
        }
        const boolean& eol_attr(){

            return type: oolean\nname: \m_eol_attr\n;
        
        }
        bool has_ref_attr(){

            return m_has_ref_attr;
        
        }
        void set_ref_attr(const ST_Ref& _ref_attr ){

            m_has_ref_attr = true;
            m_ref_attr = new ST_Ref(_ref_attr);
        
        }
        const ST_Ref& ref_attr(){

            if (m_ref_attr)
            {
                return *m_ref_attr;
            }
            return ST_Ref::default_instance();
        
        }
        bool has_action_attr(){

            return m_has_action_attr;
        
        }
        void set_action_attr(const ST_rwColActionType& _action_attr ){

            m_has_action_attr = true;
            m_action_attr = new ST_rwColActionType(_action_attr);
        
        }
        const ST_rwColActionType& action_attr(){

            if (m_action_attr)
            {
                return *m_action_attr;
            }
            return ST_rwColActionType::default_instance();
        
        }
        bool has_edge_attr(){

            return m_has_edge_attr;
        
        }
        void set_edge_attr(const boolean& _edge_attr ){

        m_has_edge_attr = true;
        m_edge_attr = _edge_attr;
        
        }
        const boolean& edge_attr(){

            return type: oolean\nname: \m_edge_attr\n;
        
        }

    private:
        vector<ChildGroup_1*> m_childGroupList_1 ;
        static CT_RevisionRowColumn* default_instance_ ;
        bool m_has_rId_attr ;
        unsignedInt m_rId_attr ;
        bool m_has_ua_attr ;
        boolean m_ua_attr ;
        bool m_has_ra_attr ;
        boolean m_ra_attr ;
        bool m_has_sId_attr ;
        unsignedInt m_sId_attr ;
        bool m_has_eol_attr ;
        boolean m_eol_attr ;
        bool m_has_ref_attr ;
        ST_Ref* m_ref_attr ;
        bool m_has_action_attr ;
        ST_rwColActionType* m_action_attr ;
        bool m_has_edge_attr ;
        boolean m_edge_attr ;
        class ChildGroup_1{
        public:
            bool has_undo(){

            return m_has_undo;
        
            }
            CT_UndoInfo* mutable_undo(){

                
                m_has_rcc = false;
                
        if (m_rcc)
        {
            delete m_rcc;
            m_rcc = NULL;
        }
    ;
            
                m_has_rfmt = false;
                
        if (m_rfmt)
        {
            delete m_rfmt;
            m_rfmt = NULL;
        }
    ;
            
                m_has_undo = true;
                if (!m_undo)
                {
                    m_undo = new CT_UndoInfo();
                }
                return m_undo;
            
            }
            const CT_UndoInfo& undo(){

            if (m_undo)
            {
                return *m_undo;
            }
            return CT_UndoInfo::default_instance();
        
            }
            bool has_rcc(){

            return m_has_rcc;
        
            }
            CT_RevisionCellChange* mutable_rcc(){

                
                m_has_undo = false;
                
        if (m_undo)
        {
            delete m_undo;
            m_undo = NULL;
        }
    ;
            
                m_has_rfmt = false;
                
        if (m_rfmt)
        {
            delete m_rfmt;
            m_rfmt = NULL;
        }
    ;
            
                m_has_rcc = true;
                if (!m_rcc)
                {
                    m_rcc = new CT_RevisionCellChange();
                }
                return m_rcc;
            
            }
            const CT_RevisionCellChange& rcc(){

            if (m_rcc)
            {
                return *m_rcc;
            }
            return CT_RevisionCellChange::default_instance();
        
            }
            bool has_rfmt(){

            return m_has_rfmt;
        
            }
            CT_RevisionFormatting* mutable_rfmt(){

                
                m_has_undo = false;
                
        if (m_undo)
        {
            delete m_undo;
            m_undo = NULL;
        }
    ;
            
                m_has_rcc = false;
                
        if (m_rcc)
        {
            delete m_rcc;
            m_rcc = NULL;
        }
    ;
            
                m_has_rfmt = true;
                if (!m_rfmt)
                {
                    m_rfmt = new CT_RevisionFormatting();
                }
                return m_rfmt;
            
            }
            const CT_RevisionFormatting& rfmt(){

            if (m_rfmt)
            {
                return *m_rfmt;
            }
            return CT_RevisionFormatting::default_instance();
        
            }

        private:
            bool m_has_undo ;
            CT_UndoInfo* m_undo ;
            bool m_has_rcc ;
            CT_RevisionCellChange* m_rcc ;
            bool m_has_rfmt ;
            CT_RevisionFormatting* m_rfmt ;

        }


    }

    class CT_RevisionMove : public XSD::ComplexType{
    public:
        CT_UndoInfo* add_undo(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_UndoInfo* pNewChild = pChildGroup->mutable_undo();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_RevisionCellChange* add_rcc(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_RevisionCellChange* pNewChild = pChildGroup->mutable_rcc();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_RevisionFormatting* add_rfmt(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_RevisionFormatting* pNewChild = pChildGroup->mutable_rfmt();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        void clear(){

                m_has_rId_attr = false;
                m_rId_attr = 0;
            
                m_has_ua_attr = false;
                m_ua_attr = false;
            
                m_has_ra_attr = false;
                m_ra_attr = false;
            
                m_has_sheetId_attr = false;
                m_sheetId_attr = 0;
            
                m_has_source_attr = false;
                
        if (m_source_attr)
        {
            delete m_source_attr;
            m_source_attr = NULL;
        }
    
            
                m_has_destination_attr = false;
                
        if (m_destination_attr)
        {
            delete m_destination_attr;
            m_destination_attr = NULL;
        }
    
            
                m_has_sourceSheetId_attr = false;
                m_sourceSheetId_attr = 0;
            
            vector<ChildGroup_1*>::iterator iter;
            for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
            {
                delete *iter;
            }
            m_childGroupList_1.clear();
        
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_rId_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_ua_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_ra_attr) << \\\;
_outStream << _attrName << \=\\ << m_sheetId_attr << \\\;
m_source_attr->toXml(_attrName, _outStream);
m_destination_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_sourceSheetId_attr << \\\;
        _outStream << \>\;
    
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_undo())
            {
                (*iter)->toXml(undo, _outStream);
            }
            else if ((*iter)->has_rcc())
            {
                (*iter)->toXml(rcc, _outStream);
            }
            else if ((*iter)->has_rfmt())
            {
                (*iter)->toXml(rfmt, _outStream);
            }
        }
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_RevisionMove& default_instance(){

    if (!CT_RevisionMove::default_instance_)
    {
        CT_RevisionMove::default_instance_ = new CT_RevisionMove();
    }
    return *CT_RevisionMove::default_instance_;

        }
        bool has_rId_attr(){

            return m_has_rId_attr;
        
        }
        void set_rId_attr(const unsignedInt& _rId_attr ){

        m_has_rId_attr = true;
        m_rId_attr = _rId_attr;
        
        }
        const unsignedInt& rId_attr(){

            return type: \unsignedInt\nname: \m_rId_attr\n;
        
        }
        bool has_ua_attr(){

            return m_has_ua_attr;
        
        }
        void set_ua_attr(const boolean& _ua_attr ){

        m_has_ua_attr = true;
        m_ua_attr = _ua_attr;
        
        }
        const boolean& ua_attr(){

            return type: oolean\nname: \m_ua_attr\n;
        
        }
        bool has_ra_attr(){

            return m_has_ra_attr;
        
        }
        void set_ra_attr(const boolean& _ra_attr ){

        m_has_ra_attr = true;
        m_ra_attr = _ra_attr;
        
        }
        const boolean& ra_attr(){

            return type: oolean\nname: \m_ra_attr\n;
        
        }
        bool has_sheetId_attr(){

            return m_has_sheetId_attr;
        
        }
        void set_sheetId_attr(const unsignedInt& _sheetId_attr ){

        m_has_sheetId_attr = true;
        m_sheetId_attr = _sheetId_attr;
        
        }
        const unsignedInt& sheetId_attr(){

            return type: \unsignedInt\nname: \m_sheetId_attr\n;
        
        }
        bool has_source_attr(){

            return m_has_source_attr;
        
        }
        void set_source_attr(const ST_Ref& _source_attr ){

            m_has_source_attr = true;
            m_source_attr = new ST_Ref(_source_attr);
        
        }
        const ST_Ref& source_attr(){

            if (m_source_attr)
            {
                return *m_source_attr;
            }
            return ST_Ref::default_instance();
        
        }
        bool has_destination_attr(){

            return m_has_destination_attr;
        
        }
        void set_destination_attr(const ST_Ref& _destination_attr ){

            m_has_destination_attr = true;
            m_destination_attr = new ST_Ref(_destination_attr);
        
        }
        const ST_Ref& destination_attr(){

            if (m_destination_attr)
            {
                return *m_destination_attr;
            }
            return ST_Ref::default_instance();
        
        }
        bool has_sourceSheetId_attr(){

            return m_has_sourceSheetId_attr;
        
        }
        void set_sourceSheetId_attr(const unsignedInt& _sourceSheetId_attr ){

        m_has_sourceSheetId_attr = true;
        m_sourceSheetId_attr = _sourceSheetId_attr;
        
        }
        const unsignedInt& sourceSheetId_attr(){

            return type: \unsignedInt\nname: \m_sourceSheetId_attr\n;
        
        }

    private:
        vector<ChildGroup_1*> m_childGroupList_1 ;
        static CT_RevisionMove* default_instance_ ;
        bool m_has_rId_attr ;
        unsignedInt m_rId_attr ;
        bool m_has_ua_attr ;
        boolean m_ua_attr ;
        bool m_has_ra_attr ;
        boolean m_ra_attr ;
        bool m_has_sheetId_attr ;
        unsignedInt m_sheetId_attr ;
        bool m_has_source_attr ;
        ST_Ref* m_source_attr ;
        bool m_has_destination_attr ;
        ST_Ref* m_destination_attr ;
        bool m_has_sourceSheetId_attr ;
        unsignedInt m_sourceSheetId_attr ;
        class ChildGroup_1{
        public:
            bool has_undo(){

            return m_has_undo;
        
            }
            CT_UndoInfo* mutable_undo(){

                
                m_has_rcc = false;
                
        if (m_rcc)
        {
            delete m_rcc;
            m_rcc = NULL;
        }
    ;
            
                m_has_rfmt = false;
                
        if (m_rfmt)
        {
            delete m_rfmt;
            m_rfmt = NULL;
        }
    ;
            
                m_has_undo = true;
                if (!m_undo)
                {
                    m_undo = new CT_UndoInfo();
                }
                return m_undo;
            
            }
            const CT_UndoInfo& undo(){

            if (m_undo)
            {
                return *m_undo;
            }
            return CT_UndoInfo::default_instance();
        
            }
            bool has_rcc(){

            return m_has_rcc;
        
            }
            CT_RevisionCellChange* mutable_rcc(){

                
                m_has_undo = false;
                
        if (m_undo)
        {
            delete m_undo;
            m_undo = NULL;
        }
    ;
            
                m_has_rfmt = false;
                
        if (m_rfmt)
        {
            delete m_rfmt;
            m_rfmt = NULL;
        }
    ;
            
                m_has_rcc = true;
                if (!m_rcc)
                {
                    m_rcc = new CT_RevisionCellChange();
                }
                return m_rcc;
            
            }
            const CT_RevisionCellChange& rcc(){

            if (m_rcc)
            {
                return *m_rcc;
            }
            return CT_RevisionCellChange::default_instance();
        
            }
            bool has_rfmt(){

            return m_has_rfmt;
        
            }
            CT_RevisionFormatting* mutable_rfmt(){

                
                m_has_undo = false;
                
        if (m_undo)
        {
            delete m_undo;
            m_undo = NULL;
        }
    ;
            
                m_has_rcc = false;
                
        if (m_rcc)
        {
            delete m_rcc;
            m_rcc = NULL;
        }
    ;
            
                m_has_rfmt = true;
                if (!m_rfmt)
                {
                    m_rfmt = new CT_RevisionFormatting();
                }
                return m_rfmt;
            
            }
            const CT_RevisionFormatting& rfmt(){

            if (m_rfmt)
            {
                return *m_rfmt;
            }
            return CT_RevisionFormatting::default_instance();
        
            }

        private:
            bool m_has_undo ;
            CT_UndoInfo* m_undo ;
            bool m_has_rcc ;
            CT_RevisionCellChange* m_rcc ;
            bool m_has_rfmt ;
            CT_RevisionFormatting* m_rfmt ;

        }


    }

    class CT_RevisionCustomView : public XSD::ComplexType{
    public:
        void clear(){

                m_has_guid_attr = false;
                
        if (m_guid_attr)
        {
            delete m_guid_attr;
            m_guid_attr = NULL;
        }
    
            
                m_has_action_attr = false;
                
        if (m_action_attr)
        {
            delete m_action_attr;
            m_action_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_guid_attr->toXml(_attrName, _outStream);
m_action_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_RevisionCustomView& default_instance(){

    if (!CT_RevisionCustomView::default_instance_)
    {
        CT_RevisionCustomView::default_instance_ = new CT_RevisionCustomView();
    }
    return *CT_RevisionCustomView::default_instance_;

        }
        bool has_guid_attr(){

            return m_has_guid_attr;
        
        }
        void set_guid_attr(const ns_s::ST_Guid& _guid_attr ){

            m_has_guid_attr = true;
            m_guid_attr = new ns_s::ST_Guid(_guid_attr);
        
        }
        const ns_s::ST_Guid& guid_attr(){

            if (m_guid_attr)
            {
                return *m_guid_attr;
            }
            return ns_s::ST_Guid::default_instance();
        
        }
        bool has_action_attr(){

            return m_has_action_attr;
        
        }
        void set_action_attr(const ST_RevisionAction& _action_attr ){

            m_has_action_attr = true;
            m_action_attr = new ST_RevisionAction(_action_attr);
        
        }
        const ST_RevisionAction& action_attr(){

            if (m_action_attr)
            {
                return *m_action_attr;
            }
            return ST_RevisionAction::default_instance();
        
        }

    private:
        static CT_RevisionCustomView* default_instance_ ;
        bool m_has_guid_attr ;
        ns_s::ST_Guid* m_guid_attr ;
        bool m_has_action_attr ;
        ST_RevisionAction* m_action_attr ;

    }

    class CT_RevisionSheetRename : public XSD::ComplexType{
    public:
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_rId_attr = false;
                m_rId_attr = 0;
            
                m_has_ua_attr = false;
                m_ua_attr = false;
            
                m_has_ra_attr = false;
                m_ra_attr = false;
            
                m_has_sheetId_attr = false;
                m_sheetId_attr = 0;
            
                m_has_oldName_attr = false;
                
        if (m_oldName_attr)
        {
            delete m_oldName_attr;
            m_oldName_attr = NULL;
        }
    
            
                m_has_newName_attr = false;
                
        if (m_newName_attr)
        {
            delete m_newName_attr;
            m_newName_attr = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_rId_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_ua_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_ra_attr) << \\\;
_outStream << _attrName << \=\\ << m_sheetId_attr << \\\;
m_oldName_attr->toXml(_attrName, _outStream);
m_newName_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_extLst)
                {
                    m_extLst->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_RevisionSheetRename& default_instance(){

    if (!CT_RevisionSheetRename::default_instance_)
    {
        CT_RevisionSheetRename::default_instance_ = new CT_RevisionSheetRename();
    }
    return *CT_RevisionSheetRename::default_instance_;

        }
        bool has_rId_attr(){

            return m_has_rId_attr;
        
        }
        void set_rId_attr(const unsignedInt& _rId_attr ){

        m_has_rId_attr = true;
        m_rId_attr = _rId_attr;
        
        }
        const unsignedInt& rId_attr(){

            return type: \unsignedInt\nname: \m_rId_attr\n;
        
        }
        bool has_ua_attr(){

            return m_has_ua_attr;
        
        }
        void set_ua_attr(const boolean& _ua_attr ){

        m_has_ua_attr = true;
        m_ua_attr = _ua_attr;
        
        }
        const boolean& ua_attr(){

            return type: oolean\nname: \m_ua_attr\n;
        
        }
        bool has_ra_attr(){

            return m_has_ra_attr;
        
        }
        void set_ra_attr(const boolean& _ra_attr ){

        m_has_ra_attr = true;
        m_ra_attr = _ra_attr;
        
        }
        const boolean& ra_attr(){

            return type: oolean\nname: \m_ra_attr\n;
        
        }
        bool has_sheetId_attr(){

            return m_has_sheetId_attr;
        
        }
        void set_sheetId_attr(const unsignedInt& _sheetId_attr ){

        m_has_sheetId_attr = true;
        m_sheetId_attr = _sheetId_attr;
        
        }
        const unsignedInt& sheetId_attr(){

            return type: \unsignedInt\nname: \m_sheetId_attr\n;
        
        }
        bool has_oldName_attr(){

            return m_has_oldName_attr;
        
        }
        void set_oldName_attr(const ns_s::ST_Xstring& _oldName_attr ){

            m_has_oldName_attr = true;
            m_oldName_attr = new ns_s::ST_Xstring(_oldName_attr);
        
        }
        const ns_s::ST_Xstring& oldName_attr(){

            if (m_oldName_attr)
            {
                return *m_oldName_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_newName_attr(){

            return m_has_newName_attr;
        
        }
        void set_newName_attr(const ns_s::ST_Xstring& _newName_attr ){

            m_has_newName_attr = true;
            m_newName_attr = new ns_s::ST_Xstring(_newName_attr);
        
        }
        const ns_s::ST_Xstring& newName_attr(){

            if (m_newName_attr)
            {
                return *m_newName_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }

    private:
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_RevisionSheetRename* default_instance_ ;
        bool m_has_rId_attr ;
        unsignedInt m_rId_attr ;
        bool m_has_ua_attr ;
        boolean m_ua_attr ;
        bool m_has_ra_attr ;
        boolean m_ra_attr ;
        bool m_has_sheetId_attr ;
        unsignedInt m_sheetId_attr ;
        bool m_has_oldName_attr ;
        ns_s::ST_Xstring* m_oldName_attr ;
        bool m_has_newName_attr ;
        ns_s::ST_Xstring* m_newName_attr ;

    }

    class CT_RevisionInsertSheet : public XSD::ComplexType{
    public:
        void clear(){

                m_has_rId_attr = false;
                m_rId_attr = 0;
            
                m_has_ua_attr = false;
                m_ua_attr = false;
            
                m_has_ra_attr = false;
                m_ra_attr = false;
            
                m_has_sheetId_attr = false;
                m_sheetId_attr = 0;
            
                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
                m_has_sheetPosition_attr = false;
                m_sheetPosition_attr = 0;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_rId_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_ua_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_ra_attr) << \\\;
_outStream << _attrName << \=\\ << m_sheetId_attr << \\\;
m_name_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_sheetPosition_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_RevisionInsertSheet& default_instance(){

    if (!CT_RevisionInsertSheet::default_instance_)
    {
        CT_RevisionInsertSheet::default_instance_ = new CT_RevisionInsertSheet();
    }
    return *CT_RevisionInsertSheet::default_instance_;

        }
        bool has_rId_attr(){

            return m_has_rId_attr;
        
        }
        void set_rId_attr(const unsignedInt& _rId_attr ){

        m_has_rId_attr = true;
        m_rId_attr = _rId_attr;
        
        }
        const unsignedInt& rId_attr(){

            return type: \unsignedInt\nname: \m_rId_attr\n;
        
        }
        bool has_ua_attr(){

            return m_has_ua_attr;
        
        }
        void set_ua_attr(const boolean& _ua_attr ){

        m_has_ua_attr = true;
        m_ua_attr = _ua_attr;
        
        }
        const boolean& ua_attr(){

            return type: oolean\nname: \m_ua_attr\n;
        
        }
        bool has_ra_attr(){

            return m_has_ra_attr;
        
        }
        void set_ra_attr(const boolean& _ra_attr ){

        m_has_ra_attr = true;
        m_ra_attr = _ra_attr;
        
        }
        const boolean& ra_attr(){

            return type: oolean\nname: \m_ra_attr\n;
        
        }
        bool has_sheetId_attr(){

            return m_has_sheetId_attr;
        
        }
        void set_sheetId_attr(const unsignedInt& _sheetId_attr ){

        m_has_sheetId_attr = true;
        m_sheetId_attr = _sheetId_attr;
        
        }
        const unsignedInt& sheetId_attr(){

            return type: \unsignedInt\nname: \m_sheetId_attr\n;
        
        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_sheetPosition_attr(){

            return m_has_sheetPosition_attr;
        
        }
        void set_sheetPosition_attr(const unsignedInt& _sheetPosition_attr ){

        m_has_sheetPosition_attr = true;
        m_sheetPosition_attr = _sheetPosition_attr;
        
        }
        const unsignedInt& sheetPosition_attr(){

            return type: \unsignedInt\nname: \m_sheetPosition_attr\n;
        
        }

    private:
        static CT_RevisionInsertSheet* default_instance_ ;
        bool m_has_rId_attr ;
        unsignedInt m_rId_attr ;
        bool m_has_ua_attr ;
        boolean m_ua_attr ;
        bool m_has_ra_attr ;
        boolean m_ra_attr ;
        bool m_has_sheetId_attr ;
        unsignedInt m_sheetId_attr ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;
        bool m_has_sheetPosition_attr ;
        unsignedInt m_sheetPosition_attr ;

    }

    class CT_RevisionCellChange : public XSD::ComplexType{
    public:
        bool has_oc(){

            return m_has_oc;
        
        }
        CT_Cell* mutable_oc(){

                m_has_oc = true;
                if (!m_oc)
                {
                    m_oc = new CT_Cell();
                }
                return m_oc;
            
        }
        const CT_Cell& oc(){

            if (m_oc)
            {
                return *m_oc;
            }
            return CT_Cell::default_instance();
        
        }
        bool has_nc(){

            return m_has_nc;
        
        }
        CT_Cell* mutable_nc(){

                m_has_nc = true;
                if (!m_nc)
                {
                    m_nc = new CT_Cell();
                }
                return m_nc;
            
        }
        const CT_Cell& nc(){

            if (m_nc)
            {
                return *m_nc;
            }
            return CT_Cell::default_instance();
        
        }
        bool has_odxf(){

            return m_has_odxf;
        
        }
        CT_Dxf* mutable_odxf(){

                m_has_odxf = true;
                if (!m_odxf)
                {
                    m_odxf = new CT_Dxf();
                }
                return m_odxf;
            
        }
        const CT_Dxf& odxf(){

            if (m_odxf)
            {
                return *m_odxf;
            }
            return CT_Dxf::default_instance();
        
        }
        bool has_ndxf(){

            return m_has_ndxf;
        
        }
        CT_Dxf* mutable_ndxf(){

                m_has_ndxf = true;
                if (!m_ndxf)
                {
                    m_ndxf = new CT_Dxf();
                }
                return m_ndxf;
            
        }
        const CT_Dxf& ndxf(){

            if (m_ndxf)
            {
                return *m_ndxf;
            }
            return CT_Dxf::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_rId_attr = false;
                m_rId_attr = 0;
            
                m_has_ua_attr = false;
                m_ua_attr = false;
            
                m_has_ra_attr = false;
                m_ra_attr = false;
            
                m_has_sId_attr = false;
                m_sId_attr = 0;
            
                m_has_odxf_attr = false;
                m_odxf_attr = false;
            
                m_has_xfDxf_attr = false;
                m_xfDxf_attr = false;
            
                m_has_s_attr = false;
                m_s_attr = false;
            
                m_has_dxf_attr = false;
                m_dxf_attr = false;
            
                m_has_numFmtId_attr = false;
                
        if (m_numFmtId_attr)
        {
            delete m_numFmtId_attr;
            m_numFmtId_attr = NULL;
        }
    
            
                m_has_quotePrefix_attr = false;
                m_quotePrefix_attr = false;
            
                m_has_oldQuotePrefix_attr = false;
                m_oldQuotePrefix_attr = false;
            
                m_has_ph_attr = false;
                m_ph_attr = false;
            
                m_has_oldPh_attr = false;
                m_oldPh_attr = false;
            
                m_has_endOfListFormulaUpdate_attr = false;
                m_endOfListFormulaUpdate_attr = false;
            
                m_has_oc = false;
                
        if (m_oc)
        {
            delete m_oc;
            m_oc = NULL;
        }
    
            
                m_has_nc = false;
                
        if (m_nc)
        {
            delete m_nc;
            m_nc = NULL;
        }
    
            
                m_has_odxf = false;
                
        if (m_odxf)
        {
            delete m_odxf;
            m_odxf = NULL;
        }
    
            
                m_has_ndxf = false;
                
        if (m_ndxf)
        {
            delete m_ndxf;
            m_ndxf = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_rId_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_ua_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_ra_attr) << \\\;
_outStream << _attrName << \=\\ << m_sId_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_odxf_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_xfDxf_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_s_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_dxf_attr) << \\\;
m_numFmtId_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_quotePrefix_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_oldQuotePrefix_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_ph_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_oldPh_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_endOfListFormulaUpdate_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_oc)
                {
                    m_oc->toXml(oc, _outStream);;
                }
            
                if (m_has_nc)
                {
                    m_oc->toXml(nc, _outStream);;
                }
            
                if (m_has_odxf)
                {
                    m_oc->toXml(odxf, _outStream);;
                }
            
                if (m_has_ndxf)
                {
                    m_oc->toXml(ndxf, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_oc->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_RevisionCellChange& default_instance(){

    if (!CT_RevisionCellChange::default_instance_)
    {
        CT_RevisionCellChange::default_instance_ = new CT_RevisionCellChange();
    }
    return *CT_RevisionCellChange::default_instance_;

        }
        bool has_rId_attr(){

            return m_has_rId_attr;
        
        }
        void set_rId_attr(const unsignedInt& _rId_attr ){

        m_has_rId_attr = true;
        m_rId_attr = _rId_attr;
        
        }
        const unsignedInt& rId_attr(){

            return type: \unsignedInt\nname: \m_rId_attr\n;
        
        }
        bool has_ua_attr(){

            return m_has_ua_attr;
        
        }
        void set_ua_attr(const boolean& _ua_attr ){

        m_has_ua_attr = true;
        m_ua_attr = _ua_attr;
        
        }
        const boolean& ua_attr(){

            return type: oolean\nname: \m_ua_attr\n;
        
        }
        bool has_ra_attr(){

            return m_has_ra_attr;
        
        }
        void set_ra_attr(const boolean& _ra_attr ){

        m_has_ra_attr = true;
        m_ra_attr = _ra_attr;
        
        }
        const boolean& ra_attr(){

            return type: oolean\nname: \m_ra_attr\n;
        
        }
        bool has_sId_attr(){

            return m_has_sId_attr;
        
        }
        void set_sId_attr(const unsignedInt& _sId_attr ){

        m_has_sId_attr = true;
        m_sId_attr = _sId_attr;
        
        }
        const unsignedInt& sId_attr(){

            return type: \unsignedInt\nname: \m_sId_attr\n;
        
        }
        bool has_odxf_attr(){

            return m_has_odxf_attr;
        
        }
        void set_odxf_attr(const boolean& _odxf_attr ){

        m_has_odxf_attr = true;
        m_odxf_attr = _odxf_attr;
        
        }
        const boolean& odxf_attr(){

            return type: oolean\nname: \m_odxf_attr\n;
        
        }
        bool has_xfDxf_attr(){

            return m_has_xfDxf_attr;
        
        }
        void set_xfDxf_attr(const boolean& _xfDxf_attr ){

        m_has_xfDxf_attr = true;
        m_xfDxf_attr = _xfDxf_attr;
        
        }
        const boolean& xfDxf_attr(){

            return type: oolean\nname: \m_xfDxf_attr\n;
        
        }
        bool has_s_attr(){

            return m_has_s_attr;
        
        }
        void set_s_attr(const boolean& _s_attr ){

        m_has_s_attr = true;
        m_s_attr = _s_attr;
        
        }
        const boolean& s_attr(){

            return type: oolean\nname: \m_s_attr\n;
        
        }
        bool has_dxf_attr(){

            return m_has_dxf_attr;
        
        }
        void set_dxf_attr(const boolean& _dxf_attr ){

        m_has_dxf_attr = true;
        m_dxf_attr = _dxf_attr;
        
        }
        const boolean& dxf_attr(){

            return type: oolean\nname: \m_dxf_attr\n;
        
        }
        bool has_numFmtId_attr(){

            return m_has_numFmtId_attr;
        
        }
        void set_numFmtId_attr(const ST_NumFmtId& _numFmtId_attr ){

            m_has_numFmtId_attr = true;
            m_numFmtId_attr = new ST_NumFmtId(_numFmtId_attr);
        
        }
        const ST_NumFmtId& numFmtId_attr(){

            if (m_numFmtId_attr)
            {
                return *m_numFmtId_attr;
            }
            return ST_NumFmtId::default_instance();
        
        }
        bool has_quotePrefix_attr(){

            return m_has_quotePrefix_attr;
        
        }
        void set_quotePrefix_attr(const boolean& _quotePrefix_attr ){

        m_has_quotePrefix_attr = true;
        m_quotePrefix_attr = _quotePrefix_attr;
        
        }
        const boolean& quotePrefix_attr(){

            return type: oolean\nname: \m_quotePrefix_attr\n;
        
        }
        bool has_oldQuotePrefix_attr(){

            return m_has_oldQuotePrefix_attr;
        
        }
        void set_oldQuotePrefix_attr(const boolean& _oldQuotePrefix_attr ){

        m_has_oldQuotePrefix_attr = true;
        m_oldQuotePrefix_attr = _oldQuotePrefix_attr;
        
        }
        const boolean& oldQuotePrefix_attr(){

            return type: oolean\nname: \m_oldQuotePrefix_attr\n;
        
        }
        bool has_ph_attr(){

            return m_has_ph_attr;
        
        }
        void set_ph_attr(const boolean& _ph_attr ){

        m_has_ph_attr = true;
        m_ph_attr = _ph_attr;
        
        }
        const boolean& ph_attr(){

            return type: oolean\nname: \m_ph_attr\n;
        
        }
        bool has_oldPh_attr(){

            return m_has_oldPh_attr;
        
        }
        void set_oldPh_attr(const boolean& _oldPh_attr ){

        m_has_oldPh_attr = true;
        m_oldPh_attr = _oldPh_attr;
        
        }
        const boolean& oldPh_attr(){

            return type: oolean\nname: \m_oldPh_attr\n;
        
        }
        bool has_endOfListFormulaUpdate_attr(){

            return m_has_endOfListFormulaUpdate_attr;
        
        }
        void set_endOfListFormulaUpdate_attr(const boolean& _endOfListFormulaUpdate_attr ){

        m_has_endOfListFormulaUpdate_attr = true;
        m_endOfListFormulaUpdate_attr = _endOfListFormulaUpdate_attr;
        
        }
        const boolean& endOfListFormulaUpdate_attr(){

            return type: oolean\nname: \m_endOfListFormulaUpdate_attr\n;
        
        }

    private:
        bool m_has_oc ;
        CT_Cell* m_oc ;
        bool m_has_nc ;
        CT_Cell* m_nc ;
        bool m_has_odxf ;
        CT_Dxf* m_odxf ;
        bool m_has_ndxf ;
        CT_Dxf* m_ndxf ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_RevisionCellChange* default_instance_ ;
        bool m_has_rId_attr ;
        unsignedInt m_rId_attr ;
        bool m_has_ua_attr ;
        boolean m_ua_attr ;
        bool m_has_ra_attr ;
        boolean m_ra_attr ;
        bool m_has_sId_attr ;
        unsignedInt m_sId_attr ;
        bool m_has_odxf_attr ;
        boolean m_odxf_attr ;
        bool m_has_xfDxf_attr ;
        boolean m_xfDxf_attr ;
        bool m_has_s_attr ;
        boolean m_s_attr ;
        bool m_has_dxf_attr ;
        boolean m_dxf_attr ;
        bool m_has_numFmtId_attr ;
        ST_NumFmtId* m_numFmtId_attr ;
        bool m_has_quotePrefix_attr ;
        boolean m_quotePrefix_attr ;
        bool m_has_oldQuotePrefix_attr ;
        boolean m_oldQuotePrefix_attr ;
        bool m_has_ph_attr ;
        boolean m_ph_attr ;
        bool m_has_oldPh_attr ;
        boolean m_oldPh_attr ;
        bool m_has_endOfListFormulaUpdate_attr ;
        boolean m_endOfListFormulaUpdate_attr ;

    }

    class CT_RevisionFormatting : public XSD::ComplexType{
    public:
        bool has_dxf(){

            return m_has_dxf;
        
        }
        CT_Dxf* mutable_dxf(){

                m_has_dxf = true;
                if (!m_dxf)
                {
                    m_dxf = new CT_Dxf();
                }
                return m_dxf;
            
        }
        const CT_Dxf& dxf(){

            if (m_dxf)
            {
                return *m_dxf;
            }
            return CT_Dxf::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_sheetId_attr = false;
                m_sheetId_attr = 0;
            
                m_has_xfDxf_attr = false;
                m_xfDxf_attr = false;
            
                m_has_s_attr = false;
                m_s_attr = false;
            
                m_has_sqref_attr = false;
                
        if (m_sqref_attr)
        {
            delete m_sqref_attr;
            m_sqref_attr = NULL;
        }
    
            
                m_has_start_attr = false;
                m_start_attr = 0;
            
                m_has_length_attr = false;
                m_length_attr = 0;
            
                m_has_dxf = false;
                
        if (m_dxf)
        {
            delete m_dxf;
            m_dxf = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_sheetId_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_xfDxf_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_s_attr) << \\\;
m_sqref_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_start_attr << \\\;
_outStream << _attrName << \=\\ << m_length_attr << \\\;
        _outStream << \>\;
    
                if (m_has_dxf)
                {
                    m_dxf->toXml(dxf, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_dxf->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_RevisionFormatting& default_instance(){

    if (!CT_RevisionFormatting::default_instance_)
    {
        CT_RevisionFormatting::default_instance_ = new CT_RevisionFormatting();
    }
    return *CT_RevisionFormatting::default_instance_;

        }
        bool has_sheetId_attr(){

            return m_has_sheetId_attr;
        
        }
        void set_sheetId_attr(const unsignedInt& _sheetId_attr ){

        m_has_sheetId_attr = true;
        m_sheetId_attr = _sheetId_attr;
        
        }
        const unsignedInt& sheetId_attr(){

            return type: \unsignedInt\nname: \m_sheetId_attr\n;
        
        }
        bool has_xfDxf_attr(){

            return m_has_xfDxf_attr;
        
        }
        void set_xfDxf_attr(const boolean& _xfDxf_attr ){

        m_has_xfDxf_attr = true;
        m_xfDxf_attr = _xfDxf_attr;
        
        }
        const boolean& xfDxf_attr(){

            return type: oolean\nname: \m_xfDxf_attr\n;
        
        }
        bool has_s_attr(){

            return m_has_s_attr;
        
        }
        void set_s_attr(const boolean& _s_attr ){

        m_has_s_attr = true;
        m_s_attr = _s_attr;
        
        }
        const boolean& s_attr(){

            return type: oolean\nname: \m_s_attr\n;
        
        }
        bool has_sqref_attr(){

            return m_has_sqref_attr;
        
        }
        void set_sqref_attr(const ST_Sqref& _sqref_attr ){

            m_has_sqref_attr = true;
            m_sqref_attr = new ST_Sqref(_sqref_attr);
        
        }
        const ST_Sqref& sqref_attr(){

            if (m_sqref_attr)
            {
                return *m_sqref_attr;
            }
            return ST_Sqref::default_instance();
        
        }
        bool has_start_attr(){

            return m_has_start_attr;
        
        }
        void set_start_attr(const unsignedInt& _start_attr ){

        m_has_start_attr = true;
        m_start_attr = _start_attr;
        
        }
        const unsignedInt& start_attr(){

            return type: \unsignedInt\nname: \m_start_attr\n;
        
        }
        bool has_length_attr(){

            return m_has_length_attr;
        
        }
        void set_length_attr(const unsignedInt& _length_attr ){

        m_has_length_attr = true;
        m_length_attr = _length_attr;
        
        }
        const unsignedInt& length_attr(){

            return type: \unsignedInt\nname: \m_length_attr\n;
        
        }

    private:
        bool m_has_dxf ;
        CT_Dxf* m_dxf ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_RevisionFormatting* default_instance_ ;
        bool m_has_sheetId_attr ;
        unsignedInt m_sheetId_attr ;
        bool m_has_xfDxf_attr ;
        boolean m_xfDxf_attr ;
        bool m_has_s_attr ;
        boolean m_s_attr ;
        bool m_has_sqref_attr ;
        ST_Sqref* m_sqref_attr ;
        bool m_has_start_attr ;
        unsignedInt m_start_attr ;
        bool m_has_length_attr ;
        unsignedInt m_length_attr ;

    }

    class CT_RevisionAutoFormatting : public XSD::ComplexType{
    public:
        void clear(){

                m_has_sheetId_attr = false;
                m_sheetId_attr = 0;
            
                m_has_autoFormatId_attr = false;
                m_autoFormatId_attr = 0;
            
                m_has_applyNumberFormats_attr = false;
                m_applyNumberFormats_attr = false;
            
                m_has_applyBorderFormats_attr = false;
                m_applyBorderFormats_attr = false;
            
                m_has_applyFontFormats_attr = false;
                m_applyFontFormats_attr = false;
            
                m_has_applyPatternFormats_attr = false;
                m_applyPatternFormats_attr = false;
            
                m_has_applyAlignmentFormats_attr = false;
                m_applyAlignmentFormats_attr = false;
            
                m_has_applyWidthHeightFormats_attr = false;
                m_applyWidthHeightFormats_attr = false;
            
                m_has_ref_attr = false;
                
        if (m_ref_attr)
        {
            delete m_ref_attr;
            m_ref_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_sheetId_attr << \\\;
_outStream << _attrName << \=\\ << m_autoFormatId_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_applyNumberFormats_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_applyBorderFormats_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_applyFontFormats_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_applyPatternFormats_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_applyAlignmentFormats_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_applyWidthHeightFormats_attr) << \\\;
m_ref_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_RevisionAutoFormatting& default_instance(){

    if (!CT_RevisionAutoFormatting::default_instance_)
    {
        CT_RevisionAutoFormatting::default_instance_ = new CT_RevisionAutoFormatting();
    }
    return *CT_RevisionAutoFormatting::default_instance_;

        }
        bool has_sheetId_attr(){

            return m_has_sheetId_attr;
        
        }
        void set_sheetId_attr(const unsignedInt& _sheetId_attr ){

        m_has_sheetId_attr = true;
        m_sheetId_attr = _sheetId_attr;
        
        }
        const unsignedInt& sheetId_attr(){

            return type: \unsignedInt\nname: \m_sheetId_attr\n;
        
        }
        bool has_autoFormatId_attr(){

            return m_has_autoFormatId_attr;
        
        }
        void set_autoFormatId_attr(const unsignedInt& _autoFormatId_attr ){

        m_has_autoFormatId_attr = true;
        m_autoFormatId_attr = _autoFormatId_attr;
        
        }
        const unsignedInt& autoFormatId_attr(){

            return type: \unsignedInt\nname: \m_autoFormatId_attr\n;
        
        }
        bool has_applyNumberFormats_attr(){

            return m_has_applyNumberFormats_attr;
        
        }
        void set_applyNumberFormats_attr(const boolean& _applyNumberFormats_attr ){

        m_has_applyNumberFormats_attr = true;
        m_applyNumberFormats_attr = _applyNumberFormats_attr;
        
        }
        const boolean& applyNumberFormats_attr(){

            return type: oolean\nname: \m_applyNumberFormats_attr\n;
        
        }
        bool has_applyBorderFormats_attr(){

            return m_has_applyBorderFormats_attr;
        
        }
        void set_applyBorderFormats_attr(const boolean& _applyBorderFormats_attr ){

        m_has_applyBorderFormats_attr = true;
        m_applyBorderFormats_attr = _applyBorderFormats_attr;
        
        }
        const boolean& applyBorderFormats_attr(){

            return type: oolean\nname: \m_applyBorderFormats_attr\n;
        
        }
        bool has_applyFontFormats_attr(){

            return m_has_applyFontFormats_attr;
        
        }
        void set_applyFontFormats_attr(const boolean& _applyFontFormats_attr ){

        m_has_applyFontFormats_attr = true;
        m_applyFontFormats_attr = _applyFontFormats_attr;
        
        }
        const boolean& applyFontFormats_attr(){

            return type: oolean\nname: \m_applyFontFormats_attr\n;
        
        }
        bool has_applyPatternFormats_attr(){

            return m_has_applyPatternFormats_attr;
        
        }
        void set_applyPatternFormats_attr(const boolean& _applyPatternFormats_attr ){

        m_has_applyPatternFormats_attr = true;
        m_applyPatternFormats_attr = _applyPatternFormats_attr;
        
        }
        const boolean& applyPatternFormats_attr(){

            return type: oolean\nname: \m_applyPatternFormats_attr\n;
        
        }
        bool has_applyAlignmentFormats_attr(){

            return m_has_applyAlignmentFormats_attr;
        
        }
        void set_applyAlignmentFormats_attr(const boolean& _applyAlignmentFormats_attr ){

        m_has_applyAlignmentFormats_attr = true;
        m_applyAlignmentFormats_attr = _applyAlignmentFormats_attr;
        
        }
        const boolean& applyAlignmentFormats_attr(){

            return type: oolean\nname: \m_applyAlignmentFormats_attr\n;
        
        }
        bool has_applyWidthHeightFormats_attr(){

            return m_has_applyWidthHeightFormats_attr;
        
        }
        void set_applyWidthHeightFormats_attr(const boolean& _applyWidthHeightFormats_attr ){

        m_has_applyWidthHeightFormats_attr = true;
        m_applyWidthHeightFormats_attr = _applyWidthHeightFormats_attr;
        
        }
        const boolean& applyWidthHeightFormats_attr(){

            return type: oolean\nname: \m_applyWidthHeightFormats_attr\n;
        
        }
        bool has_ref_attr(){

            return m_has_ref_attr;
        
        }
        void set_ref_attr(const ST_Ref& _ref_attr ){

            m_has_ref_attr = true;
            m_ref_attr = new ST_Ref(_ref_attr);
        
        }
        const ST_Ref& ref_attr(){

            if (m_ref_attr)
            {
                return *m_ref_attr;
            }
            return ST_Ref::default_instance();
        
        }

    private:
        static CT_RevisionAutoFormatting* default_instance_ ;
        bool m_has_sheetId_attr ;
        unsignedInt m_sheetId_attr ;
        bool m_has_autoFormatId_attr ;
        unsignedInt m_autoFormatId_attr ;
        bool m_has_applyNumberFormats_attr ;
        boolean m_applyNumberFormats_attr ;
        bool m_has_applyBorderFormats_attr ;
        boolean m_applyBorderFormats_attr ;
        bool m_has_applyFontFormats_attr ;
        boolean m_applyFontFormats_attr ;
        bool m_has_applyPatternFormats_attr ;
        boolean m_applyPatternFormats_attr ;
        bool m_has_applyAlignmentFormats_attr ;
        boolean m_applyAlignmentFormats_attr ;
        bool m_has_applyWidthHeightFormats_attr ;
        boolean m_applyWidthHeightFormats_attr ;
        bool m_has_ref_attr ;
        ST_Ref* m_ref_attr ;

    }

    class CT_RevisionComment : public XSD::ComplexType{
    public:
        void clear(){

                m_has_sheetId_attr = false;
                m_sheetId_attr = 0;
            
                m_has_cell_attr = false;
                
        if (m_cell_attr)
        {
            delete m_cell_attr;
            m_cell_attr = NULL;
        }
    
            
                m_has_guid_attr = false;
                
        if (m_guid_attr)
        {
            delete m_guid_attr;
            m_guid_attr = NULL;
        }
    
            
                m_has_action_attr = false;
                
        if (m_action_attr)
        {
            delete m_action_attr;
            m_action_attr = NULL;
        }
    
            
                m_has_alwaysShow_attr = false;
                m_alwaysShow_attr = false;
            
                m_has_old_attr = false;
                m_old_attr = false;
            
                m_has_hiddenRow_attr = false;
                m_hiddenRow_attr = false;
            
                m_has_hiddenColumn_attr = false;
                m_hiddenColumn_attr = false;
            
                m_has_author_attr = false;
                
        if (m_author_attr)
        {
            delete m_author_attr;
            m_author_attr = NULL;
        }
    
            
                m_has_oldLength_attr = false;
                m_oldLength_attr = 0;
            
                m_has_newLength_attr = false;
                m_newLength_attr = 0;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_sheetId_attr << \\\;
m_cell_attr->toXml(_attrName, _outStream);
m_guid_attr->toXml(_attrName, _outStream);
m_action_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_alwaysShow_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_old_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_hiddenRow_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_hiddenColumn_attr) << \\\;
m_author_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_oldLength_attr << \\\;
_outStream << _attrName << \=\\ << m_newLength_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_RevisionComment& default_instance(){

    if (!CT_RevisionComment::default_instance_)
    {
        CT_RevisionComment::default_instance_ = new CT_RevisionComment();
    }
    return *CT_RevisionComment::default_instance_;

        }
        bool has_sheetId_attr(){

            return m_has_sheetId_attr;
        
        }
        void set_sheetId_attr(const unsignedInt& _sheetId_attr ){

        m_has_sheetId_attr = true;
        m_sheetId_attr = _sheetId_attr;
        
        }
        const unsignedInt& sheetId_attr(){

            return type: \unsignedInt\nname: \m_sheetId_attr\n;
        
        }
        bool has_cell_attr(){

            return m_has_cell_attr;
        
        }
        void set_cell_attr(const ST_CellRef& _cell_attr ){

            m_has_cell_attr = true;
            m_cell_attr = new ST_CellRef(_cell_attr);
        
        }
        const ST_CellRef& cell_attr(){

            if (m_cell_attr)
            {
                return *m_cell_attr;
            }
            return ST_CellRef::default_instance();
        
        }
        bool has_guid_attr(){

            return m_has_guid_attr;
        
        }
        void set_guid_attr(const ns_s::ST_Guid& _guid_attr ){

            m_has_guid_attr = true;
            m_guid_attr = new ns_s::ST_Guid(_guid_attr);
        
        }
        const ns_s::ST_Guid& guid_attr(){

            if (m_guid_attr)
            {
                return *m_guid_attr;
            }
            return ns_s::ST_Guid::default_instance();
        
        }
        bool has_action_attr(){

            return m_has_action_attr;
        
        }
        void set_action_attr(const ST_RevisionAction& _action_attr ){

            m_has_action_attr = true;
            m_action_attr = new ST_RevisionAction(_action_attr);
        
        }
        const ST_RevisionAction& action_attr(){

            if (m_action_attr)
            {
                return *m_action_attr;
            }
            return ST_RevisionAction::default_instance();
        
        }
        bool has_alwaysShow_attr(){

            return m_has_alwaysShow_attr;
        
        }
        void set_alwaysShow_attr(const boolean& _alwaysShow_attr ){

        m_has_alwaysShow_attr = true;
        m_alwaysShow_attr = _alwaysShow_attr;
        
        }
        const boolean& alwaysShow_attr(){

            return type: oolean\nname: \m_alwaysShow_attr\n;
        
        }
        bool has_old_attr(){

            return m_has_old_attr;
        
        }
        void set_old_attr(const boolean& _old_attr ){

        m_has_old_attr = true;
        m_old_attr = _old_attr;
        
        }
        const boolean& old_attr(){

            return type: oolean\nname: \m_old_attr\n;
        
        }
        bool has_hiddenRow_attr(){

            return m_has_hiddenRow_attr;
        
        }
        void set_hiddenRow_attr(const boolean& _hiddenRow_attr ){

        m_has_hiddenRow_attr = true;
        m_hiddenRow_attr = _hiddenRow_attr;
        
        }
        const boolean& hiddenRow_attr(){

            return type: oolean\nname: \m_hiddenRow_attr\n;
        
        }
        bool has_hiddenColumn_attr(){

            return m_has_hiddenColumn_attr;
        
        }
        void set_hiddenColumn_attr(const boolean& _hiddenColumn_attr ){

        m_has_hiddenColumn_attr = true;
        m_hiddenColumn_attr = _hiddenColumn_attr;
        
        }
        const boolean& hiddenColumn_attr(){

            return type: oolean\nname: \m_hiddenColumn_attr\n;
        
        }
        bool has_author_attr(){

            return m_has_author_attr;
        
        }
        void set_author_attr(const ns_s::ST_Xstring& _author_attr ){

            m_has_author_attr = true;
            m_author_attr = new ns_s::ST_Xstring(_author_attr);
        
        }
        const ns_s::ST_Xstring& author_attr(){

            if (m_author_attr)
            {
                return *m_author_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_oldLength_attr(){

            return m_has_oldLength_attr;
        
        }
        void set_oldLength_attr(const unsignedInt& _oldLength_attr ){

        m_has_oldLength_attr = true;
        m_oldLength_attr = _oldLength_attr;
        
        }
        const unsignedInt& oldLength_attr(){

            return type: \unsignedInt\nname: \m_oldLength_attr\n;
        
        }
        bool has_newLength_attr(){

            return m_has_newLength_attr;
        
        }
        void set_newLength_attr(const unsignedInt& _newLength_attr ){

        m_has_newLength_attr = true;
        m_newLength_attr = _newLength_attr;
        
        }
        const unsignedInt& newLength_attr(){

            return type: \unsignedInt\nname: \m_newLength_attr\n;
        
        }

    private:
        static CT_RevisionComment* default_instance_ ;
        bool m_has_sheetId_attr ;
        unsignedInt m_sheetId_attr ;
        bool m_has_cell_attr ;
        ST_CellRef* m_cell_attr ;
        bool m_has_guid_attr ;
        ns_s::ST_Guid* m_guid_attr ;
        bool m_has_action_attr ;
        ST_RevisionAction* m_action_attr ;
        bool m_has_alwaysShow_attr ;
        boolean m_alwaysShow_attr ;
        bool m_has_old_attr ;
        boolean m_old_attr ;
        bool m_has_hiddenRow_attr ;
        boolean m_hiddenRow_attr ;
        bool m_has_hiddenColumn_attr ;
        boolean m_hiddenColumn_attr ;
        bool m_has_author_attr ;
        ns_s::ST_Xstring* m_author_attr ;
        bool m_has_oldLength_attr ;
        unsignedInt m_oldLength_attr ;
        bool m_has_newLength_attr ;
        unsignedInt m_newLength_attr ;

    }

    class CT_RevisionDefinedName : public XSD::ComplexType{
    public:
        bool has_formula(){

            return m_has_formula;
        
        }
        ST_Formula* mutable_formula(){

                m_has_formula = true;
                if (!m_formula)
                {
                    m_formula = new ST_Formula();
                }
                return m_formula;
            
        }
        const ST_Formula& formula(){

            if (m_formula)
            {
                return *m_formula;
            }
            return ST_Formula::default_instance();
        
        }
        bool has_oldFormula(){

            return m_has_oldFormula;
        
        }
        ST_Formula* mutable_oldFormula(){

                m_has_oldFormula = true;
                if (!m_oldFormula)
                {
                    m_oldFormula = new ST_Formula();
                }
                return m_oldFormula;
            
        }
        const ST_Formula& oldFormula(){

            if (m_oldFormula)
            {
                return *m_oldFormula;
            }
            return ST_Formula::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_rId_attr = false;
                m_rId_attr = 0;
            
                m_has_ua_attr = false;
                m_ua_attr = false;
            
                m_has_ra_attr = false;
                m_ra_attr = false;
            
                m_has_localSheetId_attr = false;
                m_localSheetId_attr = 0;
            
                m_has_customView_attr = false;
                m_customView_attr = false;
            
                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
                m_has_function_attr = false;
                m_function_attr = false;
            
                m_has_oldFunction_attr = false;
                m_oldFunction_attr = false;
            
                m_has_functionGroupId_attr = false;
                m_functionGroupId_attr = 0;
            
                m_has_oldFunctionGroupId_attr = false;
                m_oldFunctionGroupId_attr = 0;
            
                m_has_shortcutKey_attr = false;
                m_shortcutKey_attr = 0;
            
                m_has_oldShortcutKey_attr = false;
                m_oldShortcutKey_attr = 0;
            
                m_has_hidden_attr = false;
                m_hidden_attr = false;
            
                m_has_oldHidden_attr = false;
                m_oldHidden_attr = false;
            
                m_has_customMenu_attr = false;
                
        if (m_customMenu_attr)
        {
            delete m_customMenu_attr;
            m_customMenu_attr = NULL;
        }
    
            
                m_has_oldCustomMenu_attr = false;
                
        if (m_oldCustomMenu_attr)
        {
            delete m_oldCustomMenu_attr;
            m_oldCustomMenu_attr = NULL;
        }
    
            
                m_has_description_attr = false;
                
        if (m_description_attr)
        {
            delete m_description_attr;
            m_description_attr = NULL;
        }
    
            
                m_has_oldDescription_attr = false;
                
        if (m_oldDescription_attr)
        {
            delete m_oldDescription_attr;
            m_oldDescription_attr = NULL;
        }
    
            
                m_has_help_attr = false;
                
        if (m_help_attr)
        {
            delete m_help_attr;
            m_help_attr = NULL;
        }
    
            
                m_has_oldHelp_attr = false;
                
        if (m_oldHelp_attr)
        {
            delete m_oldHelp_attr;
            m_oldHelp_attr = NULL;
        }
    
            
                m_has_statusBar_attr = false;
                
        if (m_statusBar_attr)
        {
            delete m_statusBar_attr;
            m_statusBar_attr = NULL;
        }
    
            
                m_has_oldStatusBar_attr = false;
                
        if (m_oldStatusBar_attr)
        {
            delete m_oldStatusBar_attr;
            m_oldStatusBar_attr = NULL;
        }
    
            
                m_has_comment_attr = false;
                
        if (m_comment_attr)
        {
            delete m_comment_attr;
            m_comment_attr = NULL;
        }
    
            
                m_has_oldComment_attr = false;
                
        if (m_oldComment_attr)
        {
            delete m_oldComment_attr;
            m_oldComment_attr = NULL;
        }
    
            
                m_has_formula = false;
                
        if (m_formula)
        {
            delete m_formula;
            m_formula = NULL;
        }
    
            
                m_has_oldFormula = false;
                
        if (m_oldFormula)
        {
            delete m_oldFormula;
            m_oldFormula = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_rId_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_ua_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_ra_attr) << \\\;
_outStream << _attrName << \=\\ << m_localSheetId_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_customView_attr) << \\\;
m_name_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_function_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_oldFunction_attr) << \\\;
_outStream << _attrName << \=\\ << m_functionGroupId_attr << \\\;
_outStream << _attrName << \=\\ << m_oldFunctionGroupId_attr << \\\;
_outStream << _attrName << \=\\ << m_shortcutKey_attr << \\\;
_outStream << _attrName << \=\\ << m_oldShortcutKey_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_hidden_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_oldHidden_attr) << \\\;
m_customMenu_attr->toXml(_attrName, _outStream);
m_oldCustomMenu_attr->toXml(_attrName, _outStream);
m_description_attr->toXml(_attrName, _outStream);
m_oldDescription_attr->toXml(_attrName, _outStream);
m_help_attr->toXml(_attrName, _outStream);
m_oldHelp_attr->toXml(_attrName, _outStream);
m_statusBar_attr->toXml(_attrName, _outStream);
m_oldStatusBar_attr->toXml(_attrName, _outStream);
m_comment_attr->toXml(_attrName, _outStream);
m_oldComment_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_formula)
                {
                    _outStream << \<formula>\ << m_formula->toString() << \</formula>\;;
                }
            
                if (m_has_oldFormula)
                {
                    _outStream << \<oldFormula>\ << m_formula->toString() << \</oldFormula>\;;
                }
            
                if (m_has_extLst)
                {
                    m_formula->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_RevisionDefinedName& default_instance(){

    if (!CT_RevisionDefinedName::default_instance_)
    {
        CT_RevisionDefinedName::default_instance_ = new CT_RevisionDefinedName();
    }
    return *CT_RevisionDefinedName::default_instance_;

        }
        bool has_rId_attr(){

            return m_has_rId_attr;
        
        }
        void set_rId_attr(const unsignedInt& _rId_attr ){

        m_has_rId_attr = true;
        m_rId_attr = _rId_attr;
        
        }
        const unsignedInt& rId_attr(){

            return type: \unsignedInt\nname: \m_rId_attr\n;
        
        }
        bool has_ua_attr(){

            return m_has_ua_attr;
        
        }
        void set_ua_attr(const boolean& _ua_attr ){

        m_has_ua_attr = true;
        m_ua_attr = _ua_attr;
        
        }
        const boolean& ua_attr(){

            return type: oolean\nname: \m_ua_attr\n;
        
        }
        bool has_ra_attr(){

            return m_has_ra_attr;
        
        }
        void set_ra_attr(const boolean& _ra_attr ){

        m_has_ra_attr = true;
        m_ra_attr = _ra_attr;
        
        }
        const boolean& ra_attr(){

            return type: oolean\nname: \m_ra_attr\n;
        
        }
        bool has_localSheetId_attr(){

            return m_has_localSheetId_attr;
        
        }
        void set_localSheetId_attr(const unsignedInt& _localSheetId_attr ){

        m_has_localSheetId_attr = true;
        m_localSheetId_attr = _localSheetId_attr;
        
        }
        const unsignedInt& localSheetId_attr(){

            return type: \unsignedInt\nname: \m_localSheetId_attr\n;
        
        }
        bool has_customView_attr(){

            return m_has_customView_attr;
        
        }
        void set_customView_attr(const boolean& _customView_attr ){

        m_has_customView_attr = true;
        m_customView_attr = _customView_attr;
        
        }
        const boolean& customView_attr(){

            return type: oolean\nname: \m_customView_attr\n;
        
        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_function_attr(){

            return m_has_function_attr;
        
        }
        void set_function_attr(const boolean& _function_attr ){

        m_has_function_attr = true;
        m_function_attr = _function_attr;
        
        }
        const boolean& function_attr(){

            return type: oolean\nname: \m_function_attr\n;
        
        }
        bool has_oldFunction_attr(){

            return m_has_oldFunction_attr;
        
        }
        void set_oldFunction_attr(const boolean& _oldFunction_attr ){

        m_has_oldFunction_attr = true;
        m_oldFunction_attr = _oldFunction_attr;
        
        }
        const boolean& oldFunction_attr(){

            return type: oolean\nname: \m_oldFunction_attr\n;
        
        }
        bool has_functionGroupId_attr(){

            return m_has_functionGroupId_attr;
        
        }
        void set_functionGroupId_attr(const unsignedByte& _functionGroupId_attr ){

        m_has_functionGroupId_attr = true;
        m_functionGroupId_attr = _functionGroupId_attr;
        
        }
        const unsignedByte& functionGroupId_attr(){

            return type: \unsignedByte\nname: \m_functionGroupId_attr\n;
        
        }
        bool has_oldFunctionGroupId_attr(){

            return m_has_oldFunctionGroupId_attr;
        
        }
        void set_oldFunctionGroupId_attr(const unsignedByte& _oldFunctionGroupId_attr ){

        m_has_oldFunctionGroupId_attr = true;
        m_oldFunctionGroupId_attr = _oldFunctionGroupId_attr;
        
        }
        const unsignedByte& oldFunctionGroupId_attr(){

            return type: \unsignedByte\nname: \m_oldFunctionGroupId_attr\n;
        
        }
        bool has_shortcutKey_attr(){

            return m_has_shortcutKey_attr;
        
        }
        void set_shortcutKey_attr(const unsignedByte& _shortcutKey_attr ){

        m_has_shortcutKey_attr = true;
        m_shortcutKey_attr = _shortcutKey_attr;
        
        }
        const unsignedByte& shortcutKey_attr(){

            return type: \unsignedByte\nname: \m_shortcutKey_attr\n;
        
        }
        bool has_oldShortcutKey_attr(){

            return m_has_oldShortcutKey_attr;
        
        }
        void set_oldShortcutKey_attr(const unsignedByte& _oldShortcutKey_attr ){

        m_has_oldShortcutKey_attr = true;
        m_oldShortcutKey_attr = _oldShortcutKey_attr;
        
        }
        const unsignedByte& oldShortcutKey_attr(){

            return type: \unsignedByte\nname: \m_oldShortcutKey_attr\n;
        
        }
        bool has_hidden_attr(){

            return m_has_hidden_attr;
        
        }
        void set_hidden_attr(const boolean& _hidden_attr ){

        m_has_hidden_attr = true;
        m_hidden_attr = _hidden_attr;
        
        }
        const boolean& hidden_attr(){

            return type: oolean\nname: \m_hidden_attr\n;
        
        }
        bool has_oldHidden_attr(){

            return m_has_oldHidden_attr;
        
        }
        void set_oldHidden_attr(const boolean& _oldHidden_attr ){

        m_has_oldHidden_attr = true;
        m_oldHidden_attr = _oldHidden_attr;
        
        }
        const boolean& oldHidden_attr(){

            return type: oolean\nname: \m_oldHidden_attr\n;
        
        }
        bool has_customMenu_attr(){

            return m_has_customMenu_attr;
        
        }
        void set_customMenu_attr(const ns_s::ST_Xstring& _customMenu_attr ){

            m_has_customMenu_attr = true;
            m_customMenu_attr = new ns_s::ST_Xstring(_customMenu_attr);
        
        }
        const ns_s::ST_Xstring& customMenu_attr(){

            if (m_customMenu_attr)
            {
                return *m_customMenu_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_oldCustomMenu_attr(){

            return m_has_oldCustomMenu_attr;
        
        }
        void set_oldCustomMenu_attr(const ns_s::ST_Xstring& _oldCustomMenu_attr ){

            m_has_oldCustomMenu_attr = true;
            m_oldCustomMenu_attr = new ns_s::ST_Xstring(_oldCustomMenu_attr);
        
        }
        const ns_s::ST_Xstring& oldCustomMenu_attr(){

            if (m_oldCustomMenu_attr)
            {
                return *m_oldCustomMenu_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_description_attr(){

            return m_has_description_attr;
        
        }
        void set_description_attr(const ns_s::ST_Xstring& _description_attr ){

            m_has_description_attr = true;
            m_description_attr = new ns_s::ST_Xstring(_description_attr);
        
        }
        const ns_s::ST_Xstring& description_attr(){

            if (m_description_attr)
            {
                return *m_description_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_oldDescription_attr(){

            return m_has_oldDescription_attr;
        
        }
        void set_oldDescription_attr(const ns_s::ST_Xstring& _oldDescription_attr ){

            m_has_oldDescription_attr = true;
            m_oldDescription_attr = new ns_s::ST_Xstring(_oldDescription_attr);
        
        }
        const ns_s::ST_Xstring& oldDescription_attr(){

            if (m_oldDescription_attr)
            {
                return *m_oldDescription_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_help_attr(){

            return m_has_help_attr;
        
        }
        void set_help_attr(const ns_s::ST_Xstring& _help_attr ){

            m_has_help_attr = true;
            m_help_attr = new ns_s::ST_Xstring(_help_attr);
        
        }
        const ns_s::ST_Xstring& help_attr(){

            if (m_help_attr)
            {
                return *m_help_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_oldHelp_attr(){

            return m_has_oldHelp_attr;
        
        }
        void set_oldHelp_attr(const ns_s::ST_Xstring& _oldHelp_attr ){

            m_has_oldHelp_attr = true;
            m_oldHelp_attr = new ns_s::ST_Xstring(_oldHelp_attr);
        
        }
        const ns_s::ST_Xstring& oldHelp_attr(){

            if (m_oldHelp_attr)
            {
                return *m_oldHelp_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_statusBar_attr(){

            return m_has_statusBar_attr;
        
        }
        void set_statusBar_attr(const ns_s::ST_Xstring& _statusBar_attr ){

            m_has_statusBar_attr = true;
            m_statusBar_attr = new ns_s::ST_Xstring(_statusBar_attr);
        
        }
        const ns_s::ST_Xstring& statusBar_attr(){

            if (m_statusBar_attr)
            {
                return *m_statusBar_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_oldStatusBar_attr(){

            return m_has_oldStatusBar_attr;
        
        }
        void set_oldStatusBar_attr(const ns_s::ST_Xstring& _oldStatusBar_attr ){

            m_has_oldStatusBar_attr = true;
            m_oldStatusBar_attr = new ns_s::ST_Xstring(_oldStatusBar_attr);
        
        }
        const ns_s::ST_Xstring& oldStatusBar_attr(){

            if (m_oldStatusBar_attr)
            {
                return *m_oldStatusBar_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_comment_attr(){

            return m_has_comment_attr;
        
        }
        void set_comment_attr(const ns_s::ST_Xstring& _comment_attr ){

            m_has_comment_attr = true;
            m_comment_attr = new ns_s::ST_Xstring(_comment_attr);
        
        }
        const ns_s::ST_Xstring& comment_attr(){

            if (m_comment_attr)
            {
                return *m_comment_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_oldComment_attr(){

            return m_has_oldComment_attr;
        
        }
        void set_oldComment_attr(const ns_s::ST_Xstring& _oldComment_attr ){

            m_has_oldComment_attr = true;
            m_oldComment_attr = new ns_s::ST_Xstring(_oldComment_attr);
        
        }
        const ns_s::ST_Xstring& oldComment_attr(){

            if (m_oldComment_attr)
            {
                return *m_oldComment_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }

    private:
        bool m_has_formula ;
        ST_Formula* m_formula ;
        bool m_has_oldFormula ;
        ST_Formula* m_oldFormula ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_RevisionDefinedName* default_instance_ ;
        bool m_has_rId_attr ;
        unsignedInt m_rId_attr ;
        bool m_has_ua_attr ;
        boolean m_ua_attr ;
        bool m_has_ra_attr ;
        boolean m_ra_attr ;
        bool m_has_localSheetId_attr ;
        unsignedInt m_localSheetId_attr ;
        bool m_has_customView_attr ;
        boolean m_customView_attr ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;
        bool m_has_function_attr ;
        boolean m_function_attr ;
        bool m_has_oldFunction_attr ;
        boolean m_oldFunction_attr ;
        bool m_has_functionGroupId_attr ;
        unsignedByte m_functionGroupId_attr ;
        bool m_has_oldFunctionGroupId_attr ;
        unsignedByte m_oldFunctionGroupId_attr ;
        bool m_has_shortcutKey_attr ;
        unsignedByte m_shortcutKey_attr ;
        bool m_has_oldShortcutKey_attr ;
        unsignedByte m_oldShortcutKey_attr ;
        bool m_has_hidden_attr ;
        boolean m_hidden_attr ;
        bool m_has_oldHidden_attr ;
        boolean m_oldHidden_attr ;
        bool m_has_customMenu_attr ;
        ns_s::ST_Xstring* m_customMenu_attr ;
        bool m_has_oldCustomMenu_attr ;
        ns_s::ST_Xstring* m_oldCustomMenu_attr ;
        bool m_has_description_attr ;
        ns_s::ST_Xstring* m_description_attr ;
        bool m_has_oldDescription_attr ;
        ns_s::ST_Xstring* m_oldDescription_attr ;
        bool m_has_help_attr ;
        ns_s::ST_Xstring* m_help_attr ;
        bool m_has_oldHelp_attr ;
        ns_s::ST_Xstring* m_oldHelp_attr ;
        bool m_has_statusBar_attr ;
        ns_s::ST_Xstring* m_statusBar_attr ;
        bool m_has_oldStatusBar_attr ;
        ns_s::ST_Xstring* m_oldStatusBar_attr ;
        bool m_has_comment_attr ;
        ns_s::ST_Xstring* m_comment_attr ;
        bool m_has_oldComment_attr ;
        ns_s::ST_Xstring* m_oldComment_attr ;

    }

    class CT_RevisionConflict : public XSD::ComplexType{
    public:
        void clear(){

                m_has_rId_attr = false;
                m_rId_attr = 0;
            
                m_has_ua_attr = false;
                m_ua_attr = false;
            
                m_has_ra_attr = false;
                m_ra_attr = false;
            
                m_has_sheetId_attr = false;
                m_sheetId_attr = 0;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_rId_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_ua_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_ra_attr) << \\\;
_outStream << _attrName << \=\\ << m_sheetId_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_RevisionConflict& default_instance(){

    if (!CT_RevisionConflict::default_instance_)
    {
        CT_RevisionConflict::default_instance_ = new CT_RevisionConflict();
    }
    return *CT_RevisionConflict::default_instance_;

        }
        bool has_rId_attr(){

            return m_has_rId_attr;
        
        }
        void set_rId_attr(const unsignedInt& _rId_attr ){

        m_has_rId_attr = true;
        m_rId_attr = _rId_attr;
        
        }
        const unsignedInt& rId_attr(){

            return type: \unsignedInt\nname: \m_rId_attr\n;
        
        }
        bool has_ua_attr(){

            return m_has_ua_attr;
        
        }
        void set_ua_attr(const boolean& _ua_attr ){

        m_has_ua_attr = true;
        m_ua_attr = _ua_attr;
        
        }
        const boolean& ua_attr(){

            return type: oolean\nname: \m_ua_attr\n;
        
        }
        bool has_ra_attr(){

            return m_has_ra_attr;
        
        }
        void set_ra_attr(const boolean& _ra_attr ){

        m_has_ra_attr = true;
        m_ra_attr = _ra_attr;
        
        }
        const boolean& ra_attr(){

            return type: oolean\nname: \m_ra_attr\n;
        
        }
        bool has_sheetId_attr(){

            return m_has_sheetId_attr;
        
        }
        void set_sheetId_attr(const unsignedInt& _sheetId_attr ){

        m_has_sheetId_attr = true;
        m_sheetId_attr = _sheetId_attr;
        
        }
        const unsignedInt& sheetId_attr(){

            return type: \unsignedInt\nname: \m_sheetId_attr\n;
        
        }

    private:
        static CT_RevisionConflict* default_instance_ ;
        bool m_has_rId_attr ;
        unsignedInt m_rId_attr ;
        bool m_has_ua_attr ;
        boolean m_ua_attr ;
        bool m_has_ra_attr ;
        boolean m_ra_attr ;
        bool m_has_sheetId_attr ;
        unsignedInt m_sheetId_attr ;

    }

    class CT_RevisionQueryTableField : public XSD::ComplexType{
    public:
        void clear(){

                m_has_sheetId_attr = false;
                m_sheetId_attr = 0;
            
                m_has_ref_attr = false;
                
        if (m_ref_attr)
        {
            delete m_ref_attr;
            m_ref_attr = NULL;
        }
    
            
                m_has_fieldId_attr = false;
                m_fieldId_attr = 0;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_sheetId_attr << \\\;
m_ref_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_fieldId_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_RevisionQueryTableField& default_instance(){

    if (!CT_RevisionQueryTableField::default_instance_)
    {
        CT_RevisionQueryTableField::default_instance_ = new CT_RevisionQueryTableField();
    }
    return *CT_RevisionQueryTableField::default_instance_;

        }
        bool has_sheetId_attr(){

            return m_has_sheetId_attr;
        
        }
        void set_sheetId_attr(const unsignedInt& _sheetId_attr ){

        m_has_sheetId_attr = true;
        m_sheetId_attr = _sheetId_attr;
        
        }
        const unsignedInt& sheetId_attr(){

            return type: \unsignedInt\nname: \m_sheetId_attr\n;
        
        }
        bool has_ref_attr(){

            return m_has_ref_attr;
        
        }
        void set_ref_attr(const ST_Ref& _ref_attr ){

            m_has_ref_attr = true;
            m_ref_attr = new ST_Ref(_ref_attr);
        
        }
        const ST_Ref& ref_attr(){

            if (m_ref_attr)
            {
                return *m_ref_attr;
            }
            return ST_Ref::default_instance();
        
        }
        bool has_fieldId_attr(){

            return m_has_fieldId_attr;
        
        }
        void set_fieldId_attr(const unsignedInt& _fieldId_attr ){

        m_has_fieldId_attr = true;
        m_fieldId_attr = _fieldId_attr;
        
        }
        const unsignedInt& fieldId_attr(){

            return type: \unsignedInt\nname: \m_fieldId_attr\n;
        
        }

    private:
        static CT_RevisionQueryTableField* default_instance_ ;
        bool m_has_sheetId_attr ;
        unsignedInt m_sheetId_attr ;
        bool m_has_ref_attr ;
        ST_Ref* m_ref_attr ;
        bool m_has_fieldId_attr ;
        unsignedInt m_fieldId_attr ;

    }

    class CT_Users : public XSD::ComplexType{
    public:
        bool has_userInfo(){

            return m_has_userInfo;
        
        }
        CT_SharedUser* mutable_userInfo(){

                m_has_userInfo = true;
                if (!m_userInfo)
                {
                    m_userInfo = new CT_SharedUser();
                }
                return m_userInfo;
            
        }
        const CT_SharedUser& userInfo(){

            if (m_userInfo)
            {
                return *m_userInfo;
            }
            return CT_SharedUser::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_userInfo = false;
                
        if (m_userInfo)
        {
            delete m_userInfo;
            m_userInfo = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_userInfo)
                {
                    m_userInfo->toXml(userInfo, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Users& default_instance(){

    if (!CT_Users::default_instance_)
    {
        CT_Users::default_instance_ = new CT_Users();
    }
    return *CT_Users::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_userInfo ;
        CT_SharedUser* m_userInfo ;
        static CT_Users* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_SharedUser : public XSD::ComplexType{
    public:
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_guid_attr = false;
                
        if (m_guid_attr)
        {
            delete m_guid_attr;
            m_guid_attr = NULL;
        }
    
            
                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
                m_has_id_attr = false;
                m_id_attr = 0;
            
                m_has_dateTime_attr = false;
                m_dateTime_attr.clear();
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_guid_attr->toXml(_attrName, _outStream);
m_name_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_id_attr << \\\;
_outStream << _attrName << \=\\ << m_dateTime_attr << \\\;
        _outStream << \>\;
    
                if (m_has_extLst)
                {
                    m_extLst->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_SharedUser& default_instance(){

    if (!CT_SharedUser::default_instance_)
    {
        CT_SharedUser::default_instance_ = new CT_SharedUser();
    }
    return *CT_SharedUser::default_instance_;

        }
        bool has_guid_attr(){

            return m_has_guid_attr;
        
        }
        void set_guid_attr(const ns_s::ST_Guid& _guid_attr ){

            m_has_guid_attr = true;
            m_guid_attr = new ns_s::ST_Guid(_guid_attr);
        
        }
        const ns_s::ST_Guid& guid_attr(){

            if (m_guid_attr)
            {
                return *m_guid_attr;
            }
            return ns_s::ST_Guid::default_instance();
        
        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_id_attr(){

            return m_has_id_attr;
        
        }
        void set_id_attr(const int& _id_attr ){

        m_has_id_attr = true;
        m_id_attr = _id_attr;
        
        }
        const int& id_attr(){

            return type: \int\nname: \m_id_attr\n;
        
        }
        bool has_dateTime_attr(){

            return m_has_dateTime_attr;
        
        }
        void set_dateTime_attr(const dateTime& _dateTime_attr ){

        m_has_dateTime_attr = true;
        m_dateTime_attr = _dateTime_attr;
        
        }
        const dateTime& dateTime_attr(){

            return type: \dateTime\nname: \m_dateTime_attr\n;
        
        }

    private:
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_SharedUser* default_instance_ ;
        bool m_has_guid_attr ;
        ns_s::ST_Guid* m_guid_attr ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;
        bool m_has_id_attr ;
        int m_id_attr ;
        bool m_has_dateTime_attr ;
        dateTime m_dateTime_attr ;

    }

    class CT_Macrosheet : public XSD::ComplexType{
    public:
        bool has_sheetPr(){

            return m_has_sheetPr;
        
        }
        CT_SheetPr* mutable_sheetPr(){

                m_has_sheetPr = true;
                if (!m_sheetPr)
                {
                    m_sheetPr = new CT_SheetPr();
                }
                return m_sheetPr;
            
        }
        const CT_SheetPr& sheetPr(){

            if (m_sheetPr)
            {
                return *m_sheetPr;
            }
            return CT_SheetPr::default_instance();
        
        }
        bool has_dimension(){

            return m_has_dimension;
        
        }
        CT_SheetDimension* mutable_dimension(){

                m_has_dimension = true;
                if (!m_dimension)
                {
                    m_dimension = new CT_SheetDimension();
                }
                return m_dimension;
            
        }
        const CT_SheetDimension& dimension(){

            if (m_dimension)
            {
                return *m_dimension;
            }
            return CT_SheetDimension::default_instance();
        
        }
        bool has_sheetViews(){

            return m_has_sheetViews;
        
        }
        CT_SheetViews* mutable_sheetViews(){

                m_has_sheetViews = true;
                if (!m_sheetViews)
                {
                    m_sheetViews = new CT_SheetViews();
                }
                return m_sheetViews;
            
        }
        const CT_SheetViews& sheetViews(){

            if (m_sheetViews)
            {
                return *m_sheetViews;
            }
            return CT_SheetViews::default_instance();
        
        }
        bool has_sheetFormatPr(){

            return m_has_sheetFormatPr;
        
        }
        CT_SheetFormatPr* mutable_sheetFormatPr(){

                m_has_sheetFormatPr = true;
                if (!m_sheetFormatPr)
                {
                    m_sheetFormatPr = new CT_SheetFormatPr();
                }
                return m_sheetFormatPr;
            
        }
        const CT_SheetFormatPr& sheetFormatPr(){

            if (m_sheetFormatPr)
            {
                return *m_sheetFormatPr;
            }
            return CT_SheetFormatPr::default_instance();
        
        }
        bool has_cols(){

            return m_has_cols;
        
        }
        CT_Cols* mutable_cols(){

                m_has_cols = true;
                if (!m_cols)
                {
                    m_cols = new CT_Cols();
                }
                return m_cols;
            
        }
        const CT_Cols& cols(){

            if (m_cols)
            {
                return *m_cols;
            }
            return CT_Cols::default_instance();
        
        }
        bool has_sheetData(){

            return m_has_sheetData;
        
        }
        CT_SheetData* mutable_sheetData(){

                m_has_sheetData = true;
                if (!m_sheetData)
                {
                    m_sheetData = new CT_SheetData();
                }
                return m_sheetData;
            
        }
        const CT_SheetData& sheetData(){

            if (m_sheetData)
            {
                return *m_sheetData;
            }
            return CT_SheetData::default_instance();
        
        }
        bool has_sheetProtection(){

            return m_has_sheetProtection;
        
        }
        CT_SheetProtection* mutable_sheetProtection(){

                m_has_sheetProtection = true;
                if (!m_sheetProtection)
                {
                    m_sheetProtection = new CT_SheetProtection();
                }
                return m_sheetProtection;
            
        }
        const CT_SheetProtection& sheetProtection(){

            if (m_sheetProtection)
            {
                return *m_sheetProtection;
            }
            return CT_SheetProtection::default_instance();
        
        }
        bool has_autoFilter(){

            return m_has_autoFilter;
        
        }
        CT_AutoFilter* mutable_autoFilter(){

                m_has_autoFilter = true;
                if (!m_autoFilter)
                {
                    m_autoFilter = new CT_AutoFilter();
                }
                return m_autoFilter;
            
        }
        const CT_AutoFilter& autoFilter(){

            if (m_autoFilter)
            {
                return *m_autoFilter;
            }
            return CT_AutoFilter::default_instance();
        
        }
        bool has_sortState(){

            return m_has_sortState;
        
        }
        CT_SortState* mutable_sortState(){

                m_has_sortState = true;
                if (!m_sortState)
                {
                    m_sortState = new CT_SortState();
                }
                return m_sortState;
            
        }
        const CT_SortState& sortState(){

            if (m_sortState)
            {
                return *m_sortState;
            }
            return CT_SortState::default_instance();
        
        }
        bool has_dataConsolidate(){

            return m_has_dataConsolidate;
        
        }
        CT_DataConsolidate* mutable_dataConsolidate(){

                m_has_dataConsolidate = true;
                if (!m_dataConsolidate)
                {
                    m_dataConsolidate = new CT_DataConsolidate();
                }
                return m_dataConsolidate;
            
        }
        const CT_DataConsolidate& dataConsolidate(){

            if (m_dataConsolidate)
            {
                return *m_dataConsolidate;
            }
            return CT_DataConsolidate::default_instance();
        
        }
        bool has_customSheetViews(){

            return m_has_customSheetViews;
        
        }
        CT_CustomSheetViews* mutable_customSheetViews(){

                m_has_customSheetViews = true;
                if (!m_customSheetViews)
                {
                    m_customSheetViews = new CT_CustomSheetViews();
                }
                return m_customSheetViews;
            
        }
        const CT_CustomSheetViews& customSheetViews(){

            if (m_customSheetViews)
            {
                return *m_customSheetViews;
            }
            return CT_CustomSheetViews::default_instance();
        
        }
        bool has_phoneticPr(){

            return m_has_phoneticPr;
        
        }
        CT_PhoneticPr* mutable_phoneticPr(){

                m_has_phoneticPr = true;
                if (!m_phoneticPr)
                {
                    m_phoneticPr = new CT_PhoneticPr();
                }
                return m_phoneticPr;
            
        }
        const CT_PhoneticPr& phoneticPr(){

            if (m_phoneticPr)
            {
                return *m_phoneticPr;
            }
            return CT_PhoneticPr::default_instance();
        
        }
        bool has_conditionalFormatting(){

            return m_has_conditionalFormatting;
        
        }
        CT_ConditionalFormatting* mutable_conditionalFormatting(){

                m_has_conditionalFormatting = true;
                if (!m_conditionalFormatting)
                {
                    m_conditionalFormatting = new CT_ConditionalFormatting();
                }
                return m_conditionalFormatting;
            
        }
        const CT_ConditionalFormatting& conditionalFormatting(){

            if (m_conditionalFormatting)
            {
                return *m_conditionalFormatting;
            }
            return CT_ConditionalFormatting::default_instance();
        
        }
        bool has_printOptions(){

            return m_has_printOptions;
        
        }
        CT_PrintOptions* mutable_printOptions(){

                m_has_printOptions = true;
                if (!m_printOptions)
                {
                    m_printOptions = new CT_PrintOptions();
                }
                return m_printOptions;
            
        }
        const CT_PrintOptions& printOptions(){

            if (m_printOptions)
            {
                return *m_printOptions;
            }
            return CT_PrintOptions::default_instance();
        
        }
        bool has_pageMargins(){

            return m_has_pageMargins;
        
        }
        CT_PageMargins* mutable_pageMargins(){

                m_has_pageMargins = true;
                if (!m_pageMargins)
                {
                    m_pageMargins = new CT_PageMargins();
                }
                return m_pageMargins;
            
        }
        const CT_PageMargins& pageMargins(){

            if (m_pageMargins)
            {
                return *m_pageMargins;
            }
            return CT_PageMargins::default_instance();
        
        }
        bool has_pageSetup(){

            return m_has_pageSetup;
        
        }
        CT_PageSetup* mutable_pageSetup(){

                m_has_pageSetup = true;
                if (!m_pageSetup)
                {
                    m_pageSetup = new CT_PageSetup();
                }
                return m_pageSetup;
            
        }
        const CT_PageSetup& pageSetup(){

            if (m_pageSetup)
            {
                return *m_pageSetup;
            }
            return CT_PageSetup::default_instance();
        
        }
        bool has_headerFooter(){

            return m_has_headerFooter;
        
        }
        CT_HeaderFooter* mutable_headerFooter(){

                m_has_headerFooter = true;
                if (!m_headerFooter)
                {
                    m_headerFooter = new CT_HeaderFooter();
                }
                return m_headerFooter;
            
        }
        const CT_HeaderFooter& headerFooter(){

            if (m_headerFooter)
            {
                return *m_headerFooter;
            }
            return CT_HeaderFooter::default_instance();
        
        }
        bool has_rowBreaks(){

            return m_has_rowBreaks;
        
        }
        CT_PageBreak* mutable_rowBreaks(){

                m_has_rowBreaks = true;
                if (!m_rowBreaks)
                {
                    m_rowBreaks = new CT_PageBreak();
                }
                return m_rowBreaks;
            
        }
        const CT_PageBreak& rowBreaks(){

            if (m_rowBreaks)
            {
                return *m_rowBreaks;
            }
            return CT_PageBreak::default_instance();
        
        }
        bool has_colBreaks(){

            return m_has_colBreaks;
        
        }
        CT_PageBreak* mutable_colBreaks(){

                m_has_colBreaks = true;
                if (!m_colBreaks)
                {
                    m_colBreaks = new CT_PageBreak();
                }
                return m_colBreaks;
            
        }
        const CT_PageBreak& colBreaks(){

            if (m_colBreaks)
            {
                return *m_colBreaks;
            }
            return CT_PageBreak::default_instance();
        
        }
        bool has_customProperties(){

            return m_has_customProperties;
        
        }
        CT_CustomProperties* mutable_customProperties(){

                m_has_customProperties = true;
                if (!m_customProperties)
                {
                    m_customProperties = new CT_CustomProperties();
                }
                return m_customProperties;
            
        }
        const CT_CustomProperties& customProperties(){

            if (m_customProperties)
            {
                return *m_customProperties;
            }
            return CT_CustomProperties::default_instance();
        
        }
        bool has_drawing(){

            return m_has_drawing;
        
        }
        CT_Drawing* mutable_drawing(){

                m_has_drawing = true;
                if (!m_drawing)
                {
                    m_drawing = new CT_Drawing();
                }
                return m_drawing;
            
        }
        const CT_Drawing& drawing(){

            if (m_drawing)
            {
                return *m_drawing;
            }
            return CT_Drawing::default_instance();
        
        }
        bool has_legacyDrawing(){

            return m_has_legacyDrawing;
        
        }
        CT_LegacyDrawing* mutable_legacyDrawing(){

                m_has_legacyDrawing = true;
                if (!m_legacyDrawing)
                {
                    m_legacyDrawing = new CT_LegacyDrawing();
                }
                return m_legacyDrawing;
            
        }
        const CT_LegacyDrawing& legacyDrawing(){

            if (m_legacyDrawing)
            {
                return *m_legacyDrawing;
            }
            return CT_LegacyDrawing::default_instance();
        
        }
        bool has_legacyDrawingHF(){

            return m_has_legacyDrawingHF;
        
        }
        CT_LegacyDrawing* mutable_legacyDrawingHF(){

                m_has_legacyDrawingHF = true;
                if (!m_legacyDrawingHF)
                {
                    m_legacyDrawingHF = new CT_LegacyDrawing();
                }
                return m_legacyDrawingHF;
            
        }
        const CT_LegacyDrawing& legacyDrawingHF(){

            if (m_legacyDrawingHF)
            {
                return *m_legacyDrawingHF;
            }
            return CT_LegacyDrawing::default_instance();
        
        }
        bool has_drawingHF(){

            return m_has_drawingHF;
        
        }
        CT_DrawingHF* mutable_drawingHF(){

                m_has_drawingHF = true;
                if (!m_drawingHF)
                {
                    m_drawingHF = new CT_DrawingHF();
                }
                return m_drawingHF;
            
        }
        const CT_DrawingHF& drawingHF(){

            if (m_drawingHF)
            {
                return *m_drawingHF;
            }
            return CT_DrawingHF::default_instance();
        
        }
        bool has_picture(){

            return m_has_picture;
        
        }
        CT_SheetBackgroundPicture* mutable_picture(){

                m_has_picture = true;
                if (!m_picture)
                {
                    m_picture = new CT_SheetBackgroundPicture();
                }
                return m_picture;
            
        }
        const CT_SheetBackgroundPicture& picture(){

            if (m_picture)
            {
                return *m_picture;
            }
            return CT_SheetBackgroundPicture::default_instance();
        
        }
        bool has_oleObjects(){

            return m_has_oleObjects;
        
        }
        CT_OleObjects* mutable_oleObjects(){

                m_has_oleObjects = true;
                if (!m_oleObjects)
                {
                    m_oleObjects = new CT_OleObjects();
                }
                return m_oleObjects;
            
        }
        const CT_OleObjects& oleObjects(){

            if (m_oleObjects)
            {
                return *m_oleObjects;
            }
            return CT_OleObjects::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_sheetPr = false;
                
        if (m_sheetPr)
        {
            delete m_sheetPr;
            m_sheetPr = NULL;
        }
    
            
                m_has_dimension = false;
                
        if (m_dimension)
        {
            delete m_dimension;
            m_dimension = NULL;
        }
    
            
                m_has_sheetViews = false;
                
        if (m_sheetViews)
        {
            delete m_sheetViews;
            m_sheetViews = NULL;
        }
    
            
                m_has_sheetFormatPr = false;
                
        if (m_sheetFormatPr)
        {
            delete m_sheetFormatPr;
            m_sheetFormatPr = NULL;
        }
    
            
                m_has_cols = false;
                
        if (m_cols)
        {
            delete m_cols;
            m_cols = NULL;
        }
    
            
                m_has_sheetData = false;
                
        if (m_sheetData)
        {
            delete m_sheetData;
            m_sheetData = NULL;
        }
    
            
                m_has_sheetProtection = false;
                
        if (m_sheetProtection)
        {
            delete m_sheetProtection;
            m_sheetProtection = NULL;
        }
    
            
                m_has_autoFilter = false;
                
        if (m_autoFilter)
        {
            delete m_autoFilter;
            m_autoFilter = NULL;
        }
    
            
                m_has_sortState = false;
                
        if (m_sortState)
        {
            delete m_sortState;
            m_sortState = NULL;
        }
    
            
                m_has_dataConsolidate = false;
                
        if (m_dataConsolidate)
        {
            delete m_dataConsolidate;
            m_dataConsolidate = NULL;
        }
    
            
                m_has_customSheetViews = false;
                
        if (m_customSheetViews)
        {
            delete m_customSheetViews;
            m_customSheetViews = NULL;
        }
    
            
                m_has_phoneticPr = false;
                
        if (m_phoneticPr)
        {
            delete m_phoneticPr;
            m_phoneticPr = NULL;
        }
    
            
                m_has_conditionalFormatting = false;
                
        if (m_conditionalFormatting)
        {
            delete m_conditionalFormatting;
            m_conditionalFormatting = NULL;
        }
    
            
                m_has_printOptions = false;
                
        if (m_printOptions)
        {
            delete m_printOptions;
            m_printOptions = NULL;
        }
    
            
                m_has_pageMargins = false;
                
        if (m_pageMargins)
        {
            delete m_pageMargins;
            m_pageMargins = NULL;
        }
    
            
                m_has_pageSetup = false;
                
        if (m_pageSetup)
        {
            delete m_pageSetup;
            m_pageSetup = NULL;
        }
    
            
                m_has_headerFooter = false;
                
        if (m_headerFooter)
        {
            delete m_headerFooter;
            m_headerFooter = NULL;
        }
    
            
                m_has_rowBreaks = false;
                
        if (m_rowBreaks)
        {
            delete m_rowBreaks;
            m_rowBreaks = NULL;
        }
    
            
                m_has_colBreaks = false;
                
        if (m_colBreaks)
        {
            delete m_colBreaks;
            m_colBreaks = NULL;
        }
    
            
                m_has_customProperties = false;
                
        if (m_customProperties)
        {
            delete m_customProperties;
            m_customProperties = NULL;
        }
    
            
                m_has_drawing = false;
                
        if (m_drawing)
        {
            delete m_drawing;
            m_drawing = NULL;
        }
    
            
                m_has_legacyDrawing = false;
                
        if (m_legacyDrawing)
        {
            delete m_legacyDrawing;
            m_legacyDrawing = NULL;
        }
    
            
                m_has_legacyDrawingHF = false;
                
        if (m_legacyDrawingHF)
        {
            delete m_legacyDrawingHF;
            m_legacyDrawingHF = NULL;
        }
    
            
                m_has_drawingHF = false;
                
        if (m_drawingHF)
        {
            delete m_drawingHF;
            m_drawingHF = NULL;
        }
    
            
                m_has_picture = false;
                
        if (m_picture)
        {
            delete m_picture;
            m_picture = NULL;
        }
    
            
                m_has_oleObjects = false;
                
        if (m_oleObjects)
        {
            delete m_oleObjects;
            m_oleObjects = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_sheetPr)
                {
                    m_sheetPr->toXml(sheetPr, _outStream);;
                }
            
                if (m_has_dimension)
                {
                    m_sheetPr->toXml(dimension, _outStream);;
                }
            
                if (m_has_sheetViews)
                {
                    m_sheetPr->toXml(sheetViews, _outStream);;
                }
            
                if (m_has_sheetFormatPr)
                {
                    m_sheetPr->toXml(sheetFormatPr, _outStream);;
                }
            
                if (m_has_cols)
                {
                    m_sheetPr->toXml(cols, _outStream);;
                }
            
                if (m_has_sheetData)
                {
                    m_sheetPr->toXml(sheetData, _outStream);;
                }
            
                if (m_has_sheetProtection)
                {
                    m_sheetPr->toXml(sheetProtection, _outStream);;
                }
            
                if (m_has_autoFilter)
                {
                    m_sheetPr->toXml(autoFilter, _outStream);;
                }
            
                if (m_has_sortState)
                {
                    m_sheetPr->toXml(sortState, _outStream);;
                }
            
                if (m_has_dataConsolidate)
                {
                    m_sheetPr->toXml(dataConsolidate, _outStream);;
                }
            
                if (m_has_customSheetViews)
                {
                    m_sheetPr->toXml(customSheetViews, _outStream);;
                }
            
                if (m_has_phoneticPr)
                {
                    m_sheetPr->toXml(phoneticPr, _outStream);;
                }
            
                if (m_has_conditionalFormatting)
                {
                    m_sheetPr->toXml(conditionalFormatting, _outStream);;
                }
            
                if (m_has_printOptions)
                {
                    m_sheetPr->toXml(printOptions, _outStream);;
                }
            
                if (m_has_pageMargins)
                {
                    m_sheetPr->toXml(pageMargins, _outStream);;
                }
            
                if (m_has_pageSetup)
                {
                    m_sheetPr->toXml(pageSetup, _outStream);;
                }
            
                if (m_has_headerFooter)
                {
                    m_sheetPr->toXml(headerFooter, _outStream);;
                }
            
                if (m_has_rowBreaks)
                {
                    m_sheetPr->toXml(rowBreaks, _outStream);;
                }
            
                if (m_has_colBreaks)
                {
                    m_sheetPr->toXml(colBreaks, _outStream);;
                }
            
                if (m_has_customProperties)
                {
                    m_sheetPr->toXml(customProperties, _outStream);;
                }
            
                if (m_has_drawing)
                {
                    m_sheetPr->toXml(drawing, _outStream);;
                }
            
                if (m_has_legacyDrawing)
                {
                    m_sheetPr->toXml(legacyDrawing, _outStream);;
                }
            
                if (m_has_legacyDrawingHF)
                {
                    m_sheetPr->toXml(legacyDrawingHF, _outStream);;
                }
            
                if (m_has_drawingHF)
                {
                    m_sheetPr->toXml(drawingHF, _outStream);;
                }
            
                if (m_has_picture)
                {
                    m_sheetPr->toXml(picture, _outStream);;
                }
            
                if (m_has_oleObjects)
                {
                    m_sheetPr->toXml(oleObjects, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_sheetPr->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Macrosheet& default_instance(){

    if (!CT_Macrosheet::default_instance_)
    {
        CT_Macrosheet::default_instance_ = new CT_Macrosheet();
    }
    return *CT_Macrosheet::default_instance_;

        }

    private:
        bool m_has_sheetPr ;
        CT_SheetPr* m_sheetPr ;
        bool m_has_dimension ;
        CT_SheetDimension* m_dimension ;
        bool m_has_sheetViews ;
        CT_SheetViews* m_sheetViews ;
        bool m_has_sheetFormatPr ;
        CT_SheetFormatPr* m_sheetFormatPr ;
        bool m_has_cols ;
        CT_Cols* m_cols ;
        bool m_has_sheetData ;
        CT_SheetData* m_sheetData ;
        bool m_has_sheetProtection ;
        CT_SheetProtection* m_sheetProtection ;
        bool m_has_autoFilter ;
        CT_AutoFilter* m_autoFilter ;
        bool m_has_sortState ;
        CT_SortState* m_sortState ;
        bool m_has_dataConsolidate ;
        CT_DataConsolidate* m_dataConsolidate ;
        bool m_has_customSheetViews ;
        CT_CustomSheetViews* m_customSheetViews ;
        bool m_has_phoneticPr ;
        CT_PhoneticPr* m_phoneticPr ;
        bool m_has_conditionalFormatting ;
        CT_ConditionalFormatting* m_conditionalFormatting ;
        bool m_has_printOptions ;
        CT_PrintOptions* m_printOptions ;
        bool m_has_pageMargins ;
        CT_PageMargins* m_pageMargins ;
        bool m_has_pageSetup ;
        CT_PageSetup* m_pageSetup ;
        bool m_has_headerFooter ;
        CT_HeaderFooter* m_headerFooter ;
        bool m_has_rowBreaks ;
        CT_PageBreak* m_rowBreaks ;
        bool m_has_colBreaks ;
        CT_PageBreak* m_colBreaks ;
        bool m_has_customProperties ;
        CT_CustomProperties* m_customProperties ;
        bool m_has_drawing ;
        CT_Drawing* m_drawing ;
        bool m_has_legacyDrawing ;
        CT_LegacyDrawing* m_legacyDrawing ;
        bool m_has_legacyDrawingHF ;
        CT_LegacyDrawing* m_legacyDrawingHF ;
        bool m_has_drawingHF ;
        CT_DrawingHF* m_drawingHF ;
        bool m_has_picture ;
        CT_SheetBackgroundPicture* m_picture ;
        bool m_has_oleObjects ;
        CT_OleObjects* m_oleObjects ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_Macrosheet* default_instance_ ;

    }

    class CT_Dialogsheet : public XSD::ComplexType{
    public:
        bool has_sheetPr(){

            return m_has_sheetPr;
        
        }
        CT_SheetPr* mutable_sheetPr(){

                m_has_sheetPr = true;
                if (!m_sheetPr)
                {
                    m_sheetPr = new CT_SheetPr();
                }
                return m_sheetPr;
            
        }
        const CT_SheetPr& sheetPr(){

            if (m_sheetPr)
            {
                return *m_sheetPr;
            }
            return CT_SheetPr::default_instance();
        
        }
        bool has_sheetViews(){

            return m_has_sheetViews;
        
        }
        CT_SheetViews* mutable_sheetViews(){

                m_has_sheetViews = true;
                if (!m_sheetViews)
                {
                    m_sheetViews = new CT_SheetViews();
                }
                return m_sheetViews;
            
        }
        const CT_SheetViews& sheetViews(){

            if (m_sheetViews)
            {
                return *m_sheetViews;
            }
            return CT_SheetViews::default_instance();
        
        }
        bool has_sheetFormatPr(){

            return m_has_sheetFormatPr;
        
        }
        CT_SheetFormatPr* mutable_sheetFormatPr(){

                m_has_sheetFormatPr = true;
                if (!m_sheetFormatPr)
                {
                    m_sheetFormatPr = new CT_SheetFormatPr();
                }
                return m_sheetFormatPr;
            
        }
        const CT_SheetFormatPr& sheetFormatPr(){

            if (m_sheetFormatPr)
            {
                return *m_sheetFormatPr;
            }
            return CT_SheetFormatPr::default_instance();
        
        }
        bool has_sheetProtection(){

            return m_has_sheetProtection;
        
        }
        CT_SheetProtection* mutable_sheetProtection(){

                m_has_sheetProtection = true;
                if (!m_sheetProtection)
                {
                    m_sheetProtection = new CT_SheetProtection();
                }
                return m_sheetProtection;
            
        }
        const CT_SheetProtection& sheetProtection(){

            if (m_sheetProtection)
            {
                return *m_sheetProtection;
            }
            return CT_SheetProtection::default_instance();
        
        }
        bool has_customSheetViews(){

            return m_has_customSheetViews;
        
        }
        CT_CustomSheetViews* mutable_customSheetViews(){

                m_has_customSheetViews = true;
                if (!m_customSheetViews)
                {
                    m_customSheetViews = new CT_CustomSheetViews();
                }
                return m_customSheetViews;
            
        }
        const CT_CustomSheetViews& customSheetViews(){

            if (m_customSheetViews)
            {
                return *m_customSheetViews;
            }
            return CT_CustomSheetViews::default_instance();
        
        }
        bool has_printOptions(){

            return m_has_printOptions;
        
        }
        CT_PrintOptions* mutable_printOptions(){

                m_has_printOptions = true;
                if (!m_printOptions)
                {
                    m_printOptions = new CT_PrintOptions();
                }
                return m_printOptions;
            
        }
        const CT_PrintOptions& printOptions(){

            if (m_printOptions)
            {
                return *m_printOptions;
            }
            return CT_PrintOptions::default_instance();
        
        }
        bool has_pageMargins(){

            return m_has_pageMargins;
        
        }
        CT_PageMargins* mutable_pageMargins(){

                m_has_pageMargins = true;
                if (!m_pageMargins)
                {
                    m_pageMargins = new CT_PageMargins();
                }
                return m_pageMargins;
            
        }
        const CT_PageMargins& pageMargins(){

            if (m_pageMargins)
            {
                return *m_pageMargins;
            }
            return CT_PageMargins::default_instance();
        
        }
        bool has_pageSetup(){

            return m_has_pageSetup;
        
        }
        CT_PageSetup* mutable_pageSetup(){

                m_has_pageSetup = true;
                if (!m_pageSetup)
                {
                    m_pageSetup = new CT_PageSetup();
                }
                return m_pageSetup;
            
        }
        const CT_PageSetup& pageSetup(){

            if (m_pageSetup)
            {
                return *m_pageSetup;
            }
            return CT_PageSetup::default_instance();
        
        }
        bool has_headerFooter(){

            return m_has_headerFooter;
        
        }
        CT_HeaderFooter* mutable_headerFooter(){

                m_has_headerFooter = true;
                if (!m_headerFooter)
                {
                    m_headerFooter = new CT_HeaderFooter();
                }
                return m_headerFooter;
            
        }
        const CT_HeaderFooter& headerFooter(){

            if (m_headerFooter)
            {
                return *m_headerFooter;
            }
            return CT_HeaderFooter::default_instance();
        
        }
        bool has_drawing(){

            return m_has_drawing;
        
        }
        CT_Drawing* mutable_drawing(){

                m_has_drawing = true;
                if (!m_drawing)
                {
                    m_drawing = new CT_Drawing();
                }
                return m_drawing;
            
        }
        const CT_Drawing& drawing(){

            if (m_drawing)
            {
                return *m_drawing;
            }
            return CT_Drawing::default_instance();
        
        }
        bool has_legacyDrawing(){

            return m_has_legacyDrawing;
        
        }
        CT_LegacyDrawing* mutable_legacyDrawing(){

                m_has_legacyDrawing = true;
                if (!m_legacyDrawing)
                {
                    m_legacyDrawing = new CT_LegacyDrawing();
                }
                return m_legacyDrawing;
            
        }
        const CT_LegacyDrawing& legacyDrawing(){

            if (m_legacyDrawing)
            {
                return *m_legacyDrawing;
            }
            return CT_LegacyDrawing::default_instance();
        
        }
        bool has_legacyDrawingHF(){

            return m_has_legacyDrawingHF;
        
        }
        CT_LegacyDrawing* mutable_legacyDrawingHF(){

                m_has_legacyDrawingHF = true;
                if (!m_legacyDrawingHF)
                {
                    m_legacyDrawingHF = new CT_LegacyDrawing();
                }
                return m_legacyDrawingHF;
            
        }
        const CT_LegacyDrawing& legacyDrawingHF(){

            if (m_legacyDrawingHF)
            {
                return *m_legacyDrawingHF;
            }
            return CT_LegacyDrawing::default_instance();
        
        }
        bool has_drawingHF(){

            return m_has_drawingHF;
        
        }
        CT_DrawingHF* mutable_drawingHF(){

                m_has_drawingHF = true;
                if (!m_drawingHF)
                {
                    m_drawingHF = new CT_DrawingHF();
                }
                return m_drawingHF;
            
        }
        const CT_DrawingHF& drawingHF(){

            if (m_drawingHF)
            {
                return *m_drawingHF;
            }
            return CT_DrawingHF::default_instance();
        
        }
        bool has_oleObjects(){

            return m_has_oleObjects;
        
        }
        CT_OleObjects* mutable_oleObjects(){

                m_has_oleObjects = true;
                if (!m_oleObjects)
                {
                    m_oleObjects = new CT_OleObjects();
                }
                return m_oleObjects;
            
        }
        const CT_OleObjects& oleObjects(){

            if (m_oleObjects)
            {
                return *m_oleObjects;
            }
            return CT_OleObjects::default_instance();
        
        }
        bool has_controls(){

            return m_has_controls;
        
        }
        CT_Controls* mutable_controls(){

                m_has_controls = true;
                if (!m_controls)
                {
                    m_controls = new CT_Controls();
                }
                return m_controls;
            
        }
        const CT_Controls& controls(){

            if (m_controls)
            {
                return *m_controls;
            }
            return CT_Controls::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_sheetPr = false;
                
        if (m_sheetPr)
        {
            delete m_sheetPr;
            m_sheetPr = NULL;
        }
    
            
                m_has_sheetViews = false;
                
        if (m_sheetViews)
        {
            delete m_sheetViews;
            m_sheetViews = NULL;
        }
    
            
                m_has_sheetFormatPr = false;
                
        if (m_sheetFormatPr)
        {
            delete m_sheetFormatPr;
            m_sheetFormatPr = NULL;
        }
    
            
                m_has_sheetProtection = false;
                
        if (m_sheetProtection)
        {
            delete m_sheetProtection;
            m_sheetProtection = NULL;
        }
    
            
                m_has_customSheetViews = false;
                
        if (m_customSheetViews)
        {
            delete m_customSheetViews;
            m_customSheetViews = NULL;
        }
    
            
                m_has_printOptions = false;
                
        if (m_printOptions)
        {
            delete m_printOptions;
            m_printOptions = NULL;
        }
    
            
                m_has_pageMargins = false;
                
        if (m_pageMargins)
        {
            delete m_pageMargins;
            m_pageMargins = NULL;
        }
    
            
                m_has_pageSetup = false;
                
        if (m_pageSetup)
        {
            delete m_pageSetup;
            m_pageSetup = NULL;
        }
    
            
                m_has_headerFooter = false;
                
        if (m_headerFooter)
        {
            delete m_headerFooter;
            m_headerFooter = NULL;
        }
    
            
                m_has_drawing = false;
                
        if (m_drawing)
        {
            delete m_drawing;
            m_drawing = NULL;
        }
    
            
                m_has_legacyDrawing = false;
                
        if (m_legacyDrawing)
        {
            delete m_legacyDrawing;
            m_legacyDrawing = NULL;
        }
    
            
                m_has_legacyDrawingHF = false;
                
        if (m_legacyDrawingHF)
        {
            delete m_legacyDrawingHF;
            m_legacyDrawingHF = NULL;
        }
    
            
                m_has_drawingHF = false;
                
        if (m_drawingHF)
        {
            delete m_drawingHF;
            m_drawingHF = NULL;
        }
    
            
                m_has_oleObjects = false;
                
        if (m_oleObjects)
        {
            delete m_oleObjects;
            m_oleObjects = NULL;
        }
    
            
                m_has_controls = false;
                
        if (m_controls)
        {
            delete m_controls;
            m_controls = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_sheetPr)
                {
                    m_sheetPr->toXml(sheetPr, _outStream);;
                }
            
                if (m_has_sheetViews)
                {
                    m_sheetPr->toXml(sheetViews, _outStream);;
                }
            
                if (m_has_sheetFormatPr)
                {
                    m_sheetPr->toXml(sheetFormatPr, _outStream);;
                }
            
                if (m_has_sheetProtection)
                {
                    m_sheetPr->toXml(sheetProtection, _outStream);;
                }
            
                if (m_has_customSheetViews)
                {
                    m_sheetPr->toXml(customSheetViews, _outStream);;
                }
            
                if (m_has_printOptions)
                {
                    m_sheetPr->toXml(printOptions, _outStream);;
                }
            
                if (m_has_pageMargins)
                {
                    m_sheetPr->toXml(pageMargins, _outStream);;
                }
            
                if (m_has_pageSetup)
                {
                    m_sheetPr->toXml(pageSetup, _outStream);;
                }
            
                if (m_has_headerFooter)
                {
                    m_sheetPr->toXml(headerFooter, _outStream);;
                }
            
                if (m_has_drawing)
                {
                    m_sheetPr->toXml(drawing, _outStream);;
                }
            
                if (m_has_legacyDrawing)
                {
                    m_sheetPr->toXml(legacyDrawing, _outStream);;
                }
            
                if (m_has_legacyDrawingHF)
                {
                    m_sheetPr->toXml(legacyDrawingHF, _outStream);;
                }
            
                if (m_has_drawingHF)
                {
                    m_sheetPr->toXml(drawingHF, _outStream);;
                }
            
                if (m_has_oleObjects)
                {
                    m_sheetPr->toXml(oleObjects, _outStream);;
                }
            
                if (m_has_controls)
                {
                    m_sheetPr->toXml(controls, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_sheetPr->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Dialogsheet& default_instance(){

    if (!CT_Dialogsheet::default_instance_)
    {
        CT_Dialogsheet::default_instance_ = new CT_Dialogsheet();
    }
    return *CT_Dialogsheet::default_instance_;

        }

    private:
        bool m_has_sheetPr ;
        CT_SheetPr* m_sheetPr ;
        bool m_has_sheetViews ;
        CT_SheetViews* m_sheetViews ;
        bool m_has_sheetFormatPr ;
        CT_SheetFormatPr* m_sheetFormatPr ;
        bool m_has_sheetProtection ;
        CT_SheetProtection* m_sheetProtection ;
        bool m_has_customSheetViews ;
        CT_CustomSheetViews* m_customSheetViews ;
        bool m_has_printOptions ;
        CT_PrintOptions* m_printOptions ;
        bool m_has_pageMargins ;
        CT_PageMargins* m_pageMargins ;
        bool m_has_pageSetup ;
        CT_PageSetup* m_pageSetup ;
        bool m_has_headerFooter ;
        CT_HeaderFooter* m_headerFooter ;
        bool m_has_drawing ;
        CT_Drawing* m_drawing ;
        bool m_has_legacyDrawing ;
        CT_LegacyDrawing* m_legacyDrawing ;
        bool m_has_legacyDrawingHF ;
        CT_LegacyDrawing* m_legacyDrawingHF ;
        bool m_has_drawingHF ;
        CT_DrawingHF* m_drawingHF ;
        bool m_has_oleObjects ;
        CT_OleObjects* m_oleObjects ;
        bool m_has_controls ;
        CT_Controls* m_controls ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_Dialogsheet* default_instance_ ;

    }

    class CT_Worksheet : public XSD::ComplexType{
    public:
        bool has_sheetPr(){

            return m_has_sheetPr;
        
        }
        CT_SheetPr* mutable_sheetPr(){

                m_has_sheetPr = true;
                if (!m_sheetPr)
                {
                    m_sheetPr = new CT_SheetPr();
                }
                return m_sheetPr;
            
        }
        const CT_SheetPr& sheetPr(){

            if (m_sheetPr)
            {
                return *m_sheetPr;
            }
            return CT_SheetPr::default_instance();
        
        }
        bool has_dimension(){

            return m_has_dimension;
        
        }
        CT_SheetDimension* mutable_dimension(){

                m_has_dimension = true;
                if (!m_dimension)
                {
                    m_dimension = new CT_SheetDimension();
                }
                return m_dimension;
            
        }
        const CT_SheetDimension& dimension(){

            if (m_dimension)
            {
                return *m_dimension;
            }
            return CT_SheetDimension::default_instance();
        
        }
        bool has_sheetViews(){

            return m_has_sheetViews;
        
        }
        CT_SheetViews* mutable_sheetViews(){

                m_has_sheetViews = true;
                if (!m_sheetViews)
                {
                    m_sheetViews = new CT_SheetViews();
                }
                return m_sheetViews;
            
        }
        const CT_SheetViews& sheetViews(){

            if (m_sheetViews)
            {
                return *m_sheetViews;
            }
            return CT_SheetViews::default_instance();
        
        }
        bool has_sheetFormatPr(){

            return m_has_sheetFormatPr;
        
        }
        CT_SheetFormatPr* mutable_sheetFormatPr(){

                m_has_sheetFormatPr = true;
                if (!m_sheetFormatPr)
                {
                    m_sheetFormatPr = new CT_SheetFormatPr();
                }
                return m_sheetFormatPr;
            
        }
        const CT_SheetFormatPr& sheetFormatPr(){

            if (m_sheetFormatPr)
            {
                return *m_sheetFormatPr;
            }
            return CT_SheetFormatPr::default_instance();
        
        }
        bool has_cols(){

            return m_has_cols;
        
        }
        CT_Cols* mutable_cols(){

                m_has_cols = true;
                if (!m_cols)
                {
                    m_cols = new CT_Cols();
                }
                return m_cols;
            
        }
        const CT_Cols& cols(){

            if (m_cols)
            {
                return *m_cols;
            }
            return CT_Cols::default_instance();
        
        }
        bool has_sheetData(){

            return m_has_sheetData;
        
        }
        CT_SheetData* mutable_sheetData(){

                m_has_sheetData = true;
                if (!m_sheetData)
                {
                    m_sheetData = new CT_SheetData();
                }
                return m_sheetData;
            
        }
        const CT_SheetData& sheetData(){

            if (m_sheetData)
            {
                return *m_sheetData;
            }
            return CT_SheetData::default_instance();
        
        }
        bool has_sheetCalcPr(){

            return m_has_sheetCalcPr;
        
        }
        CT_SheetCalcPr* mutable_sheetCalcPr(){

                m_has_sheetCalcPr = true;
                if (!m_sheetCalcPr)
                {
                    m_sheetCalcPr = new CT_SheetCalcPr();
                }
                return m_sheetCalcPr;
            
        }
        const CT_SheetCalcPr& sheetCalcPr(){

            if (m_sheetCalcPr)
            {
                return *m_sheetCalcPr;
            }
            return CT_SheetCalcPr::default_instance();
        
        }
        bool has_sheetProtection(){

            return m_has_sheetProtection;
        
        }
        CT_SheetProtection* mutable_sheetProtection(){

                m_has_sheetProtection = true;
                if (!m_sheetProtection)
                {
                    m_sheetProtection = new CT_SheetProtection();
                }
                return m_sheetProtection;
            
        }
        const CT_SheetProtection& sheetProtection(){

            if (m_sheetProtection)
            {
                return *m_sheetProtection;
            }
            return CT_SheetProtection::default_instance();
        
        }
        bool has_protectedRanges(){

            return m_has_protectedRanges;
        
        }
        CT_ProtectedRanges* mutable_protectedRanges(){

                m_has_protectedRanges = true;
                if (!m_protectedRanges)
                {
                    m_protectedRanges = new CT_ProtectedRanges();
                }
                return m_protectedRanges;
            
        }
        const CT_ProtectedRanges& protectedRanges(){

            if (m_protectedRanges)
            {
                return *m_protectedRanges;
            }
            return CT_ProtectedRanges::default_instance();
        
        }
        bool has_scenarios(){

            return m_has_scenarios;
        
        }
        CT_Scenarios* mutable_scenarios(){

                m_has_scenarios = true;
                if (!m_scenarios)
                {
                    m_scenarios = new CT_Scenarios();
                }
                return m_scenarios;
            
        }
        const CT_Scenarios& scenarios(){

            if (m_scenarios)
            {
                return *m_scenarios;
            }
            return CT_Scenarios::default_instance();
        
        }
        bool has_autoFilter(){

            return m_has_autoFilter;
        
        }
        CT_AutoFilter* mutable_autoFilter(){

                m_has_autoFilter = true;
                if (!m_autoFilter)
                {
                    m_autoFilter = new CT_AutoFilter();
                }
                return m_autoFilter;
            
        }
        const CT_AutoFilter& autoFilter(){

            if (m_autoFilter)
            {
                return *m_autoFilter;
            }
            return CT_AutoFilter::default_instance();
        
        }
        bool has_sortState(){

            return m_has_sortState;
        
        }
        CT_SortState* mutable_sortState(){

                m_has_sortState = true;
                if (!m_sortState)
                {
                    m_sortState = new CT_SortState();
                }
                return m_sortState;
            
        }
        const CT_SortState& sortState(){

            if (m_sortState)
            {
                return *m_sortState;
            }
            return CT_SortState::default_instance();
        
        }
        bool has_dataConsolidate(){

            return m_has_dataConsolidate;
        
        }
        CT_DataConsolidate* mutable_dataConsolidate(){

                m_has_dataConsolidate = true;
                if (!m_dataConsolidate)
                {
                    m_dataConsolidate = new CT_DataConsolidate();
                }
                return m_dataConsolidate;
            
        }
        const CT_DataConsolidate& dataConsolidate(){

            if (m_dataConsolidate)
            {
                return *m_dataConsolidate;
            }
            return CT_DataConsolidate::default_instance();
        
        }
        bool has_customSheetViews(){

            return m_has_customSheetViews;
        
        }
        CT_CustomSheetViews* mutable_customSheetViews(){

                m_has_customSheetViews = true;
                if (!m_customSheetViews)
                {
                    m_customSheetViews = new CT_CustomSheetViews();
                }
                return m_customSheetViews;
            
        }
        const CT_CustomSheetViews& customSheetViews(){

            if (m_customSheetViews)
            {
                return *m_customSheetViews;
            }
            return CT_CustomSheetViews::default_instance();
        
        }
        bool has_mergeCells(){

            return m_has_mergeCells;
        
        }
        CT_MergeCells* mutable_mergeCells(){

                m_has_mergeCells = true;
                if (!m_mergeCells)
                {
                    m_mergeCells = new CT_MergeCells();
                }
                return m_mergeCells;
            
        }
        const CT_MergeCells& mergeCells(){

            if (m_mergeCells)
            {
                return *m_mergeCells;
            }
            return CT_MergeCells::default_instance();
        
        }
        bool has_phoneticPr(){

            return m_has_phoneticPr;
        
        }
        CT_PhoneticPr* mutable_phoneticPr(){

                m_has_phoneticPr = true;
                if (!m_phoneticPr)
                {
                    m_phoneticPr = new CT_PhoneticPr();
                }
                return m_phoneticPr;
            
        }
        const CT_PhoneticPr& phoneticPr(){

            if (m_phoneticPr)
            {
                return *m_phoneticPr;
            }
            return CT_PhoneticPr::default_instance();
        
        }
        bool has_conditionalFormatting(){

            return m_has_conditionalFormatting;
        
        }
        CT_ConditionalFormatting* mutable_conditionalFormatting(){

                m_has_conditionalFormatting = true;
                if (!m_conditionalFormatting)
                {
                    m_conditionalFormatting = new CT_ConditionalFormatting();
                }
                return m_conditionalFormatting;
            
        }
        const CT_ConditionalFormatting& conditionalFormatting(){

            if (m_conditionalFormatting)
            {
                return *m_conditionalFormatting;
            }
            return CT_ConditionalFormatting::default_instance();
        
        }
        bool has_dataValidations(){

            return m_has_dataValidations;
        
        }
        CT_DataValidations* mutable_dataValidations(){

                m_has_dataValidations = true;
                if (!m_dataValidations)
                {
                    m_dataValidations = new CT_DataValidations();
                }
                return m_dataValidations;
            
        }
        const CT_DataValidations& dataValidations(){

            if (m_dataValidations)
            {
                return *m_dataValidations;
            }
            return CT_DataValidations::default_instance();
        
        }
        bool has_hyperlinks(){

            return m_has_hyperlinks;
        
        }
        CT_Hyperlinks* mutable_hyperlinks(){

                m_has_hyperlinks = true;
                if (!m_hyperlinks)
                {
                    m_hyperlinks = new CT_Hyperlinks();
                }
                return m_hyperlinks;
            
        }
        const CT_Hyperlinks& hyperlinks(){

            if (m_hyperlinks)
            {
                return *m_hyperlinks;
            }
            return CT_Hyperlinks::default_instance();
        
        }
        bool has_printOptions(){

            return m_has_printOptions;
        
        }
        CT_PrintOptions* mutable_printOptions(){

                m_has_printOptions = true;
                if (!m_printOptions)
                {
                    m_printOptions = new CT_PrintOptions();
                }
                return m_printOptions;
            
        }
        const CT_PrintOptions& printOptions(){

            if (m_printOptions)
            {
                return *m_printOptions;
            }
            return CT_PrintOptions::default_instance();
        
        }
        bool has_pageMargins(){

            return m_has_pageMargins;
        
        }
        CT_PageMargins* mutable_pageMargins(){

                m_has_pageMargins = true;
                if (!m_pageMargins)
                {
                    m_pageMargins = new CT_PageMargins();
                }
                return m_pageMargins;
            
        }
        const CT_PageMargins& pageMargins(){

            if (m_pageMargins)
            {
                return *m_pageMargins;
            }
            return CT_PageMargins::default_instance();
        
        }
        bool has_pageSetup(){

            return m_has_pageSetup;
        
        }
        CT_PageSetup* mutable_pageSetup(){

                m_has_pageSetup = true;
                if (!m_pageSetup)
                {
                    m_pageSetup = new CT_PageSetup();
                }
                return m_pageSetup;
            
        }
        const CT_PageSetup& pageSetup(){

            if (m_pageSetup)
            {
                return *m_pageSetup;
            }
            return CT_PageSetup::default_instance();
        
        }
        bool has_headerFooter(){

            return m_has_headerFooter;
        
        }
        CT_HeaderFooter* mutable_headerFooter(){

                m_has_headerFooter = true;
                if (!m_headerFooter)
                {
                    m_headerFooter = new CT_HeaderFooter();
                }
                return m_headerFooter;
            
        }
        const CT_HeaderFooter& headerFooter(){

            if (m_headerFooter)
            {
                return *m_headerFooter;
            }
            return CT_HeaderFooter::default_instance();
        
        }
        bool has_rowBreaks(){

            return m_has_rowBreaks;
        
        }
        CT_PageBreak* mutable_rowBreaks(){

                m_has_rowBreaks = true;
                if (!m_rowBreaks)
                {
                    m_rowBreaks = new CT_PageBreak();
                }
                return m_rowBreaks;
            
        }
        const CT_PageBreak& rowBreaks(){

            if (m_rowBreaks)
            {
                return *m_rowBreaks;
            }
            return CT_PageBreak::default_instance();
        
        }
        bool has_colBreaks(){

            return m_has_colBreaks;
        
        }
        CT_PageBreak* mutable_colBreaks(){

                m_has_colBreaks = true;
                if (!m_colBreaks)
                {
                    m_colBreaks = new CT_PageBreak();
                }
                return m_colBreaks;
            
        }
        const CT_PageBreak& colBreaks(){

            if (m_colBreaks)
            {
                return *m_colBreaks;
            }
            return CT_PageBreak::default_instance();
        
        }
        bool has_customProperties(){

            return m_has_customProperties;
        
        }
        CT_CustomProperties* mutable_customProperties(){

                m_has_customProperties = true;
                if (!m_customProperties)
                {
                    m_customProperties = new CT_CustomProperties();
                }
                return m_customProperties;
            
        }
        const CT_CustomProperties& customProperties(){

            if (m_customProperties)
            {
                return *m_customProperties;
            }
            return CT_CustomProperties::default_instance();
        
        }
        bool has_cellWatches(){

            return m_has_cellWatches;
        
        }
        CT_CellWatches* mutable_cellWatches(){

                m_has_cellWatches = true;
                if (!m_cellWatches)
                {
                    m_cellWatches = new CT_CellWatches();
                }
                return m_cellWatches;
            
        }
        const CT_CellWatches& cellWatches(){

            if (m_cellWatches)
            {
                return *m_cellWatches;
            }
            return CT_CellWatches::default_instance();
        
        }
        bool has_ignoredErrors(){

            return m_has_ignoredErrors;
        
        }
        CT_IgnoredErrors* mutable_ignoredErrors(){

                m_has_ignoredErrors = true;
                if (!m_ignoredErrors)
                {
                    m_ignoredErrors = new CT_IgnoredErrors();
                }
                return m_ignoredErrors;
            
        }
        const CT_IgnoredErrors& ignoredErrors(){

            if (m_ignoredErrors)
            {
                return *m_ignoredErrors;
            }
            return CT_IgnoredErrors::default_instance();
        
        }
        bool has_smartTags(){

            return m_has_smartTags;
        
        }
        CT_SmartTags* mutable_smartTags(){

                m_has_smartTags = true;
                if (!m_smartTags)
                {
                    m_smartTags = new CT_SmartTags();
                }
                return m_smartTags;
            
        }
        const CT_SmartTags& smartTags(){

            if (m_smartTags)
            {
                return *m_smartTags;
            }
            return CT_SmartTags::default_instance();
        
        }
        bool has_drawing(){

            return m_has_drawing;
        
        }
        CT_Drawing* mutable_drawing(){

                m_has_drawing = true;
                if (!m_drawing)
                {
                    m_drawing = new CT_Drawing();
                }
                return m_drawing;
            
        }
        const CT_Drawing& drawing(){

            if (m_drawing)
            {
                return *m_drawing;
            }
            return CT_Drawing::default_instance();
        
        }
        bool has_legacyDrawing(){

            return m_has_legacyDrawing;
        
        }
        CT_LegacyDrawing* mutable_legacyDrawing(){

                m_has_legacyDrawing = true;
                if (!m_legacyDrawing)
                {
                    m_legacyDrawing = new CT_LegacyDrawing();
                }
                return m_legacyDrawing;
            
        }
        const CT_LegacyDrawing& legacyDrawing(){

            if (m_legacyDrawing)
            {
                return *m_legacyDrawing;
            }
            return CT_LegacyDrawing::default_instance();
        
        }
        bool has_legacyDrawingHF(){

            return m_has_legacyDrawingHF;
        
        }
        CT_LegacyDrawing* mutable_legacyDrawingHF(){

                m_has_legacyDrawingHF = true;
                if (!m_legacyDrawingHF)
                {
                    m_legacyDrawingHF = new CT_LegacyDrawing();
                }
                return m_legacyDrawingHF;
            
        }
        const CT_LegacyDrawing& legacyDrawingHF(){

            if (m_legacyDrawingHF)
            {
                return *m_legacyDrawingHF;
            }
            return CT_LegacyDrawing::default_instance();
        
        }
        bool has_drawingHF(){

            return m_has_drawingHF;
        
        }
        CT_DrawingHF* mutable_drawingHF(){

                m_has_drawingHF = true;
                if (!m_drawingHF)
                {
                    m_drawingHF = new CT_DrawingHF();
                }
                return m_drawingHF;
            
        }
        const CT_DrawingHF& drawingHF(){

            if (m_drawingHF)
            {
                return *m_drawingHF;
            }
            return CT_DrawingHF::default_instance();
        
        }
        bool has_picture(){

            return m_has_picture;
        
        }
        CT_SheetBackgroundPicture* mutable_picture(){

                m_has_picture = true;
                if (!m_picture)
                {
                    m_picture = new CT_SheetBackgroundPicture();
                }
                return m_picture;
            
        }
        const CT_SheetBackgroundPicture& picture(){

            if (m_picture)
            {
                return *m_picture;
            }
            return CT_SheetBackgroundPicture::default_instance();
        
        }
        bool has_oleObjects(){

            return m_has_oleObjects;
        
        }
        CT_OleObjects* mutable_oleObjects(){

                m_has_oleObjects = true;
                if (!m_oleObjects)
                {
                    m_oleObjects = new CT_OleObjects();
                }
                return m_oleObjects;
            
        }
        const CT_OleObjects& oleObjects(){

            if (m_oleObjects)
            {
                return *m_oleObjects;
            }
            return CT_OleObjects::default_instance();
        
        }
        bool has_controls(){

            return m_has_controls;
        
        }
        CT_Controls* mutable_controls(){

                m_has_controls = true;
                if (!m_controls)
                {
                    m_controls = new CT_Controls();
                }
                return m_controls;
            
        }
        const CT_Controls& controls(){

            if (m_controls)
            {
                return *m_controls;
            }
            return CT_Controls::default_instance();
        
        }
        bool has_webPublishItems(){

            return m_has_webPublishItems;
        
        }
        CT_WebPublishItems* mutable_webPublishItems(){

                m_has_webPublishItems = true;
                if (!m_webPublishItems)
                {
                    m_webPublishItems = new CT_WebPublishItems();
                }
                return m_webPublishItems;
            
        }
        const CT_WebPublishItems& webPublishItems(){

            if (m_webPublishItems)
            {
                return *m_webPublishItems;
            }
            return CT_WebPublishItems::default_instance();
        
        }
        bool has_tableParts(){

            return m_has_tableParts;
        
        }
        CT_TableParts* mutable_tableParts(){

                m_has_tableParts = true;
                if (!m_tableParts)
                {
                    m_tableParts = new CT_TableParts();
                }
                return m_tableParts;
            
        }
        const CT_TableParts& tableParts(){

            if (m_tableParts)
            {
                return *m_tableParts;
            }
            return CT_TableParts::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_sheetPr = false;
                
        if (m_sheetPr)
        {
            delete m_sheetPr;
            m_sheetPr = NULL;
        }
    
            
                m_has_dimension = false;
                
        if (m_dimension)
        {
            delete m_dimension;
            m_dimension = NULL;
        }
    
            
                m_has_sheetViews = false;
                
        if (m_sheetViews)
        {
            delete m_sheetViews;
            m_sheetViews = NULL;
        }
    
            
                m_has_sheetFormatPr = false;
                
        if (m_sheetFormatPr)
        {
            delete m_sheetFormatPr;
            m_sheetFormatPr = NULL;
        }
    
            
                m_has_cols = false;
                
        if (m_cols)
        {
            delete m_cols;
            m_cols = NULL;
        }
    
            
                m_has_sheetData = false;
                
        if (m_sheetData)
        {
            delete m_sheetData;
            m_sheetData = NULL;
        }
    
            
                m_has_sheetCalcPr = false;
                
        if (m_sheetCalcPr)
        {
            delete m_sheetCalcPr;
            m_sheetCalcPr = NULL;
        }
    
            
                m_has_sheetProtection = false;
                
        if (m_sheetProtection)
        {
            delete m_sheetProtection;
            m_sheetProtection = NULL;
        }
    
            
                m_has_protectedRanges = false;
                
        if (m_protectedRanges)
        {
            delete m_protectedRanges;
            m_protectedRanges = NULL;
        }
    
            
                m_has_scenarios = false;
                
        if (m_scenarios)
        {
            delete m_scenarios;
            m_scenarios = NULL;
        }
    
            
                m_has_autoFilter = false;
                
        if (m_autoFilter)
        {
            delete m_autoFilter;
            m_autoFilter = NULL;
        }
    
            
                m_has_sortState = false;
                
        if (m_sortState)
        {
            delete m_sortState;
            m_sortState = NULL;
        }
    
            
                m_has_dataConsolidate = false;
                
        if (m_dataConsolidate)
        {
            delete m_dataConsolidate;
            m_dataConsolidate = NULL;
        }
    
            
                m_has_customSheetViews = false;
                
        if (m_customSheetViews)
        {
            delete m_customSheetViews;
            m_customSheetViews = NULL;
        }
    
            
                m_has_mergeCells = false;
                
        if (m_mergeCells)
        {
            delete m_mergeCells;
            m_mergeCells = NULL;
        }
    
            
                m_has_phoneticPr = false;
                
        if (m_phoneticPr)
        {
            delete m_phoneticPr;
            m_phoneticPr = NULL;
        }
    
            
                m_has_conditionalFormatting = false;
                
        if (m_conditionalFormatting)
        {
            delete m_conditionalFormatting;
            m_conditionalFormatting = NULL;
        }
    
            
                m_has_dataValidations = false;
                
        if (m_dataValidations)
        {
            delete m_dataValidations;
            m_dataValidations = NULL;
        }
    
            
                m_has_hyperlinks = false;
                
        if (m_hyperlinks)
        {
            delete m_hyperlinks;
            m_hyperlinks = NULL;
        }
    
            
                m_has_printOptions = false;
                
        if (m_printOptions)
        {
            delete m_printOptions;
            m_printOptions = NULL;
        }
    
            
                m_has_pageMargins = false;
                
        if (m_pageMargins)
        {
            delete m_pageMargins;
            m_pageMargins = NULL;
        }
    
            
                m_has_pageSetup = false;
                
        if (m_pageSetup)
        {
            delete m_pageSetup;
            m_pageSetup = NULL;
        }
    
            
                m_has_headerFooter = false;
                
        if (m_headerFooter)
        {
            delete m_headerFooter;
            m_headerFooter = NULL;
        }
    
            
                m_has_rowBreaks = false;
                
        if (m_rowBreaks)
        {
            delete m_rowBreaks;
            m_rowBreaks = NULL;
        }
    
            
                m_has_colBreaks = false;
                
        if (m_colBreaks)
        {
            delete m_colBreaks;
            m_colBreaks = NULL;
        }
    
            
                m_has_customProperties = false;
                
        if (m_customProperties)
        {
            delete m_customProperties;
            m_customProperties = NULL;
        }
    
            
                m_has_cellWatches = false;
                
        if (m_cellWatches)
        {
            delete m_cellWatches;
            m_cellWatches = NULL;
        }
    
            
                m_has_ignoredErrors = false;
                
        if (m_ignoredErrors)
        {
            delete m_ignoredErrors;
            m_ignoredErrors = NULL;
        }
    
            
                m_has_smartTags = false;
                
        if (m_smartTags)
        {
            delete m_smartTags;
            m_smartTags = NULL;
        }
    
            
                m_has_drawing = false;
                
        if (m_drawing)
        {
            delete m_drawing;
            m_drawing = NULL;
        }
    
            
                m_has_legacyDrawing = false;
                
        if (m_legacyDrawing)
        {
            delete m_legacyDrawing;
            m_legacyDrawing = NULL;
        }
    
            
                m_has_legacyDrawingHF = false;
                
        if (m_legacyDrawingHF)
        {
            delete m_legacyDrawingHF;
            m_legacyDrawingHF = NULL;
        }
    
            
                m_has_drawingHF = false;
                
        if (m_drawingHF)
        {
            delete m_drawingHF;
            m_drawingHF = NULL;
        }
    
            
                m_has_picture = false;
                
        if (m_picture)
        {
            delete m_picture;
            m_picture = NULL;
        }
    
            
                m_has_oleObjects = false;
                
        if (m_oleObjects)
        {
            delete m_oleObjects;
            m_oleObjects = NULL;
        }
    
            
                m_has_controls = false;
                
        if (m_controls)
        {
            delete m_controls;
            m_controls = NULL;
        }
    
            
                m_has_webPublishItems = false;
                
        if (m_webPublishItems)
        {
            delete m_webPublishItems;
            m_webPublishItems = NULL;
        }
    
            
                m_has_tableParts = false;
                
        if (m_tableParts)
        {
            delete m_tableParts;
            m_tableParts = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_sheetPr)
                {
                    m_sheetPr->toXml(sheetPr, _outStream);;
                }
            
                if (m_has_dimension)
                {
                    m_sheetPr->toXml(dimension, _outStream);;
                }
            
                if (m_has_sheetViews)
                {
                    m_sheetPr->toXml(sheetViews, _outStream);;
                }
            
                if (m_has_sheetFormatPr)
                {
                    m_sheetPr->toXml(sheetFormatPr, _outStream);;
                }
            
                if (m_has_cols)
                {
                    m_sheetPr->toXml(cols, _outStream);;
                }
            
                if (m_has_sheetData)
                {
                    m_sheetPr->toXml(sheetData, _outStream);;
                }
            
                if (m_has_sheetCalcPr)
                {
                    m_sheetPr->toXml(sheetCalcPr, _outStream);;
                }
            
                if (m_has_sheetProtection)
                {
                    m_sheetPr->toXml(sheetProtection, _outStream);;
                }
            
                if (m_has_protectedRanges)
                {
                    m_sheetPr->toXml(protectedRanges, _outStream);;
                }
            
                if (m_has_scenarios)
                {
                    m_sheetPr->toXml(scenarios, _outStream);;
                }
            
                if (m_has_autoFilter)
                {
                    m_sheetPr->toXml(autoFilter, _outStream);;
                }
            
                if (m_has_sortState)
                {
                    m_sheetPr->toXml(sortState, _outStream);;
                }
            
                if (m_has_dataConsolidate)
                {
                    m_sheetPr->toXml(dataConsolidate, _outStream);;
                }
            
                if (m_has_customSheetViews)
                {
                    m_sheetPr->toXml(customSheetViews, _outStream);;
                }
            
                if (m_has_mergeCells)
                {
                    m_sheetPr->toXml(mergeCells, _outStream);;
                }
            
                if (m_has_phoneticPr)
                {
                    m_sheetPr->toXml(phoneticPr, _outStream);;
                }
            
                if (m_has_conditionalFormatting)
                {
                    m_sheetPr->toXml(conditionalFormatting, _outStream);;
                }
            
                if (m_has_dataValidations)
                {
                    m_sheetPr->toXml(dataValidations, _outStream);;
                }
            
                if (m_has_hyperlinks)
                {
                    m_sheetPr->toXml(hyperlinks, _outStream);;
                }
            
                if (m_has_printOptions)
                {
                    m_sheetPr->toXml(printOptions, _outStream);;
                }
            
                if (m_has_pageMargins)
                {
                    m_sheetPr->toXml(pageMargins, _outStream);;
                }
            
                if (m_has_pageSetup)
                {
                    m_sheetPr->toXml(pageSetup, _outStream);;
                }
            
                if (m_has_headerFooter)
                {
                    m_sheetPr->toXml(headerFooter, _outStream);;
                }
            
                if (m_has_rowBreaks)
                {
                    m_sheetPr->toXml(rowBreaks, _outStream);;
                }
            
                if (m_has_colBreaks)
                {
                    m_sheetPr->toXml(colBreaks, _outStream);;
                }
            
                if (m_has_customProperties)
                {
                    m_sheetPr->toXml(customProperties, _outStream);;
                }
            
                if (m_has_cellWatches)
                {
                    m_sheetPr->toXml(cellWatches, _outStream);;
                }
            
                if (m_has_ignoredErrors)
                {
                    m_sheetPr->toXml(ignoredErrors, _outStream);;
                }
            
                if (m_has_smartTags)
                {
                    m_sheetPr->toXml(smartTags, _outStream);;
                }
            
                if (m_has_drawing)
                {
                    m_sheetPr->toXml(drawing, _outStream);;
                }
            
                if (m_has_legacyDrawing)
                {
                    m_sheetPr->toXml(legacyDrawing, _outStream);;
                }
            
                if (m_has_legacyDrawingHF)
                {
                    m_sheetPr->toXml(legacyDrawingHF, _outStream);;
                }
            
                if (m_has_drawingHF)
                {
                    m_sheetPr->toXml(drawingHF, _outStream);;
                }
            
                if (m_has_picture)
                {
                    m_sheetPr->toXml(picture, _outStream);;
                }
            
                if (m_has_oleObjects)
                {
                    m_sheetPr->toXml(oleObjects, _outStream);;
                }
            
                if (m_has_controls)
                {
                    m_sheetPr->toXml(controls, _outStream);;
                }
            
                if (m_has_webPublishItems)
                {
                    m_sheetPr->toXml(webPublishItems, _outStream);;
                }
            
                if (m_has_tableParts)
                {
                    m_sheetPr->toXml(tableParts, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_sheetPr->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Worksheet& default_instance(){

    if (!CT_Worksheet::default_instance_)
    {
        CT_Worksheet::default_instance_ = new CT_Worksheet();
    }
    return *CT_Worksheet::default_instance_;

        }

    private:
        bool m_has_sheetPr ;
        CT_SheetPr* m_sheetPr ;
        bool m_has_dimension ;
        CT_SheetDimension* m_dimension ;
        bool m_has_sheetViews ;
        CT_SheetViews* m_sheetViews ;
        bool m_has_sheetFormatPr ;
        CT_SheetFormatPr* m_sheetFormatPr ;
        bool m_has_cols ;
        CT_Cols* m_cols ;
        bool m_has_sheetData ;
        CT_SheetData* m_sheetData ;
        bool m_has_sheetCalcPr ;
        CT_SheetCalcPr* m_sheetCalcPr ;
        bool m_has_sheetProtection ;
        CT_SheetProtection* m_sheetProtection ;
        bool m_has_protectedRanges ;
        CT_ProtectedRanges* m_protectedRanges ;
        bool m_has_scenarios ;
        CT_Scenarios* m_scenarios ;
        bool m_has_autoFilter ;
        CT_AutoFilter* m_autoFilter ;
        bool m_has_sortState ;
        CT_SortState* m_sortState ;
        bool m_has_dataConsolidate ;
        CT_DataConsolidate* m_dataConsolidate ;
        bool m_has_customSheetViews ;
        CT_CustomSheetViews* m_customSheetViews ;
        bool m_has_mergeCells ;
        CT_MergeCells* m_mergeCells ;
        bool m_has_phoneticPr ;
        CT_PhoneticPr* m_phoneticPr ;
        bool m_has_conditionalFormatting ;
        CT_ConditionalFormatting* m_conditionalFormatting ;
        bool m_has_dataValidations ;
        CT_DataValidations* m_dataValidations ;
        bool m_has_hyperlinks ;
        CT_Hyperlinks* m_hyperlinks ;
        bool m_has_printOptions ;
        CT_PrintOptions* m_printOptions ;
        bool m_has_pageMargins ;
        CT_PageMargins* m_pageMargins ;
        bool m_has_pageSetup ;
        CT_PageSetup* m_pageSetup ;
        bool m_has_headerFooter ;
        CT_HeaderFooter* m_headerFooter ;
        bool m_has_rowBreaks ;
        CT_PageBreak* m_rowBreaks ;
        bool m_has_colBreaks ;
        CT_PageBreak* m_colBreaks ;
        bool m_has_customProperties ;
        CT_CustomProperties* m_customProperties ;
        bool m_has_cellWatches ;
        CT_CellWatches* m_cellWatches ;
        bool m_has_ignoredErrors ;
        CT_IgnoredErrors* m_ignoredErrors ;
        bool m_has_smartTags ;
        CT_SmartTags* m_smartTags ;
        bool m_has_drawing ;
        CT_Drawing* m_drawing ;
        bool m_has_legacyDrawing ;
        CT_LegacyDrawing* m_legacyDrawing ;
        bool m_has_legacyDrawingHF ;
        CT_LegacyDrawing* m_legacyDrawingHF ;
        bool m_has_drawingHF ;
        CT_DrawingHF* m_drawingHF ;
        bool m_has_picture ;
        CT_SheetBackgroundPicture* m_picture ;
        bool m_has_oleObjects ;
        CT_OleObjects* m_oleObjects ;
        bool m_has_controls ;
        CT_Controls* m_controls ;
        bool m_has_webPublishItems ;
        CT_WebPublishItems* m_webPublishItems ;
        bool m_has_tableParts ;
        CT_TableParts* m_tableParts ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_Worksheet* default_instance_ ;

    }

    class CT_SheetData : public XSD::ComplexType{
    public:
        bool has_row(){

            return m_has_row;
        
        }
        CT_Row* mutable_row(){

                m_has_row = true;
                if (!m_row)
                {
                    m_row = new CT_Row();
                }
                return m_row;
            
        }
        const CT_Row& row(){

            if (m_row)
            {
                return *m_row;
            }
            return CT_Row::default_instance();
        
        }
        void clear(){

                m_has_row = false;
                
        if (m_row)
        {
            delete m_row;
            m_row = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_row)
                {
                    m_row->toXml(row, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_SheetData& default_instance(){

    if (!CT_SheetData::default_instance_)
    {
        CT_SheetData::default_instance_ = new CT_SheetData();
    }
    return *CT_SheetData::default_instance_;

        }

    private:
        bool m_has_row ;
        CT_Row* m_row ;
        static CT_SheetData* default_instance_ ;

    }

    class CT_SheetCalcPr : public XSD::ComplexType{
    public:
        void clear(){

                m_has_fullCalcOnLoad_attr = false;
                m_fullCalcOnLoad_attr = false;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_fullCalcOnLoad_attr) << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_SheetCalcPr& default_instance(){

    if (!CT_SheetCalcPr::default_instance_)
    {
        CT_SheetCalcPr::default_instance_ = new CT_SheetCalcPr();
    }
    return *CT_SheetCalcPr::default_instance_;

        }
        bool has_fullCalcOnLoad_attr(){

            return m_has_fullCalcOnLoad_attr;
        
        }
        void set_fullCalcOnLoad_attr(const boolean& _fullCalcOnLoad_attr ){

        m_has_fullCalcOnLoad_attr = true;
        m_fullCalcOnLoad_attr = _fullCalcOnLoad_attr;
        
        }
        const boolean& fullCalcOnLoad_attr(){

            return type: oolean\nname: \m_fullCalcOnLoad_attr\n;
        
        }

    private:
        static CT_SheetCalcPr* default_instance_ ;
        bool m_has_fullCalcOnLoad_attr ;
        boolean m_fullCalcOnLoad_attr ;

    }

    class CT_SheetFormatPr : public XSD::ComplexType{
    public:
        void clear(){

                m_has_baseColWidth_attr = false;
                m_baseColWidth_attr = 0;
            
                m_has_defaultColWidth_attr = false;
                m_defaultColWidth_attr = 0;
            
                m_has_defaultRowHeight_attr = false;
                m_defaultRowHeight_attr = 0;
            
                m_has_customHeight_attr = false;
                m_customHeight_attr = false;
            
                m_has_zeroHeight_attr = false;
                m_zeroHeight_attr = false;
            
                m_has_thickTop_attr = false;
                m_thickTop_attr = false;
            
                m_has_thickBottom_attr = false;
                m_thickBottom_attr = false;
            
                m_has_outlineLevelRow_attr = false;
                m_outlineLevelRow_attr = 0;
            
                m_has_outlineLevelCol_attr = false;
                m_outlineLevelCol_attr = 0;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_baseColWidth_attr << \\\;
_outStream << _attrName << \=\\ << m_defaultColWidth_attr << \\\;
_outStream << _attrName << \=\\ << m_defaultRowHeight_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_customHeight_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_zeroHeight_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_thickTop_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_thickBottom_attr) << \\\;
_outStream << _attrName << \=\\ << m_outlineLevelRow_attr << \\\;
_outStream << _attrName << \=\\ << m_outlineLevelCol_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_SheetFormatPr& default_instance(){

    if (!CT_SheetFormatPr::default_instance_)
    {
        CT_SheetFormatPr::default_instance_ = new CT_SheetFormatPr();
    }
    return *CT_SheetFormatPr::default_instance_;

        }
        bool has_baseColWidth_attr(){

            return m_has_baseColWidth_attr;
        
        }
        void set_baseColWidth_attr(const unsignedInt& _baseColWidth_attr ){

        m_has_baseColWidth_attr = true;
        m_baseColWidth_attr = _baseColWidth_attr;
        
        }
        const unsignedInt& baseColWidth_attr(){

            return type: \unsignedInt\nname: \m_baseColWidth_attr\n;
        
        }
        bool has_defaultColWidth_attr(){

            return m_has_defaultColWidth_attr;
        
        }
        void set_defaultColWidth_attr(const double& _defaultColWidth_attr ){

        m_has_defaultColWidth_attr = true;
        m_defaultColWidth_attr = _defaultColWidth_attr;
        
        }
        const double& defaultColWidth_attr(){

            return type: \double\nname: \m_defaultColWidth_attr\n;
        
        }
        bool has_defaultRowHeight_attr(){

            return m_has_defaultRowHeight_attr;
        
        }
        void set_defaultRowHeight_attr(const double& _defaultRowHeight_attr ){

        m_has_defaultRowHeight_attr = true;
        m_defaultRowHeight_attr = _defaultRowHeight_attr;
        
        }
        const double& defaultRowHeight_attr(){

            return type: \double\nname: \m_defaultRowHeight_attr\n;
        
        }
        bool has_customHeight_attr(){

            return m_has_customHeight_attr;
        
        }
        void set_customHeight_attr(const boolean& _customHeight_attr ){

        m_has_customHeight_attr = true;
        m_customHeight_attr = _customHeight_attr;
        
        }
        const boolean& customHeight_attr(){

            return type: oolean\nname: \m_customHeight_attr\n;
        
        }
        bool has_zeroHeight_attr(){

            return m_has_zeroHeight_attr;
        
        }
        void set_zeroHeight_attr(const boolean& _zeroHeight_attr ){

        m_has_zeroHeight_attr = true;
        m_zeroHeight_attr = _zeroHeight_attr;
        
        }
        const boolean& zeroHeight_attr(){

            return type: oolean\nname: \m_zeroHeight_attr\n;
        
        }
        bool has_thickTop_attr(){

            return m_has_thickTop_attr;
        
        }
        void set_thickTop_attr(const boolean& _thickTop_attr ){

        m_has_thickTop_attr = true;
        m_thickTop_attr = _thickTop_attr;
        
        }
        const boolean& thickTop_attr(){

            return type: oolean\nname: \m_thickTop_attr\n;
        
        }
        bool has_thickBottom_attr(){

            return m_has_thickBottom_attr;
        
        }
        void set_thickBottom_attr(const boolean& _thickBottom_attr ){

        m_has_thickBottom_attr = true;
        m_thickBottom_attr = _thickBottom_attr;
        
        }
        const boolean& thickBottom_attr(){

            return type: oolean\nname: \m_thickBottom_attr\n;
        
        }
        bool has_outlineLevelRow_attr(){

            return m_has_outlineLevelRow_attr;
        
        }
        void set_outlineLevelRow_attr(const unsignedByte& _outlineLevelRow_attr ){

        m_has_outlineLevelRow_attr = true;
        m_outlineLevelRow_attr = _outlineLevelRow_attr;
        
        }
        const unsignedByte& outlineLevelRow_attr(){

            return type: \unsignedByte\nname: \m_outlineLevelRow_attr\n;
        
        }
        bool has_outlineLevelCol_attr(){

            return m_has_outlineLevelCol_attr;
        
        }
        void set_outlineLevelCol_attr(const unsignedByte& _outlineLevelCol_attr ){

        m_has_outlineLevelCol_attr = true;
        m_outlineLevelCol_attr = _outlineLevelCol_attr;
        
        }
        const unsignedByte& outlineLevelCol_attr(){

            return type: \unsignedByte\nname: \m_outlineLevelCol_attr\n;
        
        }

    private:
        static CT_SheetFormatPr* default_instance_ ;
        bool m_has_baseColWidth_attr ;
        unsignedInt m_baseColWidth_attr ;
        bool m_has_defaultColWidth_attr ;
        double m_defaultColWidth_attr ;
        bool m_has_defaultRowHeight_attr ;
        double m_defaultRowHeight_attr ;
        bool m_has_customHeight_attr ;
        boolean m_customHeight_attr ;
        bool m_has_zeroHeight_attr ;
        boolean m_zeroHeight_attr ;
        bool m_has_thickTop_attr ;
        boolean m_thickTop_attr ;
        bool m_has_thickBottom_attr ;
        boolean m_thickBottom_attr ;
        bool m_has_outlineLevelRow_attr ;
        unsignedByte m_outlineLevelRow_attr ;
        bool m_has_outlineLevelCol_attr ;
        unsignedByte m_outlineLevelCol_attr ;

    }

    class CT_Cols : public XSD::ComplexType{
    public:
        bool has_col(){

            return m_has_col;
        
        }
        CT_Col* mutable_col(){

                m_has_col = true;
                if (!m_col)
                {
                    m_col = new CT_Col();
                }
                return m_col;
            
        }
        const CT_Col& col(){

            if (m_col)
            {
                return *m_col;
            }
            return CT_Col::default_instance();
        
        }
        void clear(){

                m_has_col = false;
                
        if (m_col)
        {
            delete m_col;
            m_col = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_col)
                {
                    m_col->toXml(col, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Cols& default_instance(){

    if (!CT_Cols::default_instance_)
    {
        CT_Cols::default_instance_ = new CT_Cols();
    }
    return *CT_Cols::default_instance_;

        }

    private:
        bool m_has_col ;
        CT_Col* m_col ;
        static CT_Cols* default_instance_ ;

    }

    class CT_Col : public XSD::ComplexType{
    public:
        void clear(){

                m_has_min_attr = false;
                m_min_attr = 0;
            
                m_has_max_attr = false;
                m_max_attr = 0;
            
                m_has_width_attr = false;
                m_width_attr = 0;
            
                m_has_style_attr = false;
                m_style_attr = 0;
            
                m_has_hidden_attr = false;
                m_hidden_attr = false;
            
                m_has_bestFit_attr = false;
                m_bestFit_attr = false;
            
                m_has_customWidth_attr = false;
                m_customWidth_attr = false;
            
                m_has_phonetic_attr = false;
                m_phonetic_attr = false;
            
                m_has_outlineLevel_attr = false;
                m_outlineLevel_attr = 0;
            
                m_has_collapsed_attr = false;
                m_collapsed_attr = false;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_min_attr << \\\;
_outStream << _attrName << \=\\ << m_max_attr << \\\;
_outStream << _attrName << \=\\ << m_width_attr << \\\;
_outStream << _attrName << \=\\ << m_style_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_hidden_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_bestFit_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_customWidth_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_phonetic_attr) << \\\;
_outStream << _attrName << \=\\ << m_outlineLevel_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_collapsed_attr) << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Col& default_instance(){

    if (!CT_Col::default_instance_)
    {
        CT_Col::default_instance_ = new CT_Col();
    }
    return *CT_Col::default_instance_;

        }
        bool has_min_attr(){

            return m_has_min_attr;
        
        }
        void set_min_attr(const unsignedInt& _min_attr ){

        m_has_min_attr = true;
        m_min_attr = _min_attr;
        
        }
        const unsignedInt& min_attr(){

            return type: \unsignedInt\nname: \m_min_attr\n;
        
        }
        bool has_max_attr(){

            return m_has_max_attr;
        
        }
        void set_max_attr(const unsignedInt& _max_attr ){

        m_has_max_attr = true;
        m_max_attr = _max_attr;
        
        }
        const unsignedInt& max_attr(){

            return type: \unsignedInt\nname: \m_max_attr\n;
        
        }
        bool has_width_attr(){

            return m_has_width_attr;
        
        }
        void set_width_attr(const double& _width_attr ){

        m_has_width_attr = true;
        m_width_attr = _width_attr;
        
        }
        const double& width_attr(){

            return type: \double\nname: \m_width_attr\n;
        
        }
        bool has_style_attr(){

            return m_has_style_attr;
        
        }
        void set_style_attr(const unsignedInt& _style_attr ){

        m_has_style_attr = true;
        m_style_attr = _style_attr;
        
        }
        const unsignedInt& style_attr(){

            return type: \unsignedInt\nname: \m_style_attr\n;
        
        }
        bool has_hidden_attr(){

            return m_has_hidden_attr;
        
        }
        void set_hidden_attr(const boolean& _hidden_attr ){

        m_has_hidden_attr = true;
        m_hidden_attr = _hidden_attr;
        
        }
        const boolean& hidden_attr(){

            return type: oolean\nname: \m_hidden_attr\n;
        
        }
        bool has_bestFit_attr(){

            return m_has_bestFit_attr;
        
        }
        void set_bestFit_attr(const boolean& _bestFit_attr ){

        m_has_bestFit_attr = true;
        m_bestFit_attr = _bestFit_attr;
        
        }
        const boolean& bestFit_attr(){

            return type: oolean\nname: \m_bestFit_attr\n;
        
        }
        bool has_customWidth_attr(){

            return m_has_customWidth_attr;
        
        }
        void set_customWidth_attr(const boolean& _customWidth_attr ){

        m_has_customWidth_attr = true;
        m_customWidth_attr = _customWidth_attr;
        
        }
        const boolean& customWidth_attr(){

            return type: oolean\nname: \m_customWidth_attr\n;
        
        }
        bool has_phonetic_attr(){

            return m_has_phonetic_attr;
        
        }
        void set_phonetic_attr(const boolean& _phonetic_attr ){

        m_has_phonetic_attr = true;
        m_phonetic_attr = _phonetic_attr;
        
        }
        const boolean& phonetic_attr(){

            return type: oolean\nname: \m_phonetic_attr\n;
        
        }
        bool has_outlineLevel_attr(){

            return m_has_outlineLevel_attr;
        
        }
        void set_outlineLevel_attr(const unsignedByte& _outlineLevel_attr ){

        m_has_outlineLevel_attr = true;
        m_outlineLevel_attr = _outlineLevel_attr;
        
        }
        const unsignedByte& outlineLevel_attr(){

            return type: \unsignedByte\nname: \m_outlineLevel_attr\n;
        
        }
        bool has_collapsed_attr(){

            return m_has_collapsed_attr;
        
        }
        void set_collapsed_attr(const boolean& _collapsed_attr ){

        m_has_collapsed_attr = true;
        m_collapsed_attr = _collapsed_attr;
        
        }
        const boolean& collapsed_attr(){

            return type: oolean\nname: \m_collapsed_attr\n;
        
        }

    private:
        static CT_Col* default_instance_ ;
        bool m_has_min_attr ;
        unsignedInt m_min_attr ;
        bool m_has_max_attr ;
        unsignedInt m_max_attr ;
        bool m_has_width_attr ;
        double m_width_attr ;
        bool m_has_style_attr ;
        unsignedInt m_style_attr ;
        bool m_has_hidden_attr ;
        boolean m_hidden_attr ;
        bool m_has_bestFit_attr ;
        boolean m_bestFit_attr ;
        bool m_has_customWidth_attr ;
        boolean m_customWidth_attr ;
        bool m_has_phonetic_attr ;
        boolean m_phonetic_attr ;
        bool m_has_outlineLevel_attr ;
        unsignedByte m_outlineLevel_attr ;
        bool m_has_collapsed_attr ;
        boolean m_collapsed_attr ;

    }

    class CT_Row : public XSD::ComplexType{
    public:
        bool has_c(){

            return m_has_c;
        
        }
        CT_Cell* mutable_c(){

                m_has_c = true;
                if (!m_c)
                {
                    m_c = new CT_Cell();
                }
                return m_c;
            
        }
        const CT_Cell& c(){

            if (m_c)
            {
                return *m_c;
            }
            return CT_Cell::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_r_attr = false;
                m_r_attr = 0;
            
                m_has_spans_attr = false;
                
        if (m_spans_attr)
        {
            delete m_spans_attr;
            m_spans_attr = NULL;
        }
    
            
                m_has_s_attr = false;
                m_s_attr = 0;
            
                m_has_customFormat_attr = false;
                m_customFormat_attr = false;
            
                m_has_ht_attr = false;
                m_ht_attr = 0;
            
                m_has_hidden_attr = false;
                m_hidden_attr = false;
            
                m_has_customHeight_attr = false;
                m_customHeight_attr = false;
            
                m_has_outlineLevel_attr = false;
                m_outlineLevel_attr = 0;
            
                m_has_collapsed_attr = false;
                m_collapsed_attr = false;
            
                m_has_thickTop_attr = false;
                m_thickTop_attr = false;
            
                m_has_thickBot_attr = false;
                m_thickBot_attr = false;
            
                m_has_ph_attr = false;
                m_ph_attr = false;
            
                m_has_c = false;
                
        if (m_c)
        {
            delete m_c;
            m_c = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_r_attr << \\\;
m_spans_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_s_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_customFormat_attr) << \\\;
_outStream << _attrName << \=\\ << m_ht_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_hidden_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_customHeight_attr) << \\\;
_outStream << _attrName << \=\\ << m_outlineLevel_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_collapsed_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_thickTop_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_thickBot_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_ph_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_c)
                {
                    m_c->toXml(c, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_c->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Row& default_instance(){

    if (!CT_Row::default_instance_)
    {
        CT_Row::default_instance_ = new CT_Row();
    }
    return *CT_Row::default_instance_;

        }
        bool has_r_attr(){

            return m_has_r_attr;
        
        }
        void set_r_attr(const unsignedInt& _r_attr ){

        m_has_r_attr = true;
        m_r_attr = _r_attr;
        
        }
        const unsignedInt& r_attr(){

            return type: \unsignedInt\nname: \m_r_attr\n;
        
        }
        bool has_spans_attr(){

            return m_has_spans_attr;
        
        }
        void set_spans_attr(const ST_CellSpans& _spans_attr ){

            m_has_spans_attr = true;
            m_spans_attr = new ST_CellSpans(_spans_attr);
        
        }
        const ST_CellSpans& spans_attr(){

            if (m_spans_attr)
            {
                return *m_spans_attr;
            }
            return ST_CellSpans::default_instance();
        
        }
        bool has_s_attr(){

            return m_has_s_attr;
        
        }
        void set_s_attr(const unsignedInt& _s_attr ){

        m_has_s_attr = true;
        m_s_attr = _s_attr;
        
        }
        const unsignedInt& s_attr(){

            return type: \unsignedInt\nname: \m_s_attr\n;
        
        }
        bool has_customFormat_attr(){

            return m_has_customFormat_attr;
        
        }
        void set_customFormat_attr(const boolean& _customFormat_attr ){

        m_has_customFormat_attr = true;
        m_customFormat_attr = _customFormat_attr;
        
        }
        const boolean& customFormat_attr(){

            return type: oolean\nname: \m_customFormat_attr\n;
        
        }
        bool has_ht_attr(){

            return m_has_ht_attr;
        
        }
        void set_ht_attr(const double& _ht_attr ){

        m_has_ht_attr = true;
        m_ht_attr = _ht_attr;
        
        }
        const double& ht_attr(){

            return type: \double\nname: \m_ht_attr\n;
        
        }
        bool has_hidden_attr(){

            return m_has_hidden_attr;
        
        }
        void set_hidden_attr(const boolean& _hidden_attr ){

        m_has_hidden_attr = true;
        m_hidden_attr = _hidden_attr;
        
        }
        const boolean& hidden_attr(){

            return type: oolean\nname: \m_hidden_attr\n;
        
        }
        bool has_customHeight_attr(){

            return m_has_customHeight_attr;
        
        }
        void set_customHeight_attr(const boolean& _customHeight_attr ){

        m_has_customHeight_attr = true;
        m_customHeight_attr = _customHeight_attr;
        
        }
        const boolean& customHeight_attr(){

            return type: oolean\nname: \m_customHeight_attr\n;
        
        }
        bool has_outlineLevel_attr(){

            return m_has_outlineLevel_attr;
        
        }
        void set_outlineLevel_attr(const unsignedByte& _outlineLevel_attr ){

        m_has_outlineLevel_attr = true;
        m_outlineLevel_attr = _outlineLevel_attr;
        
        }
        const unsignedByte& outlineLevel_attr(){

            return type: \unsignedByte\nname: \m_outlineLevel_attr\n;
        
        }
        bool has_collapsed_attr(){

            return m_has_collapsed_attr;
        
        }
        void set_collapsed_attr(const boolean& _collapsed_attr ){

        m_has_collapsed_attr = true;
        m_collapsed_attr = _collapsed_attr;
        
        }
        const boolean& collapsed_attr(){

            return type: oolean\nname: \m_collapsed_attr\n;
        
        }
        bool has_thickTop_attr(){

            return m_has_thickTop_attr;
        
        }
        void set_thickTop_attr(const boolean& _thickTop_attr ){

        m_has_thickTop_attr = true;
        m_thickTop_attr = _thickTop_attr;
        
        }
        const boolean& thickTop_attr(){

            return type: oolean\nname: \m_thickTop_attr\n;
        
        }
        bool has_thickBot_attr(){

            return m_has_thickBot_attr;
        
        }
        void set_thickBot_attr(const boolean& _thickBot_attr ){

        m_has_thickBot_attr = true;
        m_thickBot_attr = _thickBot_attr;
        
        }
        const boolean& thickBot_attr(){

            return type: oolean\nname: \m_thickBot_attr\n;
        
        }
        bool has_ph_attr(){

            return m_has_ph_attr;
        
        }
        void set_ph_attr(const boolean& _ph_attr ){

        m_has_ph_attr = true;
        m_ph_attr = _ph_attr;
        
        }
        const boolean& ph_attr(){

            return type: oolean\nname: \m_ph_attr\n;
        
        }

    private:
        bool m_has_c ;
        CT_Cell* m_c ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_Row* default_instance_ ;
        bool m_has_r_attr ;
        unsignedInt m_r_attr ;
        bool m_has_spans_attr ;
        ST_CellSpans* m_spans_attr ;
        bool m_has_s_attr ;
        unsignedInt m_s_attr ;
        bool m_has_customFormat_attr ;
        boolean m_customFormat_attr ;
        bool m_has_ht_attr ;
        double m_ht_attr ;
        bool m_has_hidden_attr ;
        boolean m_hidden_attr ;
        bool m_has_customHeight_attr ;
        boolean m_customHeight_attr ;
        bool m_has_outlineLevel_attr ;
        unsignedByte m_outlineLevel_attr ;
        bool m_has_collapsed_attr ;
        boolean m_collapsed_attr ;
        bool m_has_thickTop_attr ;
        boolean m_thickTop_attr ;
        bool m_has_thickBot_attr ;
        boolean m_thickBot_attr ;
        bool m_has_ph_attr ;
        boolean m_ph_attr ;

    }

    class CT_Cell : public XSD::ComplexType{
    public:
        bool has_f(){

            return m_has_f;
        
        }
        CT_CellFormula* mutable_f(){

                m_has_f = true;
                if (!m_f)
                {
                    m_f = new CT_CellFormula();
                }
                return m_f;
            
        }
        const CT_CellFormula& f(){

            if (m_f)
            {
                return *m_f;
            }
            return CT_CellFormula::default_instance();
        
        }
        bool has_v(){

            return m_has_v;
        
        }
        ns_s::ST_Xstring* mutable_v(){

                m_has_v = true;
                if (!m_v)
                {
                    m_v = new ns_s::ST_Xstring();
                }
                return m_v;
            
        }
        const ns_s::ST_Xstring& v(){

            if (m_v)
            {
                return *m_v;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_is(){

            return m_has_is;
        
        }
        CT_Rst* mutable_is(){

                m_has_is = true;
                if (!m_is)
                {
                    m_is = new CT_Rst();
                }
                return m_is;
            
        }
        const CT_Rst& is(){

            if (m_is)
            {
                return *m_is;
            }
            return CT_Rst::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_r_attr = false;
                
        if (m_r_attr)
        {
            delete m_r_attr;
            m_r_attr = NULL;
        }
    
            
                m_has_s_attr = false;
                m_s_attr = 0;
            
                m_has_t_attr = false;
                
        if (m_t_attr)
        {
            delete m_t_attr;
            m_t_attr = NULL;
        }
    
            
                m_has_cm_attr = false;
                m_cm_attr = 0;
            
                m_has_vm_attr = false;
                m_vm_attr = 0;
            
                m_has_ph_attr = false;
                m_ph_attr = false;
            
                m_has_f = false;
                
        if (m_f)
        {
            delete m_f;
            m_f = NULL;
        }
    
            
                m_has_v = false;
                
        if (m_v)
        {
            delete m_v;
            m_v = NULL;
        }
    
            
                m_has_is = false;
                
        if (m_is)
        {
            delete m_is;
            m_is = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_r_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_s_attr << \\\;
m_t_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_cm_attr << \\\;
_outStream << _attrName << \=\\ << m_vm_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_ph_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_f)
                {
                    m_f->toXml(f, _outStream);;
                }
            
                if (m_has_v)
                {
                    _outStream << \<v>\ << m_f->toString() << \</v>\;;
                }
            
                if (m_has_is)
                {
                    m_f->toXml(is, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_f->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Cell& default_instance(){

    if (!CT_Cell::default_instance_)
    {
        CT_Cell::default_instance_ = new CT_Cell();
    }
    return *CT_Cell::default_instance_;

        }
        bool has_r_attr(){

            return m_has_r_attr;
        
        }
        void set_r_attr(const ST_CellRef& _r_attr ){

            m_has_r_attr = true;
            m_r_attr = new ST_CellRef(_r_attr);
        
        }
        const ST_CellRef& r_attr(){

            if (m_r_attr)
            {
                return *m_r_attr;
            }
            return ST_CellRef::default_instance();
        
        }
        bool has_s_attr(){

            return m_has_s_attr;
        
        }
        void set_s_attr(const unsignedInt& _s_attr ){

        m_has_s_attr = true;
        m_s_attr = _s_attr;
        
        }
        const unsignedInt& s_attr(){

            return type: \unsignedInt\nname: \m_s_attr\n;
        
        }
        bool has_t_attr(){

            return m_has_t_attr;
        
        }
        void set_t_attr(const ST_CellType& _t_attr ){

            m_has_t_attr = true;
            m_t_attr = new ST_CellType(_t_attr);
        
        }
        const ST_CellType& t_attr(){

            if (m_t_attr)
            {
                return *m_t_attr;
            }
            return ST_CellType::default_instance();
        
        }
        bool has_cm_attr(){

            return m_has_cm_attr;
        
        }
        void set_cm_attr(const unsignedInt& _cm_attr ){

        m_has_cm_attr = true;
        m_cm_attr = _cm_attr;
        
        }
        const unsignedInt& cm_attr(){

            return type: \unsignedInt\nname: \m_cm_attr\n;
        
        }
        bool has_vm_attr(){

            return m_has_vm_attr;
        
        }
        void set_vm_attr(const unsignedInt& _vm_attr ){

        m_has_vm_attr = true;
        m_vm_attr = _vm_attr;
        
        }
        const unsignedInt& vm_attr(){

            return type: \unsignedInt\nname: \m_vm_attr\n;
        
        }
        bool has_ph_attr(){

            return m_has_ph_attr;
        
        }
        void set_ph_attr(const boolean& _ph_attr ){

        m_has_ph_attr = true;
        m_ph_attr = _ph_attr;
        
        }
        const boolean& ph_attr(){

            return type: oolean\nname: \m_ph_attr\n;
        
        }

    private:
        bool m_has_f ;
        CT_CellFormula* m_f ;
        bool m_has_v ;
        ns_s::ST_Xstring* m_v ;
        bool m_has_is ;
        CT_Rst* m_is ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_Cell* default_instance_ ;
        bool m_has_r_attr ;
        ST_CellRef* m_r_attr ;
        bool m_has_s_attr ;
        unsignedInt m_s_attr ;
        bool m_has_t_attr ;
        ST_CellType* m_t_attr ;
        bool m_has_cm_attr ;
        unsignedInt m_cm_attr ;
        bool m_has_vm_attr ;
        unsignedInt m_vm_attr ;
        bool m_has_ph_attr ;
        boolean m_ph_attr ;

    }

    class CT_SheetPr : public XSD::ComplexType{
    public:
        bool has_tabColor(){

            return m_has_tabColor;
        
        }
        CT_Color* mutable_tabColor(){

                m_has_tabColor = true;
                if (!m_tabColor)
                {
                    m_tabColor = new CT_Color();
                }
                return m_tabColor;
            
        }
        const CT_Color& tabColor(){

            if (m_tabColor)
            {
                return *m_tabColor;
            }
            return CT_Color::default_instance();
        
        }
        bool has_outlinePr(){

            return m_has_outlinePr;
        
        }
        CT_OutlinePr* mutable_outlinePr(){

                m_has_outlinePr = true;
                if (!m_outlinePr)
                {
                    m_outlinePr = new CT_OutlinePr();
                }
                return m_outlinePr;
            
        }
        const CT_OutlinePr& outlinePr(){

            if (m_outlinePr)
            {
                return *m_outlinePr;
            }
            return CT_OutlinePr::default_instance();
        
        }
        bool has_pageSetUpPr(){

            return m_has_pageSetUpPr;
        
        }
        CT_PageSetUpPr* mutable_pageSetUpPr(){

                m_has_pageSetUpPr = true;
                if (!m_pageSetUpPr)
                {
                    m_pageSetUpPr = new CT_PageSetUpPr();
                }
                return m_pageSetUpPr;
            
        }
        const CT_PageSetUpPr& pageSetUpPr(){

            if (m_pageSetUpPr)
            {
                return *m_pageSetUpPr;
            }
            return CT_PageSetUpPr::default_instance();
        
        }
        void clear(){

                m_has_syncHorizontal_attr = false;
                m_syncHorizontal_attr = false;
            
                m_has_syncVertical_attr = false;
                m_syncVertical_attr = false;
            
                m_has_syncRef_attr = false;
                
        if (m_syncRef_attr)
        {
            delete m_syncRef_attr;
            m_syncRef_attr = NULL;
        }
    
            
                m_has_transitionEvaluation_attr = false;
                m_transitionEvaluation_attr = false;
            
                m_has_transitionEntry_attr = false;
                m_transitionEntry_attr = false;
            
                m_has_published_attr = false;
                m_published_attr = false;
            
                m_has_codeName_attr = false;
                m_codeName_attr.clear();
            
                m_has_filterMode_attr = false;
                m_filterMode_attr = false;
            
                m_has_enableFormatConditionsCalculation_attr = false;
                m_enableFormatConditionsCalculation_attr = false;
            
                m_has_tabColor = false;
                
        if (m_tabColor)
        {
            delete m_tabColor;
            m_tabColor = NULL;
        }
    
            
                m_has_outlinePr = false;
                
        if (m_outlinePr)
        {
            delete m_outlinePr;
            m_outlinePr = NULL;
        }
    
            
                m_has_pageSetUpPr = false;
                
        if (m_pageSetUpPr)
        {
            delete m_pageSetUpPr;
            m_pageSetUpPr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_syncHorizontal_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_syncVertical_attr) << \\\;
m_syncRef_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_transitionEvaluation_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_transitionEntry_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_published_attr) << \\\;
_outStream << _attrName << \=\\ << m_codeName_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_filterMode_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_enableFormatConditionsCalculation_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_tabColor)
                {
                    m_tabColor->toXml(tabColor, _outStream);;
                }
            
                if (m_has_outlinePr)
                {
                    m_tabColor->toXml(outlinePr, _outStream);;
                }
            
                if (m_has_pageSetUpPr)
                {
                    m_tabColor->toXml(pageSetUpPr, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_SheetPr& default_instance(){

    if (!CT_SheetPr::default_instance_)
    {
        CT_SheetPr::default_instance_ = new CT_SheetPr();
    }
    return *CT_SheetPr::default_instance_;

        }
        bool has_syncHorizontal_attr(){

            return m_has_syncHorizontal_attr;
        
        }
        void set_syncHorizontal_attr(const boolean& _syncHorizontal_attr ){

        m_has_syncHorizontal_attr = true;
        m_syncHorizontal_attr = _syncHorizontal_attr;
        
        }
        const boolean& syncHorizontal_attr(){

            return type: oolean\nname: \m_syncHorizontal_attr\n;
        
        }
        bool has_syncVertical_attr(){

            return m_has_syncVertical_attr;
        
        }
        void set_syncVertical_attr(const boolean& _syncVertical_attr ){

        m_has_syncVertical_attr = true;
        m_syncVertical_attr = _syncVertical_attr;
        
        }
        const boolean& syncVertical_attr(){

            return type: oolean\nname: \m_syncVertical_attr\n;
        
        }
        bool has_syncRef_attr(){

            return m_has_syncRef_attr;
        
        }
        void set_syncRef_attr(const ST_Ref& _syncRef_attr ){

            m_has_syncRef_attr = true;
            m_syncRef_attr = new ST_Ref(_syncRef_attr);
        
        }
        const ST_Ref& syncRef_attr(){

            if (m_syncRef_attr)
            {
                return *m_syncRef_attr;
            }
            return ST_Ref::default_instance();
        
        }
        bool has_transitionEvaluation_attr(){

            return m_has_transitionEvaluation_attr;
        
        }
        void set_transitionEvaluation_attr(const boolean& _transitionEvaluation_attr ){

        m_has_transitionEvaluation_attr = true;
        m_transitionEvaluation_attr = _transitionEvaluation_attr;
        
        }
        const boolean& transitionEvaluation_attr(){

            return type: oolean\nname: \m_transitionEvaluation_attr\n;
        
        }
        bool has_transitionEntry_attr(){

            return m_has_transitionEntry_attr;
        
        }
        void set_transitionEntry_attr(const boolean& _transitionEntry_attr ){

        m_has_transitionEntry_attr = true;
        m_transitionEntry_attr = _transitionEntry_attr;
        
        }
        const boolean& transitionEntry_attr(){

            return type: oolean\nname: \m_transitionEntry_attr\n;
        
        }
        bool has_published_attr(){

            return m_has_published_attr;
        
        }
        void set_published_attr(const boolean& _published_attr ){

        m_has_published_attr = true;
        m_published_attr = _published_attr;
        
        }
        const boolean& published_attr(){

            return type: oolean\nname: \m_published_attr\n;
        
        }
        bool has_codeName_attr(){

            return m_has_codeName_attr;
        
        }
        void set_codeName_attr(const string& _codeName_attr ){

        m_has_codeName_attr = true;
        m_codeName_attr = _codeName_attr;
        
        }
        const string& codeName_attr(){

            return type: \string\nname: \m_codeName_attr\n;
        
        }
        bool has_filterMode_attr(){

            return m_has_filterMode_attr;
        
        }
        void set_filterMode_attr(const boolean& _filterMode_attr ){

        m_has_filterMode_attr = true;
        m_filterMode_attr = _filterMode_attr;
        
        }
        const boolean& filterMode_attr(){

            return type: oolean\nname: \m_filterMode_attr\n;
        
        }
        bool has_enableFormatConditionsCalculation_attr(){

            return m_has_enableFormatConditionsCalculation_attr;
        
        }
        void set_enableFormatConditionsCalculation_attr(const boolean& _enableFormatConditionsCalculation_attr ){

        m_has_enableFormatConditionsCalculation_attr = true;
        m_enableFormatConditionsCalculation_attr = _enableFormatConditionsCalculation_attr;
        
        }
        const boolean& enableFormatConditionsCalculation_attr(){

            return type: oolean\nname: \m_enableFormatConditionsCalculation_attr\n;
        
        }

    private:
        bool m_has_tabColor ;
        CT_Color* m_tabColor ;
        bool m_has_outlinePr ;
        CT_OutlinePr* m_outlinePr ;
        bool m_has_pageSetUpPr ;
        CT_PageSetUpPr* m_pageSetUpPr ;
        static CT_SheetPr* default_instance_ ;
        bool m_has_syncHorizontal_attr ;
        boolean m_syncHorizontal_attr ;
        bool m_has_syncVertical_attr ;
        boolean m_syncVertical_attr ;
        bool m_has_syncRef_attr ;
        ST_Ref* m_syncRef_attr ;
        bool m_has_transitionEvaluation_attr ;
        boolean m_transitionEvaluation_attr ;
        bool m_has_transitionEntry_attr ;
        boolean m_transitionEntry_attr ;
        bool m_has_published_attr ;
        boolean m_published_attr ;
        bool m_has_codeName_attr ;
        string m_codeName_attr ;
        bool m_has_filterMode_attr ;
        boolean m_filterMode_attr ;
        bool m_has_enableFormatConditionsCalculation_attr ;
        boolean m_enableFormatConditionsCalculation_attr ;

    }

    class CT_SheetDimension : public XSD::ComplexType{
    public:
        void clear(){

                m_has_ref_attr = false;
                
        if (m_ref_attr)
        {
            delete m_ref_attr;
            m_ref_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_ref_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_SheetDimension& default_instance(){

    if (!CT_SheetDimension::default_instance_)
    {
        CT_SheetDimension::default_instance_ = new CT_SheetDimension();
    }
    return *CT_SheetDimension::default_instance_;

        }
        bool has_ref_attr(){

            return m_has_ref_attr;
        
        }
        void set_ref_attr(const ST_Ref& _ref_attr ){

            m_has_ref_attr = true;
            m_ref_attr = new ST_Ref(_ref_attr);
        
        }
        const ST_Ref& ref_attr(){

            if (m_ref_attr)
            {
                return *m_ref_attr;
            }
            return ST_Ref::default_instance();
        
        }

    private:
        static CT_SheetDimension* default_instance_ ;
        bool m_has_ref_attr ;
        ST_Ref* m_ref_attr ;

    }

    class CT_SheetViews : public XSD::ComplexType{
    public:
        bool has_sheetView(){

            return m_has_sheetView;
        
        }
        CT_SheetView* mutable_sheetView(){

                m_has_sheetView = true;
                if (!m_sheetView)
                {
                    m_sheetView = new CT_SheetView();
                }
                return m_sheetView;
            
        }
        const CT_SheetView& sheetView(){

            if (m_sheetView)
            {
                return *m_sheetView;
            }
            return CT_SheetView::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_sheetView = false;
                
        if (m_sheetView)
        {
            delete m_sheetView;
            m_sheetView = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_sheetView)
                {
                    m_sheetView->toXml(sheetView, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_sheetView->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_SheetViews& default_instance(){

    if (!CT_SheetViews::default_instance_)
    {
        CT_SheetViews::default_instance_ = new CT_SheetViews();
    }
    return *CT_SheetViews::default_instance_;

        }

    private:
        bool m_has_sheetView ;
        CT_SheetView* m_sheetView ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_SheetViews* default_instance_ ;

    }

    class CT_SheetView : public XSD::ComplexType{
    public:
        bool has_pane(){

            return m_has_pane;
        
        }
        CT_Pane* mutable_pane(){

                m_has_pane = true;
                if (!m_pane)
                {
                    m_pane = new CT_Pane();
                }
                return m_pane;
            
        }
        const CT_Pane& pane(){

            if (m_pane)
            {
                return *m_pane;
            }
            return CT_Pane::default_instance();
        
        }
        bool has_selection(){

            return m_has_selection;
        
        }
        CT_Selection* mutable_selection(){

                m_has_selection = true;
                if (!m_selection)
                {
                    m_selection = new CT_Selection();
                }
                return m_selection;
            
        }
        const CT_Selection& selection(){

            if (m_selection)
            {
                return *m_selection;
            }
            return CT_Selection::default_instance();
        
        }
        bool has_pivotSelection(){

            return m_has_pivotSelection;
        
        }
        CT_PivotSelection* mutable_pivotSelection(){

                m_has_pivotSelection = true;
                if (!m_pivotSelection)
                {
                    m_pivotSelection = new CT_PivotSelection();
                }
                return m_pivotSelection;
            
        }
        const CT_PivotSelection& pivotSelection(){

            if (m_pivotSelection)
            {
                return *m_pivotSelection;
            }
            return CT_PivotSelection::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_windowProtection_attr = false;
                m_windowProtection_attr = false;
            
                m_has_showFormulas_attr = false;
                m_showFormulas_attr = false;
            
                m_has_showGridLines_attr = false;
                m_showGridLines_attr = false;
            
                m_has_showRowColHeaders_attr = false;
                m_showRowColHeaders_attr = false;
            
                m_has_showZeros_attr = false;
                m_showZeros_attr = false;
            
                m_has_rightToLeft_attr = false;
                m_rightToLeft_attr = false;
            
                m_has_tabSelected_attr = false;
                m_tabSelected_attr = false;
            
                m_has_showRuler_attr = false;
                m_showRuler_attr = false;
            
                m_has_showOutlineSymbols_attr = false;
                m_showOutlineSymbols_attr = false;
            
                m_has_defaultGridColor_attr = false;
                m_defaultGridColor_attr = false;
            
                m_has_showWhiteSpace_attr = false;
                m_showWhiteSpace_attr = false;
            
                m_has_view_attr = false;
                
        if (m_view_attr)
        {
            delete m_view_attr;
            m_view_attr = NULL;
        }
    
            
                m_has_topLeftCell_attr = false;
                
        if (m_topLeftCell_attr)
        {
            delete m_topLeftCell_attr;
            m_topLeftCell_attr = NULL;
        }
    
            
                m_has_colorId_attr = false;
                m_colorId_attr = 0;
            
                m_has_zoomScale_attr = false;
                m_zoomScale_attr = 0;
            
                m_has_zoomScaleNormal_attr = false;
                m_zoomScaleNormal_attr = 0;
            
                m_has_zoomScaleSheetLayoutView_attr = false;
                m_zoomScaleSheetLayoutView_attr = 0;
            
                m_has_zoomScalePageLayoutView_attr = false;
                m_zoomScalePageLayoutView_attr = 0;
            
                m_has_workbookViewId_attr = false;
                m_workbookViewId_attr = 0;
            
                m_has_pane = false;
                
        if (m_pane)
        {
            delete m_pane;
            m_pane = NULL;
        }
    
            
                m_has_selection = false;
                
        if (m_selection)
        {
            delete m_selection;
            m_selection = NULL;
        }
    
            
                m_has_pivotSelection = false;
                
        if (m_pivotSelection)
        {
            delete m_pivotSelection;
            m_pivotSelection = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_windowProtection_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showFormulas_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showGridLines_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showRowColHeaders_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showZeros_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_rightToLeft_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_tabSelected_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showRuler_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showOutlineSymbols_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_defaultGridColor_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showWhiteSpace_attr) << \\\;
m_view_attr->toXml(_attrName, _outStream);
m_topLeftCell_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_colorId_attr << \\\;
_outStream << _attrName << \=\\ << m_zoomScale_attr << \\\;
_outStream << _attrName << \=\\ << m_zoomScaleNormal_attr << \\\;
_outStream << _attrName << \=\\ << m_zoomScaleSheetLayoutView_attr << \\\;
_outStream << _attrName << \=\\ << m_zoomScalePageLayoutView_attr << \\\;
_outStream << _attrName << \=\\ << m_workbookViewId_attr << \\\;
        _outStream << \>\;
    
                if (m_has_pane)
                {
                    m_pane->toXml(pane, _outStream);;
                }
            
                if (m_has_selection)
                {
                    m_pane->toXml(selection, _outStream);;
                }
            
                if (m_has_pivotSelection)
                {
                    m_pane->toXml(pivotSelection, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_pane->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_SheetView& default_instance(){

    if (!CT_SheetView::default_instance_)
    {
        CT_SheetView::default_instance_ = new CT_SheetView();
    }
    return *CT_SheetView::default_instance_;

        }
        bool has_windowProtection_attr(){

            return m_has_windowProtection_attr;
        
        }
        void set_windowProtection_attr(const boolean& _windowProtection_attr ){

        m_has_windowProtection_attr = true;
        m_windowProtection_attr = _windowProtection_attr;
        
        }
        const boolean& windowProtection_attr(){

            return type: oolean\nname: \m_windowProtection_attr\n;
        
        }
        bool has_showFormulas_attr(){

            return m_has_showFormulas_attr;
        
        }
        void set_showFormulas_attr(const boolean& _showFormulas_attr ){

        m_has_showFormulas_attr = true;
        m_showFormulas_attr = _showFormulas_attr;
        
        }
        const boolean& showFormulas_attr(){

            return type: oolean\nname: \m_showFormulas_attr\n;
        
        }
        bool has_showGridLines_attr(){

            return m_has_showGridLines_attr;
        
        }
        void set_showGridLines_attr(const boolean& _showGridLines_attr ){

        m_has_showGridLines_attr = true;
        m_showGridLines_attr = _showGridLines_attr;
        
        }
        const boolean& showGridLines_attr(){

            return type: oolean\nname: \m_showGridLines_attr\n;
        
        }
        bool has_showRowColHeaders_attr(){

            return m_has_showRowColHeaders_attr;
        
        }
        void set_showRowColHeaders_attr(const boolean& _showRowColHeaders_attr ){

        m_has_showRowColHeaders_attr = true;
        m_showRowColHeaders_attr = _showRowColHeaders_attr;
        
        }
        const boolean& showRowColHeaders_attr(){

            return type: oolean\nname: \m_showRowColHeaders_attr\n;
        
        }
        bool has_showZeros_attr(){

            return m_has_showZeros_attr;
        
        }
        void set_showZeros_attr(const boolean& _showZeros_attr ){

        m_has_showZeros_attr = true;
        m_showZeros_attr = _showZeros_attr;
        
        }
        const boolean& showZeros_attr(){

            return type: oolean\nname: \m_showZeros_attr\n;
        
        }
        bool has_rightToLeft_attr(){

            return m_has_rightToLeft_attr;
        
        }
        void set_rightToLeft_attr(const boolean& _rightToLeft_attr ){

        m_has_rightToLeft_attr = true;
        m_rightToLeft_attr = _rightToLeft_attr;
        
        }
        const boolean& rightToLeft_attr(){

            return type: oolean\nname: \m_rightToLeft_attr\n;
        
        }
        bool has_tabSelected_attr(){

            return m_has_tabSelected_attr;
        
        }
        void set_tabSelected_attr(const boolean& _tabSelected_attr ){

        m_has_tabSelected_attr = true;
        m_tabSelected_attr = _tabSelected_attr;
        
        }
        const boolean& tabSelected_attr(){

            return type: oolean\nname: \m_tabSelected_attr\n;
        
        }
        bool has_showRuler_attr(){

            return m_has_showRuler_attr;
        
        }
        void set_showRuler_attr(const boolean& _showRuler_attr ){

        m_has_showRuler_attr = true;
        m_showRuler_attr = _showRuler_attr;
        
        }
        const boolean& showRuler_attr(){

            return type: oolean\nname: \m_showRuler_attr\n;
        
        }
        bool has_showOutlineSymbols_attr(){

            return m_has_showOutlineSymbols_attr;
        
        }
        void set_showOutlineSymbols_attr(const boolean& _showOutlineSymbols_attr ){

        m_has_showOutlineSymbols_attr = true;
        m_showOutlineSymbols_attr = _showOutlineSymbols_attr;
        
        }
        const boolean& showOutlineSymbols_attr(){

            return type: oolean\nname: \m_showOutlineSymbols_attr\n;
        
        }
        bool has_defaultGridColor_attr(){

            return m_has_defaultGridColor_attr;
        
        }
        void set_defaultGridColor_attr(const boolean& _defaultGridColor_attr ){

        m_has_defaultGridColor_attr = true;
        m_defaultGridColor_attr = _defaultGridColor_attr;
        
        }
        const boolean& defaultGridColor_attr(){

            return type: oolean\nname: \m_defaultGridColor_attr\n;
        
        }
        bool has_showWhiteSpace_attr(){

            return m_has_showWhiteSpace_attr;
        
        }
        void set_showWhiteSpace_attr(const boolean& _showWhiteSpace_attr ){

        m_has_showWhiteSpace_attr = true;
        m_showWhiteSpace_attr = _showWhiteSpace_attr;
        
        }
        const boolean& showWhiteSpace_attr(){

            return type: oolean\nname: \m_showWhiteSpace_attr\n;
        
        }
        bool has_view_attr(){

            return m_has_view_attr;
        
        }
        void set_view_attr(const ST_SheetViewType& _view_attr ){

            m_has_view_attr = true;
            m_view_attr = new ST_SheetViewType(_view_attr);
        
        }
        const ST_SheetViewType& view_attr(){

            if (m_view_attr)
            {
                return *m_view_attr;
            }
            return ST_SheetViewType::default_instance();
        
        }
        bool has_topLeftCell_attr(){

            return m_has_topLeftCell_attr;
        
        }
        void set_topLeftCell_attr(const ST_CellRef& _topLeftCell_attr ){

            m_has_topLeftCell_attr = true;
            m_topLeftCell_attr = new ST_CellRef(_topLeftCell_attr);
        
        }
        const ST_CellRef& topLeftCell_attr(){

            if (m_topLeftCell_attr)
            {
                return *m_topLeftCell_attr;
            }
            return ST_CellRef::default_instance();
        
        }
        bool has_colorId_attr(){

            return m_has_colorId_attr;
        
        }
        void set_colorId_attr(const unsignedInt& _colorId_attr ){

        m_has_colorId_attr = true;
        m_colorId_attr = _colorId_attr;
        
        }
        const unsignedInt& colorId_attr(){

            return type: \unsignedInt\nname: \m_colorId_attr\n;
        
        }
        bool has_zoomScale_attr(){

            return m_has_zoomScale_attr;
        
        }
        void set_zoomScale_attr(const unsignedInt& _zoomScale_attr ){

        m_has_zoomScale_attr = true;
        m_zoomScale_attr = _zoomScale_attr;
        
        }
        const unsignedInt& zoomScale_attr(){

            return type: \unsignedInt\nname: \m_zoomScale_attr\n;
        
        }
        bool has_zoomScaleNormal_attr(){

            return m_has_zoomScaleNormal_attr;
        
        }
        void set_zoomScaleNormal_attr(const unsignedInt& _zoomScaleNormal_attr ){

        m_has_zoomScaleNormal_attr = true;
        m_zoomScaleNormal_attr = _zoomScaleNormal_attr;
        
        }
        const unsignedInt& zoomScaleNormal_attr(){

            return type: \unsignedInt\nname: \m_zoomScaleNormal_attr\n;
        
        }
        bool has_zoomScaleSheetLayoutView_attr(){

            return m_has_zoomScaleSheetLayoutView_attr;
        
        }
        void set_zoomScaleSheetLayoutView_attr(const unsignedInt& _zoomScaleSheetLayoutView_attr ){

        m_has_zoomScaleSheetLayoutView_attr = true;
        m_zoomScaleSheetLayoutView_attr = _zoomScaleSheetLayoutView_attr;
        
        }
        const unsignedInt& zoomScaleSheetLayoutView_attr(){

            return type: \unsignedInt\nname: \m_zoomScaleSheetLayoutView_attr\n;
        
        }
        bool has_zoomScalePageLayoutView_attr(){

            return m_has_zoomScalePageLayoutView_attr;
        
        }
        void set_zoomScalePageLayoutView_attr(const unsignedInt& _zoomScalePageLayoutView_attr ){

        m_has_zoomScalePageLayoutView_attr = true;
        m_zoomScalePageLayoutView_attr = _zoomScalePageLayoutView_attr;
        
        }
        const unsignedInt& zoomScalePageLayoutView_attr(){

            return type: \unsignedInt\nname: \m_zoomScalePageLayoutView_attr\n;
        
        }
        bool has_workbookViewId_attr(){

            return m_has_workbookViewId_attr;
        
        }
        void set_workbookViewId_attr(const unsignedInt& _workbookViewId_attr ){

        m_has_workbookViewId_attr = true;
        m_workbookViewId_attr = _workbookViewId_attr;
        
        }
        const unsignedInt& workbookViewId_attr(){

            return type: \unsignedInt\nname: \m_workbookViewId_attr\n;
        
        }

    private:
        bool m_has_pane ;
        CT_Pane* m_pane ;
        bool m_has_selection ;
        CT_Selection* m_selection ;
        bool m_has_pivotSelection ;
        CT_PivotSelection* m_pivotSelection ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_SheetView* default_instance_ ;
        bool m_has_windowProtection_attr ;
        boolean m_windowProtection_attr ;
        bool m_has_showFormulas_attr ;
        boolean m_showFormulas_attr ;
        bool m_has_showGridLines_attr ;
        boolean m_showGridLines_attr ;
        bool m_has_showRowColHeaders_attr ;
        boolean m_showRowColHeaders_attr ;
        bool m_has_showZeros_attr ;
        boolean m_showZeros_attr ;
        bool m_has_rightToLeft_attr ;
        boolean m_rightToLeft_attr ;
        bool m_has_tabSelected_attr ;
        boolean m_tabSelected_attr ;
        bool m_has_showRuler_attr ;
        boolean m_showRuler_attr ;
        bool m_has_showOutlineSymbols_attr ;
        boolean m_showOutlineSymbols_attr ;
        bool m_has_defaultGridColor_attr ;
        boolean m_defaultGridColor_attr ;
        bool m_has_showWhiteSpace_attr ;
        boolean m_showWhiteSpace_attr ;
        bool m_has_view_attr ;
        ST_SheetViewType* m_view_attr ;
        bool m_has_topLeftCell_attr ;
        ST_CellRef* m_topLeftCell_attr ;
        bool m_has_colorId_attr ;
        unsignedInt m_colorId_attr ;
        bool m_has_zoomScale_attr ;
        unsignedInt m_zoomScale_attr ;
        bool m_has_zoomScaleNormal_attr ;
        unsignedInt m_zoomScaleNormal_attr ;
        bool m_has_zoomScaleSheetLayoutView_attr ;
        unsignedInt m_zoomScaleSheetLayoutView_attr ;
        bool m_has_zoomScalePageLayoutView_attr ;
        unsignedInt m_zoomScalePageLayoutView_attr ;
        bool m_has_workbookViewId_attr ;
        unsignedInt m_workbookViewId_attr ;

    }

    class CT_Pane : public XSD::ComplexType{
    public:
        void clear(){

                m_has_xSplit_attr = false;
                m_xSplit_attr = 0;
            
                m_has_ySplit_attr = false;
                m_ySplit_attr = 0;
            
                m_has_topLeftCell_attr = false;
                
        if (m_topLeftCell_attr)
        {
            delete m_topLeftCell_attr;
            m_topLeftCell_attr = NULL;
        }
    
            
                m_has_activePane_attr = false;
                
        if (m_activePane_attr)
        {
            delete m_activePane_attr;
            m_activePane_attr = NULL;
        }
    
            
                m_has_state_attr = false;
                
        if (m_state_attr)
        {
            delete m_state_attr;
            m_state_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_xSplit_attr << \\\;
_outStream << _attrName << \=\\ << m_ySplit_attr << \\\;
m_topLeftCell_attr->toXml(_attrName, _outStream);
m_activePane_attr->toXml(_attrName, _outStream);
m_state_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Pane& default_instance(){

    if (!CT_Pane::default_instance_)
    {
        CT_Pane::default_instance_ = new CT_Pane();
    }
    return *CT_Pane::default_instance_;

        }
        bool has_xSplit_attr(){

            return m_has_xSplit_attr;
        
        }
        void set_xSplit_attr(const double& _xSplit_attr ){

        m_has_xSplit_attr = true;
        m_xSplit_attr = _xSplit_attr;
        
        }
        const double& xSplit_attr(){

            return type: \double\nname: \m_xSplit_attr\n;
        
        }
        bool has_ySplit_attr(){

            return m_has_ySplit_attr;
        
        }
        void set_ySplit_attr(const double& _ySplit_attr ){

        m_has_ySplit_attr = true;
        m_ySplit_attr = _ySplit_attr;
        
        }
        const double& ySplit_attr(){

            return type: \double\nname: \m_ySplit_attr\n;
        
        }
        bool has_topLeftCell_attr(){

            return m_has_topLeftCell_attr;
        
        }
        void set_topLeftCell_attr(const ST_CellRef& _topLeftCell_attr ){

            m_has_topLeftCell_attr = true;
            m_topLeftCell_attr = new ST_CellRef(_topLeftCell_attr);
        
        }
        const ST_CellRef& topLeftCell_attr(){

            if (m_topLeftCell_attr)
            {
                return *m_topLeftCell_attr;
            }
            return ST_CellRef::default_instance();
        
        }
        bool has_activePane_attr(){

            return m_has_activePane_attr;
        
        }
        void set_activePane_attr(const ST_Pane& _activePane_attr ){

            m_has_activePane_attr = true;
            m_activePane_attr = new ST_Pane(_activePane_attr);
        
        }
        const ST_Pane& activePane_attr(){

            if (m_activePane_attr)
            {
                return *m_activePane_attr;
            }
            return ST_Pane::default_instance();
        
        }
        bool has_state_attr(){

            return m_has_state_attr;
        
        }
        void set_state_attr(const ST_PaneState& _state_attr ){

            m_has_state_attr = true;
            m_state_attr = new ST_PaneState(_state_attr);
        
        }
        const ST_PaneState& state_attr(){

            if (m_state_attr)
            {
                return *m_state_attr;
            }
            return ST_PaneState::default_instance();
        
        }

    private:
        static CT_Pane* default_instance_ ;
        bool m_has_xSplit_attr ;
        double m_xSplit_attr ;
        bool m_has_ySplit_attr ;
        double m_ySplit_attr ;
        bool m_has_topLeftCell_attr ;
        ST_CellRef* m_topLeftCell_attr ;
        bool m_has_activePane_attr ;
        ST_Pane* m_activePane_attr ;
        bool m_has_state_attr ;
        ST_PaneState* m_state_attr ;

    }

    class CT_PivotSelection : public XSD::ComplexType{
    public:
        bool has_pivotArea(){

            return m_has_pivotArea;
        
        }
        CT_PivotArea* mutable_pivotArea(){

                m_has_pivotArea = true;
                if (!m_pivotArea)
                {
                    m_pivotArea = new CT_PivotArea();
                }
                return m_pivotArea;
            
        }
        const CT_PivotArea& pivotArea(){

            if (m_pivotArea)
            {
                return *m_pivotArea;
            }
            return CT_PivotArea::default_instance();
        
        }
        void clear(){

                m_has_pane_attr = false;
                
        if (m_pane_attr)
        {
            delete m_pane_attr;
            m_pane_attr = NULL;
        }
    
            
                m_has_showHeader_attr = false;
                m_showHeader_attr = false;
            
                m_has_label_attr = false;
                m_label_attr = false;
            
                m_has_data_attr = false;
                m_data_attr = false;
            
                m_has_extendable_attr = false;
                m_extendable_attr = false;
            
                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_axis_attr = false;
                
        if (m_axis_attr)
        {
            delete m_axis_attr;
            m_axis_attr = NULL;
        }
    
            
                m_has_dimension_attr = false;
                m_dimension_attr = 0;
            
                m_has_start_attr = false;
                m_start_attr = 0;
            
                m_has_min_attr = false;
                m_min_attr = 0;
            
                m_has_max_attr = false;
                m_max_attr = 0;
            
                m_has_activeRow_attr = false;
                m_activeRow_attr = 0;
            
                m_has_activeCol_attr = false;
                m_activeCol_attr = 0;
            
                m_has_previousRow_attr = false;
                m_previousRow_attr = 0;
            
                m_has_previousCol_attr = false;
                m_previousCol_attr = 0;
            
                m_has_click_attr = false;
                m_click_attr = 0;
            
                m_has_id_attr = false;
                
        if (m_id_attr)
        {
            delete m_id_attr;
            m_id_attr = NULL;
        }
    
            
                m_has_pivotArea = false;
                
        if (m_pivotArea)
        {
            delete m_pivotArea;
            m_pivotArea = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_pane_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showHeader_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_label_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_data_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_extendable_attr) << \\\;
_outStream << _attrName << \=\\ << m_count_attr << \\\;
m_axis_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_dimension_attr << \\\;
_outStream << _attrName << \=\\ << m_start_attr << \\\;
_outStream << _attrName << \=\\ << m_min_attr << \\\;
_outStream << _attrName << \=\\ << m_max_attr << \\\;
_outStream << _attrName << \=\\ << m_activeRow_attr << \\\;
_outStream << _attrName << \=\\ << m_activeCol_attr << \\\;
_outStream << _attrName << \=\\ << m_previousRow_attr << \\\;
_outStream << _attrName << \=\\ << m_previousCol_attr << \\\;
_outStream << _attrName << \=\\ << m_click_attr << \\\;
m_id_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_pivotArea)
                {
                    m_pivotArea->toXml(pivotArea, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_PivotSelection& default_instance(){

    if (!CT_PivotSelection::default_instance_)
    {
        CT_PivotSelection::default_instance_ = new CT_PivotSelection();
    }
    return *CT_PivotSelection::default_instance_;

        }
        bool has_pane_attr(){

            return m_has_pane_attr;
        
        }
        void set_pane_attr(const ST_Pane& _pane_attr ){

            m_has_pane_attr = true;
            m_pane_attr = new ST_Pane(_pane_attr);
        
        }
        const ST_Pane& pane_attr(){

            if (m_pane_attr)
            {
                return *m_pane_attr;
            }
            return ST_Pane::default_instance();
        
        }
        bool has_showHeader_attr(){

            return m_has_showHeader_attr;
        
        }
        void set_showHeader_attr(const boolean& _showHeader_attr ){

        m_has_showHeader_attr = true;
        m_showHeader_attr = _showHeader_attr;
        
        }
        const boolean& showHeader_attr(){

            return type: oolean\nname: \m_showHeader_attr\n;
        
        }
        bool has_label_attr(){

            return m_has_label_attr;
        
        }
        void set_label_attr(const boolean& _label_attr ){

        m_has_label_attr = true;
        m_label_attr = _label_attr;
        
        }
        const boolean& label_attr(){

            return type: oolean\nname: \m_label_attr\n;
        
        }
        bool has_data_attr(){

            return m_has_data_attr;
        
        }
        void set_data_attr(const boolean& _data_attr ){

        m_has_data_attr = true;
        m_data_attr = _data_attr;
        
        }
        const boolean& data_attr(){

            return type: oolean\nname: \m_data_attr\n;
        
        }
        bool has_extendable_attr(){

            return m_has_extendable_attr;
        
        }
        void set_extendable_attr(const boolean& _extendable_attr ){

        m_has_extendable_attr = true;
        m_extendable_attr = _extendable_attr;
        
        }
        const boolean& extendable_attr(){

            return type: oolean\nname: \m_extendable_attr\n;
        
        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }
        bool has_axis_attr(){

            return m_has_axis_attr;
        
        }
        void set_axis_attr(const ST_Axis& _axis_attr ){

            m_has_axis_attr = true;
            m_axis_attr = new ST_Axis(_axis_attr);
        
        }
        const ST_Axis& axis_attr(){

            if (m_axis_attr)
            {
                return *m_axis_attr;
            }
            return ST_Axis::default_instance();
        
        }
        bool has_dimension_attr(){

            return m_has_dimension_attr;
        
        }
        void set_dimension_attr(const unsignedInt& _dimension_attr ){

        m_has_dimension_attr = true;
        m_dimension_attr = _dimension_attr;
        
        }
        const unsignedInt& dimension_attr(){

            return type: \unsignedInt\nname: \m_dimension_attr\n;
        
        }
        bool has_start_attr(){

            return m_has_start_attr;
        
        }
        void set_start_attr(const unsignedInt& _start_attr ){

        m_has_start_attr = true;
        m_start_attr = _start_attr;
        
        }
        const unsignedInt& start_attr(){

            return type: \unsignedInt\nname: \m_start_attr\n;
        
        }
        bool has_min_attr(){

            return m_has_min_attr;
        
        }
        void set_min_attr(const unsignedInt& _min_attr ){

        m_has_min_attr = true;
        m_min_attr = _min_attr;
        
        }
        const unsignedInt& min_attr(){

            return type: \unsignedInt\nname: \m_min_attr\n;
        
        }
        bool has_max_attr(){

            return m_has_max_attr;
        
        }
        void set_max_attr(const unsignedInt& _max_attr ){

        m_has_max_attr = true;
        m_max_attr = _max_attr;
        
        }
        const unsignedInt& max_attr(){

            return type: \unsignedInt\nname: \m_max_attr\n;
        
        }
        bool has_activeRow_attr(){

            return m_has_activeRow_attr;
        
        }
        void set_activeRow_attr(const unsignedInt& _activeRow_attr ){

        m_has_activeRow_attr = true;
        m_activeRow_attr = _activeRow_attr;
        
        }
        const unsignedInt& activeRow_attr(){

            return type: \unsignedInt\nname: \m_activeRow_attr\n;
        
        }
        bool has_activeCol_attr(){

            return m_has_activeCol_attr;
        
        }
        void set_activeCol_attr(const unsignedInt& _activeCol_attr ){

        m_has_activeCol_attr = true;
        m_activeCol_attr = _activeCol_attr;
        
        }
        const unsignedInt& activeCol_attr(){

            return type: \unsignedInt\nname: \m_activeCol_attr\n;
        
        }
        bool has_previousRow_attr(){

            return m_has_previousRow_attr;
        
        }
        void set_previousRow_attr(const unsignedInt& _previousRow_attr ){

        m_has_previousRow_attr = true;
        m_previousRow_attr = _previousRow_attr;
        
        }
        const unsignedInt& previousRow_attr(){

            return type: \unsignedInt\nname: \m_previousRow_attr\n;
        
        }
        bool has_previousCol_attr(){

            return m_has_previousCol_attr;
        
        }
        void set_previousCol_attr(const unsignedInt& _previousCol_attr ){

        m_has_previousCol_attr = true;
        m_previousCol_attr = _previousCol_attr;
        
        }
        const unsignedInt& previousCol_attr(){

            return type: \unsignedInt\nname: \m_previousCol_attr\n;
        
        }
        bool has_click_attr(){

            return m_has_click_attr;
        
        }
        void set_click_attr(const unsignedInt& _click_attr ){

        m_has_click_attr = true;
        m_click_attr = _click_attr;
        
        }
        const unsignedInt& click_attr(){

            return type: \unsignedInt\nname: \m_click_attr\n;
        
        }
        bool has_id_attr(){

            return m_has_id_attr;
        
        }
        void set_id_attr(const ST_RelationshipId& _id_attr ){

            m_has_id_attr = true;
            m_id_attr = new ST_RelationshipId(_id_attr);
        
        }
        const ST_RelationshipId& id_attr(){

            if (m_id_attr)
            {
                return *m_id_attr;
            }
            return ST_RelationshipId::default_instance();
        
        }

    private:
        bool m_has_pivotArea ;
        CT_PivotArea* m_pivotArea ;
        static CT_PivotSelection* default_instance_ ;
        bool m_has_pane_attr ;
        ST_Pane* m_pane_attr ;
        bool m_has_showHeader_attr ;
        boolean m_showHeader_attr ;
        bool m_has_label_attr ;
        boolean m_label_attr ;
        bool m_has_data_attr ;
        boolean m_data_attr ;
        bool m_has_extendable_attr ;
        boolean m_extendable_attr ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;
        bool m_has_axis_attr ;
        ST_Axis* m_axis_attr ;
        bool m_has_dimension_attr ;
        unsignedInt m_dimension_attr ;
        bool m_has_start_attr ;
        unsignedInt m_start_attr ;
        bool m_has_min_attr ;
        unsignedInt m_min_attr ;
        bool m_has_max_attr ;
        unsignedInt m_max_attr ;
        bool m_has_activeRow_attr ;
        unsignedInt m_activeRow_attr ;
        bool m_has_activeCol_attr ;
        unsignedInt m_activeCol_attr ;
        bool m_has_previousRow_attr ;
        unsignedInt m_previousRow_attr ;
        bool m_has_previousCol_attr ;
        unsignedInt m_previousCol_attr ;
        bool m_has_click_attr ;
        unsignedInt m_click_attr ;
        bool m_has_id_attr ;
        ST_RelationshipId* m_id_attr ;

    }

    class CT_Selection : public XSD::ComplexType{
    public:
        void clear(){

                m_has_pane_attr = false;
                
        if (m_pane_attr)
        {
            delete m_pane_attr;
            m_pane_attr = NULL;
        }
    
            
                m_has_activeCell_attr = false;
                
        if (m_activeCell_attr)
        {
            delete m_activeCell_attr;
            m_activeCell_attr = NULL;
        }
    
            
                m_has_activeCellId_attr = false;
                m_activeCellId_attr = 0;
            
                m_has_sqref_attr = false;
                
        if (m_sqref_attr)
        {
            delete m_sqref_attr;
            m_sqref_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_pane_attr->toXml(_attrName, _outStream);
m_activeCell_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_activeCellId_attr << \\\;
m_sqref_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Selection& default_instance(){

    if (!CT_Selection::default_instance_)
    {
        CT_Selection::default_instance_ = new CT_Selection();
    }
    return *CT_Selection::default_instance_;

        }
        bool has_pane_attr(){

            return m_has_pane_attr;
        
        }
        void set_pane_attr(const ST_Pane& _pane_attr ){

            m_has_pane_attr = true;
            m_pane_attr = new ST_Pane(_pane_attr);
        
        }
        const ST_Pane& pane_attr(){

            if (m_pane_attr)
            {
                return *m_pane_attr;
            }
            return ST_Pane::default_instance();
        
        }
        bool has_activeCell_attr(){

            return m_has_activeCell_attr;
        
        }
        void set_activeCell_attr(const ST_CellRef& _activeCell_attr ){

            m_has_activeCell_attr = true;
            m_activeCell_attr = new ST_CellRef(_activeCell_attr);
        
        }
        const ST_CellRef& activeCell_attr(){

            if (m_activeCell_attr)
            {
                return *m_activeCell_attr;
            }
            return ST_CellRef::default_instance();
        
        }
        bool has_activeCellId_attr(){

            return m_has_activeCellId_attr;
        
        }
        void set_activeCellId_attr(const unsignedInt& _activeCellId_attr ){

        m_has_activeCellId_attr = true;
        m_activeCellId_attr = _activeCellId_attr;
        
        }
        const unsignedInt& activeCellId_attr(){

            return type: \unsignedInt\nname: \m_activeCellId_attr\n;
        
        }
        bool has_sqref_attr(){

            return m_has_sqref_attr;
        
        }
        void set_sqref_attr(const ST_Sqref& _sqref_attr ){

            m_has_sqref_attr = true;
            m_sqref_attr = new ST_Sqref(_sqref_attr);
        
        }
        const ST_Sqref& sqref_attr(){

            if (m_sqref_attr)
            {
                return *m_sqref_attr;
            }
            return ST_Sqref::default_instance();
        
        }

    private:
        static CT_Selection* default_instance_ ;
        bool m_has_pane_attr ;
        ST_Pane* m_pane_attr ;
        bool m_has_activeCell_attr ;
        ST_CellRef* m_activeCell_attr ;
        bool m_has_activeCellId_attr ;
        unsignedInt m_activeCellId_attr ;
        bool m_has_sqref_attr ;
        ST_Sqref* m_sqref_attr ;

    }

    class CT_PageBreak : public XSD::ComplexType{
    public:
        bool has_brk(){

            return m_has_brk;
        
        }
        CT_Break* mutable_brk(){

                m_has_brk = true;
                if (!m_brk)
                {
                    m_brk = new CT_Break();
                }
                return m_brk;
            
        }
        const CT_Break& brk(){

            if (m_brk)
            {
                return *m_brk;
            }
            return CT_Break::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_manualBreakCount_attr = false;
                m_manualBreakCount_attr = 0;
            
                m_has_brk = false;
                
        if (m_brk)
        {
            delete m_brk;
            m_brk = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
_outStream << _attrName << \=\\ << m_manualBreakCount_attr << \\\;
        _outStream << \>\;
    
                if (m_has_brk)
                {
                    m_brk->toXml(brk, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_PageBreak& default_instance(){

    if (!CT_PageBreak::default_instance_)
    {
        CT_PageBreak::default_instance_ = new CT_PageBreak();
    }
    return *CT_PageBreak::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }
        bool has_manualBreakCount_attr(){

            return m_has_manualBreakCount_attr;
        
        }
        void set_manualBreakCount_attr(const unsignedInt& _manualBreakCount_attr ){

        m_has_manualBreakCount_attr = true;
        m_manualBreakCount_attr = _manualBreakCount_attr;
        
        }
        const unsignedInt& manualBreakCount_attr(){

            return type: \unsignedInt\nname: \m_manualBreakCount_attr\n;
        
        }

    private:
        bool m_has_brk ;
        CT_Break* m_brk ;
        static CT_PageBreak* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;
        bool m_has_manualBreakCount_attr ;
        unsignedInt m_manualBreakCount_attr ;

    }

    class CT_Break : public XSD::ComplexType{
    public:
        void clear(){

                m_has_id_attr = false;
                m_id_attr = 0;
            
                m_has_min_attr = false;
                m_min_attr = 0;
            
                m_has_max_attr = false;
                m_max_attr = 0;
            
                m_has_man_attr = false;
                m_man_attr = false;
            
                m_has_pt_attr = false;
                m_pt_attr = false;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_id_attr << \\\;
_outStream << _attrName << \=\\ << m_min_attr << \\\;
_outStream << _attrName << \=\\ << m_max_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_man_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_pt_attr) << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Break& default_instance(){

    if (!CT_Break::default_instance_)
    {
        CT_Break::default_instance_ = new CT_Break();
    }
    return *CT_Break::default_instance_;

        }
        bool has_id_attr(){

            return m_has_id_attr;
        
        }
        void set_id_attr(const unsignedInt& _id_attr ){

        m_has_id_attr = true;
        m_id_attr = _id_attr;
        
        }
        const unsignedInt& id_attr(){

            return type: \unsignedInt\nname: \m_id_attr\n;
        
        }
        bool has_min_attr(){

            return m_has_min_attr;
        
        }
        void set_min_attr(const unsignedInt& _min_attr ){

        m_has_min_attr = true;
        m_min_attr = _min_attr;
        
        }
        const unsignedInt& min_attr(){

            return type: \unsignedInt\nname: \m_min_attr\n;
        
        }
        bool has_max_attr(){

            return m_has_max_attr;
        
        }
        void set_max_attr(const unsignedInt& _max_attr ){

        m_has_max_attr = true;
        m_max_attr = _max_attr;
        
        }
        const unsignedInt& max_attr(){

            return type: \unsignedInt\nname: \m_max_attr\n;
        
        }
        bool has_man_attr(){

            return m_has_man_attr;
        
        }
        void set_man_attr(const boolean& _man_attr ){

        m_has_man_attr = true;
        m_man_attr = _man_attr;
        
        }
        const boolean& man_attr(){

            return type: oolean\nname: \m_man_attr\n;
        
        }
        bool has_pt_attr(){

            return m_has_pt_attr;
        
        }
        void set_pt_attr(const boolean& _pt_attr ){

        m_has_pt_attr = true;
        m_pt_attr = _pt_attr;
        
        }
        const boolean& pt_attr(){

            return type: oolean\nname: \m_pt_attr\n;
        
        }

    private:
        static CT_Break* default_instance_ ;
        bool m_has_id_attr ;
        unsignedInt m_id_attr ;
        bool m_has_min_attr ;
        unsignedInt m_min_attr ;
        bool m_has_max_attr ;
        unsignedInt m_max_attr ;
        bool m_has_man_attr ;
        boolean m_man_attr ;
        bool m_has_pt_attr ;
        boolean m_pt_attr ;

    }

    class CT_OutlinePr : public XSD::ComplexType{
    public:
        void clear(){

                m_has_applyStyles_attr = false;
                m_applyStyles_attr = false;
            
                m_has_summaryBelow_attr = false;
                m_summaryBelow_attr = false;
            
                m_has_summaryRight_attr = false;
                m_summaryRight_attr = false;
            
                m_has_showOutlineSymbols_attr = false;
                m_showOutlineSymbols_attr = false;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_applyStyles_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_summaryBelow_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_summaryRight_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showOutlineSymbols_attr) << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_OutlinePr& default_instance(){

    if (!CT_OutlinePr::default_instance_)
    {
        CT_OutlinePr::default_instance_ = new CT_OutlinePr();
    }
    return *CT_OutlinePr::default_instance_;

        }
        bool has_applyStyles_attr(){

            return m_has_applyStyles_attr;
        
        }
        void set_applyStyles_attr(const boolean& _applyStyles_attr ){

        m_has_applyStyles_attr = true;
        m_applyStyles_attr = _applyStyles_attr;
        
        }
        const boolean& applyStyles_attr(){

            return type: oolean\nname: \m_applyStyles_attr\n;
        
        }
        bool has_summaryBelow_attr(){

            return m_has_summaryBelow_attr;
        
        }
        void set_summaryBelow_attr(const boolean& _summaryBelow_attr ){

        m_has_summaryBelow_attr = true;
        m_summaryBelow_attr = _summaryBelow_attr;
        
        }
        const boolean& summaryBelow_attr(){

            return type: oolean\nname: \m_summaryBelow_attr\n;
        
        }
        bool has_summaryRight_attr(){

            return m_has_summaryRight_attr;
        
        }
        void set_summaryRight_attr(const boolean& _summaryRight_attr ){

        m_has_summaryRight_attr = true;
        m_summaryRight_attr = _summaryRight_attr;
        
        }
        const boolean& summaryRight_attr(){

            return type: oolean\nname: \m_summaryRight_attr\n;
        
        }
        bool has_showOutlineSymbols_attr(){

            return m_has_showOutlineSymbols_attr;
        
        }
        void set_showOutlineSymbols_attr(const boolean& _showOutlineSymbols_attr ){

        m_has_showOutlineSymbols_attr = true;
        m_showOutlineSymbols_attr = _showOutlineSymbols_attr;
        
        }
        const boolean& showOutlineSymbols_attr(){

            return type: oolean\nname: \m_showOutlineSymbols_attr\n;
        
        }

    private:
        static CT_OutlinePr* default_instance_ ;
        bool m_has_applyStyles_attr ;
        boolean m_applyStyles_attr ;
        bool m_has_summaryBelow_attr ;
        boolean m_summaryBelow_attr ;
        bool m_has_summaryRight_attr ;
        boolean m_summaryRight_attr ;
        bool m_has_showOutlineSymbols_attr ;
        boolean m_showOutlineSymbols_attr ;

    }

    class CT_PageSetUpPr : public XSD::ComplexType{
    public:
        void clear(){

                m_has_autoPageBreaks_attr = false;
                m_autoPageBreaks_attr = false;
            
                m_has_fitToPage_attr = false;
                m_fitToPage_attr = false;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_autoPageBreaks_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_fitToPage_attr) << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_PageSetUpPr& default_instance(){

    if (!CT_PageSetUpPr::default_instance_)
    {
        CT_PageSetUpPr::default_instance_ = new CT_PageSetUpPr();
    }
    return *CT_PageSetUpPr::default_instance_;

        }
        bool has_autoPageBreaks_attr(){

            return m_has_autoPageBreaks_attr;
        
        }
        void set_autoPageBreaks_attr(const boolean& _autoPageBreaks_attr ){

        m_has_autoPageBreaks_attr = true;
        m_autoPageBreaks_attr = _autoPageBreaks_attr;
        
        }
        const boolean& autoPageBreaks_attr(){

            return type: oolean\nname: \m_autoPageBreaks_attr\n;
        
        }
        bool has_fitToPage_attr(){

            return m_has_fitToPage_attr;
        
        }
        void set_fitToPage_attr(const boolean& _fitToPage_attr ){

        m_has_fitToPage_attr = true;
        m_fitToPage_attr = _fitToPage_attr;
        
        }
        const boolean& fitToPage_attr(){

            return type: oolean\nname: \m_fitToPage_attr\n;
        
        }

    private:
        static CT_PageSetUpPr* default_instance_ ;
        bool m_has_autoPageBreaks_attr ;
        boolean m_autoPageBreaks_attr ;
        bool m_has_fitToPage_attr ;
        boolean m_fitToPage_attr ;

    }

    class CT_DataConsolidate : public XSD::ComplexType{
    public:
        bool has_dataRefs(){

            return m_has_dataRefs;
        
        }
        CT_DataRefs* mutable_dataRefs(){

                m_has_dataRefs = true;
                if (!m_dataRefs)
                {
                    m_dataRefs = new CT_DataRefs();
                }
                return m_dataRefs;
            
        }
        const CT_DataRefs& dataRefs(){

            if (m_dataRefs)
            {
                return *m_dataRefs;
            }
            return CT_DataRefs::default_instance();
        
        }
        void clear(){

                m_has_function_attr = false;
                
        if (m_function_attr)
        {
            delete m_function_attr;
            m_function_attr = NULL;
        }
    
            
                m_has_startLabels_attr = false;
                m_startLabels_attr = false;
            
                m_has_leftLabels_attr = false;
                m_leftLabels_attr = false;
            
                m_has_topLabels_attr = false;
                m_topLabels_attr = false;
            
                m_has_link_attr = false;
                m_link_attr = false;
            
                m_has_dataRefs = false;
                
        if (m_dataRefs)
        {
            delete m_dataRefs;
            m_dataRefs = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_function_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_startLabels_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_leftLabels_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_topLabels_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_link_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_dataRefs)
                {
                    m_dataRefs->toXml(dataRefs, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_DataConsolidate& default_instance(){

    if (!CT_DataConsolidate::default_instance_)
    {
        CT_DataConsolidate::default_instance_ = new CT_DataConsolidate();
    }
    return *CT_DataConsolidate::default_instance_;

        }
        bool has_function_attr(){

            return m_has_function_attr;
        
        }
        void set_function_attr(const ST_DataConsolidateFunction& _function_attr ){

            m_has_function_attr = true;
            m_function_attr = new ST_DataConsolidateFunction(_function_attr);
        
        }
        const ST_DataConsolidateFunction& function_attr(){

            if (m_function_attr)
            {
                return *m_function_attr;
            }
            return ST_DataConsolidateFunction::default_instance();
        
        }
        bool has_startLabels_attr(){

            return m_has_startLabels_attr;
        
        }
        void set_startLabels_attr(const boolean& _startLabels_attr ){

        m_has_startLabels_attr = true;
        m_startLabels_attr = _startLabels_attr;
        
        }
        const boolean& startLabels_attr(){

            return type: oolean\nname: \m_startLabels_attr\n;
        
        }
        bool has_leftLabels_attr(){

            return m_has_leftLabels_attr;
        
        }
        void set_leftLabels_attr(const boolean& _leftLabels_attr ){

        m_has_leftLabels_attr = true;
        m_leftLabels_attr = _leftLabels_attr;
        
        }
        const boolean& leftLabels_attr(){

            return type: oolean\nname: \m_leftLabels_attr\n;
        
        }
        bool has_topLabels_attr(){

            return m_has_topLabels_attr;
        
        }
        void set_topLabels_attr(const boolean& _topLabels_attr ){

        m_has_topLabels_attr = true;
        m_topLabels_attr = _topLabels_attr;
        
        }
        const boolean& topLabels_attr(){

            return type: oolean\nname: \m_topLabels_attr\n;
        
        }
        bool has_link_attr(){

            return m_has_link_attr;
        
        }
        void set_link_attr(const boolean& _link_attr ){

        m_has_link_attr = true;
        m_link_attr = _link_attr;
        
        }
        const boolean& link_attr(){

            return type: oolean\nname: \m_link_attr\n;
        
        }

    private:
        bool m_has_dataRefs ;
        CT_DataRefs* m_dataRefs ;
        static CT_DataConsolidate* default_instance_ ;
        bool m_has_function_attr ;
        ST_DataConsolidateFunction* m_function_attr ;
        bool m_has_startLabels_attr ;
        boolean m_startLabels_attr ;
        bool m_has_leftLabels_attr ;
        boolean m_leftLabels_attr ;
        bool m_has_topLabels_attr ;
        boolean m_topLabels_attr ;
        bool m_has_link_attr ;
        boolean m_link_attr ;

    }

    class CT_DataRefs : public XSD::ComplexType{
    public:
        bool has_dataRef(){

            return m_has_dataRef;
        
        }
        CT_DataRef* mutable_dataRef(){

                m_has_dataRef = true;
                if (!m_dataRef)
                {
                    m_dataRef = new CT_DataRef();
                }
                return m_dataRef;
            
        }
        const CT_DataRef& dataRef(){

            if (m_dataRef)
            {
                return *m_dataRef;
            }
            return CT_DataRef::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_dataRef = false;
                
        if (m_dataRef)
        {
            delete m_dataRef;
            m_dataRef = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_dataRef)
                {
                    m_dataRef->toXml(dataRef, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_DataRefs& default_instance(){

    if (!CT_DataRefs::default_instance_)
    {
        CT_DataRefs::default_instance_ = new CT_DataRefs();
    }
    return *CT_DataRefs::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_dataRef ;
        CT_DataRef* m_dataRef ;
        static CT_DataRefs* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_DataRef : public XSD::ComplexType{
    public:
        void clear(){

                m_has_ref_attr = false;
                
        if (m_ref_attr)
        {
            delete m_ref_attr;
            m_ref_attr = NULL;
        }
    
            
                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
                m_has_sheet_attr = false;
                
        if (m_sheet_attr)
        {
            delete m_sheet_attr;
            m_sheet_attr = NULL;
        }
    
            
                m_has_id_attr = false;
                
        if (m_id_attr)
        {
            delete m_id_attr;
            m_id_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_ref_attr->toXml(_attrName, _outStream);
m_name_attr->toXml(_attrName, _outStream);
m_sheet_attr->toXml(_attrName, _outStream);
m_id_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_DataRef& default_instance(){

    if (!CT_DataRef::default_instance_)
    {
        CT_DataRef::default_instance_ = new CT_DataRef();
    }
    return *CT_DataRef::default_instance_;

        }
        bool has_ref_attr(){

            return m_has_ref_attr;
        
        }
        void set_ref_attr(const ST_Ref& _ref_attr ){

            m_has_ref_attr = true;
            m_ref_attr = new ST_Ref(_ref_attr);
        
        }
        const ST_Ref& ref_attr(){

            if (m_ref_attr)
            {
                return *m_ref_attr;
            }
            return ST_Ref::default_instance();
        
        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_sheet_attr(){

            return m_has_sheet_attr;
        
        }
        void set_sheet_attr(const ns_s::ST_Xstring& _sheet_attr ){

            m_has_sheet_attr = true;
            m_sheet_attr = new ns_s::ST_Xstring(_sheet_attr);
        
        }
        const ns_s::ST_Xstring& sheet_attr(){

            if (m_sheet_attr)
            {
                return *m_sheet_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_id_attr(){

            return m_has_id_attr;
        
        }
        void set_id_attr(const ST_RelationshipId& _id_attr ){

            m_has_id_attr = true;
            m_id_attr = new ST_RelationshipId(_id_attr);
        
        }
        const ST_RelationshipId& id_attr(){

            if (m_id_attr)
            {
                return *m_id_attr;
            }
            return ST_RelationshipId::default_instance();
        
        }

    private:
        static CT_DataRef* default_instance_ ;
        bool m_has_ref_attr ;
        ST_Ref* m_ref_attr ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;
        bool m_has_sheet_attr ;
        ns_s::ST_Xstring* m_sheet_attr ;
        bool m_has_id_attr ;
        ST_RelationshipId* m_id_attr ;

    }

    class CT_MergeCells : public XSD::ComplexType{
    public:
        bool has_mergeCell(){

            return m_has_mergeCell;
        
        }
        CT_MergeCell* mutable_mergeCell(){

                m_has_mergeCell = true;
                if (!m_mergeCell)
                {
                    m_mergeCell = new CT_MergeCell();
                }
                return m_mergeCell;
            
        }
        const CT_MergeCell& mergeCell(){

            if (m_mergeCell)
            {
                return *m_mergeCell;
            }
            return CT_MergeCell::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_mergeCell = false;
                
        if (m_mergeCell)
        {
            delete m_mergeCell;
            m_mergeCell = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_mergeCell)
                {
                    m_mergeCell->toXml(mergeCell, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_MergeCells& default_instance(){

    if (!CT_MergeCells::default_instance_)
    {
        CT_MergeCells::default_instance_ = new CT_MergeCells();
    }
    return *CT_MergeCells::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_mergeCell ;
        CT_MergeCell* m_mergeCell ;
        static CT_MergeCells* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_MergeCell : public XSD::ComplexType{
    public:
        void clear(){

                m_has_ref_attr = false;
                
        if (m_ref_attr)
        {
            delete m_ref_attr;
            m_ref_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_ref_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_MergeCell& default_instance(){

    if (!CT_MergeCell::default_instance_)
    {
        CT_MergeCell::default_instance_ = new CT_MergeCell();
    }
    return *CT_MergeCell::default_instance_;

        }
        bool has_ref_attr(){

            return m_has_ref_attr;
        
        }
        void set_ref_attr(const ST_Ref& _ref_attr ){

            m_has_ref_attr = true;
            m_ref_attr = new ST_Ref(_ref_attr);
        
        }
        const ST_Ref& ref_attr(){

            if (m_ref_attr)
            {
                return *m_ref_attr;
            }
            return ST_Ref::default_instance();
        
        }

    private:
        static CT_MergeCell* default_instance_ ;
        bool m_has_ref_attr ;
        ST_Ref* m_ref_attr ;

    }

    class CT_SmartTags : public XSD::ComplexType{
    public:
        bool has_cellSmartTags(){

            return m_has_cellSmartTags;
        
        }
        CT_CellSmartTags* mutable_cellSmartTags(){

                m_has_cellSmartTags = true;
                if (!m_cellSmartTags)
                {
                    m_cellSmartTags = new CT_CellSmartTags();
                }
                return m_cellSmartTags;
            
        }
        const CT_CellSmartTags& cellSmartTags(){

            if (m_cellSmartTags)
            {
                return *m_cellSmartTags;
            }
            return CT_CellSmartTags::default_instance();
        
        }
        void clear(){

                m_has_cellSmartTags = false;
                
        if (m_cellSmartTags)
        {
            delete m_cellSmartTags;
            m_cellSmartTags = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_cellSmartTags)
                {
                    m_cellSmartTags->toXml(cellSmartTags, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_SmartTags& default_instance(){

    if (!CT_SmartTags::default_instance_)
    {
        CT_SmartTags::default_instance_ = new CT_SmartTags();
    }
    return *CT_SmartTags::default_instance_;

        }

    private:
        bool m_has_cellSmartTags ;
        CT_CellSmartTags* m_cellSmartTags ;
        static CT_SmartTags* default_instance_ ;

    }

    class CT_CellSmartTags : public XSD::ComplexType{
    public:
        bool has_cellSmartTag(){

            return m_has_cellSmartTag;
        
        }
        CT_CellSmartTag* mutable_cellSmartTag(){

                m_has_cellSmartTag = true;
                if (!m_cellSmartTag)
                {
                    m_cellSmartTag = new CT_CellSmartTag();
                }
                return m_cellSmartTag;
            
        }
        const CT_CellSmartTag& cellSmartTag(){

            if (m_cellSmartTag)
            {
                return *m_cellSmartTag;
            }
            return CT_CellSmartTag::default_instance();
        
        }
        void clear(){

                m_has_r_attr = false;
                
        if (m_r_attr)
        {
            delete m_r_attr;
            m_r_attr = NULL;
        }
    
            
                m_has_cellSmartTag = false;
                
        if (m_cellSmartTag)
        {
            delete m_cellSmartTag;
            m_cellSmartTag = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_r_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_cellSmartTag)
                {
                    m_cellSmartTag->toXml(cellSmartTag, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CellSmartTags& default_instance(){

    if (!CT_CellSmartTags::default_instance_)
    {
        CT_CellSmartTags::default_instance_ = new CT_CellSmartTags();
    }
    return *CT_CellSmartTags::default_instance_;

        }
        bool has_r_attr(){

            return m_has_r_attr;
        
        }
        void set_r_attr(const ST_CellRef& _r_attr ){

            m_has_r_attr = true;
            m_r_attr = new ST_CellRef(_r_attr);
        
        }
        const ST_CellRef& r_attr(){

            if (m_r_attr)
            {
                return *m_r_attr;
            }
            return ST_CellRef::default_instance();
        
        }

    private:
        bool m_has_cellSmartTag ;
        CT_CellSmartTag* m_cellSmartTag ;
        static CT_CellSmartTags* default_instance_ ;
        bool m_has_r_attr ;
        ST_CellRef* m_r_attr ;

    }

    class CT_CellSmartTag : public XSD::ComplexType{
    public:
        bool has_cellSmartTagPr(){

            return m_has_cellSmartTagPr;
        
        }
        CT_CellSmartTagPr* mutable_cellSmartTagPr(){

                m_has_cellSmartTagPr = true;
                if (!m_cellSmartTagPr)
                {
                    m_cellSmartTagPr = new CT_CellSmartTagPr();
                }
                return m_cellSmartTagPr;
            
        }
        const CT_CellSmartTagPr& cellSmartTagPr(){

            if (m_cellSmartTagPr)
            {
                return *m_cellSmartTagPr;
            }
            return CT_CellSmartTagPr::default_instance();
        
        }
        void clear(){

                m_has_type_attr = false;
                m_type_attr = 0;
            
                m_has_deleted_attr = false;
                m_deleted_attr = false;
            
                m_has_xmlBased_attr = false;
                m_xmlBased_attr = false;
            
                m_has_cellSmartTagPr = false;
                
        if (m_cellSmartTagPr)
        {
            delete m_cellSmartTagPr;
            m_cellSmartTagPr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_type_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_deleted_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_xmlBased_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_cellSmartTagPr)
                {
                    m_cellSmartTagPr->toXml(cellSmartTagPr, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CellSmartTag& default_instance(){

    if (!CT_CellSmartTag::default_instance_)
    {
        CT_CellSmartTag::default_instance_ = new CT_CellSmartTag();
    }
    return *CT_CellSmartTag::default_instance_;

        }
        bool has_type_attr(){

            return m_has_type_attr;
        
        }
        void set_type_attr(const unsignedInt& _type_attr ){

        m_has_type_attr = true;
        m_type_attr = _type_attr;
        
        }
        const unsignedInt& type_attr(){

            return type: \unsignedInt\nname: \m_type_attr\n;
        
        }
        bool has_deleted_attr(){

            return m_has_deleted_attr;
        
        }
        void set_deleted_attr(const boolean& _deleted_attr ){

        m_has_deleted_attr = true;
        m_deleted_attr = _deleted_attr;
        
        }
        const boolean& deleted_attr(){

            return type: oolean\nname: \m_deleted_attr\n;
        
        }
        bool has_xmlBased_attr(){

            return m_has_xmlBased_attr;
        
        }
        void set_xmlBased_attr(const boolean& _xmlBased_attr ){

        m_has_xmlBased_attr = true;
        m_xmlBased_attr = _xmlBased_attr;
        
        }
        const boolean& xmlBased_attr(){

            return type: oolean\nname: \m_xmlBased_attr\n;
        
        }

    private:
        bool m_has_cellSmartTagPr ;
        CT_CellSmartTagPr* m_cellSmartTagPr ;
        static CT_CellSmartTag* default_instance_ ;
        bool m_has_type_attr ;
        unsignedInt m_type_attr ;
        bool m_has_deleted_attr ;
        boolean m_deleted_attr ;
        bool m_has_xmlBased_attr ;
        boolean m_xmlBased_attr ;

    }

    class CT_CellSmartTagPr : public XSD::ComplexType{
    public:
        void clear(){

                m_has_key_attr = false;
                
        if (m_key_attr)
        {
            delete m_key_attr;
            m_key_attr = NULL;
        }
    
            
                m_has_val_attr = false;
                
        if (m_val_attr)
        {
            delete m_val_attr;
            m_val_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_key_attr->toXml(_attrName, _outStream);
m_val_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CellSmartTagPr& default_instance(){

    if (!CT_CellSmartTagPr::default_instance_)
    {
        CT_CellSmartTagPr::default_instance_ = new CT_CellSmartTagPr();
    }
    return *CT_CellSmartTagPr::default_instance_;

        }
        bool has_key_attr(){

            return m_has_key_attr;
        
        }
        void set_key_attr(const ns_s::ST_Xstring& _key_attr ){

            m_has_key_attr = true;
            m_key_attr = new ns_s::ST_Xstring(_key_attr);
        
        }
        const ns_s::ST_Xstring& key_attr(){

            if (m_key_attr)
            {
                return *m_key_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_val_attr(){

            return m_has_val_attr;
        
        }
        void set_val_attr(const ns_s::ST_Xstring& _val_attr ){

            m_has_val_attr = true;
            m_val_attr = new ns_s::ST_Xstring(_val_attr);
        
        }
        const ns_s::ST_Xstring& val_attr(){

            if (m_val_attr)
            {
                return *m_val_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }

    private:
        static CT_CellSmartTagPr* default_instance_ ;
        bool m_has_key_attr ;
        ns_s::ST_Xstring* m_key_attr ;
        bool m_has_val_attr ;
        ns_s::ST_Xstring* m_val_attr ;

    }

    class CT_Drawing : public XSD::ComplexType{
    public:
        void clear(){

                m_has_id_attr = false;
                
        if (m_id_attr)
        {
            delete m_id_attr;
            m_id_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_id_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Drawing& default_instance(){

    if (!CT_Drawing::default_instance_)
    {
        CT_Drawing::default_instance_ = new CT_Drawing();
    }
    return *CT_Drawing::default_instance_;

        }
        bool has_id_attr(){

            return m_has_id_attr;
        
        }
        void set_id_attr(const ST_RelationshipId& _id_attr ){

            m_has_id_attr = true;
            m_id_attr = new ST_RelationshipId(_id_attr);
        
        }
        const ST_RelationshipId& id_attr(){

            if (m_id_attr)
            {
                return *m_id_attr;
            }
            return ST_RelationshipId::default_instance();
        
        }

    private:
        static CT_Drawing* default_instance_ ;
        bool m_has_id_attr ;
        ST_RelationshipId* m_id_attr ;

    }

    class CT_LegacyDrawing : public XSD::ComplexType{
    public:
        void clear(){

                m_has_id_attr = false;
                
        if (m_id_attr)
        {
            delete m_id_attr;
            m_id_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_id_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_LegacyDrawing& default_instance(){

    if (!CT_LegacyDrawing::default_instance_)
    {
        CT_LegacyDrawing::default_instance_ = new CT_LegacyDrawing();
    }
    return *CT_LegacyDrawing::default_instance_;

        }
        bool has_id_attr(){

            return m_has_id_attr;
        
        }
        void set_id_attr(const ST_RelationshipId& _id_attr ){

            m_has_id_attr = true;
            m_id_attr = new ST_RelationshipId(_id_attr);
        
        }
        const ST_RelationshipId& id_attr(){

            if (m_id_attr)
            {
                return *m_id_attr;
            }
            return ST_RelationshipId::default_instance();
        
        }

    private:
        static CT_LegacyDrawing* default_instance_ ;
        bool m_has_id_attr ;
        ST_RelationshipId* m_id_attr ;

    }

    class CT_DrawingHF : public XSD::ComplexType{
    public:
        void clear(){

                m_has_id_attr = false;
                
        if (m_id_attr)
        {
            delete m_id_attr;
            m_id_attr = NULL;
        }
    
            
                m_has_lho_attr = false;
                m_lho_attr = 0;
            
                m_has_lhe_attr = false;
                m_lhe_attr = 0;
            
                m_has_lhf_attr = false;
                m_lhf_attr = 0;
            
                m_has_cho_attr = false;
                m_cho_attr = 0;
            
                m_has_che_attr = false;
                m_che_attr = 0;
            
                m_has_chf_attr = false;
                m_chf_attr = 0;
            
                m_has_rho_attr = false;
                m_rho_attr = 0;
            
                m_has_rhe_attr = false;
                m_rhe_attr = 0;
            
                m_has_rhf_attr = false;
                m_rhf_attr = 0;
            
                m_has_lfo_attr = false;
                m_lfo_attr = 0;
            
                m_has_lfe_attr = false;
                m_lfe_attr = 0;
            
                m_has_lff_attr = false;
                m_lff_attr = 0;
            
                m_has_cfo_attr = false;
                m_cfo_attr = 0;
            
                m_has_cfe_attr = false;
                m_cfe_attr = 0;
            
                m_has_cff_attr = false;
                m_cff_attr = 0;
            
                m_has_rfo_attr = false;
                m_rfo_attr = 0;
            
                m_has_rfe_attr = false;
                m_rfe_attr = 0;
            
                m_has_rff_attr = false;
                m_rff_attr = 0;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_id_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_lho_attr << \\\;
_outStream << _attrName << \=\\ << m_lhe_attr << \\\;
_outStream << _attrName << \=\\ << m_lhf_attr << \\\;
_outStream << _attrName << \=\\ << m_cho_attr << \\\;
_outStream << _attrName << \=\\ << m_che_attr << \\\;
_outStream << _attrName << \=\\ << m_chf_attr << \\\;
_outStream << _attrName << \=\\ << m_rho_attr << \\\;
_outStream << _attrName << \=\\ << m_rhe_attr << \\\;
_outStream << _attrName << \=\\ << m_rhf_attr << \\\;
_outStream << _attrName << \=\\ << m_lfo_attr << \\\;
_outStream << _attrName << \=\\ << m_lfe_attr << \\\;
_outStream << _attrName << \=\\ << m_lff_attr << \\\;
_outStream << _attrName << \=\\ << m_cfo_attr << \\\;
_outStream << _attrName << \=\\ << m_cfe_attr << \\\;
_outStream << _attrName << \=\\ << m_cff_attr << \\\;
_outStream << _attrName << \=\\ << m_rfo_attr << \\\;
_outStream << _attrName << \=\\ << m_rfe_attr << \\\;
_outStream << _attrName << \=\\ << m_rff_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_DrawingHF& default_instance(){

    if (!CT_DrawingHF::default_instance_)
    {
        CT_DrawingHF::default_instance_ = new CT_DrawingHF();
    }
    return *CT_DrawingHF::default_instance_;

        }
        bool has_id_attr(){

            return m_has_id_attr;
        
        }
        void set_id_attr(const ST_RelationshipId& _id_attr ){

            m_has_id_attr = true;
            m_id_attr = new ST_RelationshipId(_id_attr);
        
        }
        const ST_RelationshipId& id_attr(){

            if (m_id_attr)
            {
                return *m_id_attr;
            }
            return ST_RelationshipId::default_instance();
        
        }
        bool has_lho_attr(){

            return m_has_lho_attr;
        
        }
        void set_lho_attr(const unsignedInt& _lho_attr ){

        m_has_lho_attr = true;
        m_lho_attr = _lho_attr;
        
        }
        const unsignedInt& lho_attr(){

            return type: \unsignedInt\nname: \m_lho_attr\n;
        
        }
        bool has_lhe_attr(){

            return m_has_lhe_attr;
        
        }
        void set_lhe_attr(const unsignedInt& _lhe_attr ){

        m_has_lhe_attr = true;
        m_lhe_attr = _lhe_attr;
        
        }
        const unsignedInt& lhe_attr(){

            return type: \unsignedInt\nname: \m_lhe_attr\n;
        
        }
        bool has_lhf_attr(){

            return m_has_lhf_attr;
        
        }
        void set_lhf_attr(const unsignedInt& _lhf_attr ){

        m_has_lhf_attr = true;
        m_lhf_attr = _lhf_attr;
        
        }
        const unsignedInt& lhf_attr(){

            return type: \unsignedInt\nname: \m_lhf_attr\n;
        
        }
        bool has_cho_attr(){

            return m_has_cho_attr;
        
        }
        void set_cho_attr(const unsignedInt& _cho_attr ){

        m_has_cho_attr = true;
        m_cho_attr = _cho_attr;
        
        }
        const unsignedInt& cho_attr(){

            return type: \unsignedInt\nname: \m_cho_attr\n;
        
        }
        bool has_che_attr(){

            return m_has_che_attr;
        
        }
        void set_che_attr(const unsignedInt& _che_attr ){

        m_has_che_attr = true;
        m_che_attr = _che_attr;
        
        }
        const unsignedInt& che_attr(){

            return type: \unsignedInt\nname: \m_che_attr\n;
        
        }
        bool has_chf_attr(){

            return m_has_chf_attr;
        
        }
        void set_chf_attr(const unsignedInt& _chf_attr ){

        m_has_chf_attr = true;
        m_chf_attr = _chf_attr;
        
        }
        const unsignedInt& chf_attr(){

            return type: \unsignedInt\nname: \m_chf_attr\n;
        
        }
        bool has_rho_attr(){

            return m_has_rho_attr;
        
        }
        void set_rho_attr(const unsignedInt& _rho_attr ){

        m_has_rho_attr = true;
        m_rho_attr = _rho_attr;
        
        }
        const unsignedInt& rho_attr(){

            return type: \unsignedInt\nname: \m_rho_attr\n;
        
        }
        bool has_rhe_attr(){

            return m_has_rhe_attr;
        
        }
        void set_rhe_attr(const unsignedInt& _rhe_attr ){

        m_has_rhe_attr = true;
        m_rhe_attr = _rhe_attr;
        
        }
        const unsignedInt& rhe_attr(){

            return type: \unsignedInt\nname: \m_rhe_attr\n;
        
        }
        bool has_rhf_attr(){

            return m_has_rhf_attr;
        
        }
        void set_rhf_attr(const unsignedInt& _rhf_attr ){

        m_has_rhf_attr = true;
        m_rhf_attr = _rhf_attr;
        
        }
        const unsignedInt& rhf_attr(){

            return type: \unsignedInt\nname: \m_rhf_attr\n;
        
        }
        bool has_lfo_attr(){

            return m_has_lfo_attr;
        
        }
        void set_lfo_attr(const unsignedInt& _lfo_attr ){

        m_has_lfo_attr = true;
        m_lfo_attr = _lfo_attr;
        
        }
        const unsignedInt& lfo_attr(){

            return type: \unsignedInt\nname: \m_lfo_attr\n;
        
        }
        bool has_lfe_attr(){

            return m_has_lfe_attr;
        
        }
        void set_lfe_attr(const unsignedInt& _lfe_attr ){

        m_has_lfe_attr = true;
        m_lfe_attr = _lfe_attr;
        
        }
        const unsignedInt& lfe_attr(){

            return type: \unsignedInt\nname: \m_lfe_attr\n;
        
        }
        bool has_lff_attr(){

            return m_has_lff_attr;
        
        }
        void set_lff_attr(const unsignedInt& _lff_attr ){

        m_has_lff_attr = true;
        m_lff_attr = _lff_attr;
        
        }
        const unsignedInt& lff_attr(){

            return type: \unsignedInt\nname: \m_lff_attr\n;
        
        }
        bool has_cfo_attr(){

            return m_has_cfo_attr;
        
        }
        void set_cfo_attr(const unsignedInt& _cfo_attr ){

        m_has_cfo_attr = true;
        m_cfo_attr = _cfo_attr;
        
        }
        const unsignedInt& cfo_attr(){

            return type: \unsignedInt\nname: \m_cfo_attr\n;
        
        }
        bool has_cfe_attr(){

            return m_has_cfe_attr;
        
        }
        void set_cfe_attr(const unsignedInt& _cfe_attr ){

        m_has_cfe_attr = true;
        m_cfe_attr = _cfe_attr;
        
        }
        const unsignedInt& cfe_attr(){

            return type: \unsignedInt\nname: \m_cfe_attr\n;
        
        }
        bool has_cff_attr(){

            return m_has_cff_attr;
        
        }
        void set_cff_attr(const unsignedInt& _cff_attr ){

        m_has_cff_attr = true;
        m_cff_attr = _cff_attr;
        
        }
        const unsignedInt& cff_attr(){

            return type: \unsignedInt\nname: \m_cff_attr\n;
        
        }
        bool has_rfo_attr(){

            return m_has_rfo_attr;
        
        }
        void set_rfo_attr(const unsignedInt& _rfo_attr ){

        m_has_rfo_attr = true;
        m_rfo_attr = _rfo_attr;
        
        }
        const unsignedInt& rfo_attr(){

            return type: \unsignedInt\nname: \m_rfo_attr\n;
        
        }
        bool has_rfe_attr(){

            return m_has_rfe_attr;
        
        }
        void set_rfe_attr(const unsignedInt& _rfe_attr ){

        m_has_rfe_attr = true;
        m_rfe_attr = _rfe_attr;
        
        }
        const unsignedInt& rfe_attr(){

            return type: \unsignedInt\nname: \m_rfe_attr\n;
        
        }
        bool has_rff_attr(){

            return m_has_rff_attr;
        
        }
        void set_rff_attr(const unsignedInt& _rff_attr ){

        m_has_rff_attr = true;
        m_rff_attr = _rff_attr;
        
        }
        const unsignedInt& rff_attr(){

            return type: \unsignedInt\nname: \m_rff_attr\n;
        
        }

    private:
        static CT_DrawingHF* default_instance_ ;
        bool m_has_id_attr ;
        ST_RelationshipId* m_id_attr ;
        bool m_has_lho_attr ;
        unsignedInt m_lho_attr ;
        bool m_has_lhe_attr ;
        unsignedInt m_lhe_attr ;
        bool m_has_lhf_attr ;
        unsignedInt m_lhf_attr ;
        bool m_has_cho_attr ;
        unsignedInt m_cho_attr ;
        bool m_has_che_attr ;
        unsignedInt m_che_attr ;
        bool m_has_chf_attr ;
        unsignedInt m_chf_attr ;
        bool m_has_rho_attr ;
        unsignedInt m_rho_attr ;
        bool m_has_rhe_attr ;
        unsignedInt m_rhe_attr ;
        bool m_has_rhf_attr ;
        unsignedInt m_rhf_attr ;
        bool m_has_lfo_attr ;
        unsignedInt m_lfo_attr ;
        bool m_has_lfe_attr ;
        unsignedInt m_lfe_attr ;
        bool m_has_lff_attr ;
        unsignedInt m_lff_attr ;
        bool m_has_cfo_attr ;
        unsignedInt m_cfo_attr ;
        bool m_has_cfe_attr ;
        unsignedInt m_cfe_attr ;
        bool m_has_cff_attr ;
        unsignedInt m_cff_attr ;
        bool m_has_rfo_attr ;
        unsignedInt m_rfo_attr ;
        bool m_has_rfe_attr ;
        unsignedInt m_rfe_attr ;
        bool m_has_rff_attr ;
        unsignedInt m_rff_attr ;

    }

    class CT_CustomSheetViews : public XSD::ComplexType{
    public:
        bool has_customSheetView(){

            return m_has_customSheetView;
        
        }
        CT_CustomSheetView* mutable_customSheetView(){

                m_has_customSheetView = true;
                if (!m_customSheetView)
                {
                    m_customSheetView = new CT_CustomSheetView();
                }
                return m_customSheetView;
            
        }
        const CT_CustomSheetView& customSheetView(){

            if (m_customSheetView)
            {
                return *m_customSheetView;
            }
            return CT_CustomSheetView::default_instance();
        
        }
        void clear(){

                m_has_customSheetView = false;
                
        if (m_customSheetView)
        {
            delete m_customSheetView;
            m_customSheetView = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_customSheetView)
                {
                    m_customSheetView->toXml(customSheetView, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CustomSheetViews& default_instance(){

    if (!CT_CustomSheetViews::default_instance_)
    {
        CT_CustomSheetViews::default_instance_ = new CT_CustomSheetViews();
    }
    return *CT_CustomSheetViews::default_instance_;

        }

    private:
        bool m_has_customSheetView ;
        CT_CustomSheetView* m_customSheetView ;
        static CT_CustomSheetViews* default_instance_ ;

    }

    class CT_CustomSheetView : public XSD::ComplexType{
    public:
        bool has_pane(){

            return m_has_pane;
        
        }
        CT_Pane* mutable_pane(){

                m_has_pane = true;
                if (!m_pane)
                {
                    m_pane = new CT_Pane();
                }
                return m_pane;
            
        }
        const CT_Pane& pane(){

            if (m_pane)
            {
                return *m_pane;
            }
            return CT_Pane::default_instance();
        
        }
        bool has_selection(){

            return m_has_selection;
        
        }
        CT_Selection* mutable_selection(){

                m_has_selection = true;
                if (!m_selection)
                {
                    m_selection = new CT_Selection();
                }
                return m_selection;
            
        }
        const CT_Selection& selection(){

            if (m_selection)
            {
                return *m_selection;
            }
            return CT_Selection::default_instance();
        
        }
        bool has_rowBreaks(){

            return m_has_rowBreaks;
        
        }
        CT_PageBreak* mutable_rowBreaks(){

                m_has_rowBreaks = true;
                if (!m_rowBreaks)
                {
                    m_rowBreaks = new CT_PageBreak();
                }
                return m_rowBreaks;
            
        }
        const CT_PageBreak& rowBreaks(){

            if (m_rowBreaks)
            {
                return *m_rowBreaks;
            }
            return CT_PageBreak::default_instance();
        
        }
        bool has_colBreaks(){

            return m_has_colBreaks;
        
        }
        CT_PageBreak* mutable_colBreaks(){

                m_has_colBreaks = true;
                if (!m_colBreaks)
                {
                    m_colBreaks = new CT_PageBreak();
                }
                return m_colBreaks;
            
        }
        const CT_PageBreak& colBreaks(){

            if (m_colBreaks)
            {
                return *m_colBreaks;
            }
            return CT_PageBreak::default_instance();
        
        }
        bool has_pageMargins(){

            return m_has_pageMargins;
        
        }
        CT_PageMargins* mutable_pageMargins(){

                m_has_pageMargins = true;
                if (!m_pageMargins)
                {
                    m_pageMargins = new CT_PageMargins();
                }
                return m_pageMargins;
            
        }
        const CT_PageMargins& pageMargins(){

            if (m_pageMargins)
            {
                return *m_pageMargins;
            }
            return CT_PageMargins::default_instance();
        
        }
        bool has_printOptions(){

            return m_has_printOptions;
        
        }
        CT_PrintOptions* mutable_printOptions(){

                m_has_printOptions = true;
                if (!m_printOptions)
                {
                    m_printOptions = new CT_PrintOptions();
                }
                return m_printOptions;
            
        }
        const CT_PrintOptions& printOptions(){

            if (m_printOptions)
            {
                return *m_printOptions;
            }
            return CT_PrintOptions::default_instance();
        
        }
        bool has_pageSetup(){

            return m_has_pageSetup;
        
        }
        CT_PageSetup* mutable_pageSetup(){

                m_has_pageSetup = true;
                if (!m_pageSetup)
                {
                    m_pageSetup = new CT_PageSetup();
                }
                return m_pageSetup;
            
        }
        const CT_PageSetup& pageSetup(){

            if (m_pageSetup)
            {
                return *m_pageSetup;
            }
            return CT_PageSetup::default_instance();
        
        }
        bool has_headerFooter(){

            return m_has_headerFooter;
        
        }
        CT_HeaderFooter* mutable_headerFooter(){

                m_has_headerFooter = true;
                if (!m_headerFooter)
                {
                    m_headerFooter = new CT_HeaderFooter();
                }
                return m_headerFooter;
            
        }
        const CT_HeaderFooter& headerFooter(){

            if (m_headerFooter)
            {
                return *m_headerFooter;
            }
            return CT_HeaderFooter::default_instance();
        
        }
        bool has_autoFilter(){

            return m_has_autoFilter;
        
        }
        CT_AutoFilter* mutable_autoFilter(){

                m_has_autoFilter = true;
                if (!m_autoFilter)
                {
                    m_autoFilter = new CT_AutoFilter();
                }
                return m_autoFilter;
            
        }
        const CT_AutoFilter& autoFilter(){

            if (m_autoFilter)
            {
                return *m_autoFilter;
            }
            return CT_AutoFilter::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_guid_attr = false;
                
        if (m_guid_attr)
        {
            delete m_guid_attr;
            m_guid_attr = NULL;
        }
    
            
                m_has_scale_attr = false;
                m_scale_attr = 0;
            
                m_has_colorId_attr = false;
                m_colorId_attr = 0;
            
                m_has_showPageBreaks_attr = false;
                m_showPageBreaks_attr = false;
            
                m_has_showFormulas_attr = false;
                m_showFormulas_attr = false;
            
                m_has_showGridLines_attr = false;
                m_showGridLines_attr = false;
            
                m_has_showRowCol_attr = false;
                m_showRowCol_attr = false;
            
                m_has_outlineSymbols_attr = false;
                m_outlineSymbols_attr = false;
            
                m_has_zeroValues_attr = false;
                m_zeroValues_attr = false;
            
                m_has_fitToPage_attr = false;
                m_fitToPage_attr = false;
            
                m_has_printArea_attr = false;
                m_printArea_attr = false;
            
                m_has_filter_attr = false;
                m_filter_attr = false;
            
                m_has_showAutoFilter_attr = false;
                m_showAutoFilter_attr = false;
            
                m_has_hiddenRows_attr = false;
                m_hiddenRows_attr = false;
            
                m_has_hiddenColumns_attr = false;
                m_hiddenColumns_attr = false;
            
                m_has_state_attr = false;
                
        if (m_state_attr)
        {
            delete m_state_attr;
            m_state_attr = NULL;
        }
    
            
                m_has_filterUnique_attr = false;
                m_filterUnique_attr = false;
            
                m_has_view_attr = false;
                
        if (m_view_attr)
        {
            delete m_view_attr;
            m_view_attr = NULL;
        }
    
            
                m_has_showRuler_attr = false;
                m_showRuler_attr = false;
            
                m_has_topLeftCell_attr = false;
                
        if (m_topLeftCell_attr)
        {
            delete m_topLeftCell_attr;
            m_topLeftCell_attr = NULL;
        }
    
            
                m_has_pane = false;
                
        if (m_pane)
        {
            delete m_pane;
            m_pane = NULL;
        }
    
            
                m_has_selection = false;
                
        if (m_selection)
        {
            delete m_selection;
            m_selection = NULL;
        }
    
            
                m_has_rowBreaks = false;
                
        if (m_rowBreaks)
        {
            delete m_rowBreaks;
            m_rowBreaks = NULL;
        }
    
            
                m_has_colBreaks = false;
                
        if (m_colBreaks)
        {
            delete m_colBreaks;
            m_colBreaks = NULL;
        }
    
            
                m_has_pageMargins = false;
                
        if (m_pageMargins)
        {
            delete m_pageMargins;
            m_pageMargins = NULL;
        }
    
            
                m_has_printOptions = false;
                
        if (m_printOptions)
        {
            delete m_printOptions;
            m_printOptions = NULL;
        }
    
            
                m_has_pageSetup = false;
                
        if (m_pageSetup)
        {
            delete m_pageSetup;
            m_pageSetup = NULL;
        }
    
            
                m_has_headerFooter = false;
                
        if (m_headerFooter)
        {
            delete m_headerFooter;
            m_headerFooter = NULL;
        }
    
            
                m_has_autoFilter = false;
                
        if (m_autoFilter)
        {
            delete m_autoFilter;
            m_autoFilter = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_guid_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_scale_attr << \\\;
_outStream << _attrName << \=\\ << m_colorId_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showPageBreaks_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showFormulas_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showGridLines_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showRowCol_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_outlineSymbols_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_zeroValues_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_fitToPage_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_printArea_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_filter_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showAutoFilter_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_hiddenRows_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_hiddenColumns_attr) << \\\;
m_state_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_filterUnique_attr) << \\\;
m_view_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showRuler_attr) << \\\;
m_topLeftCell_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_pane)
                {
                    m_pane->toXml(pane, _outStream);;
                }
            
                if (m_has_selection)
                {
                    m_pane->toXml(selection, _outStream);;
                }
            
                if (m_has_rowBreaks)
                {
                    m_pane->toXml(rowBreaks, _outStream);;
                }
            
                if (m_has_colBreaks)
                {
                    m_pane->toXml(colBreaks, _outStream);;
                }
            
                if (m_has_pageMargins)
                {
                    m_pane->toXml(pageMargins, _outStream);;
                }
            
                if (m_has_printOptions)
                {
                    m_pane->toXml(printOptions, _outStream);;
                }
            
                if (m_has_pageSetup)
                {
                    m_pane->toXml(pageSetup, _outStream);;
                }
            
                if (m_has_headerFooter)
                {
                    m_pane->toXml(headerFooter, _outStream);;
                }
            
                if (m_has_autoFilter)
                {
                    m_pane->toXml(autoFilter, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_pane->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CustomSheetView& default_instance(){

    if (!CT_CustomSheetView::default_instance_)
    {
        CT_CustomSheetView::default_instance_ = new CT_CustomSheetView();
    }
    return *CT_CustomSheetView::default_instance_;

        }
        bool has_guid_attr(){

            return m_has_guid_attr;
        
        }
        void set_guid_attr(const ns_s::ST_Guid& _guid_attr ){

            m_has_guid_attr = true;
            m_guid_attr = new ns_s::ST_Guid(_guid_attr);
        
        }
        const ns_s::ST_Guid& guid_attr(){

            if (m_guid_attr)
            {
                return *m_guid_attr;
            }
            return ns_s::ST_Guid::default_instance();
        
        }
        bool has_scale_attr(){

            return m_has_scale_attr;
        
        }
        void set_scale_attr(const unsignedInt& _scale_attr ){

        m_has_scale_attr = true;
        m_scale_attr = _scale_attr;
        
        }
        const unsignedInt& scale_attr(){

            return type: \unsignedInt\nname: \m_scale_attr\n;
        
        }
        bool has_colorId_attr(){

            return m_has_colorId_attr;
        
        }
        void set_colorId_attr(const unsignedInt& _colorId_attr ){

        m_has_colorId_attr = true;
        m_colorId_attr = _colorId_attr;
        
        }
        const unsignedInt& colorId_attr(){

            return type: \unsignedInt\nname: \m_colorId_attr\n;
        
        }
        bool has_showPageBreaks_attr(){

            return m_has_showPageBreaks_attr;
        
        }
        void set_showPageBreaks_attr(const boolean& _showPageBreaks_attr ){

        m_has_showPageBreaks_attr = true;
        m_showPageBreaks_attr = _showPageBreaks_attr;
        
        }
        const boolean& showPageBreaks_attr(){

            return type: oolean\nname: \m_showPageBreaks_attr\n;
        
        }
        bool has_showFormulas_attr(){

            return m_has_showFormulas_attr;
        
        }
        void set_showFormulas_attr(const boolean& _showFormulas_attr ){

        m_has_showFormulas_attr = true;
        m_showFormulas_attr = _showFormulas_attr;
        
        }
        const boolean& showFormulas_attr(){

            return type: oolean\nname: \m_showFormulas_attr\n;
        
        }
        bool has_showGridLines_attr(){

            return m_has_showGridLines_attr;
        
        }
        void set_showGridLines_attr(const boolean& _showGridLines_attr ){

        m_has_showGridLines_attr = true;
        m_showGridLines_attr = _showGridLines_attr;
        
        }
        const boolean& showGridLines_attr(){

            return type: oolean\nname: \m_showGridLines_attr\n;
        
        }
        bool has_showRowCol_attr(){

            return m_has_showRowCol_attr;
        
        }
        void set_showRowCol_attr(const boolean& _showRowCol_attr ){

        m_has_showRowCol_attr = true;
        m_showRowCol_attr = _showRowCol_attr;
        
        }
        const boolean& showRowCol_attr(){

            return type: oolean\nname: \m_showRowCol_attr\n;
        
        }
        bool has_outlineSymbols_attr(){

            return m_has_outlineSymbols_attr;
        
        }
        void set_outlineSymbols_attr(const boolean& _outlineSymbols_attr ){

        m_has_outlineSymbols_attr = true;
        m_outlineSymbols_attr = _outlineSymbols_attr;
        
        }
        const boolean& outlineSymbols_attr(){

            return type: oolean\nname: \m_outlineSymbols_attr\n;
        
        }
        bool has_zeroValues_attr(){

            return m_has_zeroValues_attr;
        
        }
        void set_zeroValues_attr(const boolean& _zeroValues_attr ){

        m_has_zeroValues_attr = true;
        m_zeroValues_attr = _zeroValues_attr;
        
        }
        const boolean& zeroValues_attr(){

            return type: oolean\nname: \m_zeroValues_attr\n;
        
        }
        bool has_fitToPage_attr(){

            return m_has_fitToPage_attr;
        
        }
        void set_fitToPage_attr(const boolean& _fitToPage_attr ){

        m_has_fitToPage_attr = true;
        m_fitToPage_attr = _fitToPage_attr;
        
        }
        const boolean& fitToPage_attr(){

            return type: oolean\nname: \m_fitToPage_attr\n;
        
        }
        bool has_printArea_attr(){

            return m_has_printArea_attr;
        
        }
        void set_printArea_attr(const boolean& _printArea_attr ){

        m_has_printArea_attr = true;
        m_printArea_attr = _printArea_attr;
        
        }
        const boolean& printArea_attr(){

            return type: oolean\nname: \m_printArea_attr\n;
        
        }
        bool has_filter_attr(){

            return m_has_filter_attr;
        
        }
        void set_filter_attr(const boolean& _filter_attr ){

        m_has_filter_attr = true;
        m_filter_attr = _filter_attr;
        
        }
        const boolean& filter_attr(){

            return type: oolean\nname: \m_filter_attr\n;
        
        }
        bool has_showAutoFilter_attr(){

            return m_has_showAutoFilter_attr;
        
        }
        void set_showAutoFilter_attr(const boolean& _showAutoFilter_attr ){

        m_has_showAutoFilter_attr = true;
        m_showAutoFilter_attr = _showAutoFilter_attr;
        
        }
        const boolean& showAutoFilter_attr(){

            return type: oolean\nname: \m_showAutoFilter_attr\n;
        
        }
        bool has_hiddenRows_attr(){

            return m_has_hiddenRows_attr;
        
        }
        void set_hiddenRows_attr(const boolean& _hiddenRows_attr ){

        m_has_hiddenRows_attr = true;
        m_hiddenRows_attr = _hiddenRows_attr;
        
        }
        const boolean& hiddenRows_attr(){

            return type: oolean\nname: \m_hiddenRows_attr\n;
        
        }
        bool has_hiddenColumns_attr(){

            return m_has_hiddenColumns_attr;
        
        }
        void set_hiddenColumns_attr(const boolean& _hiddenColumns_attr ){

        m_has_hiddenColumns_attr = true;
        m_hiddenColumns_attr = _hiddenColumns_attr;
        
        }
        const boolean& hiddenColumns_attr(){

            return type: oolean\nname: \m_hiddenColumns_attr\n;
        
        }
        bool has_state_attr(){

            return m_has_state_attr;
        
        }
        void set_state_attr(const ST_SheetState& _state_attr ){

            m_has_state_attr = true;
            m_state_attr = new ST_SheetState(_state_attr);
        
        }
        const ST_SheetState& state_attr(){

            if (m_state_attr)
            {
                return *m_state_attr;
            }
            return ST_SheetState::default_instance();
        
        }
        bool has_filterUnique_attr(){

            return m_has_filterUnique_attr;
        
        }
        void set_filterUnique_attr(const boolean& _filterUnique_attr ){

        m_has_filterUnique_attr = true;
        m_filterUnique_attr = _filterUnique_attr;
        
        }
        const boolean& filterUnique_attr(){

            return type: oolean\nname: \m_filterUnique_attr\n;
        
        }
        bool has_view_attr(){

            return m_has_view_attr;
        
        }
        void set_view_attr(const ST_SheetViewType& _view_attr ){

            m_has_view_attr = true;
            m_view_attr = new ST_SheetViewType(_view_attr);
        
        }
        const ST_SheetViewType& view_attr(){

            if (m_view_attr)
            {
                return *m_view_attr;
            }
            return ST_SheetViewType::default_instance();
        
        }
        bool has_showRuler_attr(){

            return m_has_showRuler_attr;
        
        }
        void set_showRuler_attr(const boolean& _showRuler_attr ){

        m_has_showRuler_attr = true;
        m_showRuler_attr = _showRuler_attr;
        
        }
        const boolean& showRuler_attr(){

            return type: oolean\nname: \m_showRuler_attr\n;
        
        }
        bool has_topLeftCell_attr(){

            return m_has_topLeftCell_attr;
        
        }
        void set_topLeftCell_attr(const ST_CellRef& _topLeftCell_attr ){

            m_has_topLeftCell_attr = true;
            m_topLeftCell_attr = new ST_CellRef(_topLeftCell_attr);
        
        }
        const ST_CellRef& topLeftCell_attr(){

            if (m_topLeftCell_attr)
            {
                return *m_topLeftCell_attr;
            }
            return ST_CellRef::default_instance();
        
        }

    private:
        bool m_has_pane ;
        CT_Pane* m_pane ;
        bool m_has_selection ;
        CT_Selection* m_selection ;
        bool m_has_rowBreaks ;
        CT_PageBreak* m_rowBreaks ;
        bool m_has_colBreaks ;
        CT_PageBreak* m_colBreaks ;
        bool m_has_pageMargins ;
        CT_PageMargins* m_pageMargins ;
        bool m_has_printOptions ;
        CT_PrintOptions* m_printOptions ;
        bool m_has_pageSetup ;
        CT_PageSetup* m_pageSetup ;
        bool m_has_headerFooter ;
        CT_HeaderFooter* m_headerFooter ;
        bool m_has_autoFilter ;
        CT_AutoFilter* m_autoFilter ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_CustomSheetView* default_instance_ ;
        bool m_has_guid_attr ;
        ns_s::ST_Guid* m_guid_attr ;
        bool m_has_scale_attr ;
        unsignedInt m_scale_attr ;
        bool m_has_colorId_attr ;
        unsignedInt m_colorId_attr ;
        bool m_has_showPageBreaks_attr ;
        boolean m_showPageBreaks_attr ;
        bool m_has_showFormulas_attr ;
        boolean m_showFormulas_attr ;
        bool m_has_showGridLines_attr ;
        boolean m_showGridLines_attr ;
        bool m_has_showRowCol_attr ;
        boolean m_showRowCol_attr ;
        bool m_has_outlineSymbols_attr ;
        boolean m_outlineSymbols_attr ;
        bool m_has_zeroValues_attr ;
        boolean m_zeroValues_attr ;
        bool m_has_fitToPage_attr ;
        boolean m_fitToPage_attr ;
        bool m_has_printArea_attr ;
        boolean m_printArea_attr ;
        bool m_has_filter_attr ;
        boolean m_filter_attr ;
        bool m_has_showAutoFilter_attr ;
        boolean m_showAutoFilter_attr ;
        bool m_has_hiddenRows_attr ;
        boolean m_hiddenRows_attr ;
        bool m_has_hiddenColumns_attr ;
        boolean m_hiddenColumns_attr ;
        bool m_has_state_attr ;
        ST_SheetState* m_state_attr ;
        bool m_has_filterUnique_attr ;
        boolean m_filterUnique_attr ;
        bool m_has_view_attr ;
        ST_SheetViewType* m_view_attr ;
        bool m_has_showRuler_attr ;
        boolean m_showRuler_attr ;
        bool m_has_topLeftCell_attr ;
        ST_CellRef* m_topLeftCell_attr ;

    }

    class CT_DataValidations : public XSD::ComplexType{
    public:
        bool has_dataValidation(){

            return m_has_dataValidation;
        
        }
        CT_DataValidation* mutable_dataValidation(){

                m_has_dataValidation = true;
                if (!m_dataValidation)
                {
                    m_dataValidation = new CT_DataValidation();
                }
                return m_dataValidation;
            
        }
        const CT_DataValidation& dataValidation(){

            if (m_dataValidation)
            {
                return *m_dataValidation;
            }
            return CT_DataValidation::default_instance();
        
        }
        void clear(){

                m_has_disablePrompts_attr = false;
                m_disablePrompts_attr = false;
            
                m_has_xWindow_attr = false;
                m_xWindow_attr = 0;
            
                m_has_yWindow_attr = false;
                m_yWindow_attr = 0;
            
                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_dataValidation = false;
                
        if (m_dataValidation)
        {
            delete m_dataValidation;
            m_dataValidation = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_disablePrompts_attr) << \\\;
_outStream << _attrName << \=\\ << m_xWindow_attr << \\\;
_outStream << _attrName << \=\\ << m_yWindow_attr << \\\;
_outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_dataValidation)
                {
                    m_dataValidation->toXml(dataValidation, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_DataValidations& default_instance(){

    if (!CT_DataValidations::default_instance_)
    {
        CT_DataValidations::default_instance_ = new CT_DataValidations();
    }
    return *CT_DataValidations::default_instance_;

        }
        bool has_disablePrompts_attr(){

            return m_has_disablePrompts_attr;
        
        }
        void set_disablePrompts_attr(const boolean& _disablePrompts_attr ){

        m_has_disablePrompts_attr = true;
        m_disablePrompts_attr = _disablePrompts_attr;
        
        }
        const boolean& disablePrompts_attr(){

            return type: oolean\nname: \m_disablePrompts_attr\n;
        
        }
        bool has_xWindow_attr(){

            return m_has_xWindow_attr;
        
        }
        void set_xWindow_attr(const unsignedInt& _xWindow_attr ){

        m_has_xWindow_attr = true;
        m_xWindow_attr = _xWindow_attr;
        
        }
        const unsignedInt& xWindow_attr(){

            return type: \unsignedInt\nname: \m_xWindow_attr\n;
        
        }
        bool has_yWindow_attr(){

            return m_has_yWindow_attr;
        
        }
        void set_yWindow_attr(const unsignedInt& _yWindow_attr ){

        m_has_yWindow_attr = true;
        m_yWindow_attr = _yWindow_attr;
        
        }
        const unsignedInt& yWindow_attr(){

            return type: \unsignedInt\nname: \m_yWindow_attr\n;
        
        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_dataValidation ;
        CT_DataValidation* m_dataValidation ;
        static CT_DataValidations* default_instance_ ;
        bool m_has_disablePrompts_attr ;
        boolean m_disablePrompts_attr ;
        bool m_has_xWindow_attr ;
        unsignedInt m_xWindow_attr ;
        bool m_has_yWindow_attr ;
        unsignedInt m_yWindow_attr ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_DataValidation : public XSD::ComplexType{
    public:
        bool has_formula1(){

            return m_has_formula1;
        
        }
        ST_Formula* mutable_formula1(){

                m_has_formula1 = true;
                if (!m_formula1)
                {
                    m_formula1 = new ST_Formula();
                }
                return m_formula1;
            
        }
        const ST_Formula& formula1(){

            if (m_formula1)
            {
                return *m_formula1;
            }
            return ST_Formula::default_instance();
        
        }
        bool has_formula2(){

            return m_has_formula2;
        
        }
        ST_Formula* mutable_formula2(){

                m_has_formula2 = true;
                if (!m_formula2)
                {
                    m_formula2 = new ST_Formula();
                }
                return m_formula2;
            
        }
        const ST_Formula& formula2(){

            if (m_formula2)
            {
                return *m_formula2;
            }
            return ST_Formula::default_instance();
        
        }
        void clear(){

                m_has_type_attr = false;
                
        if (m_type_attr)
        {
            delete m_type_attr;
            m_type_attr = NULL;
        }
    
            
                m_has_errorStyle_attr = false;
                
        if (m_errorStyle_attr)
        {
            delete m_errorStyle_attr;
            m_errorStyle_attr = NULL;
        }
    
            
                m_has_imeMode_attr = false;
                
        if (m_imeMode_attr)
        {
            delete m_imeMode_attr;
            m_imeMode_attr = NULL;
        }
    
            
                m_has_operator_attr = false;
                
        if (m_operator_attr)
        {
            delete m_operator_attr;
            m_operator_attr = NULL;
        }
    
            
                m_has_allowBlank_attr = false;
                m_allowBlank_attr = false;
            
                m_has_showDropDown_attr = false;
                m_showDropDown_attr = false;
            
                m_has_showInputMessage_attr = false;
                m_showInputMessage_attr = false;
            
                m_has_showErrorMessage_attr = false;
                m_showErrorMessage_attr = false;
            
                m_has_errorTitle_attr = false;
                
        if (m_errorTitle_attr)
        {
            delete m_errorTitle_attr;
            m_errorTitle_attr = NULL;
        }
    
            
                m_has_error_attr = false;
                
        if (m_error_attr)
        {
            delete m_error_attr;
            m_error_attr = NULL;
        }
    
            
                m_has_promptTitle_attr = false;
                
        if (m_promptTitle_attr)
        {
            delete m_promptTitle_attr;
            m_promptTitle_attr = NULL;
        }
    
            
                m_has_prompt_attr = false;
                
        if (m_prompt_attr)
        {
            delete m_prompt_attr;
            m_prompt_attr = NULL;
        }
    
            
                m_has_sqref_attr = false;
                
        if (m_sqref_attr)
        {
            delete m_sqref_attr;
            m_sqref_attr = NULL;
        }
    
            
                m_has_formula1 = false;
                
        if (m_formula1)
        {
            delete m_formula1;
            m_formula1 = NULL;
        }
    
            
                m_has_formula2 = false;
                
        if (m_formula2)
        {
            delete m_formula2;
            m_formula2 = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_type_attr->toXml(_attrName, _outStream);
m_errorStyle_attr->toXml(_attrName, _outStream);
m_imeMode_attr->toXml(_attrName, _outStream);
m_operator_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_allowBlank_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showDropDown_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showInputMessage_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showErrorMessage_attr) << \\\;
m_errorTitle_attr->toXml(_attrName, _outStream);
m_error_attr->toXml(_attrName, _outStream);
m_promptTitle_attr->toXml(_attrName, _outStream);
m_prompt_attr->toXml(_attrName, _outStream);
m_sqref_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_formula1)
                {
                    _outStream << \<formula1>\ << m_formula1->toString() << \</formula1>\;;
                }
            
                if (m_has_formula2)
                {
                    _outStream << \<formula2>\ << m_formula1->toString() << \</formula2>\;;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_DataValidation& default_instance(){

    if (!CT_DataValidation::default_instance_)
    {
        CT_DataValidation::default_instance_ = new CT_DataValidation();
    }
    return *CT_DataValidation::default_instance_;

        }
        bool has_type_attr(){

            return m_has_type_attr;
        
        }
        void set_type_attr(const ST_DataValidationType& _type_attr ){

            m_has_type_attr = true;
            m_type_attr = new ST_DataValidationType(_type_attr);
        
        }
        const ST_DataValidationType& type_attr(){

            if (m_type_attr)
            {
                return *m_type_attr;
            }
            return ST_DataValidationType::default_instance();
        
        }
        bool has_errorStyle_attr(){

            return m_has_errorStyle_attr;
        
        }
        void set_errorStyle_attr(const ST_DataValidationErrorStyle& _errorStyle_attr ){

            m_has_errorStyle_attr = true;
            m_errorStyle_attr = new ST_DataValidationErrorStyle(_errorStyle_attr);
        
        }
        const ST_DataValidationErrorStyle& errorStyle_attr(){

            if (m_errorStyle_attr)
            {
                return *m_errorStyle_attr;
            }
            return ST_DataValidationErrorStyle::default_instance();
        
        }
        bool has_imeMode_attr(){

            return m_has_imeMode_attr;
        
        }
        void set_imeMode_attr(const ST_DataValidationImeMode& _imeMode_attr ){

            m_has_imeMode_attr = true;
            m_imeMode_attr = new ST_DataValidationImeMode(_imeMode_attr);
        
        }
        const ST_DataValidationImeMode& imeMode_attr(){

            if (m_imeMode_attr)
            {
                return *m_imeMode_attr;
            }
            return ST_DataValidationImeMode::default_instance();
        
        }
        bool has_operator_attr(){

            return m_has_operator_attr;
        
        }
        void set_operator_attr(const ST_DataValidationOperator& _operator_attr ){

            m_has_operator_attr = true;
            m_operator_attr = new ST_DataValidationOperator(_operator_attr);
        
        }
        const ST_DataValidationOperator& operator_attr(){

            if (m_operator_attr)
            {
                return *m_operator_attr;
            }
            return ST_DataValidationOperator::default_instance();
        
        }
        bool has_allowBlank_attr(){

            return m_has_allowBlank_attr;
        
        }
        void set_allowBlank_attr(const boolean& _allowBlank_attr ){

        m_has_allowBlank_attr = true;
        m_allowBlank_attr = _allowBlank_attr;
        
        }
        const boolean& allowBlank_attr(){

            return type: oolean\nname: \m_allowBlank_attr\n;
        
        }
        bool has_showDropDown_attr(){

            return m_has_showDropDown_attr;
        
        }
        void set_showDropDown_attr(const boolean& _showDropDown_attr ){

        m_has_showDropDown_attr = true;
        m_showDropDown_attr = _showDropDown_attr;
        
        }
        const boolean& showDropDown_attr(){

            return type: oolean\nname: \m_showDropDown_attr\n;
        
        }
        bool has_showInputMessage_attr(){

            return m_has_showInputMessage_attr;
        
        }
        void set_showInputMessage_attr(const boolean& _showInputMessage_attr ){

        m_has_showInputMessage_attr = true;
        m_showInputMessage_attr = _showInputMessage_attr;
        
        }
        const boolean& showInputMessage_attr(){

            return type: oolean\nname: \m_showInputMessage_attr\n;
        
        }
        bool has_showErrorMessage_attr(){

            return m_has_showErrorMessage_attr;
        
        }
        void set_showErrorMessage_attr(const boolean& _showErrorMessage_attr ){

        m_has_showErrorMessage_attr = true;
        m_showErrorMessage_attr = _showErrorMessage_attr;
        
        }
        const boolean& showErrorMessage_attr(){

            return type: oolean\nname: \m_showErrorMessage_attr\n;
        
        }
        bool has_errorTitle_attr(){

            return m_has_errorTitle_attr;
        
        }
        void set_errorTitle_attr(const ns_s::ST_Xstring& _errorTitle_attr ){

            m_has_errorTitle_attr = true;
            m_errorTitle_attr = new ns_s::ST_Xstring(_errorTitle_attr);
        
        }
        const ns_s::ST_Xstring& errorTitle_attr(){

            if (m_errorTitle_attr)
            {
                return *m_errorTitle_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_error_attr(){

            return m_has_error_attr;
        
        }
        void set_error_attr(const ns_s::ST_Xstring& _error_attr ){

            m_has_error_attr = true;
            m_error_attr = new ns_s::ST_Xstring(_error_attr);
        
        }
        const ns_s::ST_Xstring& error_attr(){

            if (m_error_attr)
            {
                return *m_error_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_promptTitle_attr(){

            return m_has_promptTitle_attr;
        
        }
        void set_promptTitle_attr(const ns_s::ST_Xstring& _promptTitle_attr ){

            m_has_promptTitle_attr = true;
            m_promptTitle_attr = new ns_s::ST_Xstring(_promptTitle_attr);
        
        }
        const ns_s::ST_Xstring& promptTitle_attr(){

            if (m_promptTitle_attr)
            {
                return *m_promptTitle_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_prompt_attr(){

            return m_has_prompt_attr;
        
        }
        void set_prompt_attr(const ns_s::ST_Xstring& _prompt_attr ){

            m_has_prompt_attr = true;
            m_prompt_attr = new ns_s::ST_Xstring(_prompt_attr);
        
        }
        const ns_s::ST_Xstring& prompt_attr(){

            if (m_prompt_attr)
            {
                return *m_prompt_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_sqref_attr(){

            return m_has_sqref_attr;
        
        }
        void set_sqref_attr(const ST_Sqref& _sqref_attr ){

            m_has_sqref_attr = true;
            m_sqref_attr = new ST_Sqref(_sqref_attr);
        
        }
        const ST_Sqref& sqref_attr(){

            if (m_sqref_attr)
            {
                return *m_sqref_attr;
            }
            return ST_Sqref::default_instance();
        
        }

    private:
        bool m_has_formula1 ;
        ST_Formula* m_formula1 ;
        bool m_has_formula2 ;
        ST_Formula* m_formula2 ;
        static CT_DataValidation* default_instance_ ;
        bool m_has_type_attr ;
        ST_DataValidationType* m_type_attr ;
        bool m_has_errorStyle_attr ;
        ST_DataValidationErrorStyle* m_errorStyle_attr ;
        bool m_has_imeMode_attr ;
        ST_DataValidationImeMode* m_imeMode_attr ;
        bool m_has_operator_attr ;
        ST_DataValidationOperator* m_operator_attr ;
        bool m_has_allowBlank_attr ;
        boolean m_allowBlank_attr ;
        bool m_has_showDropDown_attr ;
        boolean m_showDropDown_attr ;
        bool m_has_showInputMessage_attr ;
        boolean m_showInputMessage_attr ;
        bool m_has_showErrorMessage_attr ;
        boolean m_showErrorMessage_attr ;
        bool m_has_errorTitle_attr ;
        ns_s::ST_Xstring* m_errorTitle_attr ;
        bool m_has_error_attr ;
        ns_s::ST_Xstring* m_error_attr ;
        bool m_has_promptTitle_attr ;
        ns_s::ST_Xstring* m_promptTitle_attr ;
        bool m_has_prompt_attr ;
        ns_s::ST_Xstring* m_prompt_attr ;
        bool m_has_sqref_attr ;
        ST_Sqref* m_sqref_attr ;

    }

    class CT_ConditionalFormatting : public XSD::ComplexType{
    public:
        bool has_cfRule(){

            return m_has_cfRule;
        
        }
        CT_CfRule* mutable_cfRule(){

                m_has_cfRule = true;
                if (!m_cfRule)
                {
                    m_cfRule = new CT_CfRule();
                }
                return m_cfRule;
            
        }
        const CT_CfRule& cfRule(){

            if (m_cfRule)
            {
                return *m_cfRule;
            }
            return CT_CfRule::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_pivot_attr = false;
                m_pivot_attr = false;
            
                m_has_sqref_attr = false;
                
        if (m_sqref_attr)
        {
            delete m_sqref_attr;
            m_sqref_attr = NULL;
        }
    
            
                m_has_cfRule = false;
                
        if (m_cfRule)
        {
            delete m_cfRule;
            m_cfRule = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_pivot_attr) << \\\;
m_sqref_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_cfRule)
                {
                    m_cfRule->toXml(cfRule, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_cfRule->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_ConditionalFormatting& default_instance(){

    if (!CT_ConditionalFormatting::default_instance_)
    {
        CT_ConditionalFormatting::default_instance_ = new CT_ConditionalFormatting();
    }
    return *CT_ConditionalFormatting::default_instance_;

        }
        bool has_pivot_attr(){

            return m_has_pivot_attr;
        
        }
        void set_pivot_attr(const boolean& _pivot_attr ){

        m_has_pivot_attr = true;
        m_pivot_attr = _pivot_attr;
        
        }
        const boolean& pivot_attr(){

            return type: oolean\nname: \m_pivot_attr\n;
        
        }
        bool has_sqref_attr(){

            return m_has_sqref_attr;
        
        }
        void set_sqref_attr(const ST_Sqref& _sqref_attr ){

            m_has_sqref_attr = true;
            m_sqref_attr = new ST_Sqref(_sqref_attr);
        
        }
        const ST_Sqref& sqref_attr(){

            if (m_sqref_attr)
            {
                return *m_sqref_attr;
            }
            return ST_Sqref::default_instance();
        
        }

    private:
        bool m_has_cfRule ;
        CT_CfRule* m_cfRule ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_ConditionalFormatting* default_instance_ ;
        bool m_has_pivot_attr ;
        boolean m_pivot_attr ;
        bool m_has_sqref_attr ;
        ST_Sqref* m_sqref_attr ;

    }

    class CT_CfRule : public XSD::ComplexType{
    public:
        bool has_formula(){

            return m_has_formula;
        
        }
        ST_Formula* mutable_formula(){

                m_has_formula = true;
                if (!m_formula)
                {
                    m_formula = new ST_Formula();
                }
                return m_formula;
            
        }
        const ST_Formula& formula(){

            if (m_formula)
            {
                return *m_formula;
            }
            return ST_Formula::default_instance();
        
        }
        bool has_colorScale(){

            return m_has_colorScale;
        
        }
        CT_ColorScale* mutable_colorScale(){

                m_has_colorScale = true;
                if (!m_colorScale)
                {
                    m_colorScale = new CT_ColorScale();
                }
                return m_colorScale;
            
        }
        const CT_ColorScale& colorScale(){

            if (m_colorScale)
            {
                return *m_colorScale;
            }
            return CT_ColorScale::default_instance();
        
        }
        bool has_dataBar(){

            return m_has_dataBar;
        
        }
        CT_DataBar* mutable_dataBar(){

                m_has_dataBar = true;
                if (!m_dataBar)
                {
                    m_dataBar = new CT_DataBar();
                }
                return m_dataBar;
            
        }
        const CT_DataBar& dataBar(){

            if (m_dataBar)
            {
                return *m_dataBar;
            }
            return CT_DataBar::default_instance();
        
        }
        bool has_iconSet(){

            return m_has_iconSet;
        
        }
        CT_IconSet* mutable_iconSet(){

                m_has_iconSet = true;
                if (!m_iconSet)
                {
                    m_iconSet = new CT_IconSet();
                }
                return m_iconSet;
            
        }
        const CT_IconSet& iconSet(){

            if (m_iconSet)
            {
                return *m_iconSet;
            }
            return CT_IconSet::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_type_attr = false;
                
        if (m_type_attr)
        {
            delete m_type_attr;
            m_type_attr = NULL;
        }
    
            
                m_has_dxfId_attr = false;
                
        if (m_dxfId_attr)
        {
            delete m_dxfId_attr;
            m_dxfId_attr = NULL;
        }
    
            
                m_has_priority_attr = false;
                m_priority_attr = 0;
            
                m_has_stopIfTrue_attr = false;
                m_stopIfTrue_attr = false;
            
                m_has_aboveAverage_attr = false;
                m_aboveAverage_attr = false;
            
                m_has_percent_attr = false;
                m_percent_attr = false;
            
                m_has_bottom_attr = false;
                m_bottom_attr = false;
            
                m_has_operator_attr = false;
                
        if (m_operator_attr)
        {
            delete m_operator_attr;
            m_operator_attr = NULL;
        }
    
            
                m_has_text_attr = false;
                m_text_attr.clear();
            
                m_has_timePeriod_attr = false;
                
        if (m_timePeriod_attr)
        {
            delete m_timePeriod_attr;
            m_timePeriod_attr = NULL;
        }
    
            
                m_has_rank_attr = false;
                m_rank_attr = 0;
            
                m_has_stdDev_attr = false;
                m_stdDev_attr = 0;
            
                m_has_equalAverage_attr = false;
                m_equalAverage_attr = false;
            
                m_has_formula = false;
                
        if (m_formula)
        {
            delete m_formula;
            m_formula = NULL;
        }
    
            
                m_has_colorScale = false;
                
        if (m_colorScale)
        {
            delete m_colorScale;
            m_colorScale = NULL;
        }
    
            
                m_has_dataBar = false;
                
        if (m_dataBar)
        {
            delete m_dataBar;
            m_dataBar = NULL;
        }
    
            
                m_has_iconSet = false;
                
        if (m_iconSet)
        {
            delete m_iconSet;
            m_iconSet = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_type_attr->toXml(_attrName, _outStream);
m_dxfId_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_priority_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_stopIfTrue_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_aboveAverage_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_percent_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_bottom_attr) << \\\;
m_operator_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_text_attr << \\\;
m_timePeriod_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_rank_attr << \\\;
_outStream << _attrName << \=\\ << m_stdDev_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_equalAverage_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_formula)
                {
                    _outStream << \<formula>\ << m_formula->toString() << \</formula>\;;
                }
            
                if (m_has_colorScale)
                {
                    m_formula->toXml(colorScale, _outStream);;
                }
            
                if (m_has_dataBar)
                {
                    m_formula->toXml(dataBar, _outStream);;
                }
            
                if (m_has_iconSet)
                {
                    m_formula->toXml(iconSet, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_formula->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CfRule& default_instance(){

    if (!CT_CfRule::default_instance_)
    {
        CT_CfRule::default_instance_ = new CT_CfRule();
    }
    return *CT_CfRule::default_instance_;

        }
        bool has_type_attr(){

            return m_has_type_attr;
        
        }
        void set_type_attr(const ST_CfType& _type_attr ){

            m_has_type_attr = true;
            m_type_attr = new ST_CfType(_type_attr);
        
        }
        const ST_CfType& type_attr(){

            if (m_type_attr)
            {
                return *m_type_attr;
            }
            return ST_CfType::default_instance();
        
        }
        bool has_dxfId_attr(){

            return m_has_dxfId_attr;
        
        }
        void set_dxfId_attr(const ST_DxfId& _dxfId_attr ){

            m_has_dxfId_attr = true;
            m_dxfId_attr = new ST_DxfId(_dxfId_attr);
        
        }
        const ST_DxfId& dxfId_attr(){

            if (m_dxfId_attr)
            {
                return *m_dxfId_attr;
            }
            return ST_DxfId::default_instance();
        
        }
        bool has_priority_attr(){

            return m_has_priority_attr;
        
        }
        void set_priority_attr(const int& _priority_attr ){

        m_has_priority_attr = true;
        m_priority_attr = _priority_attr;
        
        }
        const int& priority_attr(){

            return type: \int\nname: \m_priority_attr\n;
        
        }
        bool has_stopIfTrue_attr(){

            return m_has_stopIfTrue_attr;
        
        }
        void set_stopIfTrue_attr(const boolean& _stopIfTrue_attr ){

        m_has_stopIfTrue_attr = true;
        m_stopIfTrue_attr = _stopIfTrue_attr;
        
        }
        const boolean& stopIfTrue_attr(){

            return type: oolean\nname: \m_stopIfTrue_attr\n;
        
        }
        bool has_aboveAverage_attr(){

            return m_has_aboveAverage_attr;
        
        }
        void set_aboveAverage_attr(const boolean& _aboveAverage_attr ){

        m_has_aboveAverage_attr = true;
        m_aboveAverage_attr = _aboveAverage_attr;
        
        }
        const boolean& aboveAverage_attr(){

            return type: oolean\nname: \m_aboveAverage_attr\n;
        
        }
        bool has_percent_attr(){

            return m_has_percent_attr;
        
        }
        void set_percent_attr(const boolean& _percent_attr ){

        m_has_percent_attr = true;
        m_percent_attr = _percent_attr;
        
        }
        const boolean& percent_attr(){

            return type: oolean\nname: \m_percent_attr\n;
        
        }
        bool has_bottom_attr(){

            return m_has_bottom_attr;
        
        }
        void set_bottom_attr(const boolean& _bottom_attr ){

        m_has_bottom_attr = true;
        m_bottom_attr = _bottom_attr;
        
        }
        const boolean& bottom_attr(){

            return type: oolean\nname: \m_bottom_attr\n;
        
        }
        bool has_operator_attr(){

            return m_has_operator_attr;
        
        }
        void set_operator_attr(const ST_ConditionalFormattingOperator& _operator_attr ){

            m_has_operator_attr = true;
            m_operator_attr = new ST_ConditionalFormattingOperator(_operator_attr);
        
        }
        const ST_ConditionalFormattingOperator& operator_attr(){

            if (m_operator_attr)
            {
                return *m_operator_attr;
            }
            return ST_ConditionalFormattingOperator::default_instance();
        
        }
        bool has_text_attr(){

            return m_has_text_attr;
        
        }
        void set_text_attr(const string& _text_attr ){

        m_has_text_attr = true;
        m_text_attr = _text_attr;
        
        }
        const string& text_attr(){

            return type: \string\nname: \m_text_attr\n;
        
        }
        bool has_timePeriod_attr(){

            return m_has_timePeriod_attr;
        
        }
        void set_timePeriod_attr(const ST_TimePeriod& _timePeriod_attr ){

            m_has_timePeriod_attr = true;
            m_timePeriod_attr = new ST_TimePeriod(_timePeriod_attr);
        
        }
        const ST_TimePeriod& timePeriod_attr(){

            if (m_timePeriod_attr)
            {
                return *m_timePeriod_attr;
            }
            return ST_TimePeriod::default_instance();
        
        }
        bool has_rank_attr(){

            return m_has_rank_attr;
        
        }
        void set_rank_attr(const unsignedInt& _rank_attr ){

        m_has_rank_attr = true;
        m_rank_attr = _rank_attr;
        
        }
        const unsignedInt& rank_attr(){

            return type: \unsignedInt\nname: \m_rank_attr\n;
        
        }
        bool has_stdDev_attr(){

            return m_has_stdDev_attr;
        
        }
        void set_stdDev_attr(const int& _stdDev_attr ){

        m_has_stdDev_attr = true;
        m_stdDev_attr = _stdDev_attr;
        
        }
        const int& stdDev_attr(){

            return type: \int\nname: \m_stdDev_attr\n;
        
        }
        bool has_equalAverage_attr(){

            return m_has_equalAverage_attr;
        
        }
        void set_equalAverage_attr(const boolean& _equalAverage_attr ){

        m_has_equalAverage_attr = true;
        m_equalAverage_attr = _equalAverage_attr;
        
        }
        const boolean& equalAverage_attr(){

            return type: oolean\nname: \m_equalAverage_attr\n;
        
        }

    private:
        bool m_has_formula ;
        ST_Formula* m_formula ;
        bool m_has_colorScale ;
        CT_ColorScale* m_colorScale ;
        bool m_has_dataBar ;
        CT_DataBar* m_dataBar ;
        bool m_has_iconSet ;
        CT_IconSet* m_iconSet ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_CfRule* default_instance_ ;
        bool m_has_type_attr ;
        ST_CfType* m_type_attr ;
        bool m_has_dxfId_attr ;
        ST_DxfId* m_dxfId_attr ;
        bool m_has_priority_attr ;
        int m_priority_attr ;
        bool m_has_stopIfTrue_attr ;
        boolean m_stopIfTrue_attr ;
        bool m_has_aboveAverage_attr ;
        boolean m_aboveAverage_attr ;
        bool m_has_percent_attr ;
        boolean m_percent_attr ;
        bool m_has_bottom_attr ;
        boolean m_bottom_attr ;
        bool m_has_operator_attr ;
        ST_ConditionalFormattingOperator* m_operator_attr ;
        bool m_has_text_attr ;
        string m_text_attr ;
        bool m_has_timePeriod_attr ;
        ST_TimePeriod* m_timePeriod_attr ;
        bool m_has_rank_attr ;
        unsignedInt m_rank_attr ;
        bool m_has_stdDev_attr ;
        int m_stdDev_attr ;
        bool m_has_equalAverage_attr ;
        boolean m_equalAverage_attr ;

    }

    class CT_Hyperlinks : public XSD::ComplexType{
    public:
        bool has_hyperlink(){

            return m_has_hyperlink;
        
        }
        CT_Hyperlink* mutable_hyperlink(){

                m_has_hyperlink = true;
                if (!m_hyperlink)
                {
                    m_hyperlink = new CT_Hyperlink();
                }
                return m_hyperlink;
            
        }
        const CT_Hyperlink& hyperlink(){

            if (m_hyperlink)
            {
                return *m_hyperlink;
            }
            return CT_Hyperlink::default_instance();
        
        }
        void clear(){

                m_has_hyperlink = false;
                
        if (m_hyperlink)
        {
            delete m_hyperlink;
            m_hyperlink = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_hyperlink)
                {
                    m_hyperlink->toXml(hyperlink, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Hyperlinks& default_instance(){

    if (!CT_Hyperlinks::default_instance_)
    {
        CT_Hyperlinks::default_instance_ = new CT_Hyperlinks();
    }
    return *CT_Hyperlinks::default_instance_;

        }

    private:
        bool m_has_hyperlink ;
        CT_Hyperlink* m_hyperlink ;
        static CT_Hyperlinks* default_instance_ ;

    }

    class CT_Hyperlink : public XSD::ComplexType{
    public:
        void clear(){

                m_has_ref_attr = false;
                
        if (m_ref_attr)
        {
            delete m_ref_attr;
            m_ref_attr = NULL;
        }
    
            
                m_has_id_attr = false;
                
        if (m_id_attr)
        {
            delete m_id_attr;
            m_id_attr = NULL;
        }
    
            
                m_has_location_attr = false;
                
        if (m_location_attr)
        {
            delete m_location_attr;
            m_location_attr = NULL;
        }
    
            
                m_has_tooltip_attr = false;
                
        if (m_tooltip_attr)
        {
            delete m_tooltip_attr;
            m_tooltip_attr = NULL;
        }
    
            
                m_has_display_attr = false;
                
        if (m_display_attr)
        {
            delete m_display_attr;
            m_display_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_ref_attr->toXml(_attrName, _outStream);
m_id_attr->toXml(_attrName, _outStream);
m_location_attr->toXml(_attrName, _outStream);
m_tooltip_attr->toXml(_attrName, _outStream);
m_display_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Hyperlink& default_instance(){

    if (!CT_Hyperlink::default_instance_)
    {
        CT_Hyperlink::default_instance_ = new CT_Hyperlink();
    }
    return *CT_Hyperlink::default_instance_;

        }
        bool has_ref_attr(){

            return m_has_ref_attr;
        
        }
        void set_ref_attr(const ST_Ref& _ref_attr ){

            m_has_ref_attr = true;
            m_ref_attr = new ST_Ref(_ref_attr);
        
        }
        const ST_Ref& ref_attr(){

            if (m_ref_attr)
            {
                return *m_ref_attr;
            }
            return ST_Ref::default_instance();
        
        }
        bool has_id_attr(){

            return m_has_id_attr;
        
        }
        void set_id_attr(const ST_RelationshipId& _id_attr ){

            m_has_id_attr = true;
            m_id_attr = new ST_RelationshipId(_id_attr);
        
        }
        const ST_RelationshipId& id_attr(){

            if (m_id_attr)
            {
                return *m_id_attr;
            }
            return ST_RelationshipId::default_instance();
        
        }
        bool has_location_attr(){

            return m_has_location_attr;
        
        }
        void set_location_attr(const ns_s::ST_Xstring& _location_attr ){

            m_has_location_attr = true;
            m_location_attr = new ns_s::ST_Xstring(_location_attr);
        
        }
        const ns_s::ST_Xstring& location_attr(){

            if (m_location_attr)
            {
                return *m_location_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_tooltip_attr(){

            return m_has_tooltip_attr;
        
        }
        void set_tooltip_attr(const ns_s::ST_Xstring& _tooltip_attr ){

            m_has_tooltip_attr = true;
            m_tooltip_attr = new ns_s::ST_Xstring(_tooltip_attr);
        
        }
        const ns_s::ST_Xstring& tooltip_attr(){

            if (m_tooltip_attr)
            {
                return *m_tooltip_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_display_attr(){

            return m_has_display_attr;
        
        }
        void set_display_attr(const ns_s::ST_Xstring& _display_attr ){

            m_has_display_attr = true;
            m_display_attr = new ns_s::ST_Xstring(_display_attr);
        
        }
        const ns_s::ST_Xstring& display_attr(){

            if (m_display_attr)
            {
                return *m_display_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }

    private:
        static CT_Hyperlink* default_instance_ ;
        bool m_has_ref_attr ;
        ST_Ref* m_ref_attr ;
        bool m_has_id_attr ;
        ST_RelationshipId* m_id_attr ;
        bool m_has_location_attr ;
        ns_s::ST_Xstring* m_location_attr ;
        bool m_has_tooltip_attr ;
        ns_s::ST_Xstring* m_tooltip_attr ;
        bool m_has_display_attr ;
        ns_s::ST_Xstring* m_display_attr ;

    }

    class CT_CellFormula : public XSD::ComplexType{
    public:
        void clear(){

        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CellFormula& default_instance(){

    if (!CT_CellFormula::default_instance_)
    {
        CT_CellFormula::default_instance_ = new CT_CellFormula();
    }
    return *CT_CellFormula::default_instance_;

        }

    private:
        static CT_CellFormula* default_instance_ ;

    }

    class CT_ColorScale : public XSD::ComplexType{
    public:
        bool has_cfvo(){

            return m_has_cfvo;
        
        }
        CT_Cfvo* mutable_cfvo(){

                m_has_cfvo = true;
                if (!m_cfvo)
                {
                    m_cfvo = new CT_Cfvo();
                }
                return m_cfvo;
            
        }
        const CT_Cfvo& cfvo(){

            if (m_cfvo)
            {
                return *m_cfvo;
            }
            return CT_Cfvo::default_instance();
        
        }
        bool has_color(){

            return m_has_color;
        
        }
        CT_Color* mutable_color(){

                m_has_color = true;
                if (!m_color)
                {
                    m_color = new CT_Color();
                }
                return m_color;
            
        }
        const CT_Color& color(){

            if (m_color)
            {
                return *m_color;
            }
            return CT_Color::default_instance();
        
        }
        void clear(){

                m_has_cfvo = false;
                
        if (m_cfvo)
        {
            delete m_cfvo;
            m_cfvo = NULL;
        }
    
            
                m_has_color = false;
                
        if (m_color)
        {
            delete m_color;
            m_color = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_cfvo)
                {
                    m_cfvo->toXml(cfvo, _outStream);;
                }
            
                if (m_has_color)
                {
                    m_cfvo->toXml(color, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_ColorScale& default_instance(){

    if (!CT_ColorScale::default_instance_)
    {
        CT_ColorScale::default_instance_ = new CT_ColorScale();
    }
    return *CT_ColorScale::default_instance_;

        }

    private:
        bool m_has_cfvo ;
        CT_Cfvo* m_cfvo ;
        bool m_has_color ;
        CT_Color* m_color ;
        static CT_ColorScale* default_instance_ ;

    }

    class CT_DataBar : public XSD::ComplexType{
    public:
        bool has_cfvo(){

            return m_has_cfvo;
        
        }
        CT_Cfvo* mutable_cfvo(){

                m_has_cfvo = true;
                if (!m_cfvo)
                {
                    m_cfvo = new CT_Cfvo();
                }
                return m_cfvo;
            
        }
        const CT_Cfvo& cfvo(){

            if (m_cfvo)
            {
                return *m_cfvo;
            }
            return CT_Cfvo::default_instance();
        
        }
        bool has_color(){

            return m_has_color;
        
        }
        CT_Color* mutable_color(){

                m_has_color = true;
                if (!m_color)
                {
                    m_color = new CT_Color();
                }
                return m_color;
            
        }
        const CT_Color& color(){

            if (m_color)
            {
                return *m_color;
            }
            return CT_Color::default_instance();
        
        }
        void clear(){

                m_has_minLength_attr = false;
                m_minLength_attr = 0;
            
                m_has_maxLength_attr = false;
                m_maxLength_attr = 0;
            
                m_has_showValue_attr = false;
                m_showValue_attr = false;
            
                m_has_cfvo = false;
                
        if (m_cfvo)
        {
            delete m_cfvo;
            m_cfvo = NULL;
        }
    
            
                m_has_color = false;
                
        if (m_color)
        {
            delete m_color;
            m_color = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_minLength_attr << \\\;
_outStream << _attrName << \=\\ << m_maxLength_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showValue_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_cfvo)
                {
                    m_cfvo->toXml(cfvo, _outStream);;
                }
            
                if (m_has_color)
                {
                    m_cfvo->toXml(color, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_DataBar& default_instance(){

    if (!CT_DataBar::default_instance_)
    {
        CT_DataBar::default_instance_ = new CT_DataBar();
    }
    return *CT_DataBar::default_instance_;

        }
        bool has_minLength_attr(){

            return m_has_minLength_attr;
        
        }
        void set_minLength_attr(const unsignedInt& _minLength_attr ){

        m_has_minLength_attr = true;
        m_minLength_attr = _minLength_attr;
        
        }
        const unsignedInt& minLength_attr(){

            return type: \unsignedInt\nname: \m_minLength_attr\n;
        
        }
        bool has_maxLength_attr(){

            return m_has_maxLength_attr;
        
        }
        void set_maxLength_attr(const unsignedInt& _maxLength_attr ){

        m_has_maxLength_attr = true;
        m_maxLength_attr = _maxLength_attr;
        
        }
        const unsignedInt& maxLength_attr(){

            return type: \unsignedInt\nname: \m_maxLength_attr\n;
        
        }
        bool has_showValue_attr(){

            return m_has_showValue_attr;
        
        }
        void set_showValue_attr(const boolean& _showValue_attr ){

        m_has_showValue_attr = true;
        m_showValue_attr = _showValue_attr;
        
        }
        const boolean& showValue_attr(){

            return type: oolean\nname: \m_showValue_attr\n;
        
        }

    private:
        bool m_has_cfvo ;
        CT_Cfvo* m_cfvo ;
        bool m_has_color ;
        CT_Color* m_color ;
        static CT_DataBar* default_instance_ ;
        bool m_has_minLength_attr ;
        unsignedInt m_minLength_attr ;
        bool m_has_maxLength_attr ;
        unsignedInt m_maxLength_attr ;
        bool m_has_showValue_attr ;
        boolean m_showValue_attr ;

    }

    class CT_IconSet : public XSD::ComplexType{
    public:
        bool has_cfvo(){

            return m_has_cfvo;
        
        }
        CT_Cfvo* mutable_cfvo(){

                m_has_cfvo = true;
                if (!m_cfvo)
                {
                    m_cfvo = new CT_Cfvo();
                }
                return m_cfvo;
            
        }
        const CT_Cfvo& cfvo(){

            if (m_cfvo)
            {
                return *m_cfvo;
            }
            return CT_Cfvo::default_instance();
        
        }
        void clear(){

                m_has_iconSet_attr = false;
                
        if (m_iconSet_attr)
        {
            delete m_iconSet_attr;
            m_iconSet_attr = NULL;
        }
    
            
                m_has_showValue_attr = false;
                m_showValue_attr = false;
            
                m_has_percent_attr = false;
                m_percent_attr = false;
            
                m_has_reverse_attr = false;
                m_reverse_attr = false;
            
                m_has_cfvo = false;
                
        if (m_cfvo)
        {
            delete m_cfvo;
            m_cfvo = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_iconSet_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showValue_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_percent_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_reverse_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_cfvo)
                {
                    m_cfvo->toXml(cfvo, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_IconSet& default_instance(){

    if (!CT_IconSet::default_instance_)
    {
        CT_IconSet::default_instance_ = new CT_IconSet();
    }
    return *CT_IconSet::default_instance_;

        }
        bool has_iconSet_attr(){

            return m_has_iconSet_attr;
        
        }
        void set_iconSet_attr(const ST_IconSetType& _iconSet_attr ){

            m_has_iconSet_attr = true;
            m_iconSet_attr = new ST_IconSetType(_iconSet_attr);
        
        }
        const ST_IconSetType& iconSet_attr(){

            if (m_iconSet_attr)
            {
                return *m_iconSet_attr;
            }
            return ST_IconSetType::default_instance();
        
        }
        bool has_showValue_attr(){

            return m_has_showValue_attr;
        
        }
        void set_showValue_attr(const boolean& _showValue_attr ){

        m_has_showValue_attr = true;
        m_showValue_attr = _showValue_attr;
        
        }
        const boolean& showValue_attr(){

            return type: oolean\nname: \m_showValue_attr\n;
        
        }
        bool has_percent_attr(){

            return m_has_percent_attr;
        
        }
        void set_percent_attr(const boolean& _percent_attr ){

        m_has_percent_attr = true;
        m_percent_attr = _percent_attr;
        
        }
        const boolean& percent_attr(){

            return type: oolean\nname: \m_percent_attr\n;
        
        }
        bool has_reverse_attr(){

            return m_has_reverse_attr;
        
        }
        void set_reverse_attr(const boolean& _reverse_attr ){

        m_has_reverse_attr = true;
        m_reverse_attr = _reverse_attr;
        
        }
        const boolean& reverse_attr(){

            return type: oolean\nname: \m_reverse_attr\n;
        
        }

    private:
        bool m_has_cfvo ;
        CT_Cfvo* m_cfvo ;
        static CT_IconSet* default_instance_ ;
        bool m_has_iconSet_attr ;
        ST_IconSetType* m_iconSet_attr ;
        bool m_has_showValue_attr ;
        boolean m_showValue_attr ;
        bool m_has_percent_attr ;
        boolean m_percent_attr ;
        bool m_has_reverse_attr ;
        boolean m_reverse_attr ;

    }

    class CT_Cfvo : public XSD::ComplexType{
    public:
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_type_attr = false;
                
        if (m_type_attr)
        {
            delete m_type_attr;
            m_type_attr = NULL;
        }
    
            
                m_has_val_attr = false;
                
        if (m_val_attr)
        {
            delete m_val_attr;
            m_val_attr = NULL;
        }
    
            
                m_has_gte_attr = false;
                m_gte_attr = false;
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_type_attr->toXml(_attrName, _outStream);
m_val_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_gte_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_extLst)
                {
                    m_extLst->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Cfvo& default_instance(){

    if (!CT_Cfvo::default_instance_)
    {
        CT_Cfvo::default_instance_ = new CT_Cfvo();
    }
    return *CT_Cfvo::default_instance_;

        }
        bool has_type_attr(){

            return m_has_type_attr;
        
        }
        void set_type_attr(const ST_CfvoType& _type_attr ){

            m_has_type_attr = true;
            m_type_attr = new ST_CfvoType(_type_attr);
        
        }
        const ST_CfvoType& type_attr(){

            if (m_type_attr)
            {
                return *m_type_attr;
            }
            return ST_CfvoType::default_instance();
        
        }
        bool has_val_attr(){

            return m_has_val_attr;
        
        }
        void set_val_attr(const ns_s::ST_Xstring& _val_attr ){

            m_has_val_attr = true;
            m_val_attr = new ns_s::ST_Xstring(_val_attr);
        
        }
        const ns_s::ST_Xstring& val_attr(){

            if (m_val_attr)
            {
                return *m_val_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_gte_attr(){

            return m_has_gte_attr;
        
        }
        void set_gte_attr(const boolean& _gte_attr ){

        m_has_gte_attr = true;
        m_gte_attr = _gte_attr;
        
        }
        const boolean& gte_attr(){

            return type: oolean\nname: \m_gte_attr\n;
        
        }

    private:
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_Cfvo* default_instance_ ;
        bool m_has_type_attr ;
        ST_CfvoType* m_type_attr ;
        bool m_has_val_attr ;
        ns_s::ST_Xstring* m_val_attr ;
        bool m_has_gte_attr ;
        boolean m_gte_attr ;

    }

    class CT_PageMargins : public XSD::ComplexType{
    public:
        void clear(){

                m_has_left_attr = false;
                m_left_attr = 0;
            
                m_has_right_attr = false;
                m_right_attr = 0;
            
                m_has_top_attr = false;
                m_top_attr = 0;
            
                m_has_bottom_attr = false;
                m_bottom_attr = 0;
            
                m_has_header_attr = false;
                m_header_attr = 0;
            
                m_has_footer_attr = false;
                m_footer_attr = 0;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_left_attr << \\\;
_outStream << _attrName << \=\\ << m_right_attr << \\\;
_outStream << _attrName << \=\\ << m_top_attr << \\\;
_outStream << _attrName << \=\\ << m_bottom_attr << \\\;
_outStream << _attrName << \=\\ << m_header_attr << \\\;
_outStream << _attrName << \=\\ << m_footer_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_PageMargins& default_instance(){

    if (!CT_PageMargins::default_instance_)
    {
        CT_PageMargins::default_instance_ = new CT_PageMargins();
    }
    return *CT_PageMargins::default_instance_;

        }
        bool has_left_attr(){

            return m_has_left_attr;
        
        }
        void set_left_attr(const double& _left_attr ){

        m_has_left_attr = true;
        m_left_attr = _left_attr;
        
        }
        const double& left_attr(){

            return type: \double\nname: \m_left_attr\n;
        
        }
        bool has_right_attr(){

            return m_has_right_attr;
        
        }
        void set_right_attr(const double& _right_attr ){

        m_has_right_attr = true;
        m_right_attr = _right_attr;
        
        }
        const double& right_attr(){

            return type: \double\nname: \m_right_attr\n;
        
        }
        bool has_top_attr(){

            return m_has_top_attr;
        
        }
        void set_top_attr(const double& _top_attr ){

        m_has_top_attr = true;
        m_top_attr = _top_attr;
        
        }
        const double& top_attr(){

            return type: \double\nname: \m_top_attr\n;
        
        }
        bool has_bottom_attr(){

            return m_has_bottom_attr;
        
        }
        void set_bottom_attr(const double& _bottom_attr ){

        m_has_bottom_attr = true;
        m_bottom_attr = _bottom_attr;
        
        }
        const double& bottom_attr(){

            return type: \double\nname: \m_bottom_attr\n;
        
        }
        bool has_header_attr(){

            return m_has_header_attr;
        
        }
        void set_header_attr(const double& _header_attr ){

        m_has_header_attr = true;
        m_header_attr = _header_attr;
        
        }
        const double& header_attr(){

            return type: \double\nname: \m_header_attr\n;
        
        }
        bool has_footer_attr(){

            return m_has_footer_attr;
        
        }
        void set_footer_attr(const double& _footer_attr ){

        m_has_footer_attr = true;
        m_footer_attr = _footer_attr;
        
        }
        const double& footer_attr(){

            return type: \double\nname: \m_footer_attr\n;
        
        }

    private:
        static CT_PageMargins* default_instance_ ;
        bool m_has_left_attr ;
        double m_left_attr ;
        bool m_has_right_attr ;
        double m_right_attr ;
        bool m_has_top_attr ;
        double m_top_attr ;
        bool m_has_bottom_attr ;
        double m_bottom_attr ;
        bool m_has_header_attr ;
        double m_header_attr ;
        bool m_has_footer_attr ;
        double m_footer_attr ;

    }

    class CT_PrintOptions : public XSD::ComplexType{
    public:
        void clear(){

                m_has_horizontalCentered_attr = false;
                m_horizontalCentered_attr = false;
            
                m_has_verticalCentered_attr = false;
                m_verticalCentered_attr = false;
            
                m_has_headings_attr = false;
                m_headings_attr = false;
            
                m_has_gridLines_attr = false;
                m_gridLines_attr = false;
            
                m_has_gridLinesSet_attr = false;
                m_gridLinesSet_attr = false;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_horizontalCentered_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_verticalCentered_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_headings_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_gridLines_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_gridLinesSet_attr) << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_PrintOptions& default_instance(){

    if (!CT_PrintOptions::default_instance_)
    {
        CT_PrintOptions::default_instance_ = new CT_PrintOptions();
    }
    return *CT_PrintOptions::default_instance_;

        }
        bool has_horizontalCentered_attr(){

            return m_has_horizontalCentered_attr;
        
        }
        void set_horizontalCentered_attr(const boolean& _horizontalCentered_attr ){

        m_has_horizontalCentered_attr = true;
        m_horizontalCentered_attr = _horizontalCentered_attr;
        
        }
        const boolean& horizontalCentered_attr(){

            return type: oolean\nname: \m_horizontalCentered_attr\n;
        
        }
        bool has_verticalCentered_attr(){

            return m_has_verticalCentered_attr;
        
        }
        void set_verticalCentered_attr(const boolean& _verticalCentered_attr ){

        m_has_verticalCentered_attr = true;
        m_verticalCentered_attr = _verticalCentered_attr;
        
        }
        const boolean& verticalCentered_attr(){

            return type: oolean\nname: \m_verticalCentered_attr\n;
        
        }
        bool has_headings_attr(){

            return m_has_headings_attr;
        
        }
        void set_headings_attr(const boolean& _headings_attr ){

        m_has_headings_attr = true;
        m_headings_attr = _headings_attr;
        
        }
        const boolean& headings_attr(){

            return type: oolean\nname: \m_headings_attr\n;
        
        }
        bool has_gridLines_attr(){

            return m_has_gridLines_attr;
        
        }
        void set_gridLines_attr(const boolean& _gridLines_attr ){

        m_has_gridLines_attr = true;
        m_gridLines_attr = _gridLines_attr;
        
        }
        const boolean& gridLines_attr(){

            return type: oolean\nname: \m_gridLines_attr\n;
        
        }
        bool has_gridLinesSet_attr(){

            return m_has_gridLinesSet_attr;
        
        }
        void set_gridLinesSet_attr(const boolean& _gridLinesSet_attr ){

        m_has_gridLinesSet_attr = true;
        m_gridLinesSet_attr = _gridLinesSet_attr;
        
        }
        const boolean& gridLinesSet_attr(){

            return type: oolean\nname: \m_gridLinesSet_attr\n;
        
        }

    private:
        static CT_PrintOptions* default_instance_ ;
        bool m_has_horizontalCentered_attr ;
        boolean m_horizontalCentered_attr ;
        bool m_has_verticalCentered_attr ;
        boolean m_verticalCentered_attr ;
        bool m_has_headings_attr ;
        boolean m_headings_attr ;
        bool m_has_gridLines_attr ;
        boolean m_gridLines_attr ;
        bool m_has_gridLinesSet_attr ;
        boolean m_gridLinesSet_attr ;

    }

    class CT_PageSetup : public XSD::ComplexType{
    public:
        void clear(){

                m_has_paperSize_attr = false;
                m_paperSize_attr = 0;
            
                m_has_paperHeight_attr = false;
                
        if (m_paperHeight_attr)
        {
            delete m_paperHeight_attr;
            m_paperHeight_attr = NULL;
        }
    
            
                m_has_paperWidth_attr = false;
                
        if (m_paperWidth_attr)
        {
            delete m_paperWidth_attr;
            m_paperWidth_attr = NULL;
        }
    
            
                m_has_scale_attr = false;
                m_scale_attr = 0;
            
                m_has_firstPageNumber_attr = false;
                m_firstPageNumber_attr = 0;
            
                m_has_fitToWidth_attr = false;
                m_fitToWidth_attr = 0;
            
                m_has_fitToHeight_attr = false;
                m_fitToHeight_attr = 0;
            
                m_has_pageOrder_attr = false;
                
        if (m_pageOrder_attr)
        {
            delete m_pageOrder_attr;
            m_pageOrder_attr = NULL;
        }
    
            
                m_has_orientation_attr = false;
                
        if (m_orientation_attr)
        {
            delete m_orientation_attr;
            m_orientation_attr = NULL;
        }
    
            
                m_has_usePrinterDefaults_attr = false;
                m_usePrinterDefaults_attr = false;
            
                m_has_blackAndWhite_attr = false;
                m_blackAndWhite_attr = false;
            
                m_has_draft_attr = false;
                m_draft_attr = false;
            
                m_has_cellComments_attr = false;
                
        if (m_cellComments_attr)
        {
            delete m_cellComments_attr;
            m_cellComments_attr = NULL;
        }
    
            
                m_has_useFirstPageNumber_attr = false;
                m_useFirstPageNumber_attr = false;
            
                m_has_errors_attr = false;
                
        if (m_errors_attr)
        {
            delete m_errors_attr;
            m_errors_attr = NULL;
        }
    
            
                m_has_horizontalDpi_attr = false;
                m_horizontalDpi_attr = 0;
            
                m_has_verticalDpi_attr = false;
                m_verticalDpi_attr = 0;
            
                m_has_copies_attr = false;
                m_copies_attr = 0;
            
                m_has_id_attr = false;
                
        if (m_id_attr)
        {
            delete m_id_attr;
            m_id_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_paperSize_attr << \\\;
m_paperHeight_attr->toXml(_attrName, _outStream);
m_paperWidth_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_scale_attr << \\\;
_outStream << _attrName << \=\\ << m_firstPageNumber_attr << \\\;
_outStream << _attrName << \=\\ << m_fitToWidth_attr << \\\;
_outStream << _attrName << \=\\ << m_fitToHeight_attr << \\\;
m_pageOrder_attr->toXml(_attrName, _outStream);
m_orientation_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_usePrinterDefaults_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_blackAndWhite_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_draft_attr) << \\\;
m_cellComments_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_useFirstPageNumber_attr) << \\\;
m_errors_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_horizontalDpi_attr << \\\;
_outStream << _attrName << \=\\ << m_verticalDpi_attr << \\\;
_outStream << _attrName << \=\\ << m_copies_attr << \\\;
m_id_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_PageSetup& default_instance(){

    if (!CT_PageSetup::default_instance_)
    {
        CT_PageSetup::default_instance_ = new CT_PageSetup();
    }
    return *CT_PageSetup::default_instance_;

        }
        bool has_paperSize_attr(){

            return m_has_paperSize_attr;
        
        }
        void set_paperSize_attr(const unsignedInt& _paperSize_attr ){

        m_has_paperSize_attr = true;
        m_paperSize_attr = _paperSize_attr;
        
        }
        const unsignedInt& paperSize_attr(){

            return type: \unsignedInt\nname: \m_paperSize_attr\n;
        
        }
        bool has_paperHeight_attr(){

            return m_has_paperHeight_attr;
        
        }
        void set_paperHeight_attr(const ns_s::ST_PositiveUniversalMeasure& _paperHeight_attr ){

            m_has_paperHeight_attr = true;
            m_paperHeight_attr = new ns_s::ST_PositiveUniversalMeasure(_paperHeight_attr);
        
        }
        const ns_s::ST_PositiveUniversalMeasure& paperHeight_attr(){

            if (m_paperHeight_attr)
            {
                return *m_paperHeight_attr;
            }
            return ns_s::ST_PositiveUniversalMeasure::default_instance();
        
        }
        bool has_paperWidth_attr(){

            return m_has_paperWidth_attr;
        
        }
        void set_paperWidth_attr(const ns_s::ST_PositiveUniversalMeasure& _paperWidth_attr ){

            m_has_paperWidth_attr = true;
            m_paperWidth_attr = new ns_s::ST_PositiveUniversalMeasure(_paperWidth_attr);
        
        }
        const ns_s::ST_PositiveUniversalMeasure& paperWidth_attr(){

            if (m_paperWidth_attr)
            {
                return *m_paperWidth_attr;
            }
            return ns_s::ST_PositiveUniversalMeasure::default_instance();
        
        }
        bool has_scale_attr(){

            return m_has_scale_attr;
        
        }
        void set_scale_attr(const unsignedInt& _scale_attr ){

        m_has_scale_attr = true;
        m_scale_attr = _scale_attr;
        
        }
        const unsignedInt& scale_attr(){

            return type: \unsignedInt\nname: \m_scale_attr\n;
        
        }
        bool has_firstPageNumber_attr(){

            return m_has_firstPageNumber_attr;
        
        }
        void set_firstPageNumber_attr(const unsignedInt& _firstPageNumber_attr ){

        m_has_firstPageNumber_attr = true;
        m_firstPageNumber_attr = _firstPageNumber_attr;
        
        }
        const unsignedInt& firstPageNumber_attr(){

            return type: \unsignedInt\nname: \m_firstPageNumber_attr\n;
        
        }
        bool has_fitToWidth_attr(){

            return m_has_fitToWidth_attr;
        
        }
        void set_fitToWidth_attr(const unsignedInt& _fitToWidth_attr ){

        m_has_fitToWidth_attr = true;
        m_fitToWidth_attr = _fitToWidth_attr;
        
        }
        const unsignedInt& fitToWidth_attr(){

            return type: \unsignedInt\nname: \m_fitToWidth_attr\n;
        
        }
        bool has_fitToHeight_attr(){

            return m_has_fitToHeight_attr;
        
        }
        void set_fitToHeight_attr(const unsignedInt& _fitToHeight_attr ){

        m_has_fitToHeight_attr = true;
        m_fitToHeight_attr = _fitToHeight_attr;
        
        }
        const unsignedInt& fitToHeight_attr(){

            return type: \unsignedInt\nname: \m_fitToHeight_attr\n;
        
        }
        bool has_pageOrder_attr(){

            return m_has_pageOrder_attr;
        
        }
        void set_pageOrder_attr(const ST_PageOrder& _pageOrder_attr ){

            m_has_pageOrder_attr = true;
            m_pageOrder_attr = new ST_PageOrder(_pageOrder_attr);
        
        }
        const ST_PageOrder& pageOrder_attr(){

            if (m_pageOrder_attr)
            {
                return *m_pageOrder_attr;
            }
            return ST_PageOrder::default_instance();
        
        }
        bool has_orientation_attr(){

            return m_has_orientation_attr;
        
        }
        void set_orientation_attr(const ST_Orientation& _orientation_attr ){

            m_has_orientation_attr = true;
            m_orientation_attr = new ST_Orientation(_orientation_attr);
        
        }
        const ST_Orientation& orientation_attr(){

            if (m_orientation_attr)
            {
                return *m_orientation_attr;
            }
            return ST_Orientation::default_instance();
        
        }
        bool has_usePrinterDefaults_attr(){

            return m_has_usePrinterDefaults_attr;
        
        }
        void set_usePrinterDefaults_attr(const boolean& _usePrinterDefaults_attr ){

        m_has_usePrinterDefaults_attr = true;
        m_usePrinterDefaults_attr = _usePrinterDefaults_attr;
        
        }
        const boolean& usePrinterDefaults_attr(){

            return type: oolean\nname: \m_usePrinterDefaults_attr\n;
        
        }
        bool has_blackAndWhite_attr(){

            return m_has_blackAndWhite_attr;
        
        }
        void set_blackAndWhite_attr(const boolean& _blackAndWhite_attr ){

        m_has_blackAndWhite_attr = true;
        m_blackAndWhite_attr = _blackAndWhite_attr;
        
        }
        const boolean& blackAndWhite_attr(){

            return type: oolean\nname: \m_blackAndWhite_attr\n;
        
        }
        bool has_draft_attr(){

            return m_has_draft_attr;
        
        }
        void set_draft_attr(const boolean& _draft_attr ){

        m_has_draft_attr = true;
        m_draft_attr = _draft_attr;
        
        }
        const boolean& draft_attr(){

            return type: oolean\nname: \m_draft_attr\n;
        
        }
        bool has_cellComments_attr(){

            return m_has_cellComments_attr;
        
        }
        void set_cellComments_attr(const ST_CellComments& _cellComments_attr ){

            m_has_cellComments_attr = true;
            m_cellComments_attr = new ST_CellComments(_cellComments_attr);
        
        }
        const ST_CellComments& cellComments_attr(){

            if (m_cellComments_attr)
            {
                return *m_cellComments_attr;
            }
            return ST_CellComments::default_instance();
        
        }
        bool has_useFirstPageNumber_attr(){

            return m_has_useFirstPageNumber_attr;
        
        }
        void set_useFirstPageNumber_attr(const boolean& _useFirstPageNumber_attr ){

        m_has_useFirstPageNumber_attr = true;
        m_useFirstPageNumber_attr = _useFirstPageNumber_attr;
        
        }
        const boolean& useFirstPageNumber_attr(){

            return type: oolean\nname: \m_useFirstPageNumber_attr\n;
        
        }
        bool has_errors_attr(){

            return m_has_errors_attr;
        
        }
        void set_errors_attr(const ST_PrintError& _errors_attr ){

            m_has_errors_attr = true;
            m_errors_attr = new ST_PrintError(_errors_attr);
        
        }
        const ST_PrintError& errors_attr(){

            if (m_errors_attr)
            {
                return *m_errors_attr;
            }
            return ST_PrintError::default_instance();
        
        }
        bool has_horizontalDpi_attr(){

            return m_has_horizontalDpi_attr;
        
        }
        void set_horizontalDpi_attr(const unsignedInt& _horizontalDpi_attr ){

        m_has_horizontalDpi_attr = true;
        m_horizontalDpi_attr = _horizontalDpi_attr;
        
        }
        const unsignedInt& horizontalDpi_attr(){

            return type: \unsignedInt\nname: \m_horizontalDpi_attr\n;
        
        }
        bool has_verticalDpi_attr(){

            return m_has_verticalDpi_attr;
        
        }
        void set_verticalDpi_attr(const unsignedInt& _verticalDpi_attr ){

        m_has_verticalDpi_attr = true;
        m_verticalDpi_attr = _verticalDpi_attr;
        
        }
        const unsignedInt& verticalDpi_attr(){

            return type: \unsignedInt\nname: \m_verticalDpi_attr\n;
        
        }
        bool has_copies_attr(){

            return m_has_copies_attr;
        
        }
        void set_copies_attr(const unsignedInt& _copies_attr ){

        m_has_copies_attr = true;
        m_copies_attr = _copies_attr;
        
        }
        const unsignedInt& copies_attr(){

            return type: \unsignedInt\nname: \m_copies_attr\n;
        
        }
        bool has_id_attr(){

            return m_has_id_attr;
        
        }
        void set_id_attr(const ST_RelationshipId& _id_attr ){

            m_has_id_attr = true;
            m_id_attr = new ST_RelationshipId(_id_attr);
        
        }
        const ST_RelationshipId& id_attr(){

            if (m_id_attr)
            {
                return *m_id_attr;
            }
            return ST_RelationshipId::default_instance();
        
        }

    private:
        static CT_PageSetup* default_instance_ ;
        bool m_has_paperSize_attr ;
        unsignedInt m_paperSize_attr ;
        bool m_has_paperHeight_attr ;
        ns_s::ST_PositiveUniversalMeasure* m_paperHeight_attr ;
        bool m_has_paperWidth_attr ;
        ns_s::ST_PositiveUniversalMeasure* m_paperWidth_attr ;
        bool m_has_scale_attr ;
        unsignedInt m_scale_attr ;
        bool m_has_firstPageNumber_attr ;
        unsignedInt m_firstPageNumber_attr ;
        bool m_has_fitToWidth_attr ;
        unsignedInt m_fitToWidth_attr ;
        bool m_has_fitToHeight_attr ;
        unsignedInt m_fitToHeight_attr ;
        bool m_has_pageOrder_attr ;
        ST_PageOrder* m_pageOrder_attr ;
        bool m_has_orientation_attr ;
        ST_Orientation* m_orientation_attr ;
        bool m_has_usePrinterDefaults_attr ;
        boolean m_usePrinterDefaults_attr ;
        bool m_has_blackAndWhite_attr ;
        boolean m_blackAndWhite_attr ;
        bool m_has_draft_attr ;
        boolean m_draft_attr ;
        bool m_has_cellComments_attr ;
        ST_CellComments* m_cellComments_attr ;
        bool m_has_useFirstPageNumber_attr ;
        boolean m_useFirstPageNumber_attr ;
        bool m_has_errors_attr ;
        ST_PrintError* m_errors_attr ;
        bool m_has_horizontalDpi_attr ;
        unsignedInt m_horizontalDpi_attr ;
        bool m_has_verticalDpi_attr ;
        unsignedInt m_verticalDpi_attr ;
        bool m_has_copies_attr ;
        unsignedInt m_copies_attr ;
        bool m_has_id_attr ;
        ST_RelationshipId* m_id_attr ;

    }

    class CT_HeaderFooter : public XSD::ComplexType{
    public:
        bool has_oddHeader(){

            return m_has_oddHeader;
        
        }
        ns_s::ST_Xstring* mutable_oddHeader(){

                m_has_oddHeader = true;
                if (!m_oddHeader)
                {
                    m_oddHeader = new ns_s::ST_Xstring();
                }
                return m_oddHeader;
            
        }
        const ns_s::ST_Xstring& oddHeader(){

            if (m_oddHeader)
            {
                return *m_oddHeader;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_oddFooter(){

            return m_has_oddFooter;
        
        }
        ns_s::ST_Xstring* mutable_oddFooter(){

                m_has_oddFooter = true;
                if (!m_oddFooter)
                {
                    m_oddFooter = new ns_s::ST_Xstring();
                }
                return m_oddFooter;
            
        }
        const ns_s::ST_Xstring& oddFooter(){

            if (m_oddFooter)
            {
                return *m_oddFooter;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_evenHeader(){

            return m_has_evenHeader;
        
        }
        ns_s::ST_Xstring* mutable_evenHeader(){

                m_has_evenHeader = true;
                if (!m_evenHeader)
                {
                    m_evenHeader = new ns_s::ST_Xstring();
                }
                return m_evenHeader;
            
        }
        const ns_s::ST_Xstring& evenHeader(){

            if (m_evenHeader)
            {
                return *m_evenHeader;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_evenFooter(){

            return m_has_evenFooter;
        
        }
        ns_s::ST_Xstring* mutable_evenFooter(){

                m_has_evenFooter = true;
                if (!m_evenFooter)
                {
                    m_evenFooter = new ns_s::ST_Xstring();
                }
                return m_evenFooter;
            
        }
        const ns_s::ST_Xstring& evenFooter(){

            if (m_evenFooter)
            {
                return *m_evenFooter;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_firstHeader(){

            return m_has_firstHeader;
        
        }
        ns_s::ST_Xstring* mutable_firstHeader(){

                m_has_firstHeader = true;
                if (!m_firstHeader)
                {
                    m_firstHeader = new ns_s::ST_Xstring();
                }
                return m_firstHeader;
            
        }
        const ns_s::ST_Xstring& firstHeader(){

            if (m_firstHeader)
            {
                return *m_firstHeader;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_firstFooter(){

            return m_has_firstFooter;
        
        }
        ns_s::ST_Xstring* mutable_firstFooter(){

                m_has_firstFooter = true;
                if (!m_firstFooter)
                {
                    m_firstFooter = new ns_s::ST_Xstring();
                }
                return m_firstFooter;
            
        }
        const ns_s::ST_Xstring& firstFooter(){

            if (m_firstFooter)
            {
                return *m_firstFooter;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        void clear(){

                m_has_differentOddEven_attr = false;
                m_differentOddEven_attr = false;
            
                m_has_differentFirst_attr = false;
                m_differentFirst_attr = false;
            
                m_has_scaleWithDoc_attr = false;
                m_scaleWithDoc_attr = false;
            
                m_has_alignWithMargins_attr = false;
                m_alignWithMargins_attr = false;
            
                m_has_oddHeader = false;
                
        if (m_oddHeader)
        {
            delete m_oddHeader;
            m_oddHeader = NULL;
        }
    
            
                m_has_oddFooter = false;
                
        if (m_oddFooter)
        {
            delete m_oddFooter;
            m_oddFooter = NULL;
        }
    
            
                m_has_evenHeader = false;
                
        if (m_evenHeader)
        {
            delete m_evenHeader;
            m_evenHeader = NULL;
        }
    
            
                m_has_evenFooter = false;
                
        if (m_evenFooter)
        {
            delete m_evenFooter;
            m_evenFooter = NULL;
        }
    
            
                m_has_firstHeader = false;
                
        if (m_firstHeader)
        {
            delete m_firstHeader;
            m_firstHeader = NULL;
        }
    
            
                m_has_firstFooter = false;
                
        if (m_firstFooter)
        {
            delete m_firstFooter;
            m_firstFooter = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_differentOddEven_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_differentFirst_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_scaleWithDoc_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_alignWithMargins_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_oddHeader)
                {
                    _outStream << \<oddHeader>\ << m_oddHeader->toString() << \</oddHeader>\;;
                }
            
                if (m_has_oddFooter)
                {
                    _outStream << \<oddFooter>\ << m_oddHeader->toString() << \</oddFooter>\;;
                }
            
                if (m_has_evenHeader)
                {
                    _outStream << \<evenHeader>\ << m_oddHeader->toString() << \</evenHeader>\;;
                }
            
                if (m_has_evenFooter)
                {
                    _outStream << \<evenFooter>\ << m_oddHeader->toString() << \</evenFooter>\;;
                }
            
                if (m_has_firstHeader)
                {
                    _outStream << \<firstHeader>\ << m_oddHeader->toString() << \</firstHeader>\;;
                }
            
                if (m_has_firstFooter)
                {
                    _outStream << \<firstFooter>\ << m_oddHeader->toString() << \</firstFooter>\;;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_HeaderFooter& default_instance(){

    if (!CT_HeaderFooter::default_instance_)
    {
        CT_HeaderFooter::default_instance_ = new CT_HeaderFooter();
    }
    return *CT_HeaderFooter::default_instance_;

        }
        bool has_differentOddEven_attr(){

            return m_has_differentOddEven_attr;
        
        }
        void set_differentOddEven_attr(const boolean& _differentOddEven_attr ){

        m_has_differentOddEven_attr = true;
        m_differentOddEven_attr = _differentOddEven_attr;
        
        }
        const boolean& differentOddEven_attr(){

            return type: oolean\nname: \m_differentOddEven_attr\n;
        
        }
        bool has_differentFirst_attr(){

            return m_has_differentFirst_attr;
        
        }
        void set_differentFirst_attr(const boolean& _differentFirst_attr ){

        m_has_differentFirst_attr = true;
        m_differentFirst_attr = _differentFirst_attr;
        
        }
        const boolean& differentFirst_attr(){

            return type: oolean\nname: \m_differentFirst_attr\n;
        
        }
        bool has_scaleWithDoc_attr(){

            return m_has_scaleWithDoc_attr;
        
        }
        void set_scaleWithDoc_attr(const boolean& _scaleWithDoc_attr ){

        m_has_scaleWithDoc_attr = true;
        m_scaleWithDoc_attr = _scaleWithDoc_attr;
        
        }
        const boolean& scaleWithDoc_attr(){

            return type: oolean\nname: \m_scaleWithDoc_attr\n;
        
        }
        bool has_alignWithMargins_attr(){

            return m_has_alignWithMargins_attr;
        
        }
        void set_alignWithMargins_attr(const boolean& _alignWithMargins_attr ){

        m_has_alignWithMargins_attr = true;
        m_alignWithMargins_attr = _alignWithMargins_attr;
        
        }
        const boolean& alignWithMargins_attr(){

            return type: oolean\nname: \m_alignWithMargins_attr\n;
        
        }

    private:
        bool m_has_oddHeader ;
        ns_s::ST_Xstring* m_oddHeader ;
        bool m_has_oddFooter ;
        ns_s::ST_Xstring* m_oddFooter ;
        bool m_has_evenHeader ;
        ns_s::ST_Xstring* m_evenHeader ;
        bool m_has_evenFooter ;
        ns_s::ST_Xstring* m_evenFooter ;
        bool m_has_firstHeader ;
        ns_s::ST_Xstring* m_firstHeader ;
        bool m_has_firstFooter ;
        ns_s::ST_Xstring* m_firstFooter ;
        static CT_HeaderFooter* default_instance_ ;
        bool m_has_differentOddEven_attr ;
        boolean m_differentOddEven_attr ;
        bool m_has_differentFirst_attr ;
        boolean m_differentFirst_attr ;
        bool m_has_scaleWithDoc_attr ;
        boolean m_scaleWithDoc_attr ;
        bool m_has_alignWithMargins_attr ;
        boolean m_alignWithMargins_attr ;

    }

    class CT_Scenarios : public XSD::ComplexType{
    public:
        bool has_scenario(){

            return m_has_scenario;
        
        }
        CT_Scenario* mutable_scenario(){

                m_has_scenario = true;
                if (!m_scenario)
                {
                    m_scenario = new CT_Scenario();
                }
                return m_scenario;
            
        }
        const CT_Scenario& scenario(){

            if (m_scenario)
            {
                return *m_scenario;
            }
            return CT_Scenario::default_instance();
        
        }
        void clear(){

                m_has_current_attr = false;
                m_current_attr = 0;
            
                m_has_show_attr = false;
                m_show_attr = 0;
            
                m_has_sqref_attr = false;
                
        if (m_sqref_attr)
        {
            delete m_sqref_attr;
            m_sqref_attr = NULL;
        }
    
            
                m_has_scenario = false;
                
        if (m_scenario)
        {
            delete m_scenario;
            m_scenario = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_current_attr << \\\;
_outStream << _attrName << \=\\ << m_show_attr << \\\;
m_sqref_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_scenario)
                {
                    m_scenario->toXml(scenario, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Scenarios& default_instance(){

    if (!CT_Scenarios::default_instance_)
    {
        CT_Scenarios::default_instance_ = new CT_Scenarios();
    }
    return *CT_Scenarios::default_instance_;

        }
        bool has_current_attr(){

            return m_has_current_attr;
        
        }
        void set_current_attr(const unsignedInt& _current_attr ){

        m_has_current_attr = true;
        m_current_attr = _current_attr;
        
        }
        const unsignedInt& current_attr(){

            return type: \unsignedInt\nname: \m_current_attr\n;
        
        }
        bool has_show_attr(){

            return m_has_show_attr;
        
        }
        void set_show_attr(const unsignedInt& _show_attr ){

        m_has_show_attr = true;
        m_show_attr = _show_attr;
        
        }
        const unsignedInt& show_attr(){

            return type: \unsignedInt\nname: \m_show_attr\n;
        
        }
        bool has_sqref_attr(){

            return m_has_sqref_attr;
        
        }
        void set_sqref_attr(const ST_Sqref& _sqref_attr ){

            m_has_sqref_attr = true;
            m_sqref_attr = new ST_Sqref(_sqref_attr);
        
        }
        const ST_Sqref& sqref_attr(){

            if (m_sqref_attr)
            {
                return *m_sqref_attr;
            }
            return ST_Sqref::default_instance();
        
        }

    private:
        bool m_has_scenario ;
        CT_Scenario* m_scenario ;
        static CT_Scenarios* default_instance_ ;
        bool m_has_current_attr ;
        unsignedInt m_current_attr ;
        bool m_has_show_attr ;
        unsignedInt m_show_attr ;
        bool m_has_sqref_attr ;
        ST_Sqref* m_sqref_attr ;

    }

    class CT_SheetProtection : public XSD::ComplexType{
    public:
        void clear(){

                m_has_password_attr = false;
                
        if (m_password_attr)
        {
            delete m_password_attr;
            m_password_attr = NULL;
        }
    
            
                m_has_algorithmName_attr = false;
                
        if (m_algorithmName_attr)
        {
            delete m_algorithmName_attr;
            m_algorithmName_attr = NULL;
        }
    
            
                m_has_hashValue_attr = false;
                m_hashValue_attr.clear();
            
                m_has_saltValue_attr = false;
                m_saltValue_attr.clear();
            
                m_has_spinCount_attr = false;
                m_spinCount_attr = 0;
            
                m_has_sheet_attr = false;
                m_sheet_attr = false;
            
                m_has_objects_attr = false;
                m_objects_attr = false;
            
                m_has_scenarios_attr = false;
                m_scenarios_attr = false;
            
                m_has_formatCells_attr = false;
                m_formatCells_attr = false;
            
                m_has_formatColumns_attr = false;
                m_formatColumns_attr = false;
            
                m_has_formatRows_attr = false;
                m_formatRows_attr = false;
            
                m_has_insertColumns_attr = false;
                m_insertColumns_attr = false;
            
                m_has_insertRows_attr = false;
                m_insertRows_attr = false;
            
                m_has_insertHyperlinks_attr = false;
                m_insertHyperlinks_attr = false;
            
                m_has_deleteColumns_attr = false;
                m_deleteColumns_attr = false;
            
                m_has_deleteRows_attr = false;
                m_deleteRows_attr = false;
            
                m_has_selectLockedCells_attr = false;
                m_selectLockedCells_attr = false;
            
                m_has_sort_attr = false;
                m_sort_attr = false;
            
                m_has_autoFilter_attr = false;
                m_autoFilter_attr = false;
            
                m_has_pivotTables_attr = false;
                m_pivotTables_attr = false;
            
                m_has_selectUnlockedCells_attr = false;
                m_selectUnlockedCells_attr = false;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_password_attr->toXml(_attrName, _outStream);
m_algorithmName_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_hashValue_attr << \\\;
_outStream << _attrName << \=\\ << m_saltValue_attr << \\\;
_outStream << _attrName << \=\\ << m_spinCount_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_sheet_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_objects_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_scenarios_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_formatCells_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_formatColumns_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_formatRows_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_insertColumns_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_insertRows_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_insertHyperlinks_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_deleteColumns_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_deleteRows_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_selectLockedCells_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_sort_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_autoFilter_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_pivotTables_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_selectUnlockedCells_attr) << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_SheetProtection& default_instance(){

    if (!CT_SheetProtection::default_instance_)
    {
        CT_SheetProtection::default_instance_ = new CT_SheetProtection();
    }
    return *CT_SheetProtection::default_instance_;

        }
        bool has_password_attr(){

            return m_has_password_attr;
        
        }
        void set_password_attr(const ST_UnsignedShortHex& _password_attr ){

            m_has_password_attr = true;
            m_password_attr = new ST_UnsignedShortHex(_password_attr);
        
        }
        const ST_UnsignedShortHex& password_attr(){

            if (m_password_attr)
            {
                return *m_password_attr;
            }
            return ST_UnsignedShortHex::default_instance();
        
        }
        bool has_algorithmName_attr(){

            return m_has_algorithmName_attr;
        
        }
        void set_algorithmName_attr(const ns_s::ST_Xstring& _algorithmName_attr ){

            m_has_algorithmName_attr = true;
            m_algorithmName_attr = new ns_s::ST_Xstring(_algorithmName_attr);
        
        }
        const ns_s::ST_Xstring& algorithmName_attr(){

            if (m_algorithmName_attr)
            {
                return *m_algorithmName_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_hashValue_attr(){

            return m_has_hashValue_attr;
        
        }
        void set_hashValue_attr(const base64Binary& _hashValue_attr ){

        m_has_hashValue_attr = true;
        m_hashValue_attr = _hashValue_attr;
        
        }
        const base64Binary& hashValue_attr(){

            return type: ase64Binary\nname: \m_hashValue_attr\n;
        
        }
        bool has_saltValue_attr(){

            return m_has_saltValue_attr;
        
        }
        void set_saltValue_attr(const base64Binary& _saltValue_attr ){

        m_has_saltValue_attr = true;
        m_saltValue_attr = _saltValue_attr;
        
        }
        const base64Binary& saltValue_attr(){

            return type: ase64Binary\nname: \m_saltValue_attr\n;
        
        }
        bool has_spinCount_attr(){

            return m_has_spinCount_attr;
        
        }
        void set_spinCount_attr(const unsignedInt& _spinCount_attr ){

        m_has_spinCount_attr = true;
        m_spinCount_attr = _spinCount_attr;
        
        }
        const unsignedInt& spinCount_attr(){

            return type: \unsignedInt\nname: \m_spinCount_attr\n;
        
        }
        bool has_sheet_attr(){

            return m_has_sheet_attr;
        
        }
        void set_sheet_attr(const boolean& _sheet_attr ){

        m_has_sheet_attr = true;
        m_sheet_attr = _sheet_attr;
        
        }
        const boolean& sheet_attr(){

            return type: oolean\nname: \m_sheet_attr\n;
        
        }
        bool has_objects_attr(){

            return m_has_objects_attr;
        
        }
        void set_objects_attr(const boolean& _objects_attr ){

        m_has_objects_attr = true;
        m_objects_attr = _objects_attr;
        
        }
        const boolean& objects_attr(){

            return type: oolean\nname: \m_objects_attr\n;
        
        }
        bool has_scenarios_attr(){

            return m_has_scenarios_attr;
        
        }
        void set_scenarios_attr(const boolean& _scenarios_attr ){

        m_has_scenarios_attr = true;
        m_scenarios_attr = _scenarios_attr;
        
        }
        const boolean& scenarios_attr(){

            return type: oolean\nname: \m_scenarios_attr\n;
        
        }
        bool has_formatCells_attr(){

            return m_has_formatCells_attr;
        
        }
        void set_formatCells_attr(const boolean& _formatCells_attr ){

        m_has_formatCells_attr = true;
        m_formatCells_attr = _formatCells_attr;
        
        }
        const boolean& formatCells_attr(){

            return type: oolean\nname: \m_formatCells_attr\n;
        
        }
        bool has_formatColumns_attr(){

            return m_has_formatColumns_attr;
        
        }
        void set_formatColumns_attr(const boolean& _formatColumns_attr ){

        m_has_formatColumns_attr = true;
        m_formatColumns_attr = _formatColumns_attr;
        
        }
        const boolean& formatColumns_attr(){

            return type: oolean\nname: \m_formatColumns_attr\n;
        
        }
        bool has_formatRows_attr(){

            return m_has_formatRows_attr;
        
        }
        void set_formatRows_attr(const boolean& _formatRows_attr ){

        m_has_formatRows_attr = true;
        m_formatRows_attr = _formatRows_attr;
        
        }
        const boolean& formatRows_attr(){

            return type: oolean\nname: \m_formatRows_attr\n;
        
        }
        bool has_insertColumns_attr(){

            return m_has_insertColumns_attr;
        
        }
        void set_insertColumns_attr(const boolean& _insertColumns_attr ){

        m_has_insertColumns_attr = true;
        m_insertColumns_attr = _insertColumns_attr;
        
        }
        const boolean& insertColumns_attr(){

            return type: oolean\nname: \m_insertColumns_attr\n;
        
        }
        bool has_insertRows_attr(){

            return m_has_insertRows_attr;
        
        }
        void set_insertRows_attr(const boolean& _insertRows_attr ){

        m_has_insertRows_attr = true;
        m_insertRows_attr = _insertRows_attr;
        
        }
        const boolean& insertRows_attr(){

            return type: oolean\nname: \m_insertRows_attr\n;
        
        }
        bool has_insertHyperlinks_attr(){

            return m_has_insertHyperlinks_attr;
        
        }
        void set_insertHyperlinks_attr(const boolean& _insertHyperlinks_attr ){

        m_has_insertHyperlinks_attr = true;
        m_insertHyperlinks_attr = _insertHyperlinks_attr;
        
        }
        const boolean& insertHyperlinks_attr(){

            return type: oolean\nname: \m_insertHyperlinks_attr\n;
        
        }
        bool has_deleteColumns_attr(){

            return m_has_deleteColumns_attr;
        
        }
        void set_deleteColumns_attr(const boolean& _deleteColumns_attr ){

        m_has_deleteColumns_attr = true;
        m_deleteColumns_attr = _deleteColumns_attr;
        
        }
        const boolean& deleteColumns_attr(){

            return type: oolean\nname: \m_deleteColumns_attr\n;
        
        }
        bool has_deleteRows_attr(){

            return m_has_deleteRows_attr;
        
        }
        void set_deleteRows_attr(const boolean& _deleteRows_attr ){

        m_has_deleteRows_attr = true;
        m_deleteRows_attr = _deleteRows_attr;
        
        }
        const boolean& deleteRows_attr(){

            return type: oolean\nname: \m_deleteRows_attr\n;
        
        }
        bool has_selectLockedCells_attr(){

            return m_has_selectLockedCells_attr;
        
        }
        void set_selectLockedCells_attr(const boolean& _selectLockedCells_attr ){

        m_has_selectLockedCells_attr = true;
        m_selectLockedCells_attr = _selectLockedCells_attr;
        
        }
        const boolean& selectLockedCells_attr(){

            return type: oolean\nname: \m_selectLockedCells_attr\n;
        
        }
        bool has_sort_attr(){

            return m_has_sort_attr;
        
        }
        void set_sort_attr(const boolean& _sort_attr ){

        m_has_sort_attr = true;
        m_sort_attr = _sort_attr;
        
        }
        const boolean& sort_attr(){

            return type: oolean\nname: \m_sort_attr\n;
        
        }
        bool has_autoFilter_attr(){

            return m_has_autoFilter_attr;
        
        }
        void set_autoFilter_attr(const boolean& _autoFilter_attr ){

        m_has_autoFilter_attr = true;
        m_autoFilter_attr = _autoFilter_attr;
        
        }
        const boolean& autoFilter_attr(){

            return type: oolean\nname: \m_autoFilter_attr\n;
        
        }
        bool has_pivotTables_attr(){

            return m_has_pivotTables_attr;
        
        }
        void set_pivotTables_attr(const boolean& _pivotTables_attr ){

        m_has_pivotTables_attr = true;
        m_pivotTables_attr = _pivotTables_attr;
        
        }
        const boolean& pivotTables_attr(){

            return type: oolean\nname: \m_pivotTables_attr\n;
        
        }
        bool has_selectUnlockedCells_attr(){

            return m_has_selectUnlockedCells_attr;
        
        }
        void set_selectUnlockedCells_attr(const boolean& _selectUnlockedCells_attr ){

        m_has_selectUnlockedCells_attr = true;
        m_selectUnlockedCells_attr = _selectUnlockedCells_attr;
        
        }
        const boolean& selectUnlockedCells_attr(){

            return type: oolean\nname: \m_selectUnlockedCells_attr\n;
        
        }

    private:
        static CT_SheetProtection* default_instance_ ;
        bool m_has_password_attr ;
        ST_UnsignedShortHex* m_password_attr ;
        bool m_has_algorithmName_attr ;
        ns_s::ST_Xstring* m_algorithmName_attr ;
        bool m_has_hashValue_attr ;
        base64Binary m_hashValue_attr ;
        bool m_has_saltValue_attr ;
        base64Binary m_saltValue_attr ;
        bool m_has_spinCount_attr ;
        unsignedInt m_spinCount_attr ;
        bool m_has_sheet_attr ;
        boolean m_sheet_attr ;
        bool m_has_objects_attr ;
        boolean m_objects_attr ;
        bool m_has_scenarios_attr ;
        boolean m_scenarios_attr ;
        bool m_has_formatCells_attr ;
        boolean m_formatCells_attr ;
        bool m_has_formatColumns_attr ;
        boolean m_formatColumns_attr ;
        bool m_has_formatRows_attr ;
        boolean m_formatRows_attr ;
        bool m_has_insertColumns_attr ;
        boolean m_insertColumns_attr ;
        bool m_has_insertRows_attr ;
        boolean m_insertRows_attr ;
        bool m_has_insertHyperlinks_attr ;
        boolean m_insertHyperlinks_attr ;
        bool m_has_deleteColumns_attr ;
        boolean m_deleteColumns_attr ;
        bool m_has_deleteRows_attr ;
        boolean m_deleteRows_attr ;
        bool m_has_selectLockedCells_attr ;
        boolean m_selectLockedCells_attr ;
        bool m_has_sort_attr ;
        boolean m_sort_attr ;
        bool m_has_autoFilter_attr ;
        boolean m_autoFilter_attr ;
        bool m_has_pivotTables_attr ;
        boolean m_pivotTables_attr ;
        bool m_has_selectUnlockedCells_attr ;
        boolean m_selectUnlockedCells_attr ;

    }

    class CT_ProtectedRanges : public XSD::ComplexType{
    public:
        bool has_protectedRange(){

            return m_has_protectedRange;
        
        }
        CT_ProtectedRange* mutable_protectedRange(){

                m_has_protectedRange = true;
                if (!m_protectedRange)
                {
                    m_protectedRange = new CT_ProtectedRange();
                }
                return m_protectedRange;
            
        }
        const CT_ProtectedRange& protectedRange(){

            if (m_protectedRange)
            {
                return *m_protectedRange;
            }
            return CT_ProtectedRange::default_instance();
        
        }
        void clear(){

                m_has_protectedRange = false;
                
        if (m_protectedRange)
        {
            delete m_protectedRange;
            m_protectedRange = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_protectedRange)
                {
                    m_protectedRange->toXml(protectedRange, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_ProtectedRanges& default_instance(){

    if (!CT_ProtectedRanges::default_instance_)
    {
        CT_ProtectedRanges::default_instance_ = new CT_ProtectedRanges();
    }
    return *CT_ProtectedRanges::default_instance_;

        }

    private:
        bool m_has_protectedRange ;
        CT_ProtectedRange* m_protectedRange ;
        static CT_ProtectedRanges* default_instance_ ;

    }

    class CT_ProtectedRange : public XSD::ComplexType{
    public:
        bool has_securityDescriptor(){

        return m_has_securityDescriptor;
    
        }
        void set_securityDescriptor(const string& _securityDescriptor ){

            m_has_securityDescriptor = true;
            string = _securityDescriptor;
            
        }
        const string& securityDescriptor(){

        return type: \string\nname: \m_securityDescriptor\n;
    
        }
        void clear(){

                m_has_password_attr = false;
                
        if (m_password_attr)
        {
            delete m_password_attr;
            m_password_attr = NULL;
        }
    
            
                m_has_sqref_attr = false;
                
        if (m_sqref_attr)
        {
            delete m_sqref_attr;
            m_sqref_attr = NULL;
        }
    
            
                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
                m_has_securityDescriptor_attr = false;
                m_securityDescriptor_attr.clear();
            
                m_has_algorithmName_attr = false;
                
        if (m_algorithmName_attr)
        {
            delete m_algorithmName_attr;
            m_algorithmName_attr = NULL;
        }
    
            
                m_has_hashValue_attr = false;
                m_hashValue_attr.clear();
            
                m_has_saltValue_attr = false;
                m_saltValue_attr.clear();
            
                m_has_spinCount_attr = false;
                m_spinCount_attr = 0;
            
                m_has_securityDescriptor = false;
                m_securityDescriptor.clear();
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_password_attr->toXml(_attrName, _outStream);
m_sqref_attr->toXml(_attrName, _outStream);
m_name_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_securityDescriptor_attr << \\\;
m_algorithmName_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_hashValue_attr << \\\;
_outStream << _attrName << \=\\ << m_saltValue_attr << \\\;
_outStream << _attrName << \=\\ << m_spinCount_attr << \\\;
        _outStream << \>\;
    
                if (m_has_securityDescriptor)
                {
                    _outStream << \<securityDescriptor>\ << m_securityDescriptor << \</securityDescriptor>\;;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_ProtectedRange& default_instance(){

    if (!CT_ProtectedRange::default_instance_)
    {
        CT_ProtectedRange::default_instance_ = new CT_ProtectedRange();
    }
    return *CT_ProtectedRange::default_instance_;

        }
        bool has_password_attr(){

            return m_has_password_attr;
        
        }
        void set_password_attr(const ST_UnsignedShortHex& _password_attr ){

            m_has_password_attr = true;
            m_password_attr = new ST_UnsignedShortHex(_password_attr);
        
        }
        const ST_UnsignedShortHex& password_attr(){

            if (m_password_attr)
            {
                return *m_password_attr;
            }
            return ST_UnsignedShortHex::default_instance();
        
        }
        bool has_sqref_attr(){

            return m_has_sqref_attr;
        
        }
        void set_sqref_attr(const ST_Sqref& _sqref_attr ){

            m_has_sqref_attr = true;
            m_sqref_attr = new ST_Sqref(_sqref_attr);
        
        }
        const ST_Sqref& sqref_attr(){

            if (m_sqref_attr)
            {
                return *m_sqref_attr;
            }
            return ST_Sqref::default_instance();
        
        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_securityDescriptor_attr(){

            return m_has_securityDescriptor_attr;
        
        }
        void set_securityDescriptor_attr(const string& _securityDescriptor_attr ){

        m_has_securityDescriptor_attr = true;
        m_securityDescriptor_attr = _securityDescriptor_attr;
        
        }
        const string& securityDescriptor_attr(){

            return type: \string\nname: \m_securityDescriptor_attr\n;
        
        }
        bool has_algorithmName_attr(){

            return m_has_algorithmName_attr;
        
        }
        void set_algorithmName_attr(const ns_s::ST_Xstring& _algorithmName_attr ){

            m_has_algorithmName_attr = true;
            m_algorithmName_attr = new ns_s::ST_Xstring(_algorithmName_attr);
        
        }
        const ns_s::ST_Xstring& algorithmName_attr(){

            if (m_algorithmName_attr)
            {
                return *m_algorithmName_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_hashValue_attr(){

            return m_has_hashValue_attr;
        
        }
        void set_hashValue_attr(const base64Binary& _hashValue_attr ){

        m_has_hashValue_attr = true;
        m_hashValue_attr = _hashValue_attr;
        
        }
        const base64Binary& hashValue_attr(){

            return type: ase64Binary\nname: \m_hashValue_attr\n;
        
        }
        bool has_saltValue_attr(){

            return m_has_saltValue_attr;
        
        }
        void set_saltValue_attr(const base64Binary& _saltValue_attr ){

        m_has_saltValue_attr = true;
        m_saltValue_attr = _saltValue_attr;
        
        }
        const base64Binary& saltValue_attr(){

            return type: ase64Binary\nname: \m_saltValue_attr\n;
        
        }
        bool has_spinCount_attr(){

            return m_has_spinCount_attr;
        
        }
        void set_spinCount_attr(const unsignedInt& _spinCount_attr ){

        m_has_spinCount_attr = true;
        m_spinCount_attr = _spinCount_attr;
        
        }
        const unsignedInt& spinCount_attr(){

            return type: \unsignedInt\nname: \m_spinCount_attr\n;
        
        }

    private:
        bool m_has_securityDescriptor ;
        string m_securityDescriptor ;
        static CT_ProtectedRange* default_instance_ ;
        bool m_has_password_attr ;
        ST_UnsignedShortHex* m_password_attr ;
        bool m_has_sqref_attr ;
        ST_Sqref* m_sqref_attr ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;
        bool m_has_securityDescriptor_attr ;
        string m_securityDescriptor_attr ;
        bool m_has_algorithmName_attr ;
        ns_s::ST_Xstring* m_algorithmName_attr ;
        bool m_has_hashValue_attr ;
        base64Binary m_hashValue_attr ;
        bool m_has_saltValue_attr ;
        base64Binary m_saltValue_attr ;
        bool m_has_spinCount_attr ;
        unsignedInt m_spinCount_attr ;

    }

    class CT_Scenario : public XSD::ComplexType{
    public:
        bool has_inputCells(){

            return m_has_inputCells;
        
        }
        CT_InputCells* mutable_inputCells(){

                m_has_inputCells = true;
                if (!m_inputCells)
                {
                    m_inputCells = new CT_InputCells();
                }
                return m_inputCells;
            
        }
        const CT_InputCells& inputCells(){

            if (m_inputCells)
            {
                return *m_inputCells;
            }
            return CT_InputCells::default_instance();
        
        }
        void clear(){

                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
                m_has_locked_attr = false;
                m_locked_attr = false;
            
                m_has_hidden_attr = false;
                m_hidden_attr = false;
            
                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_user_attr = false;
                
        if (m_user_attr)
        {
            delete m_user_attr;
            m_user_attr = NULL;
        }
    
            
                m_has_comment_attr = false;
                
        if (m_comment_attr)
        {
            delete m_comment_attr;
            m_comment_attr = NULL;
        }
    
            
                m_has_inputCells = false;
                
        if (m_inputCells)
        {
            delete m_inputCells;
            m_inputCells = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_name_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_locked_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_hidden_attr) << \\\;
_outStream << _attrName << \=\\ << m_count_attr << \\\;
m_user_attr->toXml(_attrName, _outStream);
m_comment_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_inputCells)
                {
                    m_inputCells->toXml(inputCells, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Scenario& default_instance(){

    if (!CT_Scenario::default_instance_)
    {
        CT_Scenario::default_instance_ = new CT_Scenario();
    }
    return *CT_Scenario::default_instance_;

        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_locked_attr(){

            return m_has_locked_attr;
        
        }
        void set_locked_attr(const boolean& _locked_attr ){

        m_has_locked_attr = true;
        m_locked_attr = _locked_attr;
        
        }
        const boolean& locked_attr(){

            return type: oolean\nname: \m_locked_attr\n;
        
        }
        bool has_hidden_attr(){

            return m_has_hidden_attr;
        
        }
        void set_hidden_attr(const boolean& _hidden_attr ){

        m_has_hidden_attr = true;
        m_hidden_attr = _hidden_attr;
        
        }
        const boolean& hidden_attr(){

            return type: oolean\nname: \m_hidden_attr\n;
        
        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }
        bool has_user_attr(){

            return m_has_user_attr;
        
        }
        void set_user_attr(const ns_s::ST_Xstring& _user_attr ){

            m_has_user_attr = true;
            m_user_attr = new ns_s::ST_Xstring(_user_attr);
        
        }
        const ns_s::ST_Xstring& user_attr(){

            if (m_user_attr)
            {
                return *m_user_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_comment_attr(){

            return m_has_comment_attr;
        
        }
        void set_comment_attr(const ns_s::ST_Xstring& _comment_attr ){

            m_has_comment_attr = true;
            m_comment_attr = new ns_s::ST_Xstring(_comment_attr);
        
        }
        const ns_s::ST_Xstring& comment_attr(){

            if (m_comment_attr)
            {
                return *m_comment_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }

    private:
        bool m_has_inputCells ;
        CT_InputCells* m_inputCells ;
        static CT_Scenario* default_instance_ ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;
        bool m_has_locked_attr ;
        boolean m_locked_attr ;
        bool m_has_hidden_attr ;
        boolean m_hidden_attr ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;
        bool m_has_user_attr ;
        ns_s::ST_Xstring* m_user_attr ;
        bool m_has_comment_attr ;
        ns_s::ST_Xstring* m_comment_attr ;

    }

    class CT_InputCells : public XSD::ComplexType{
    public:
        void clear(){

                m_has_r_attr = false;
                
        if (m_r_attr)
        {
            delete m_r_attr;
            m_r_attr = NULL;
        }
    
            
                m_has_deleted_attr = false;
                m_deleted_attr = false;
            
                m_has_undone_attr = false;
                m_undone_attr = false;
            
                m_has_val_attr = false;
                
        if (m_val_attr)
        {
            delete m_val_attr;
            m_val_attr = NULL;
        }
    
            
                m_has_numFmtId_attr = false;
                
        if (m_numFmtId_attr)
        {
            delete m_numFmtId_attr;
            m_numFmtId_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_r_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_deleted_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_undone_attr) << \\\;
m_val_attr->toXml(_attrName, _outStream);
m_numFmtId_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_InputCells& default_instance(){

    if (!CT_InputCells::default_instance_)
    {
        CT_InputCells::default_instance_ = new CT_InputCells();
    }
    return *CT_InputCells::default_instance_;

        }
        bool has_r_attr(){

            return m_has_r_attr;
        
        }
        void set_r_attr(const ST_CellRef& _r_attr ){

            m_has_r_attr = true;
            m_r_attr = new ST_CellRef(_r_attr);
        
        }
        const ST_CellRef& r_attr(){

            if (m_r_attr)
            {
                return *m_r_attr;
            }
            return ST_CellRef::default_instance();
        
        }
        bool has_deleted_attr(){

            return m_has_deleted_attr;
        
        }
        void set_deleted_attr(const boolean& _deleted_attr ){

        m_has_deleted_attr = true;
        m_deleted_attr = _deleted_attr;
        
        }
        const boolean& deleted_attr(){

            return type: oolean\nname: \m_deleted_attr\n;
        
        }
        bool has_undone_attr(){

            return m_has_undone_attr;
        
        }
        void set_undone_attr(const boolean& _undone_attr ){

        m_has_undone_attr = true;
        m_undone_attr = _undone_attr;
        
        }
        const boolean& undone_attr(){

            return type: oolean\nname: \m_undone_attr\n;
        
        }
        bool has_val_attr(){

            return m_has_val_attr;
        
        }
        void set_val_attr(const ns_s::ST_Xstring& _val_attr ){

            m_has_val_attr = true;
            m_val_attr = new ns_s::ST_Xstring(_val_attr);
        
        }
        const ns_s::ST_Xstring& val_attr(){

            if (m_val_attr)
            {
                return *m_val_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_numFmtId_attr(){

            return m_has_numFmtId_attr;
        
        }
        void set_numFmtId_attr(const ST_NumFmtId& _numFmtId_attr ){

            m_has_numFmtId_attr = true;
            m_numFmtId_attr = new ST_NumFmtId(_numFmtId_attr);
        
        }
        const ST_NumFmtId& numFmtId_attr(){

            if (m_numFmtId_attr)
            {
                return *m_numFmtId_attr;
            }
            return ST_NumFmtId::default_instance();
        
        }

    private:
        static CT_InputCells* default_instance_ ;
        bool m_has_r_attr ;
        ST_CellRef* m_r_attr ;
        bool m_has_deleted_attr ;
        boolean m_deleted_attr ;
        bool m_has_undone_attr ;
        boolean m_undone_attr ;
        bool m_has_val_attr ;
        ns_s::ST_Xstring* m_val_attr ;
        bool m_has_numFmtId_attr ;
        ST_NumFmtId* m_numFmtId_attr ;

    }

    class CT_CellWatches : public XSD::ComplexType{
    public:
        bool has_cellWatch(){

            return m_has_cellWatch;
        
        }
        CT_CellWatch* mutable_cellWatch(){

                m_has_cellWatch = true;
                if (!m_cellWatch)
                {
                    m_cellWatch = new CT_CellWatch();
                }
                return m_cellWatch;
            
        }
        const CT_CellWatch& cellWatch(){

            if (m_cellWatch)
            {
                return *m_cellWatch;
            }
            return CT_CellWatch::default_instance();
        
        }
        void clear(){

                m_has_cellWatch = false;
                
        if (m_cellWatch)
        {
            delete m_cellWatch;
            m_cellWatch = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_cellWatch)
                {
                    m_cellWatch->toXml(cellWatch, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CellWatches& default_instance(){

    if (!CT_CellWatches::default_instance_)
    {
        CT_CellWatches::default_instance_ = new CT_CellWatches();
    }
    return *CT_CellWatches::default_instance_;

        }

    private:
        bool m_has_cellWatch ;
        CT_CellWatch* m_cellWatch ;
        static CT_CellWatches* default_instance_ ;

    }

    class CT_CellWatch : public XSD::ComplexType{
    public:
        void clear(){

                m_has_r_attr = false;
                
        if (m_r_attr)
        {
            delete m_r_attr;
            m_r_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_r_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CellWatch& default_instance(){

    if (!CT_CellWatch::default_instance_)
    {
        CT_CellWatch::default_instance_ = new CT_CellWatch();
    }
    return *CT_CellWatch::default_instance_;

        }
        bool has_r_attr(){

            return m_has_r_attr;
        
        }
        void set_r_attr(const ST_CellRef& _r_attr ){

            m_has_r_attr = true;
            m_r_attr = new ST_CellRef(_r_attr);
        
        }
        const ST_CellRef& r_attr(){

            if (m_r_attr)
            {
                return *m_r_attr;
            }
            return ST_CellRef::default_instance();
        
        }

    private:
        static CT_CellWatch* default_instance_ ;
        bool m_has_r_attr ;
        ST_CellRef* m_r_attr ;

    }

    class CT_Chartsheet : public XSD::ComplexType{
    public:
        bool has_sheetPr(){

            return m_has_sheetPr;
        
        }
        CT_ChartsheetPr* mutable_sheetPr(){

                m_has_sheetPr = true;
                if (!m_sheetPr)
                {
                    m_sheetPr = new CT_ChartsheetPr();
                }
                return m_sheetPr;
            
        }
        const CT_ChartsheetPr& sheetPr(){

            if (m_sheetPr)
            {
                return *m_sheetPr;
            }
            return CT_ChartsheetPr::default_instance();
        
        }
        bool has_sheetViews(){

            return m_has_sheetViews;
        
        }
        CT_ChartsheetViews* mutable_sheetViews(){

                m_has_sheetViews = true;
                if (!m_sheetViews)
                {
                    m_sheetViews = new CT_ChartsheetViews();
                }
                return m_sheetViews;
            
        }
        const CT_ChartsheetViews& sheetViews(){

            if (m_sheetViews)
            {
                return *m_sheetViews;
            }
            return CT_ChartsheetViews::default_instance();
        
        }
        bool has_sheetProtection(){

            return m_has_sheetProtection;
        
        }
        CT_ChartsheetProtection* mutable_sheetProtection(){

                m_has_sheetProtection = true;
                if (!m_sheetProtection)
                {
                    m_sheetProtection = new CT_ChartsheetProtection();
                }
                return m_sheetProtection;
            
        }
        const CT_ChartsheetProtection& sheetProtection(){

            if (m_sheetProtection)
            {
                return *m_sheetProtection;
            }
            return CT_ChartsheetProtection::default_instance();
        
        }
        bool has_customSheetViews(){

            return m_has_customSheetViews;
        
        }
        CT_CustomChartsheetViews* mutable_customSheetViews(){

                m_has_customSheetViews = true;
                if (!m_customSheetViews)
                {
                    m_customSheetViews = new CT_CustomChartsheetViews();
                }
                return m_customSheetViews;
            
        }
        const CT_CustomChartsheetViews& customSheetViews(){

            if (m_customSheetViews)
            {
                return *m_customSheetViews;
            }
            return CT_CustomChartsheetViews::default_instance();
        
        }
        bool has_pageMargins(){

            return m_has_pageMargins;
        
        }
        CT_PageMargins* mutable_pageMargins(){

                m_has_pageMargins = true;
                if (!m_pageMargins)
                {
                    m_pageMargins = new CT_PageMargins();
                }
                return m_pageMargins;
            
        }
        const CT_PageMargins& pageMargins(){

            if (m_pageMargins)
            {
                return *m_pageMargins;
            }
            return CT_PageMargins::default_instance();
        
        }
        bool has_pageSetup(){

            return m_has_pageSetup;
        
        }
        CT_CsPageSetup* mutable_pageSetup(){

                m_has_pageSetup = true;
                if (!m_pageSetup)
                {
                    m_pageSetup = new CT_CsPageSetup();
                }
                return m_pageSetup;
            
        }
        const CT_CsPageSetup& pageSetup(){

            if (m_pageSetup)
            {
                return *m_pageSetup;
            }
            return CT_CsPageSetup::default_instance();
        
        }
        bool has_headerFooter(){

            return m_has_headerFooter;
        
        }
        CT_HeaderFooter* mutable_headerFooter(){

                m_has_headerFooter = true;
                if (!m_headerFooter)
                {
                    m_headerFooter = new CT_HeaderFooter();
                }
                return m_headerFooter;
            
        }
        const CT_HeaderFooter& headerFooter(){

            if (m_headerFooter)
            {
                return *m_headerFooter;
            }
            return CT_HeaderFooter::default_instance();
        
        }
        bool has_drawing(){

            return m_has_drawing;
        
        }
        CT_Drawing* mutable_drawing(){

                m_has_drawing = true;
                if (!m_drawing)
                {
                    m_drawing = new CT_Drawing();
                }
                return m_drawing;
            
        }
        const CT_Drawing& drawing(){

            if (m_drawing)
            {
                return *m_drawing;
            }
            return CT_Drawing::default_instance();
        
        }
        bool has_legacyDrawing(){

            return m_has_legacyDrawing;
        
        }
        CT_LegacyDrawing* mutable_legacyDrawing(){

                m_has_legacyDrawing = true;
                if (!m_legacyDrawing)
                {
                    m_legacyDrawing = new CT_LegacyDrawing();
                }
                return m_legacyDrawing;
            
        }
        const CT_LegacyDrawing& legacyDrawing(){

            if (m_legacyDrawing)
            {
                return *m_legacyDrawing;
            }
            return CT_LegacyDrawing::default_instance();
        
        }
        bool has_legacyDrawingHF(){

            return m_has_legacyDrawingHF;
        
        }
        CT_LegacyDrawing* mutable_legacyDrawingHF(){

                m_has_legacyDrawingHF = true;
                if (!m_legacyDrawingHF)
                {
                    m_legacyDrawingHF = new CT_LegacyDrawing();
                }
                return m_legacyDrawingHF;
            
        }
        const CT_LegacyDrawing& legacyDrawingHF(){

            if (m_legacyDrawingHF)
            {
                return *m_legacyDrawingHF;
            }
            return CT_LegacyDrawing::default_instance();
        
        }
        bool has_drawingHF(){

            return m_has_drawingHF;
        
        }
        CT_DrawingHF* mutable_drawingHF(){

                m_has_drawingHF = true;
                if (!m_drawingHF)
                {
                    m_drawingHF = new CT_DrawingHF();
                }
                return m_drawingHF;
            
        }
        const CT_DrawingHF& drawingHF(){

            if (m_drawingHF)
            {
                return *m_drawingHF;
            }
            return CT_DrawingHF::default_instance();
        
        }
        bool has_picture(){

            return m_has_picture;
        
        }
        CT_SheetBackgroundPicture* mutable_picture(){

                m_has_picture = true;
                if (!m_picture)
                {
                    m_picture = new CT_SheetBackgroundPicture();
                }
                return m_picture;
            
        }
        const CT_SheetBackgroundPicture& picture(){

            if (m_picture)
            {
                return *m_picture;
            }
            return CT_SheetBackgroundPicture::default_instance();
        
        }
        bool has_webPublishItems(){

            return m_has_webPublishItems;
        
        }
        CT_WebPublishItems* mutable_webPublishItems(){

                m_has_webPublishItems = true;
                if (!m_webPublishItems)
                {
                    m_webPublishItems = new CT_WebPublishItems();
                }
                return m_webPublishItems;
            
        }
        const CT_WebPublishItems& webPublishItems(){

            if (m_webPublishItems)
            {
                return *m_webPublishItems;
            }
            return CT_WebPublishItems::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_sheetPr = false;
                
        if (m_sheetPr)
        {
            delete m_sheetPr;
            m_sheetPr = NULL;
        }
    
            
                m_has_sheetViews = false;
                
        if (m_sheetViews)
        {
            delete m_sheetViews;
            m_sheetViews = NULL;
        }
    
            
                m_has_sheetProtection = false;
                
        if (m_sheetProtection)
        {
            delete m_sheetProtection;
            m_sheetProtection = NULL;
        }
    
            
                m_has_customSheetViews = false;
                
        if (m_customSheetViews)
        {
            delete m_customSheetViews;
            m_customSheetViews = NULL;
        }
    
            
                m_has_pageMargins = false;
                
        if (m_pageMargins)
        {
            delete m_pageMargins;
            m_pageMargins = NULL;
        }
    
            
                m_has_pageSetup = false;
                
        if (m_pageSetup)
        {
            delete m_pageSetup;
            m_pageSetup = NULL;
        }
    
            
                m_has_headerFooter = false;
                
        if (m_headerFooter)
        {
            delete m_headerFooter;
            m_headerFooter = NULL;
        }
    
            
                m_has_drawing = false;
                
        if (m_drawing)
        {
            delete m_drawing;
            m_drawing = NULL;
        }
    
            
                m_has_legacyDrawing = false;
                
        if (m_legacyDrawing)
        {
            delete m_legacyDrawing;
            m_legacyDrawing = NULL;
        }
    
            
                m_has_legacyDrawingHF = false;
                
        if (m_legacyDrawingHF)
        {
            delete m_legacyDrawingHF;
            m_legacyDrawingHF = NULL;
        }
    
            
                m_has_drawingHF = false;
                
        if (m_drawingHF)
        {
            delete m_drawingHF;
            m_drawingHF = NULL;
        }
    
            
                m_has_picture = false;
                
        if (m_picture)
        {
            delete m_picture;
            m_picture = NULL;
        }
    
            
                m_has_webPublishItems = false;
                
        if (m_webPublishItems)
        {
            delete m_webPublishItems;
            m_webPublishItems = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_sheetPr)
                {
                    m_sheetPr->toXml(sheetPr, _outStream);;
                }
            
                if (m_has_sheetViews)
                {
                    m_sheetPr->toXml(sheetViews, _outStream);;
                }
            
                if (m_has_sheetProtection)
                {
                    m_sheetPr->toXml(sheetProtection, _outStream);;
                }
            
                if (m_has_customSheetViews)
                {
                    m_sheetPr->toXml(customSheetViews, _outStream);;
                }
            
                if (m_has_pageMargins)
                {
                    m_sheetPr->toXml(pageMargins, _outStream);;
                }
            
                if (m_has_pageSetup)
                {
                    m_sheetPr->toXml(pageSetup, _outStream);;
                }
            
                if (m_has_headerFooter)
                {
                    m_sheetPr->toXml(headerFooter, _outStream);;
                }
            
                if (m_has_drawing)
                {
                    m_sheetPr->toXml(drawing, _outStream);;
                }
            
                if (m_has_legacyDrawing)
                {
                    m_sheetPr->toXml(legacyDrawing, _outStream);;
                }
            
                if (m_has_legacyDrawingHF)
                {
                    m_sheetPr->toXml(legacyDrawingHF, _outStream);;
                }
            
                if (m_has_drawingHF)
                {
                    m_sheetPr->toXml(drawingHF, _outStream);;
                }
            
                if (m_has_picture)
                {
                    m_sheetPr->toXml(picture, _outStream);;
                }
            
                if (m_has_webPublishItems)
                {
                    m_sheetPr->toXml(webPublishItems, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_sheetPr->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Chartsheet& default_instance(){

    if (!CT_Chartsheet::default_instance_)
    {
        CT_Chartsheet::default_instance_ = new CT_Chartsheet();
    }
    return *CT_Chartsheet::default_instance_;

        }

    private:
        bool m_has_sheetPr ;
        CT_ChartsheetPr* m_sheetPr ;
        bool m_has_sheetViews ;
        CT_ChartsheetViews* m_sheetViews ;
        bool m_has_sheetProtection ;
        CT_ChartsheetProtection* m_sheetProtection ;
        bool m_has_customSheetViews ;
        CT_CustomChartsheetViews* m_customSheetViews ;
        bool m_has_pageMargins ;
        CT_PageMargins* m_pageMargins ;
        bool m_has_pageSetup ;
        CT_CsPageSetup* m_pageSetup ;
        bool m_has_headerFooter ;
        CT_HeaderFooter* m_headerFooter ;
        bool m_has_drawing ;
        CT_Drawing* m_drawing ;
        bool m_has_legacyDrawing ;
        CT_LegacyDrawing* m_legacyDrawing ;
        bool m_has_legacyDrawingHF ;
        CT_LegacyDrawing* m_legacyDrawingHF ;
        bool m_has_drawingHF ;
        CT_DrawingHF* m_drawingHF ;
        bool m_has_picture ;
        CT_SheetBackgroundPicture* m_picture ;
        bool m_has_webPublishItems ;
        CT_WebPublishItems* m_webPublishItems ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_Chartsheet* default_instance_ ;

    }

    class CT_ChartsheetPr : public XSD::ComplexType{
    public:
        bool has_tabColor(){

            return m_has_tabColor;
        
        }
        CT_Color* mutable_tabColor(){

                m_has_tabColor = true;
                if (!m_tabColor)
                {
                    m_tabColor = new CT_Color();
                }
                return m_tabColor;
            
        }
        const CT_Color& tabColor(){

            if (m_tabColor)
            {
                return *m_tabColor;
            }
            return CT_Color::default_instance();
        
        }
        void clear(){

                m_has_published_attr = false;
                m_published_attr = false;
            
                m_has_codeName_attr = false;
                m_codeName_attr.clear();
            
                m_has_tabColor = false;
                
        if (m_tabColor)
        {
            delete m_tabColor;
            m_tabColor = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_published_attr) << \\\;
_outStream << _attrName << \=\\ << m_codeName_attr << \\\;
        _outStream << \>\;
    
                if (m_has_tabColor)
                {
                    m_tabColor->toXml(tabColor, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_ChartsheetPr& default_instance(){

    if (!CT_ChartsheetPr::default_instance_)
    {
        CT_ChartsheetPr::default_instance_ = new CT_ChartsheetPr();
    }
    return *CT_ChartsheetPr::default_instance_;

        }
        bool has_published_attr(){

            return m_has_published_attr;
        
        }
        void set_published_attr(const boolean& _published_attr ){

        m_has_published_attr = true;
        m_published_attr = _published_attr;
        
        }
        const boolean& published_attr(){

            return type: oolean\nname: \m_published_attr\n;
        
        }
        bool has_codeName_attr(){

            return m_has_codeName_attr;
        
        }
        void set_codeName_attr(const string& _codeName_attr ){

        m_has_codeName_attr = true;
        m_codeName_attr = _codeName_attr;
        
        }
        const string& codeName_attr(){

            return type: \string\nname: \m_codeName_attr\n;
        
        }

    private:
        bool m_has_tabColor ;
        CT_Color* m_tabColor ;
        static CT_ChartsheetPr* default_instance_ ;
        bool m_has_published_attr ;
        boolean m_published_attr ;
        bool m_has_codeName_attr ;
        string m_codeName_attr ;

    }

    class CT_ChartsheetViews : public XSD::ComplexType{
    public:
        bool has_sheetView(){

            return m_has_sheetView;
        
        }
        CT_ChartsheetView* mutable_sheetView(){

                m_has_sheetView = true;
                if (!m_sheetView)
                {
                    m_sheetView = new CT_ChartsheetView();
                }
                return m_sheetView;
            
        }
        const CT_ChartsheetView& sheetView(){

            if (m_sheetView)
            {
                return *m_sheetView;
            }
            return CT_ChartsheetView::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_sheetView = false;
                
        if (m_sheetView)
        {
            delete m_sheetView;
            m_sheetView = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_sheetView)
                {
                    m_sheetView->toXml(sheetView, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_sheetView->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_ChartsheetViews& default_instance(){

    if (!CT_ChartsheetViews::default_instance_)
    {
        CT_ChartsheetViews::default_instance_ = new CT_ChartsheetViews();
    }
    return *CT_ChartsheetViews::default_instance_;

        }

    private:
        bool m_has_sheetView ;
        CT_ChartsheetView* m_sheetView ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_ChartsheetViews* default_instance_ ;

    }

    class CT_ChartsheetView : public XSD::ComplexType{
    public:
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_tabSelected_attr = false;
                m_tabSelected_attr = false;
            
                m_has_zoomScale_attr = false;
                m_zoomScale_attr = 0;
            
                m_has_workbookViewId_attr = false;
                m_workbookViewId_attr = 0;
            
                m_has_zoomToFit_attr = false;
                m_zoomToFit_attr = false;
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_tabSelected_attr) << \\\;
_outStream << _attrName << \=\\ << m_zoomScale_attr << \\\;
_outStream << _attrName << \=\\ << m_workbookViewId_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_zoomToFit_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_extLst)
                {
                    m_extLst->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_ChartsheetView& default_instance(){

    if (!CT_ChartsheetView::default_instance_)
    {
        CT_ChartsheetView::default_instance_ = new CT_ChartsheetView();
    }
    return *CT_ChartsheetView::default_instance_;

        }
        bool has_tabSelected_attr(){

            return m_has_tabSelected_attr;
        
        }
        void set_tabSelected_attr(const boolean& _tabSelected_attr ){

        m_has_tabSelected_attr = true;
        m_tabSelected_attr = _tabSelected_attr;
        
        }
        const boolean& tabSelected_attr(){

            return type: oolean\nname: \m_tabSelected_attr\n;
        
        }
        bool has_zoomScale_attr(){

            return m_has_zoomScale_attr;
        
        }
        void set_zoomScale_attr(const unsignedInt& _zoomScale_attr ){

        m_has_zoomScale_attr = true;
        m_zoomScale_attr = _zoomScale_attr;
        
        }
        const unsignedInt& zoomScale_attr(){

            return type: \unsignedInt\nname: \m_zoomScale_attr\n;
        
        }
        bool has_workbookViewId_attr(){

            return m_has_workbookViewId_attr;
        
        }
        void set_workbookViewId_attr(const unsignedInt& _workbookViewId_attr ){

        m_has_workbookViewId_attr = true;
        m_workbookViewId_attr = _workbookViewId_attr;
        
        }
        const unsignedInt& workbookViewId_attr(){

            return type: \unsignedInt\nname: \m_workbookViewId_attr\n;
        
        }
        bool has_zoomToFit_attr(){

            return m_has_zoomToFit_attr;
        
        }
        void set_zoomToFit_attr(const boolean& _zoomToFit_attr ){

        m_has_zoomToFit_attr = true;
        m_zoomToFit_attr = _zoomToFit_attr;
        
        }
        const boolean& zoomToFit_attr(){

            return type: oolean\nname: \m_zoomToFit_attr\n;
        
        }

    private:
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_ChartsheetView* default_instance_ ;
        bool m_has_tabSelected_attr ;
        boolean m_tabSelected_attr ;
        bool m_has_zoomScale_attr ;
        unsignedInt m_zoomScale_attr ;
        bool m_has_workbookViewId_attr ;
        unsignedInt m_workbookViewId_attr ;
        bool m_has_zoomToFit_attr ;
        boolean m_zoomToFit_attr ;

    }

    class CT_ChartsheetProtection : public XSD::ComplexType{
    public:
        void clear(){

                m_has_password_attr = false;
                
        if (m_password_attr)
        {
            delete m_password_attr;
            m_password_attr = NULL;
        }
    
            
                m_has_algorithmName_attr = false;
                
        if (m_algorithmName_attr)
        {
            delete m_algorithmName_attr;
            m_algorithmName_attr = NULL;
        }
    
            
                m_has_hashValue_attr = false;
                m_hashValue_attr.clear();
            
                m_has_saltValue_attr = false;
                m_saltValue_attr.clear();
            
                m_has_spinCount_attr = false;
                m_spinCount_attr = 0;
            
                m_has_content_attr = false;
                m_content_attr = false;
            
                m_has_objects_attr = false;
                m_objects_attr = false;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_password_attr->toXml(_attrName, _outStream);
m_algorithmName_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_hashValue_attr << \\\;
_outStream << _attrName << \=\\ << m_saltValue_attr << \\\;
_outStream << _attrName << \=\\ << m_spinCount_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_content_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_objects_attr) << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_ChartsheetProtection& default_instance(){

    if (!CT_ChartsheetProtection::default_instance_)
    {
        CT_ChartsheetProtection::default_instance_ = new CT_ChartsheetProtection();
    }
    return *CT_ChartsheetProtection::default_instance_;

        }
        bool has_password_attr(){

            return m_has_password_attr;
        
        }
        void set_password_attr(const ST_UnsignedShortHex& _password_attr ){

            m_has_password_attr = true;
            m_password_attr = new ST_UnsignedShortHex(_password_attr);
        
        }
        const ST_UnsignedShortHex& password_attr(){

            if (m_password_attr)
            {
                return *m_password_attr;
            }
            return ST_UnsignedShortHex::default_instance();
        
        }
        bool has_algorithmName_attr(){

            return m_has_algorithmName_attr;
        
        }
        void set_algorithmName_attr(const ns_s::ST_Xstring& _algorithmName_attr ){

            m_has_algorithmName_attr = true;
            m_algorithmName_attr = new ns_s::ST_Xstring(_algorithmName_attr);
        
        }
        const ns_s::ST_Xstring& algorithmName_attr(){

            if (m_algorithmName_attr)
            {
                return *m_algorithmName_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_hashValue_attr(){

            return m_has_hashValue_attr;
        
        }
        void set_hashValue_attr(const base64Binary& _hashValue_attr ){

        m_has_hashValue_attr = true;
        m_hashValue_attr = _hashValue_attr;
        
        }
        const base64Binary& hashValue_attr(){

            return type: ase64Binary\nname: \m_hashValue_attr\n;
        
        }
        bool has_saltValue_attr(){

            return m_has_saltValue_attr;
        
        }
        void set_saltValue_attr(const base64Binary& _saltValue_attr ){

        m_has_saltValue_attr = true;
        m_saltValue_attr = _saltValue_attr;
        
        }
        const base64Binary& saltValue_attr(){

            return type: ase64Binary\nname: \m_saltValue_attr\n;
        
        }
        bool has_spinCount_attr(){

            return m_has_spinCount_attr;
        
        }
        void set_spinCount_attr(const unsignedInt& _spinCount_attr ){

        m_has_spinCount_attr = true;
        m_spinCount_attr = _spinCount_attr;
        
        }
        const unsignedInt& spinCount_attr(){

            return type: \unsignedInt\nname: \m_spinCount_attr\n;
        
        }
        bool has_content_attr(){

            return m_has_content_attr;
        
        }
        void set_content_attr(const boolean& _content_attr ){

        m_has_content_attr = true;
        m_content_attr = _content_attr;
        
        }
        const boolean& content_attr(){

            return type: oolean\nname: \m_content_attr\n;
        
        }
        bool has_objects_attr(){

            return m_has_objects_attr;
        
        }
        void set_objects_attr(const boolean& _objects_attr ){

        m_has_objects_attr = true;
        m_objects_attr = _objects_attr;
        
        }
        const boolean& objects_attr(){

            return type: oolean\nname: \m_objects_attr\n;
        
        }

    private:
        static CT_ChartsheetProtection* default_instance_ ;
        bool m_has_password_attr ;
        ST_UnsignedShortHex* m_password_attr ;
        bool m_has_algorithmName_attr ;
        ns_s::ST_Xstring* m_algorithmName_attr ;
        bool m_has_hashValue_attr ;
        base64Binary m_hashValue_attr ;
        bool m_has_saltValue_attr ;
        base64Binary m_saltValue_attr ;
        bool m_has_spinCount_attr ;
        unsignedInt m_spinCount_attr ;
        bool m_has_content_attr ;
        boolean m_content_attr ;
        bool m_has_objects_attr ;
        boolean m_objects_attr ;

    }

    class CT_CsPageSetup : public XSD::ComplexType{
    public:
        void clear(){

                m_has_paperSize_attr = false;
                m_paperSize_attr = 0;
            
                m_has_paperHeight_attr = false;
                
        if (m_paperHeight_attr)
        {
            delete m_paperHeight_attr;
            m_paperHeight_attr = NULL;
        }
    
            
                m_has_paperWidth_attr = false;
                
        if (m_paperWidth_attr)
        {
            delete m_paperWidth_attr;
            m_paperWidth_attr = NULL;
        }
    
            
                m_has_firstPageNumber_attr = false;
                m_firstPageNumber_attr = 0;
            
                m_has_orientation_attr = false;
                
        if (m_orientation_attr)
        {
            delete m_orientation_attr;
            m_orientation_attr = NULL;
        }
    
            
                m_has_usePrinterDefaults_attr = false;
                m_usePrinterDefaults_attr = false;
            
                m_has_blackAndWhite_attr = false;
                m_blackAndWhite_attr = false;
            
                m_has_draft_attr = false;
                m_draft_attr = false;
            
                m_has_useFirstPageNumber_attr = false;
                m_useFirstPageNumber_attr = false;
            
                m_has_horizontalDpi_attr = false;
                m_horizontalDpi_attr = 0;
            
                m_has_verticalDpi_attr = false;
                m_verticalDpi_attr = 0;
            
                m_has_copies_attr = false;
                m_copies_attr = 0;
            
                m_has_id_attr = false;
                
        if (m_id_attr)
        {
            delete m_id_attr;
            m_id_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_paperSize_attr << \\\;
m_paperHeight_attr->toXml(_attrName, _outStream);
m_paperWidth_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_firstPageNumber_attr << \\\;
m_orientation_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_usePrinterDefaults_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_blackAndWhite_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_draft_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_useFirstPageNumber_attr) << \\\;
_outStream << _attrName << \=\\ << m_horizontalDpi_attr << \\\;
_outStream << _attrName << \=\\ << m_verticalDpi_attr << \\\;
_outStream << _attrName << \=\\ << m_copies_attr << \\\;
m_id_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CsPageSetup& default_instance(){

    if (!CT_CsPageSetup::default_instance_)
    {
        CT_CsPageSetup::default_instance_ = new CT_CsPageSetup();
    }
    return *CT_CsPageSetup::default_instance_;

        }
        bool has_paperSize_attr(){

            return m_has_paperSize_attr;
        
        }
        void set_paperSize_attr(const unsignedInt& _paperSize_attr ){

        m_has_paperSize_attr = true;
        m_paperSize_attr = _paperSize_attr;
        
        }
        const unsignedInt& paperSize_attr(){

            return type: \unsignedInt\nname: \m_paperSize_attr\n;
        
        }
        bool has_paperHeight_attr(){

            return m_has_paperHeight_attr;
        
        }
        void set_paperHeight_attr(const ns_s::ST_PositiveUniversalMeasure& _paperHeight_attr ){

            m_has_paperHeight_attr = true;
            m_paperHeight_attr = new ns_s::ST_PositiveUniversalMeasure(_paperHeight_attr);
        
        }
        const ns_s::ST_PositiveUniversalMeasure& paperHeight_attr(){

            if (m_paperHeight_attr)
            {
                return *m_paperHeight_attr;
            }
            return ns_s::ST_PositiveUniversalMeasure::default_instance();
        
        }
        bool has_paperWidth_attr(){

            return m_has_paperWidth_attr;
        
        }
        void set_paperWidth_attr(const ns_s::ST_PositiveUniversalMeasure& _paperWidth_attr ){

            m_has_paperWidth_attr = true;
            m_paperWidth_attr = new ns_s::ST_PositiveUniversalMeasure(_paperWidth_attr);
        
        }
        const ns_s::ST_PositiveUniversalMeasure& paperWidth_attr(){

            if (m_paperWidth_attr)
            {
                return *m_paperWidth_attr;
            }
            return ns_s::ST_PositiveUniversalMeasure::default_instance();
        
        }
        bool has_firstPageNumber_attr(){

            return m_has_firstPageNumber_attr;
        
        }
        void set_firstPageNumber_attr(const unsignedInt& _firstPageNumber_attr ){

        m_has_firstPageNumber_attr = true;
        m_firstPageNumber_attr = _firstPageNumber_attr;
        
        }
        const unsignedInt& firstPageNumber_attr(){

            return type: \unsignedInt\nname: \m_firstPageNumber_attr\n;
        
        }
        bool has_orientation_attr(){

            return m_has_orientation_attr;
        
        }
        void set_orientation_attr(const ST_Orientation& _orientation_attr ){

            m_has_orientation_attr = true;
            m_orientation_attr = new ST_Orientation(_orientation_attr);
        
        }
        const ST_Orientation& orientation_attr(){

            if (m_orientation_attr)
            {
                return *m_orientation_attr;
            }
            return ST_Orientation::default_instance();
        
        }
        bool has_usePrinterDefaults_attr(){

            return m_has_usePrinterDefaults_attr;
        
        }
        void set_usePrinterDefaults_attr(const boolean& _usePrinterDefaults_attr ){

        m_has_usePrinterDefaults_attr = true;
        m_usePrinterDefaults_attr = _usePrinterDefaults_attr;
        
        }
        const boolean& usePrinterDefaults_attr(){

            return type: oolean\nname: \m_usePrinterDefaults_attr\n;
        
        }
        bool has_blackAndWhite_attr(){

            return m_has_blackAndWhite_attr;
        
        }
        void set_blackAndWhite_attr(const boolean& _blackAndWhite_attr ){

        m_has_blackAndWhite_attr = true;
        m_blackAndWhite_attr = _blackAndWhite_attr;
        
        }
        const boolean& blackAndWhite_attr(){

            return type: oolean\nname: \m_blackAndWhite_attr\n;
        
        }
        bool has_draft_attr(){

            return m_has_draft_attr;
        
        }
        void set_draft_attr(const boolean& _draft_attr ){

        m_has_draft_attr = true;
        m_draft_attr = _draft_attr;
        
        }
        const boolean& draft_attr(){

            return type: oolean\nname: \m_draft_attr\n;
        
        }
        bool has_useFirstPageNumber_attr(){

            return m_has_useFirstPageNumber_attr;
        
        }
        void set_useFirstPageNumber_attr(const boolean& _useFirstPageNumber_attr ){

        m_has_useFirstPageNumber_attr = true;
        m_useFirstPageNumber_attr = _useFirstPageNumber_attr;
        
        }
        const boolean& useFirstPageNumber_attr(){

            return type: oolean\nname: \m_useFirstPageNumber_attr\n;
        
        }
        bool has_horizontalDpi_attr(){

            return m_has_horizontalDpi_attr;
        
        }
        void set_horizontalDpi_attr(const unsignedInt& _horizontalDpi_attr ){

        m_has_horizontalDpi_attr = true;
        m_horizontalDpi_attr = _horizontalDpi_attr;
        
        }
        const unsignedInt& horizontalDpi_attr(){

            return type: \unsignedInt\nname: \m_horizontalDpi_attr\n;
        
        }
        bool has_verticalDpi_attr(){

            return m_has_verticalDpi_attr;
        
        }
        void set_verticalDpi_attr(const unsignedInt& _verticalDpi_attr ){

        m_has_verticalDpi_attr = true;
        m_verticalDpi_attr = _verticalDpi_attr;
        
        }
        const unsignedInt& verticalDpi_attr(){

            return type: \unsignedInt\nname: \m_verticalDpi_attr\n;
        
        }
        bool has_copies_attr(){

            return m_has_copies_attr;
        
        }
        void set_copies_attr(const unsignedInt& _copies_attr ){

        m_has_copies_attr = true;
        m_copies_attr = _copies_attr;
        
        }
        const unsignedInt& copies_attr(){

            return type: \unsignedInt\nname: \m_copies_attr\n;
        
        }
        bool has_id_attr(){

            return m_has_id_attr;
        
        }
        void set_id_attr(const ST_RelationshipId& _id_attr ){

            m_has_id_attr = true;
            m_id_attr = new ST_RelationshipId(_id_attr);
        
        }
        const ST_RelationshipId& id_attr(){

            if (m_id_attr)
            {
                return *m_id_attr;
            }
            return ST_RelationshipId::default_instance();
        
        }

    private:
        static CT_CsPageSetup* default_instance_ ;
        bool m_has_paperSize_attr ;
        unsignedInt m_paperSize_attr ;
        bool m_has_paperHeight_attr ;
        ns_s::ST_PositiveUniversalMeasure* m_paperHeight_attr ;
        bool m_has_paperWidth_attr ;
        ns_s::ST_PositiveUniversalMeasure* m_paperWidth_attr ;
        bool m_has_firstPageNumber_attr ;
        unsignedInt m_firstPageNumber_attr ;
        bool m_has_orientation_attr ;
        ST_Orientation* m_orientation_attr ;
        bool m_has_usePrinterDefaults_attr ;
        boolean m_usePrinterDefaults_attr ;
        bool m_has_blackAndWhite_attr ;
        boolean m_blackAndWhite_attr ;
        bool m_has_draft_attr ;
        boolean m_draft_attr ;
        bool m_has_useFirstPageNumber_attr ;
        boolean m_useFirstPageNumber_attr ;
        bool m_has_horizontalDpi_attr ;
        unsignedInt m_horizontalDpi_attr ;
        bool m_has_verticalDpi_attr ;
        unsignedInt m_verticalDpi_attr ;
        bool m_has_copies_attr ;
        unsignedInt m_copies_attr ;
        bool m_has_id_attr ;
        ST_RelationshipId* m_id_attr ;

    }

    class CT_CustomChartsheetViews : public XSD::ComplexType{
    public:
        bool has_customSheetView(){

            return m_has_customSheetView;
        
        }
        CT_CustomChartsheetView* mutable_customSheetView(){

                m_has_customSheetView = true;
                if (!m_customSheetView)
                {
                    m_customSheetView = new CT_CustomChartsheetView();
                }
                return m_customSheetView;
            
        }
        const CT_CustomChartsheetView& customSheetView(){

            if (m_customSheetView)
            {
                return *m_customSheetView;
            }
            return CT_CustomChartsheetView::default_instance();
        
        }
        void clear(){

                m_has_customSheetView = false;
                
        if (m_customSheetView)
        {
            delete m_customSheetView;
            m_customSheetView = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_customSheetView)
                {
                    m_customSheetView->toXml(customSheetView, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CustomChartsheetViews& default_instance(){

    if (!CT_CustomChartsheetViews::default_instance_)
    {
        CT_CustomChartsheetViews::default_instance_ = new CT_CustomChartsheetViews();
    }
    return *CT_CustomChartsheetViews::default_instance_;

        }

    private:
        bool m_has_customSheetView ;
        CT_CustomChartsheetView* m_customSheetView ;
        static CT_CustomChartsheetViews* default_instance_ ;

    }

    class CT_CustomChartsheetView : public XSD::ComplexType{
    public:
        bool has_pageMargins(){

            return m_has_pageMargins;
        
        }
        CT_PageMargins* mutable_pageMargins(){

                m_has_pageMargins = true;
                if (!m_pageMargins)
                {
                    m_pageMargins = new CT_PageMargins();
                }
                return m_pageMargins;
            
        }
        const CT_PageMargins& pageMargins(){

            if (m_pageMargins)
            {
                return *m_pageMargins;
            }
            return CT_PageMargins::default_instance();
        
        }
        bool has_pageSetup(){

            return m_has_pageSetup;
        
        }
        CT_CsPageSetup* mutable_pageSetup(){

                m_has_pageSetup = true;
                if (!m_pageSetup)
                {
                    m_pageSetup = new CT_CsPageSetup();
                }
                return m_pageSetup;
            
        }
        const CT_CsPageSetup& pageSetup(){

            if (m_pageSetup)
            {
                return *m_pageSetup;
            }
            return CT_CsPageSetup::default_instance();
        
        }
        bool has_headerFooter(){

            return m_has_headerFooter;
        
        }
        CT_HeaderFooter* mutable_headerFooter(){

                m_has_headerFooter = true;
                if (!m_headerFooter)
                {
                    m_headerFooter = new CT_HeaderFooter();
                }
                return m_headerFooter;
            
        }
        const CT_HeaderFooter& headerFooter(){

            if (m_headerFooter)
            {
                return *m_headerFooter;
            }
            return CT_HeaderFooter::default_instance();
        
        }
        void clear(){

                m_has_guid_attr = false;
                
        if (m_guid_attr)
        {
            delete m_guid_attr;
            m_guid_attr = NULL;
        }
    
            
                m_has_scale_attr = false;
                m_scale_attr = 0;
            
                m_has_state_attr = false;
                
        if (m_state_attr)
        {
            delete m_state_attr;
            m_state_attr = NULL;
        }
    
            
                m_has_zoomToFit_attr = false;
                m_zoomToFit_attr = false;
            
                m_has_pageMargins = false;
                
        if (m_pageMargins)
        {
            delete m_pageMargins;
            m_pageMargins = NULL;
        }
    
            
                m_has_pageSetup = false;
                
        if (m_pageSetup)
        {
            delete m_pageSetup;
            m_pageSetup = NULL;
        }
    
            
                m_has_headerFooter = false;
                
        if (m_headerFooter)
        {
            delete m_headerFooter;
            m_headerFooter = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_guid_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_scale_attr << \\\;
m_state_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_zoomToFit_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_pageMargins)
                {
                    m_pageMargins->toXml(pageMargins, _outStream);;
                }
            
                if (m_has_pageSetup)
                {
                    m_pageMargins->toXml(pageSetup, _outStream);;
                }
            
                if (m_has_headerFooter)
                {
                    m_pageMargins->toXml(headerFooter, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CustomChartsheetView& default_instance(){

    if (!CT_CustomChartsheetView::default_instance_)
    {
        CT_CustomChartsheetView::default_instance_ = new CT_CustomChartsheetView();
    }
    return *CT_CustomChartsheetView::default_instance_;

        }
        bool has_guid_attr(){

            return m_has_guid_attr;
        
        }
        void set_guid_attr(const ns_s::ST_Guid& _guid_attr ){

            m_has_guid_attr = true;
            m_guid_attr = new ns_s::ST_Guid(_guid_attr);
        
        }
        const ns_s::ST_Guid& guid_attr(){

            if (m_guid_attr)
            {
                return *m_guid_attr;
            }
            return ns_s::ST_Guid::default_instance();
        
        }
        bool has_scale_attr(){

            return m_has_scale_attr;
        
        }
        void set_scale_attr(const unsignedInt& _scale_attr ){

        m_has_scale_attr = true;
        m_scale_attr = _scale_attr;
        
        }
        const unsignedInt& scale_attr(){

            return type: \unsignedInt\nname: \m_scale_attr\n;
        
        }
        bool has_state_attr(){

            return m_has_state_attr;
        
        }
        void set_state_attr(const ST_SheetState& _state_attr ){

            m_has_state_attr = true;
            m_state_attr = new ST_SheetState(_state_attr);
        
        }
        const ST_SheetState& state_attr(){

            if (m_state_attr)
            {
                return *m_state_attr;
            }
            return ST_SheetState::default_instance();
        
        }
        bool has_zoomToFit_attr(){

            return m_has_zoomToFit_attr;
        
        }
        void set_zoomToFit_attr(const boolean& _zoomToFit_attr ){

        m_has_zoomToFit_attr = true;
        m_zoomToFit_attr = _zoomToFit_attr;
        
        }
        const boolean& zoomToFit_attr(){

            return type: oolean\nname: \m_zoomToFit_attr\n;
        
        }

    private:
        bool m_has_pageMargins ;
        CT_PageMargins* m_pageMargins ;
        bool m_has_pageSetup ;
        CT_CsPageSetup* m_pageSetup ;
        bool m_has_headerFooter ;
        CT_HeaderFooter* m_headerFooter ;
        static CT_CustomChartsheetView* default_instance_ ;
        bool m_has_guid_attr ;
        ns_s::ST_Guid* m_guid_attr ;
        bool m_has_scale_attr ;
        unsignedInt m_scale_attr ;
        bool m_has_state_attr ;
        ST_SheetState* m_state_attr ;
        bool m_has_zoomToFit_attr ;
        boolean m_zoomToFit_attr ;

    }

    class CT_CustomProperties : public XSD::ComplexType{
    public:
        bool has_customPr(){

            return m_has_customPr;
        
        }
        CT_CustomProperty* mutable_customPr(){

                m_has_customPr = true;
                if (!m_customPr)
                {
                    m_customPr = new CT_CustomProperty();
                }
                return m_customPr;
            
        }
        const CT_CustomProperty& customPr(){

            if (m_customPr)
            {
                return *m_customPr;
            }
            return CT_CustomProperty::default_instance();
        
        }
        void clear(){

                m_has_customPr = false;
                
        if (m_customPr)
        {
            delete m_customPr;
            m_customPr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_customPr)
                {
                    m_customPr->toXml(customPr, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CustomProperties& default_instance(){

    if (!CT_CustomProperties::default_instance_)
    {
        CT_CustomProperties::default_instance_ = new CT_CustomProperties();
    }
    return *CT_CustomProperties::default_instance_;

        }

    private:
        bool m_has_customPr ;
        CT_CustomProperty* m_customPr ;
        static CT_CustomProperties* default_instance_ ;

    }

    class CT_CustomProperty : public XSD::ComplexType{
    public:
        void clear(){

                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
                m_has_id_attr = false;
                
        if (m_id_attr)
        {
            delete m_id_attr;
            m_id_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_name_attr->toXml(_attrName, _outStream);
m_id_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CustomProperty& default_instance(){

    if (!CT_CustomProperty::default_instance_)
    {
        CT_CustomProperty::default_instance_ = new CT_CustomProperty();
    }
    return *CT_CustomProperty::default_instance_;

        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_id_attr(){

            return m_has_id_attr;
        
        }
        void set_id_attr(const ST_RelationshipId& _id_attr ){

            m_has_id_attr = true;
            m_id_attr = new ST_RelationshipId(_id_attr);
        
        }
        const ST_RelationshipId& id_attr(){

            if (m_id_attr)
            {
                return *m_id_attr;
            }
            return ST_RelationshipId::default_instance();
        
        }

    private:
        static CT_CustomProperty* default_instance_ ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;
        bool m_has_id_attr ;
        ST_RelationshipId* m_id_attr ;

    }

    class CT_OleObjects : public XSD::ComplexType{
    public:
        bool has_oleObject(){

            return m_has_oleObject;
        
        }
        CT_OleObject* mutable_oleObject(){

                m_has_oleObject = true;
                if (!m_oleObject)
                {
                    m_oleObject = new CT_OleObject();
                }
                return m_oleObject;
            
        }
        const CT_OleObject& oleObject(){

            if (m_oleObject)
            {
                return *m_oleObject;
            }
            return CT_OleObject::default_instance();
        
        }
        void clear(){

                m_has_oleObject = false;
                
        if (m_oleObject)
        {
            delete m_oleObject;
            m_oleObject = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_oleObject)
                {
                    m_oleObject->toXml(oleObject, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_OleObjects& default_instance(){

    if (!CT_OleObjects::default_instance_)
    {
        CT_OleObjects::default_instance_ = new CT_OleObjects();
    }
    return *CT_OleObjects::default_instance_;

        }

    private:
        bool m_has_oleObject ;
        CT_OleObject* m_oleObject ;
        static CT_OleObjects* default_instance_ ;

    }

    class CT_OleObject : public XSD::ComplexType{
    public:
        bool has_objectPr(){

            return m_has_objectPr;
        
        }
        CT_ObjectPr* mutable_objectPr(){

                m_has_objectPr = true;
                if (!m_objectPr)
                {
                    m_objectPr = new CT_ObjectPr();
                }
                return m_objectPr;
            
        }
        const CT_ObjectPr& objectPr(){

            if (m_objectPr)
            {
                return *m_objectPr;
            }
            return CT_ObjectPr::default_instance();
        
        }
        void clear(){

                m_has_progId_attr = false;
                m_progId_attr.clear();
            
                m_has_dvAspect_attr = false;
                
        if (m_dvAspect_attr)
        {
            delete m_dvAspect_attr;
            m_dvAspect_attr = NULL;
        }
    
            
                m_has_link_attr = false;
                
        if (m_link_attr)
        {
            delete m_link_attr;
            m_link_attr = NULL;
        }
    
            
                m_has_oleUpdate_attr = false;
                
        if (m_oleUpdate_attr)
        {
            delete m_oleUpdate_attr;
            m_oleUpdate_attr = NULL;
        }
    
            
                m_has_autoLoad_attr = false;
                m_autoLoad_attr = false;
            
                m_has_shapeId_attr = false;
                m_shapeId_attr = 0;
            
                m_has_id_attr = false;
                
        if (m_id_attr)
        {
            delete m_id_attr;
            m_id_attr = NULL;
        }
    
            
                m_has_objectPr = false;
                
        if (m_objectPr)
        {
            delete m_objectPr;
            m_objectPr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_progId_attr << \\\;
m_dvAspect_attr->toXml(_attrName, _outStream);
m_link_attr->toXml(_attrName, _outStream);
m_oleUpdate_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_autoLoad_attr) << \\\;
_outStream << _attrName << \=\\ << m_shapeId_attr << \\\;
m_id_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_objectPr)
                {
                    m_objectPr->toXml(objectPr, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_OleObject& default_instance(){

    if (!CT_OleObject::default_instance_)
    {
        CT_OleObject::default_instance_ = new CT_OleObject();
    }
    return *CT_OleObject::default_instance_;

        }
        bool has_progId_attr(){

            return m_has_progId_attr;
        
        }
        void set_progId_attr(const string& _progId_attr ){

        m_has_progId_attr = true;
        m_progId_attr = _progId_attr;
        
        }
        const string& progId_attr(){

            return type: \string\nname: \m_progId_attr\n;
        
        }
        bool has_dvAspect_attr(){

            return m_has_dvAspect_attr;
        
        }
        void set_dvAspect_attr(const ST_DvAspect& _dvAspect_attr ){

            m_has_dvAspect_attr = true;
            m_dvAspect_attr = new ST_DvAspect(_dvAspect_attr);
        
        }
        const ST_DvAspect& dvAspect_attr(){

            if (m_dvAspect_attr)
            {
                return *m_dvAspect_attr;
            }
            return ST_DvAspect::default_instance();
        
        }
        bool has_link_attr(){

            return m_has_link_attr;
        
        }
        void set_link_attr(const ns_s::ST_Xstring& _link_attr ){

            m_has_link_attr = true;
            m_link_attr = new ns_s::ST_Xstring(_link_attr);
        
        }
        const ns_s::ST_Xstring& link_attr(){

            if (m_link_attr)
            {
                return *m_link_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_oleUpdate_attr(){

            return m_has_oleUpdate_attr;
        
        }
        void set_oleUpdate_attr(const ST_OleUpdate& _oleUpdate_attr ){

            m_has_oleUpdate_attr = true;
            m_oleUpdate_attr = new ST_OleUpdate(_oleUpdate_attr);
        
        }
        const ST_OleUpdate& oleUpdate_attr(){

            if (m_oleUpdate_attr)
            {
                return *m_oleUpdate_attr;
            }
            return ST_OleUpdate::default_instance();
        
        }
        bool has_autoLoad_attr(){

            return m_has_autoLoad_attr;
        
        }
        void set_autoLoad_attr(const boolean& _autoLoad_attr ){

        m_has_autoLoad_attr = true;
        m_autoLoad_attr = _autoLoad_attr;
        
        }
        const boolean& autoLoad_attr(){

            return type: oolean\nname: \m_autoLoad_attr\n;
        
        }
        bool has_shapeId_attr(){

            return m_has_shapeId_attr;
        
        }
        void set_shapeId_attr(const unsignedInt& _shapeId_attr ){

        m_has_shapeId_attr = true;
        m_shapeId_attr = _shapeId_attr;
        
        }
        const unsignedInt& shapeId_attr(){

            return type: \unsignedInt\nname: \m_shapeId_attr\n;
        
        }
        bool has_id_attr(){

            return m_has_id_attr;
        
        }
        void set_id_attr(const ST_RelationshipId& _id_attr ){

            m_has_id_attr = true;
            m_id_attr = new ST_RelationshipId(_id_attr);
        
        }
        const ST_RelationshipId& id_attr(){

            if (m_id_attr)
            {
                return *m_id_attr;
            }
            return ST_RelationshipId::default_instance();
        
        }

    private:
        bool m_has_objectPr ;
        CT_ObjectPr* m_objectPr ;
        static CT_OleObject* default_instance_ ;
        bool m_has_progId_attr ;
        string m_progId_attr ;
        bool m_has_dvAspect_attr ;
        ST_DvAspect* m_dvAspect_attr ;
        bool m_has_link_attr ;
        ns_s::ST_Xstring* m_link_attr ;
        bool m_has_oleUpdate_attr ;
        ST_OleUpdate* m_oleUpdate_attr ;
        bool m_has_autoLoad_attr ;
        boolean m_autoLoad_attr ;
        bool m_has_shapeId_attr ;
        unsignedInt m_shapeId_attr ;
        bool m_has_id_attr ;
        ST_RelationshipId* m_id_attr ;

    }

    class CT_ObjectPr : public XSD::ComplexType{
    public:
        bool has_anchor(){

            return m_has_anchor;
        
        }
        CT_ObjectAnchor* mutable_anchor(){

                m_has_anchor = true;
                if (!m_anchor)
                {
                    m_anchor = new CT_ObjectAnchor();
                }
                return m_anchor;
            
        }
        const CT_ObjectAnchor& anchor(){

            if (m_anchor)
            {
                return *m_anchor;
            }
            return CT_ObjectAnchor::default_instance();
        
        }
        void clear(){

                m_has_locked_attr = false;
                m_locked_attr = false;
            
                m_has_defaultSize_attr = false;
                m_defaultSize_attr = false;
            
                m_has_print_attr = false;
                m_print_attr = false;
            
                m_has_disabled_attr = false;
                m_disabled_attr = false;
            
                m_has_uiObject_attr = false;
                m_uiObject_attr = false;
            
                m_has_autoFill_attr = false;
                m_autoFill_attr = false;
            
                m_has_autoLine_attr = false;
                m_autoLine_attr = false;
            
                m_has_autoPict_attr = false;
                m_autoPict_attr = false;
            
                m_has_macro_attr = false;
                
        if (m_macro_attr)
        {
            delete m_macro_attr;
            m_macro_attr = NULL;
        }
    
            
                m_has_altText_attr = false;
                
        if (m_altText_attr)
        {
            delete m_altText_attr;
            m_altText_attr = NULL;
        }
    
            
                m_has_dde_attr = false;
                m_dde_attr = false;
            
                m_has_id_attr = false;
                
        if (m_id_attr)
        {
            delete m_id_attr;
            m_id_attr = NULL;
        }
    
            
                m_has_anchor = false;
                
        if (m_anchor)
        {
            delete m_anchor;
            m_anchor = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_locked_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_defaultSize_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_print_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_disabled_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_uiObject_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_autoFill_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_autoLine_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_autoPict_attr) << \\\;
m_macro_attr->toXml(_attrName, _outStream);
m_altText_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_dde_attr) << \\\;
m_id_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_anchor)
                {
                    m_anchor->toXml(anchor, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_ObjectPr& default_instance(){

    if (!CT_ObjectPr::default_instance_)
    {
        CT_ObjectPr::default_instance_ = new CT_ObjectPr();
    }
    return *CT_ObjectPr::default_instance_;

        }
        bool has_locked_attr(){

            return m_has_locked_attr;
        
        }
        void set_locked_attr(const boolean& _locked_attr ){

        m_has_locked_attr = true;
        m_locked_attr = _locked_attr;
        
        }
        const boolean& locked_attr(){

            return type: oolean\nname: \m_locked_attr\n;
        
        }
        bool has_defaultSize_attr(){

            return m_has_defaultSize_attr;
        
        }
        void set_defaultSize_attr(const boolean& _defaultSize_attr ){

        m_has_defaultSize_attr = true;
        m_defaultSize_attr = _defaultSize_attr;
        
        }
        const boolean& defaultSize_attr(){

            return type: oolean\nname: \m_defaultSize_attr\n;
        
        }
        bool has_print_attr(){

            return m_has_print_attr;
        
        }
        void set_print_attr(const boolean& _print_attr ){

        m_has_print_attr = true;
        m_print_attr = _print_attr;
        
        }
        const boolean& print_attr(){

            return type: oolean\nname: \m_print_attr\n;
        
        }
        bool has_disabled_attr(){

            return m_has_disabled_attr;
        
        }
        void set_disabled_attr(const boolean& _disabled_attr ){

        m_has_disabled_attr = true;
        m_disabled_attr = _disabled_attr;
        
        }
        const boolean& disabled_attr(){

            return type: oolean\nname: \m_disabled_attr\n;
        
        }
        bool has_uiObject_attr(){

            return m_has_uiObject_attr;
        
        }
        void set_uiObject_attr(const boolean& _uiObject_attr ){

        m_has_uiObject_attr = true;
        m_uiObject_attr = _uiObject_attr;
        
        }
        const boolean& uiObject_attr(){

            return type: oolean\nname: \m_uiObject_attr\n;
        
        }
        bool has_autoFill_attr(){

            return m_has_autoFill_attr;
        
        }
        void set_autoFill_attr(const boolean& _autoFill_attr ){

        m_has_autoFill_attr = true;
        m_autoFill_attr = _autoFill_attr;
        
        }
        const boolean& autoFill_attr(){

            return type: oolean\nname: \m_autoFill_attr\n;
        
        }
        bool has_autoLine_attr(){

            return m_has_autoLine_attr;
        
        }
        void set_autoLine_attr(const boolean& _autoLine_attr ){

        m_has_autoLine_attr = true;
        m_autoLine_attr = _autoLine_attr;
        
        }
        const boolean& autoLine_attr(){

            return type: oolean\nname: \m_autoLine_attr\n;
        
        }
        bool has_autoPict_attr(){

            return m_has_autoPict_attr;
        
        }
        void set_autoPict_attr(const boolean& _autoPict_attr ){

        m_has_autoPict_attr = true;
        m_autoPict_attr = _autoPict_attr;
        
        }
        const boolean& autoPict_attr(){

            return type: oolean\nname: \m_autoPict_attr\n;
        
        }
        bool has_macro_attr(){

            return m_has_macro_attr;
        
        }
        void set_macro_attr(const ST_Formula& _macro_attr ){

            m_has_macro_attr = true;
            m_macro_attr = new ST_Formula(_macro_attr);
        
        }
        const ST_Formula& macro_attr(){

            if (m_macro_attr)
            {
                return *m_macro_attr;
            }
            return ST_Formula::default_instance();
        
        }
        bool has_altText_attr(){

            return m_has_altText_attr;
        
        }
        void set_altText_attr(const ns_s::ST_Xstring& _altText_attr ){

            m_has_altText_attr = true;
            m_altText_attr = new ns_s::ST_Xstring(_altText_attr);
        
        }
        const ns_s::ST_Xstring& altText_attr(){

            if (m_altText_attr)
            {
                return *m_altText_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_dde_attr(){

            return m_has_dde_attr;
        
        }
        void set_dde_attr(const boolean& _dde_attr ){

        m_has_dde_attr = true;
        m_dde_attr = _dde_attr;
        
        }
        const boolean& dde_attr(){

            return type: oolean\nname: \m_dde_attr\n;
        
        }
        bool has_id_attr(){

            return m_has_id_attr;
        
        }
        void set_id_attr(const ST_RelationshipId& _id_attr ){

            m_has_id_attr = true;
            m_id_attr = new ST_RelationshipId(_id_attr);
        
        }
        const ST_RelationshipId& id_attr(){

            if (m_id_attr)
            {
                return *m_id_attr;
            }
            return ST_RelationshipId::default_instance();
        
        }

    private:
        bool m_has_anchor ;
        CT_ObjectAnchor* m_anchor ;
        static CT_ObjectPr* default_instance_ ;
        bool m_has_locked_attr ;
        boolean m_locked_attr ;
        bool m_has_defaultSize_attr ;
        boolean m_defaultSize_attr ;
        bool m_has_print_attr ;
        boolean m_print_attr ;
        bool m_has_disabled_attr ;
        boolean m_disabled_attr ;
        bool m_has_uiObject_attr ;
        boolean m_uiObject_attr ;
        bool m_has_autoFill_attr ;
        boolean m_autoFill_attr ;
        bool m_has_autoLine_attr ;
        boolean m_autoLine_attr ;
        bool m_has_autoPict_attr ;
        boolean m_autoPict_attr ;
        bool m_has_macro_attr ;
        ST_Formula* m_macro_attr ;
        bool m_has_altText_attr ;
        ns_s::ST_Xstring* m_altText_attr ;
        bool m_has_dde_attr ;
        boolean m_dde_attr ;
        bool m_has_id_attr ;
        ST_RelationshipId* m_id_attr ;

    }

    class CT_WebPublishItems : public XSD::ComplexType{
    public:
        bool has_webPublishItem(){

            return m_has_webPublishItem;
        
        }
        CT_WebPublishItem* mutable_webPublishItem(){

                m_has_webPublishItem = true;
                if (!m_webPublishItem)
                {
                    m_webPublishItem = new CT_WebPublishItem();
                }
                return m_webPublishItem;
            
        }
        const CT_WebPublishItem& webPublishItem(){

            if (m_webPublishItem)
            {
                return *m_webPublishItem;
            }
            return CT_WebPublishItem::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_webPublishItem = false;
                
        if (m_webPublishItem)
        {
            delete m_webPublishItem;
            m_webPublishItem = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_webPublishItem)
                {
                    m_webPublishItem->toXml(webPublishItem, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_WebPublishItems& default_instance(){

    if (!CT_WebPublishItems::default_instance_)
    {
        CT_WebPublishItems::default_instance_ = new CT_WebPublishItems();
    }
    return *CT_WebPublishItems::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_webPublishItem ;
        CT_WebPublishItem* m_webPublishItem ;
        static CT_WebPublishItems* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_WebPublishItem : public XSD::ComplexType{
    public:
        void clear(){

                m_has_id_attr = false;
                m_id_attr = 0;
            
                m_has_divId_attr = false;
                
        if (m_divId_attr)
        {
            delete m_divId_attr;
            m_divId_attr = NULL;
        }
    
            
                m_has_sourceType_attr = false;
                
        if (m_sourceType_attr)
        {
            delete m_sourceType_attr;
            m_sourceType_attr = NULL;
        }
    
            
                m_has_sourceRef_attr = false;
                
        if (m_sourceRef_attr)
        {
            delete m_sourceRef_attr;
            m_sourceRef_attr = NULL;
        }
    
            
                m_has_sourceObject_attr = false;
                
        if (m_sourceObject_attr)
        {
            delete m_sourceObject_attr;
            m_sourceObject_attr = NULL;
        }
    
            
                m_has_destinationFile_attr = false;
                
        if (m_destinationFile_attr)
        {
            delete m_destinationFile_attr;
            m_destinationFile_attr = NULL;
        }
    
            
                m_has_title_attr = false;
                
        if (m_title_attr)
        {
            delete m_title_attr;
            m_title_attr = NULL;
        }
    
            
                m_has_autoRepublish_attr = false;
                m_autoRepublish_attr = false;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_id_attr << \\\;
m_divId_attr->toXml(_attrName, _outStream);
m_sourceType_attr->toXml(_attrName, _outStream);
m_sourceRef_attr->toXml(_attrName, _outStream);
m_sourceObject_attr->toXml(_attrName, _outStream);
m_destinationFile_attr->toXml(_attrName, _outStream);
m_title_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_autoRepublish_attr) << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_WebPublishItem& default_instance(){

    if (!CT_WebPublishItem::default_instance_)
    {
        CT_WebPublishItem::default_instance_ = new CT_WebPublishItem();
    }
    return *CT_WebPublishItem::default_instance_;

        }
        bool has_id_attr(){

            return m_has_id_attr;
        
        }
        void set_id_attr(const unsignedInt& _id_attr ){

        m_has_id_attr = true;
        m_id_attr = _id_attr;
        
        }
        const unsignedInt& id_attr(){

            return type: \unsignedInt\nname: \m_id_attr\n;
        
        }
        bool has_divId_attr(){

            return m_has_divId_attr;
        
        }
        void set_divId_attr(const ns_s::ST_Xstring& _divId_attr ){

            m_has_divId_attr = true;
            m_divId_attr = new ns_s::ST_Xstring(_divId_attr);
        
        }
        const ns_s::ST_Xstring& divId_attr(){

            if (m_divId_attr)
            {
                return *m_divId_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_sourceType_attr(){

            return m_has_sourceType_attr;
        
        }
        void set_sourceType_attr(const ST_WebSourceType& _sourceType_attr ){

            m_has_sourceType_attr = true;
            m_sourceType_attr = new ST_WebSourceType(_sourceType_attr);
        
        }
        const ST_WebSourceType& sourceType_attr(){

            if (m_sourceType_attr)
            {
                return *m_sourceType_attr;
            }
            return ST_WebSourceType::default_instance();
        
        }
        bool has_sourceRef_attr(){

            return m_has_sourceRef_attr;
        
        }
        void set_sourceRef_attr(const ST_Ref& _sourceRef_attr ){

            m_has_sourceRef_attr = true;
            m_sourceRef_attr = new ST_Ref(_sourceRef_attr);
        
        }
        const ST_Ref& sourceRef_attr(){

            if (m_sourceRef_attr)
            {
                return *m_sourceRef_attr;
            }
            return ST_Ref::default_instance();
        
        }
        bool has_sourceObject_attr(){

            return m_has_sourceObject_attr;
        
        }
        void set_sourceObject_attr(const ns_s::ST_Xstring& _sourceObject_attr ){

            m_has_sourceObject_attr = true;
            m_sourceObject_attr = new ns_s::ST_Xstring(_sourceObject_attr);
        
        }
        const ns_s::ST_Xstring& sourceObject_attr(){

            if (m_sourceObject_attr)
            {
                return *m_sourceObject_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_destinationFile_attr(){

            return m_has_destinationFile_attr;
        
        }
        void set_destinationFile_attr(const ns_s::ST_Xstring& _destinationFile_attr ){

            m_has_destinationFile_attr = true;
            m_destinationFile_attr = new ns_s::ST_Xstring(_destinationFile_attr);
        
        }
        const ns_s::ST_Xstring& destinationFile_attr(){

            if (m_destinationFile_attr)
            {
                return *m_destinationFile_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_title_attr(){

            return m_has_title_attr;
        
        }
        void set_title_attr(const ns_s::ST_Xstring& _title_attr ){

            m_has_title_attr = true;
            m_title_attr = new ns_s::ST_Xstring(_title_attr);
        
        }
        const ns_s::ST_Xstring& title_attr(){

            if (m_title_attr)
            {
                return *m_title_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_autoRepublish_attr(){

            return m_has_autoRepublish_attr;
        
        }
        void set_autoRepublish_attr(const boolean& _autoRepublish_attr ){

        m_has_autoRepublish_attr = true;
        m_autoRepublish_attr = _autoRepublish_attr;
        
        }
        const boolean& autoRepublish_attr(){

            return type: oolean\nname: \m_autoRepublish_attr\n;
        
        }

    private:
        static CT_WebPublishItem* default_instance_ ;
        bool m_has_id_attr ;
        unsignedInt m_id_attr ;
        bool m_has_divId_attr ;
        ns_s::ST_Xstring* m_divId_attr ;
        bool m_has_sourceType_attr ;
        ST_WebSourceType* m_sourceType_attr ;
        bool m_has_sourceRef_attr ;
        ST_Ref* m_sourceRef_attr ;
        bool m_has_sourceObject_attr ;
        ns_s::ST_Xstring* m_sourceObject_attr ;
        bool m_has_destinationFile_attr ;
        ns_s::ST_Xstring* m_destinationFile_attr ;
        bool m_has_title_attr ;
        ns_s::ST_Xstring* m_title_attr ;
        bool m_has_autoRepublish_attr ;
        boolean m_autoRepublish_attr ;

    }

    class CT_Controls : public XSD::ComplexType{
    public:
        bool has_control(){

            return m_has_control;
        
        }
        CT_Control* mutable_control(){

                m_has_control = true;
                if (!m_control)
                {
                    m_control = new CT_Control();
                }
                return m_control;
            
        }
        const CT_Control& control(){

            if (m_control)
            {
                return *m_control;
            }
            return CT_Control::default_instance();
        
        }
        void clear(){

                m_has_control = false;
                
        if (m_control)
        {
            delete m_control;
            m_control = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_control)
                {
                    m_control->toXml(control, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Controls& default_instance(){

    if (!CT_Controls::default_instance_)
    {
        CT_Controls::default_instance_ = new CT_Controls();
    }
    return *CT_Controls::default_instance_;

        }

    private:
        bool m_has_control ;
        CT_Control* m_control ;
        static CT_Controls* default_instance_ ;

    }

    class CT_Control : public XSD::ComplexType{
    public:
        bool has_controlPr(){

            return m_has_controlPr;
        
        }
        CT_ControlPr* mutable_controlPr(){

                m_has_controlPr = true;
                if (!m_controlPr)
                {
                    m_controlPr = new CT_ControlPr();
                }
                return m_controlPr;
            
        }
        const CT_ControlPr& controlPr(){

            if (m_controlPr)
            {
                return *m_controlPr;
            }
            return CT_ControlPr::default_instance();
        
        }
        void clear(){

                m_has_shapeId_attr = false;
                m_shapeId_attr = 0;
            
                m_has_id_attr = false;
                
        if (m_id_attr)
        {
            delete m_id_attr;
            m_id_attr = NULL;
        }
    
            
                m_has_name_attr = false;
                m_name_attr.clear();
            
                m_has_controlPr = false;
                
        if (m_controlPr)
        {
            delete m_controlPr;
            m_controlPr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_shapeId_attr << \\\;
m_id_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_name_attr << \\\;
        _outStream << \>\;
    
                if (m_has_controlPr)
                {
                    m_controlPr->toXml(controlPr, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Control& default_instance(){

    if (!CT_Control::default_instance_)
    {
        CT_Control::default_instance_ = new CT_Control();
    }
    return *CT_Control::default_instance_;

        }
        bool has_shapeId_attr(){

            return m_has_shapeId_attr;
        
        }
        void set_shapeId_attr(const unsignedInt& _shapeId_attr ){

        m_has_shapeId_attr = true;
        m_shapeId_attr = _shapeId_attr;
        
        }
        const unsignedInt& shapeId_attr(){

            return type: \unsignedInt\nname: \m_shapeId_attr\n;
        
        }
        bool has_id_attr(){

            return m_has_id_attr;
        
        }
        void set_id_attr(const ST_RelationshipId& _id_attr ){

            m_has_id_attr = true;
            m_id_attr = new ST_RelationshipId(_id_attr);
        
        }
        const ST_RelationshipId& id_attr(){

            if (m_id_attr)
            {
                return *m_id_attr;
            }
            return ST_RelationshipId::default_instance();
        
        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const string& _name_attr ){

        m_has_name_attr = true;
        m_name_attr = _name_attr;
        
        }
        const string& name_attr(){

            return type: \string\nname: \m_name_attr\n;
        
        }

    private:
        bool m_has_controlPr ;
        CT_ControlPr* m_controlPr ;
        static CT_Control* default_instance_ ;
        bool m_has_shapeId_attr ;
        unsignedInt m_shapeId_attr ;
        bool m_has_id_attr ;
        ST_RelationshipId* m_id_attr ;
        bool m_has_name_attr ;
        string m_name_attr ;

    }

    class CT_ControlPr : public XSD::ComplexType{
    public:
        bool has_anchor(){

            return m_has_anchor;
        
        }
        CT_ObjectAnchor* mutable_anchor(){

                m_has_anchor = true;
                if (!m_anchor)
                {
                    m_anchor = new CT_ObjectAnchor();
                }
                return m_anchor;
            
        }
        const CT_ObjectAnchor& anchor(){

            if (m_anchor)
            {
                return *m_anchor;
            }
            return CT_ObjectAnchor::default_instance();
        
        }
        void clear(){

                m_has_locked_attr = false;
                m_locked_attr = false;
            
                m_has_defaultSize_attr = false;
                m_defaultSize_attr = false;
            
                m_has_print_attr = false;
                m_print_attr = false;
            
                m_has_disabled_attr = false;
                m_disabled_attr = false;
            
                m_has_recalcAlways_attr = false;
                m_recalcAlways_attr = false;
            
                m_has_uiObject_attr = false;
                m_uiObject_attr = false;
            
                m_has_autoFill_attr = false;
                m_autoFill_attr = false;
            
                m_has_autoLine_attr = false;
                m_autoLine_attr = false;
            
                m_has_autoPict_attr = false;
                m_autoPict_attr = false;
            
                m_has_macro_attr = false;
                
        if (m_macro_attr)
        {
            delete m_macro_attr;
            m_macro_attr = NULL;
        }
    
            
                m_has_altText_attr = false;
                
        if (m_altText_attr)
        {
            delete m_altText_attr;
            m_altText_attr = NULL;
        }
    
            
                m_has_linkedCell_attr = false;
                
        if (m_linkedCell_attr)
        {
            delete m_linkedCell_attr;
            m_linkedCell_attr = NULL;
        }
    
            
                m_has_listFillRange_attr = false;
                
        if (m_listFillRange_attr)
        {
            delete m_listFillRange_attr;
            m_listFillRange_attr = NULL;
        }
    
            
                m_has_cf_attr = false;
                
        if (m_cf_attr)
        {
            delete m_cf_attr;
            m_cf_attr = NULL;
        }
    
            
                m_has_id_attr = false;
                
        if (m_id_attr)
        {
            delete m_id_attr;
            m_id_attr = NULL;
        }
    
            
                m_has_anchor = false;
                
        if (m_anchor)
        {
            delete m_anchor;
            m_anchor = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_locked_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_defaultSize_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_print_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_disabled_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_recalcAlways_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_uiObject_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_autoFill_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_autoLine_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_autoPict_attr) << \\\;
m_macro_attr->toXml(_attrName, _outStream);
m_altText_attr->toXml(_attrName, _outStream);
m_linkedCell_attr->toXml(_attrName, _outStream);
m_listFillRange_attr->toXml(_attrName, _outStream);
m_cf_attr->toXml(_attrName, _outStream);
m_id_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_anchor)
                {
                    m_anchor->toXml(anchor, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_ControlPr& default_instance(){

    if (!CT_ControlPr::default_instance_)
    {
        CT_ControlPr::default_instance_ = new CT_ControlPr();
    }
    return *CT_ControlPr::default_instance_;

        }
        bool has_locked_attr(){

            return m_has_locked_attr;
        
        }
        void set_locked_attr(const boolean& _locked_attr ){

        m_has_locked_attr = true;
        m_locked_attr = _locked_attr;
        
        }
        const boolean& locked_attr(){

            return type: oolean\nname: \m_locked_attr\n;
        
        }
        bool has_defaultSize_attr(){

            return m_has_defaultSize_attr;
        
        }
        void set_defaultSize_attr(const boolean& _defaultSize_attr ){

        m_has_defaultSize_attr = true;
        m_defaultSize_attr = _defaultSize_attr;
        
        }
        const boolean& defaultSize_attr(){

            return type: oolean\nname: \m_defaultSize_attr\n;
        
        }
        bool has_print_attr(){

            return m_has_print_attr;
        
        }
        void set_print_attr(const boolean& _print_attr ){

        m_has_print_attr = true;
        m_print_attr = _print_attr;
        
        }
        const boolean& print_attr(){

            return type: oolean\nname: \m_print_attr\n;
        
        }
        bool has_disabled_attr(){

            return m_has_disabled_attr;
        
        }
        void set_disabled_attr(const boolean& _disabled_attr ){

        m_has_disabled_attr = true;
        m_disabled_attr = _disabled_attr;
        
        }
        const boolean& disabled_attr(){

            return type: oolean\nname: \m_disabled_attr\n;
        
        }
        bool has_recalcAlways_attr(){

            return m_has_recalcAlways_attr;
        
        }
        void set_recalcAlways_attr(const boolean& _recalcAlways_attr ){

        m_has_recalcAlways_attr = true;
        m_recalcAlways_attr = _recalcAlways_attr;
        
        }
        const boolean& recalcAlways_attr(){

            return type: oolean\nname: \m_recalcAlways_attr\n;
        
        }
        bool has_uiObject_attr(){

            return m_has_uiObject_attr;
        
        }
        void set_uiObject_attr(const boolean& _uiObject_attr ){

        m_has_uiObject_attr = true;
        m_uiObject_attr = _uiObject_attr;
        
        }
        const boolean& uiObject_attr(){

            return type: oolean\nname: \m_uiObject_attr\n;
        
        }
        bool has_autoFill_attr(){

            return m_has_autoFill_attr;
        
        }
        void set_autoFill_attr(const boolean& _autoFill_attr ){

        m_has_autoFill_attr = true;
        m_autoFill_attr = _autoFill_attr;
        
        }
        const boolean& autoFill_attr(){

            return type: oolean\nname: \m_autoFill_attr\n;
        
        }
        bool has_autoLine_attr(){

            return m_has_autoLine_attr;
        
        }
        void set_autoLine_attr(const boolean& _autoLine_attr ){

        m_has_autoLine_attr = true;
        m_autoLine_attr = _autoLine_attr;
        
        }
        const boolean& autoLine_attr(){

            return type: oolean\nname: \m_autoLine_attr\n;
        
        }
        bool has_autoPict_attr(){

            return m_has_autoPict_attr;
        
        }
        void set_autoPict_attr(const boolean& _autoPict_attr ){

        m_has_autoPict_attr = true;
        m_autoPict_attr = _autoPict_attr;
        
        }
        const boolean& autoPict_attr(){

            return type: oolean\nname: \m_autoPict_attr\n;
        
        }
        bool has_macro_attr(){

            return m_has_macro_attr;
        
        }
        void set_macro_attr(const ST_Formula& _macro_attr ){

            m_has_macro_attr = true;
            m_macro_attr = new ST_Formula(_macro_attr);
        
        }
        const ST_Formula& macro_attr(){

            if (m_macro_attr)
            {
                return *m_macro_attr;
            }
            return ST_Formula::default_instance();
        
        }
        bool has_altText_attr(){

            return m_has_altText_attr;
        
        }
        void set_altText_attr(const ns_s::ST_Xstring& _altText_attr ){

            m_has_altText_attr = true;
            m_altText_attr = new ns_s::ST_Xstring(_altText_attr);
        
        }
        const ns_s::ST_Xstring& altText_attr(){

            if (m_altText_attr)
            {
                return *m_altText_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_linkedCell_attr(){

            return m_has_linkedCell_attr;
        
        }
        void set_linkedCell_attr(const ST_Formula& _linkedCell_attr ){

            m_has_linkedCell_attr = true;
            m_linkedCell_attr = new ST_Formula(_linkedCell_attr);
        
        }
        const ST_Formula& linkedCell_attr(){

            if (m_linkedCell_attr)
            {
                return *m_linkedCell_attr;
            }
            return ST_Formula::default_instance();
        
        }
        bool has_listFillRange_attr(){

            return m_has_listFillRange_attr;
        
        }
        void set_listFillRange_attr(const ST_Formula& _listFillRange_attr ){

            m_has_listFillRange_attr = true;
            m_listFillRange_attr = new ST_Formula(_listFillRange_attr);
        
        }
        const ST_Formula& listFillRange_attr(){

            if (m_listFillRange_attr)
            {
                return *m_listFillRange_attr;
            }
            return ST_Formula::default_instance();
        
        }
        bool has_cf_attr(){

            return m_has_cf_attr;
        
        }
        void set_cf_attr(const ns_s::ST_Xstring& _cf_attr ){

            m_has_cf_attr = true;
            m_cf_attr = new ns_s::ST_Xstring(_cf_attr);
        
        }
        const ns_s::ST_Xstring& cf_attr(){

            if (m_cf_attr)
            {
                return *m_cf_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_id_attr(){

            return m_has_id_attr;
        
        }
        void set_id_attr(const ST_RelationshipId& _id_attr ){

            m_has_id_attr = true;
            m_id_attr = new ST_RelationshipId(_id_attr);
        
        }
        const ST_RelationshipId& id_attr(){

            if (m_id_attr)
            {
                return *m_id_attr;
            }
            return ST_RelationshipId::default_instance();
        
        }

    private:
        bool m_has_anchor ;
        CT_ObjectAnchor* m_anchor ;
        static CT_ControlPr* default_instance_ ;
        bool m_has_locked_attr ;
        boolean m_locked_attr ;
        bool m_has_defaultSize_attr ;
        boolean m_defaultSize_attr ;
        bool m_has_print_attr ;
        boolean m_print_attr ;
        bool m_has_disabled_attr ;
        boolean m_disabled_attr ;
        bool m_has_recalcAlways_attr ;
        boolean m_recalcAlways_attr ;
        bool m_has_uiObject_attr ;
        boolean m_uiObject_attr ;
        bool m_has_autoFill_attr ;
        boolean m_autoFill_attr ;
        bool m_has_autoLine_attr ;
        boolean m_autoLine_attr ;
        bool m_has_autoPict_attr ;
        boolean m_autoPict_attr ;
        bool m_has_macro_attr ;
        ST_Formula* m_macro_attr ;
        bool m_has_altText_attr ;
        ns_s::ST_Xstring* m_altText_attr ;
        bool m_has_linkedCell_attr ;
        ST_Formula* m_linkedCell_attr ;
        bool m_has_listFillRange_attr ;
        ST_Formula* m_listFillRange_attr ;
        bool m_has_cf_attr ;
        ns_s::ST_Xstring* m_cf_attr ;
        bool m_has_id_attr ;
        ST_RelationshipId* m_id_attr ;

    }

    class CT_IgnoredErrors : public XSD::ComplexType{
    public:
        bool has_ignoredError(){

            return m_has_ignoredError;
        
        }
        CT_IgnoredError* mutable_ignoredError(){

                m_has_ignoredError = true;
                if (!m_ignoredError)
                {
                    m_ignoredError = new CT_IgnoredError();
                }
                return m_ignoredError;
            
        }
        const CT_IgnoredError& ignoredError(){

            if (m_ignoredError)
            {
                return *m_ignoredError;
            }
            return CT_IgnoredError::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_ignoredError = false;
                
        if (m_ignoredError)
        {
            delete m_ignoredError;
            m_ignoredError = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_ignoredError)
                {
                    m_ignoredError->toXml(ignoredError, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_ignoredError->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_IgnoredErrors& default_instance(){

    if (!CT_IgnoredErrors::default_instance_)
    {
        CT_IgnoredErrors::default_instance_ = new CT_IgnoredErrors();
    }
    return *CT_IgnoredErrors::default_instance_;

        }

    private:
        bool m_has_ignoredError ;
        CT_IgnoredError* m_ignoredError ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_IgnoredErrors* default_instance_ ;

    }

    class CT_IgnoredError : public XSD::ComplexType{
    public:
        void clear(){

                m_has_sqref_attr = false;
                
        if (m_sqref_attr)
        {
            delete m_sqref_attr;
            m_sqref_attr = NULL;
        }
    
            
                m_has_evalError_attr = false;
                m_evalError_attr = false;
            
                m_has_twoDigitTextYear_attr = false;
                m_twoDigitTextYear_attr = false;
            
                m_has_numberStoredAsText_attr = false;
                m_numberStoredAsText_attr = false;
            
                m_has_formula_attr = false;
                m_formula_attr = false;
            
                m_has_formulaRange_attr = false;
                m_formulaRange_attr = false;
            
                m_has_unlockedFormula_attr = false;
                m_unlockedFormula_attr = false;
            
                m_has_emptyCellReference_attr = false;
                m_emptyCellReference_attr = false;
            
                m_has_listDataValidation_attr = false;
                m_listDataValidation_attr = false;
            
                m_has_calculatedColumn_attr = false;
                m_calculatedColumn_attr = false;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_sqref_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_evalError_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_twoDigitTextYear_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_numberStoredAsText_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_formula_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_formulaRange_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_unlockedFormula_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_emptyCellReference_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_listDataValidation_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_calculatedColumn_attr) << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_IgnoredError& default_instance(){

    if (!CT_IgnoredError::default_instance_)
    {
        CT_IgnoredError::default_instance_ = new CT_IgnoredError();
    }
    return *CT_IgnoredError::default_instance_;

        }
        bool has_sqref_attr(){

            return m_has_sqref_attr;
        
        }
        void set_sqref_attr(const ST_Sqref& _sqref_attr ){

            m_has_sqref_attr = true;
            m_sqref_attr = new ST_Sqref(_sqref_attr);
        
        }
        const ST_Sqref& sqref_attr(){

            if (m_sqref_attr)
            {
                return *m_sqref_attr;
            }
            return ST_Sqref::default_instance();
        
        }
        bool has_evalError_attr(){

            return m_has_evalError_attr;
        
        }
        void set_evalError_attr(const boolean& _evalError_attr ){

        m_has_evalError_attr = true;
        m_evalError_attr = _evalError_attr;
        
        }
        const boolean& evalError_attr(){

            return type: oolean\nname: \m_evalError_attr\n;
        
        }
        bool has_twoDigitTextYear_attr(){

            return m_has_twoDigitTextYear_attr;
        
        }
        void set_twoDigitTextYear_attr(const boolean& _twoDigitTextYear_attr ){

        m_has_twoDigitTextYear_attr = true;
        m_twoDigitTextYear_attr = _twoDigitTextYear_attr;
        
        }
        const boolean& twoDigitTextYear_attr(){

            return type: oolean\nname: \m_twoDigitTextYear_attr\n;
        
        }
        bool has_numberStoredAsText_attr(){

            return m_has_numberStoredAsText_attr;
        
        }
        void set_numberStoredAsText_attr(const boolean& _numberStoredAsText_attr ){

        m_has_numberStoredAsText_attr = true;
        m_numberStoredAsText_attr = _numberStoredAsText_attr;
        
        }
        const boolean& numberStoredAsText_attr(){

            return type: oolean\nname: \m_numberStoredAsText_attr\n;
        
        }
        bool has_formula_attr(){

            return m_has_formula_attr;
        
        }
        void set_formula_attr(const boolean& _formula_attr ){

        m_has_formula_attr = true;
        m_formula_attr = _formula_attr;
        
        }
        const boolean& formula_attr(){

            return type: oolean\nname: \m_formula_attr\n;
        
        }
        bool has_formulaRange_attr(){

            return m_has_formulaRange_attr;
        
        }
        void set_formulaRange_attr(const boolean& _formulaRange_attr ){

        m_has_formulaRange_attr = true;
        m_formulaRange_attr = _formulaRange_attr;
        
        }
        const boolean& formulaRange_attr(){

            return type: oolean\nname: \m_formulaRange_attr\n;
        
        }
        bool has_unlockedFormula_attr(){

            return m_has_unlockedFormula_attr;
        
        }
        void set_unlockedFormula_attr(const boolean& _unlockedFormula_attr ){

        m_has_unlockedFormula_attr = true;
        m_unlockedFormula_attr = _unlockedFormula_attr;
        
        }
        const boolean& unlockedFormula_attr(){

            return type: oolean\nname: \m_unlockedFormula_attr\n;
        
        }
        bool has_emptyCellReference_attr(){

            return m_has_emptyCellReference_attr;
        
        }
        void set_emptyCellReference_attr(const boolean& _emptyCellReference_attr ){

        m_has_emptyCellReference_attr = true;
        m_emptyCellReference_attr = _emptyCellReference_attr;
        
        }
        const boolean& emptyCellReference_attr(){

            return type: oolean\nname: \m_emptyCellReference_attr\n;
        
        }
        bool has_listDataValidation_attr(){

            return m_has_listDataValidation_attr;
        
        }
        void set_listDataValidation_attr(const boolean& _listDataValidation_attr ){

        m_has_listDataValidation_attr = true;
        m_listDataValidation_attr = _listDataValidation_attr;
        
        }
        const boolean& listDataValidation_attr(){

            return type: oolean\nname: \m_listDataValidation_attr\n;
        
        }
        bool has_calculatedColumn_attr(){

            return m_has_calculatedColumn_attr;
        
        }
        void set_calculatedColumn_attr(const boolean& _calculatedColumn_attr ){

        m_has_calculatedColumn_attr = true;
        m_calculatedColumn_attr = _calculatedColumn_attr;
        
        }
        const boolean& calculatedColumn_attr(){

            return type: oolean\nname: \m_calculatedColumn_attr\n;
        
        }

    private:
        static CT_IgnoredError* default_instance_ ;
        bool m_has_sqref_attr ;
        ST_Sqref* m_sqref_attr ;
        bool m_has_evalError_attr ;
        boolean m_evalError_attr ;
        bool m_has_twoDigitTextYear_attr ;
        boolean m_twoDigitTextYear_attr ;
        bool m_has_numberStoredAsText_attr ;
        boolean m_numberStoredAsText_attr ;
        bool m_has_formula_attr ;
        boolean m_formula_attr ;
        bool m_has_formulaRange_attr ;
        boolean m_formulaRange_attr ;
        bool m_has_unlockedFormula_attr ;
        boolean m_unlockedFormula_attr ;
        bool m_has_emptyCellReference_attr ;
        boolean m_emptyCellReference_attr ;
        bool m_has_listDataValidation_attr ;
        boolean m_listDataValidation_attr ;
        bool m_has_calculatedColumn_attr ;
        boolean m_calculatedColumn_attr ;

    }

    class CT_TableParts : public XSD::ComplexType{
    public:
        bool has_tablePart(){

            return m_has_tablePart;
        
        }
        CT_TablePart* mutable_tablePart(){

                m_has_tablePart = true;
                if (!m_tablePart)
                {
                    m_tablePart = new CT_TablePart();
                }
                return m_tablePart;
            
        }
        const CT_TablePart& tablePart(){

            if (m_tablePart)
            {
                return *m_tablePart;
            }
            return CT_TablePart::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_tablePart = false;
                
        if (m_tablePart)
        {
            delete m_tablePart;
            m_tablePart = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_tablePart)
                {
                    m_tablePart->toXml(tablePart, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_TableParts& default_instance(){

    if (!CT_TableParts::default_instance_)
    {
        CT_TableParts::default_instance_ = new CT_TableParts();
    }
    return *CT_TableParts::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_tablePart ;
        CT_TablePart* m_tablePart ;
        static CT_TableParts* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_TablePart : public XSD::ComplexType{
    public:
        void clear(){

                m_has_id_attr = false;
                
        if (m_id_attr)
        {
            delete m_id_attr;
            m_id_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_id_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_TablePart& default_instance(){

    if (!CT_TablePart::default_instance_)
    {
        CT_TablePart::default_instance_ = new CT_TablePart();
    }
    return *CT_TablePart::default_instance_;

        }
        bool has_id_attr(){

            return m_has_id_attr;
        
        }
        void set_id_attr(const ST_RelationshipId& _id_attr ){

            m_has_id_attr = true;
            m_id_attr = new ST_RelationshipId(_id_attr);
        
        }
        const ST_RelationshipId& id_attr(){

            if (m_id_attr)
            {
                return *m_id_attr;
            }
            return ST_RelationshipId::default_instance();
        
        }

    private:
        static CT_TablePart* default_instance_ ;
        bool m_has_id_attr ;
        ST_RelationshipId* m_id_attr ;

    }

    class CT_Metadata : public XSD::ComplexType{
    public:
        bool has_metadataTypes(){

            return m_has_metadataTypes;
        
        }
        CT_MetadataTypes* mutable_metadataTypes(){

                m_has_metadataTypes = true;
                if (!m_metadataTypes)
                {
                    m_metadataTypes = new CT_MetadataTypes();
                }
                return m_metadataTypes;
            
        }
        const CT_MetadataTypes& metadataTypes(){

            if (m_metadataTypes)
            {
                return *m_metadataTypes;
            }
            return CT_MetadataTypes::default_instance();
        
        }
        bool has_metadataStrings(){

            return m_has_metadataStrings;
        
        }
        CT_MetadataStrings* mutable_metadataStrings(){

                m_has_metadataStrings = true;
                if (!m_metadataStrings)
                {
                    m_metadataStrings = new CT_MetadataStrings();
                }
                return m_metadataStrings;
            
        }
        const CT_MetadataStrings& metadataStrings(){

            if (m_metadataStrings)
            {
                return *m_metadataStrings;
            }
            return CT_MetadataStrings::default_instance();
        
        }
        bool has_mdxMetadata(){

            return m_has_mdxMetadata;
        
        }
        CT_MdxMetadata* mutable_mdxMetadata(){

                m_has_mdxMetadata = true;
                if (!m_mdxMetadata)
                {
                    m_mdxMetadata = new CT_MdxMetadata();
                }
                return m_mdxMetadata;
            
        }
        const CT_MdxMetadata& mdxMetadata(){

            if (m_mdxMetadata)
            {
                return *m_mdxMetadata;
            }
            return CT_MdxMetadata::default_instance();
        
        }
        bool has_futureMetadata(){

            return m_has_futureMetadata;
        
        }
        CT_FutureMetadata* mutable_futureMetadata(){

                m_has_futureMetadata = true;
                if (!m_futureMetadata)
                {
                    m_futureMetadata = new CT_FutureMetadata();
                }
                return m_futureMetadata;
            
        }
        const CT_FutureMetadata& futureMetadata(){

            if (m_futureMetadata)
            {
                return *m_futureMetadata;
            }
            return CT_FutureMetadata::default_instance();
        
        }
        bool has_cellMetadata(){

            return m_has_cellMetadata;
        
        }
        CT_MetadataBlocks* mutable_cellMetadata(){

                m_has_cellMetadata = true;
                if (!m_cellMetadata)
                {
                    m_cellMetadata = new CT_MetadataBlocks();
                }
                return m_cellMetadata;
            
        }
        const CT_MetadataBlocks& cellMetadata(){

            if (m_cellMetadata)
            {
                return *m_cellMetadata;
            }
            return CT_MetadataBlocks::default_instance();
        
        }
        bool has_valueMetadata(){

            return m_has_valueMetadata;
        
        }
        CT_MetadataBlocks* mutable_valueMetadata(){

                m_has_valueMetadata = true;
                if (!m_valueMetadata)
                {
                    m_valueMetadata = new CT_MetadataBlocks();
                }
                return m_valueMetadata;
            
        }
        const CT_MetadataBlocks& valueMetadata(){

            if (m_valueMetadata)
            {
                return *m_valueMetadata;
            }
            return CT_MetadataBlocks::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_metadataTypes = false;
                
        if (m_metadataTypes)
        {
            delete m_metadataTypes;
            m_metadataTypes = NULL;
        }
    
            
                m_has_metadataStrings = false;
                
        if (m_metadataStrings)
        {
            delete m_metadataStrings;
            m_metadataStrings = NULL;
        }
    
            
                m_has_mdxMetadata = false;
                
        if (m_mdxMetadata)
        {
            delete m_mdxMetadata;
            m_mdxMetadata = NULL;
        }
    
            
                m_has_futureMetadata = false;
                
        if (m_futureMetadata)
        {
            delete m_futureMetadata;
            m_futureMetadata = NULL;
        }
    
            
                m_has_cellMetadata = false;
                
        if (m_cellMetadata)
        {
            delete m_cellMetadata;
            m_cellMetadata = NULL;
        }
    
            
                m_has_valueMetadata = false;
                
        if (m_valueMetadata)
        {
            delete m_valueMetadata;
            m_valueMetadata = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_metadataTypes)
                {
                    m_metadataTypes->toXml(metadataTypes, _outStream);;
                }
            
                if (m_has_metadataStrings)
                {
                    m_metadataTypes->toXml(metadataStrings, _outStream);;
                }
            
                if (m_has_mdxMetadata)
                {
                    m_metadataTypes->toXml(mdxMetadata, _outStream);;
                }
            
                if (m_has_futureMetadata)
                {
                    m_metadataTypes->toXml(futureMetadata, _outStream);;
                }
            
                if (m_has_cellMetadata)
                {
                    m_metadataTypes->toXml(cellMetadata, _outStream);;
                }
            
                if (m_has_valueMetadata)
                {
                    m_metadataTypes->toXml(valueMetadata, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_metadataTypes->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Metadata& default_instance(){

    if (!CT_Metadata::default_instance_)
    {
        CT_Metadata::default_instance_ = new CT_Metadata();
    }
    return *CT_Metadata::default_instance_;

        }

    private:
        bool m_has_metadataTypes ;
        CT_MetadataTypes* m_metadataTypes ;
        bool m_has_metadataStrings ;
        CT_MetadataStrings* m_metadataStrings ;
        bool m_has_mdxMetadata ;
        CT_MdxMetadata* m_mdxMetadata ;
        bool m_has_futureMetadata ;
        CT_FutureMetadata* m_futureMetadata ;
        bool m_has_cellMetadata ;
        CT_MetadataBlocks* m_cellMetadata ;
        bool m_has_valueMetadata ;
        CT_MetadataBlocks* m_valueMetadata ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_Metadata* default_instance_ ;

    }

    class CT_MetadataTypes : public XSD::ComplexType{
    public:
        bool has_metadataType(){

            return m_has_metadataType;
        
        }
        CT_MetadataType* mutable_metadataType(){

                m_has_metadataType = true;
                if (!m_metadataType)
                {
                    m_metadataType = new CT_MetadataType();
                }
                return m_metadataType;
            
        }
        const CT_MetadataType& metadataType(){

            if (m_metadataType)
            {
                return *m_metadataType;
            }
            return CT_MetadataType::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_metadataType = false;
                
        if (m_metadataType)
        {
            delete m_metadataType;
            m_metadataType = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_metadataType)
                {
                    m_metadataType->toXml(metadataType, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_MetadataTypes& default_instance(){

    if (!CT_MetadataTypes::default_instance_)
    {
        CT_MetadataTypes::default_instance_ = new CT_MetadataTypes();
    }
    return *CT_MetadataTypes::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_metadataType ;
        CT_MetadataType* m_metadataType ;
        static CT_MetadataTypes* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_MetadataType : public XSD::ComplexType{
    public:
        void clear(){

                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
                m_has_minSupportedVersion_attr = false;
                m_minSupportedVersion_attr = 0;
            
                m_has_ghostRow_attr = false;
                m_ghostRow_attr = false;
            
                m_has_ghostCol_attr = false;
                m_ghostCol_attr = false;
            
                m_has_edit_attr = false;
                m_edit_attr = false;
            
                m_has_delete_attr = false;
                m_delete_attr = false;
            
                m_has_copy_attr = false;
                m_copy_attr = false;
            
                m_has_pasteAll_attr = false;
                m_pasteAll_attr = false;
            
                m_has_pasteFormulas_attr = false;
                m_pasteFormulas_attr = false;
            
                m_has_pasteValues_attr = false;
                m_pasteValues_attr = false;
            
                m_has_pasteFormats_attr = false;
                m_pasteFormats_attr = false;
            
                m_has_pasteComments_attr = false;
                m_pasteComments_attr = false;
            
                m_has_pasteDataValidation_attr = false;
                m_pasteDataValidation_attr = false;
            
                m_has_pasteBorders_attr = false;
                m_pasteBorders_attr = false;
            
                m_has_pasteColWidths_attr = false;
                m_pasteColWidths_attr = false;
            
                m_has_pasteNumberFormats_attr = false;
                m_pasteNumberFormats_attr = false;
            
                m_has_merge_attr = false;
                m_merge_attr = false;
            
                m_has_splitFirst_attr = false;
                m_splitFirst_attr = false;
            
                m_has_splitAll_attr = false;
                m_splitAll_attr = false;
            
                m_has_rowColShift_attr = false;
                m_rowColShift_attr = false;
            
                m_has_clearAll_attr = false;
                m_clearAll_attr = false;
            
                m_has_clearFormats_attr = false;
                m_clearFormats_attr = false;
            
                m_has_clearContents_attr = false;
                m_clearContents_attr = false;
            
                m_has_clearComments_attr = false;
                m_clearComments_attr = false;
            
                m_has_assign_attr = false;
                m_assign_attr = false;
            
                m_has_coerce_attr = false;
                m_coerce_attr = false;
            
                m_has_adjust_attr = false;
                m_adjust_attr = false;
            
                m_has_cellMeta_attr = false;
                m_cellMeta_attr = false;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_name_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_minSupportedVersion_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_ghostRow_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_ghostCol_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_edit_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_delete_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_copy_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_pasteAll_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_pasteFormulas_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_pasteValues_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_pasteFormats_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_pasteComments_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_pasteDataValidation_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_pasteBorders_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_pasteColWidths_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_pasteNumberFormats_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_merge_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_splitFirst_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_splitAll_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_rowColShift_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_clearAll_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_clearFormats_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_clearContents_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_clearComments_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_assign_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_coerce_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_adjust_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_cellMeta_attr) << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_MetadataType& default_instance(){

    if (!CT_MetadataType::default_instance_)
    {
        CT_MetadataType::default_instance_ = new CT_MetadataType();
    }
    return *CT_MetadataType::default_instance_;

        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_minSupportedVersion_attr(){

            return m_has_minSupportedVersion_attr;
        
        }
        void set_minSupportedVersion_attr(const unsignedInt& _minSupportedVersion_attr ){

        m_has_minSupportedVersion_attr = true;
        m_minSupportedVersion_attr = _minSupportedVersion_attr;
        
        }
        const unsignedInt& minSupportedVersion_attr(){

            return type: \unsignedInt\nname: \m_minSupportedVersion_attr\n;
        
        }
        bool has_ghostRow_attr(){

            return m_has_ghostRow_attr;
        
        }
        void set_ghostRow_attr(const boolean& _ghostRow_attr ){

        m_has_ghostRow_attr = true;
        m_ghostRow_attr = _ghostRow_attr;
        
        }
        const boolean& ghostRow_attr(){

            return type: oolean\nname: \m_ghostRow_attr\n;
        
        }
        bool has_ghostCol_attr(){

            return m_has_ghostCol_attr;
        
        }
        void set_ghostCol_attr(const boolean& _ghostCol_attr ){

        m_has_ghostCol_attr = true;
        m_ghostCol_attr = _ghostCol_attr;
        
        }
        const boolean& ghostCol_attr(){

            return type: oolean\nname: \m_ghostCol_attr\n;
        
        }
        bool has_edit_attr(){

            return m_has_edit_attr;
        
        }
        void set_edit_attr(const boolean& _edit_attr ){

        m_has_edit_attr = true;
        m_edit_attr = _edit_attr;
        
        }
        const boolean& edit_attr(){

            return type: oolean\nname: \m_edit_attr\n;
        
        }
        bool has_delete_attr(){

            return m_has_delete_attr;
        
        }
        void set_delete_attr(const boolean& _delete_attr ){

        m_has_delete_attr = true;
        m_delete_attr = _delete_attr;
        
        }
        const boolean& delete_attr(){

            return type: oolean\nname: \m_delete_attr\n;
        
        }
        bool has_copy_attr(){

            return m_has_copy_attr;
        
        }
        void set_copy_attr(const boolean& _copy_attr ){

        m_has_copy_attr = true;
        m_copy_attr = _copy_attr;
        
        }
        const boolean& copy_attr(){

            return type: oolean\nname: \m_copy_attr\n;
        
        }
        bool has_pasteAll_attr(){

            return m_has_pasteAll_attr;
        
        }
        void set_pasteAll_attr(const boolean& _pasteAll_attr ){

        m_has_pasteAll_attr = true;
        m_pasteAll_attr = _pasteAll_attr;
        
        }
        const boolean& pasteAll_attr(){

            return type: oolean\nname: \m_pasteAll_attr\n;
        
        }
        bool has_pasteFormulas_attr(){

            return m_has_pasteFormulas_attr;
        
        }
        void set_pasteFormulas_attr(const boolean& _pasteFormulas_attr ){

        m_has_pasteFormulas_attr = true;
        m_pasteFormulas_attr = _pasteFormulas_attr;
        
        }
        const boolean& pasteFormulas_attr(){

            return type: oolean\nname: \m_pasteFormulas_attr\n;
        
        }
        bool has_pasteValues_attr(){

            return m_has_pasteValues_attr;
        
        }
        void set_pasteValues_attr(const boolean& _pasteValues_attr ){

        m_has_pasteValues_attr = true;
        m_pasteValues_attr = _pasteValues_attr;
        
        }
        const boolean& pasteValues_attr(){

            return type: oolean\nname: \m_pasteValues_attr\n;
        
        }
        bool has_pasteFormats_attr(){

            return m_has_pasteFormats_attr;
        
        }
        void set_pasteFormats_attr(const boolean& _pasteFormats_attr ){

        m_has_pasteFormats_attr = true;
        m_pasteFormats_attr = _pasteFormats_attr;
        
        }
        const boolean& pasteFormats_attr(){

            return type: oolean\nname: \m_pasteFormats_attr\n;
        
        }
        bool has_pasteComments_attr(){

            return m_has_pasteComments_attr;
        
        }
        void set_pasteComments_attr(const boolean& _pasteComments_attr ){

        m_has_pasteComments_attr = true;
        m_pasteComments_attr = _pasteComments_attr;
        
        }
        const boolean& pasteComments_attr(){

            return type: oolean\nname: \m_pasteComments_attr\n;
        
        }
        bool has_pasteDataValidation_attr(){

            return m_has_pasteDataValidation_attr;
        
        }
        void set_pasteDataValidation_attr(const boolean& _pasteDataValidation_attr ){

        m_has_pasteDataValidation_attr = true;
        m_pasteDataValidation_attr = _pasteDataValidation_attr;
        
        }
        const boolean& pasteDataValidation_attr(){

            return type: oolean\nname: \m_pasteDataValidation_attr\n;
        
        }
        bool has_pasteBorders_attr(){

            return m_has_pasteBorders_attr;
        
        }
        void set_pasteBorders_attr(const boolean& _pasteBorders_attr ){

        m_has_pasteBorders_attr = true;
        m_pasteBorders_attr = _pasteBorders_attr;
        
        }
        const boolean& pasteBorders_attr(){

            return type: oolean\nname: \m_pasteBorders_attr\n;
        
        }
        bool has_pasteColWidths_attr(){

            return m_has_pasteColWidths_attr;
        
        }
        void set_pasteColWidths_attr(const boolean& _pasteColWidths_attr ){

        m_has_pasteColWidths_attr = true;
        m_pasteColWidths_attr = _pasteColWidths_attr;
        
        }
        const boolean& pasteColWidths_attr(){

            return type: oolean\nname: \m_pasteColWidths_attr\n;
        
        }
        bool has_pasteNumberFormats_attr(){

            return m_has_pasteNumberFormats_attr;
        
        }
        void set_pasteNumberFormats_attr(const boolean& _pasteNumberFormats_attr ){

        m_has_pasteNumberFormats_attr = true;
        m_pasteNumberFormats_attr = _pasteNumberFormats_attr;
        
        }
        const boolean& pasteNumberFormats_attr(){

            return type: oolean\nname: \m_pasteNumberFormats_attr\n;
        
        }
        bool has_merge_attr(){

            return m_has_merge_attr;
        
        }
        void set_merge_attr(const boolean& _merge_attr ){

        m_has_merge_attr = true;
        m_merge_attr = _merge_attr;
        
        }
        const boolean& merge_attr(){

            return type: oolean\nname: \m_merge_attr\n;
        
        }
        bool has_splitFirst_attr(){

            return m_has_splitFirst_attr;
        
        }
        void set_splitFirst_attr(const boolean& _splitFirst_attr ){

        m_has_splitFirst_attr = true;
        m_splitFirst_attr = _splitFirst_attr;
        
        }
        const boolean& splitFirst_attr(){

            return type: oolean\nname: \m_splitFirst_attr\n;
        
        }
        bool has_splitAll_attr(){

            return m_has_splitAll_attr;
        
        }
        void set_splitAll_attr(const boolean& _splitAll_attr ){

        m_has_splitAll_attr = true;
        m_splitAll_attr = _splitAll_attr;
        
        }
        const boolean& splitAll_attr(){

            return type: oolean\nname: \m_splitAll_attr\n;
        
        }
        bool has_rowColShift_attr(){

            return m_has_rowColShift_attr;
        
        }
        void set_rowColShift_attr(const boolean& _rowColShift_attr ){

        m_has_rowColShift_attr = true;
        m_rowColShift_attr = _rowColShift_attr;
        
        }
        const boolean& rowColShift_attr(){

            return type: oolean\nname: \m_rowColShift_attr\n;
        
        }
        bool has_clearAll_attr(){

            return m_has_clearAll_attr;
        
        }
        void set_clearAll_attr(const boolean& _clearAll_attr ){

        m_has_clearAll_attr = true;
        m_clearAll_attr = _clearAll_attr;
        
        }
        const boolean& clearAll_attr(){

            return type: oolean\nname: \m_clearAll_attr\n;
        
        }
        bool has_clearFormats_attr(){

            return m_has_clearFormats_attr;
        
        }
        void set_clearFormats_attr(const boolean& _clearFormats_attr ){

        m_has_clearFormats_attr = true;
        m_clearFormats_attr = _clearFormats_attr;
        
        }
        const boolean& clearFormats_attr(){

            return type: oolean\nname: \m_clearFormats_attr\n;
        
        }
        bool has_clearContents_attr(){

            return m_has_clearContents_attr;
        
        }
        void set_clearContents_attr(const boolean& _clearContents_attr ){

        m_has_clearContents_attr = true;
        m_clearContents_attr = _clearContents_attr;
        
        }
        const boolean& clearContents_attr(){

            return type: oolean\nname: \m_clearContents_attr\n;
        
        }
        bool has_clearComments_attr(){

            return m_has_clearComments_attr;
        
        }
        void set_clearComments_attr(const boolean& _clearComments_attr ){

        m_has_clearComments_attr = true;
        m_clearComments_attr = _clearComments_attr;
        
        }
        const boolean& clearComments_attr(){

            return type: oolean\nname: \m_clearComments_attr\n;
        
        }
        bool has_assign_attr(){

            return m_has_assign_attr;
        
        }
        void set_assign_attr(const boolean& _assign_attr ){

        m_has_assign_attr = true;
        m_assign_attr = _assign_attr;
        
        }
        const boolean& assign_attr(){

            return type: oolean\nname: \m_assign_attr\n;
        
        }
        bool has_coerce_attr(){

            return m_has_coerce_attr;
        
        }
        void set_coerce_attr(const boolean& _coerce_attr ){

        m_has_coerce_attr = true;
        m_coerce_attr = _coerce_attr;
        
        }
        const boolean& coerce_attr(){

            return type: oolean\nname: \m_coerce_attr\n;
        
        }
        bool has_adjust_attr(){

            return m_has_adjust_attr;
        
        }
        void set_adjust_attr(const boolean& _adjust_attr ){

        m_has_adjust_attr = true;
        m_adjust_attr = _adjust_attr;
        
        }
        const boolean& adjust_attr(){

            return type: oolean\nname: \m_adjust_attr\n;
        
        }
        bool has_cellMeta_attr(){

            return m_has_cellMeta_attr;
        
        }
        void set_cellMeta_attr(const boolean& _cellMeta_attr ){

        m_has_cellMeta_attr = true;
        m_cellMeta_attr = _cellMeta_attr;
        
        }
        const boolean& cellMeta_attr(){

            return type: oolean\nname: \m_cellMeta_attr\n;
        
        }

    private:
        static CT_MetadataType* default_instance_ ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;
        bool m_has_minSupportedVersion_attr ;
        unsignedInt m_minSupportedVersion_attr ;
        bool m_has_ghostRow_attr ;
        boolean m_ghostRow_attr ;
        bool m_has_ghostCol_attr ;
        boolean m_ghostCol_attr ;
        bool m_has_edit_attr ;
        boolean m_edit_attr ;
        bool m_has_delete_attr ;
        boolean m_delete_attr ;
        bool m_has_copy_attr ;
        boolean m_copy_attr ;
        bool m_has_pasteAll_attr ;
        boolean m_pasteAll_attr ;
        bool m_has_pasteFormulas_attr ;
        boolean m_pasteFormulas_attr ;
        bool m_has_pasteValues_attr ;
        boolean m_pasteValues_attr ;
        bool m_has_pasteFormats_attr ;
        boolean m_pasteFormats_attr ;
        bool m_has_pasteComments_attr ;
        boolean m_pasteComments_attr ;
        bool m_has_pasteDataValidation_attr ;
        boolean m_pasteDataValidation_attr ;
        bool m_has_pasteBorders_attr ;
        boolean m_pasteBorders_attr ;
        bool m_has_pasteColWidths_attr ;
        boolean m_pasteColWidths_attr ;
        bool m_has_pasteNumberFormats_attr ;
        boolean m_pasteNumberFormats_attr ;
        bool m_has_merge_attr ;
        boolean m_merge_attr ;
        bool m_has_splitFirst_attr ;
        boolean m_splitFirst_attr ;
        bool m_has_splitAll_attr ;
        boolean m_splitAll_attr ;
        bool m_has_rowColShift_attr ;
        boolean m_rowColShift_attr ;
        bool m_has_clearAll_attr ;
        boolean m_clearAll_attr ;
        bool m_has_clearFormats_attr ;
        boolean m_clearFormats_attr ;
        bool m_has_clearContents_attr ;
        boolean m_clearContents_attr ;
        bool m_has_clearComments_attr ;
        boolean m_clearComments_attr ;
        bool m_has_assign_attr ;
        boolean m_assign_attr ;
        bool m_has_coerce_attr ;
        boolean m_coerce_attr ;
        bool m_has_adjust_attr ;
        boolean m_adjust_attr ;
        bool m_has_cellMeta_attr ;
        boolean m_cellMeta_attr ;

    }

    class CT_MetadataBlocks : public XSD::ComplexType{
    public:
        bool has_bk(){

            return m_has_bk;
        
        }
        CT_MetadataBlock* mutable_bk(){

                m_has_bk = true;
                if (!m_bk)
                {
                    m_bk = new CT_MetadataBlock();
                }
                return m_bk;
            
        }
        const CT_MetadataBlock& bk(){

            if (m_bk)
            {
                return *m_bk;
            }
            return CT_MetadataBlock::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_bk = false;
                
        if (m_bk)
        {
            delete m_bk;
            m_bk = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_bk)
                {
                    m_bk->toXml(bk, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_MetadataBlocks& default_instance(){

    if (!CT_MetadataBlocks::default_instance_)
    {
        CT_MetadataBlocks::default_instance_ = new CT_MetadataBlocks();
    }
    return *CT_MetadataBlocks::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_bk ;
        CT_MetadataBlock* m_bk ;
        static CT_MetadataBlocks* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_MetadataBlock : public XSD::ComplexType{
    public:
        bool has_rc(){

            return m_has_rc;
        
        }
        CT_MetadataRecord* mutable_rc(){

                m_has_rc = true;
                if (!m_rc)
                {
                    m_rc = new CT_MetadataRecord();
                }
                return m_rc;
            
        }
        const CT_MetadataRecord& rc(){

            if (m_rc)
            {
                return *m_rc;
            }
            return CT_MetadataRecord::default_instance();
        
        }
        void clear(){

                m_has_rc = false;
                
        if (m_rc)
        {
            delete m_rc;
            m_rc = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_rc)
                {
                    m_rc->toXml(rc, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_MetadataBlock& default_instance(){

    if (!CT_MetadataBlock::default_instance_)
    {
        CT_MetadataBlock::default_instance_ = new CT_MetadataBlock();
    }
    return *CT_MetadataBlock::default_instance_;

        }

    private:
        bool m_has_rc ;
        CT_MetadataRecord* m_rc ;
        static CT_MetadataBlock* default_instance_ ;

    }

    class CT_MetadataRecord : public XSD::ComplexType{
    public:
        void clear(){

                m_has_t_attr = false;
                m_t_attr = 0;
            
                m_has_v_attr = false;
                m_v_attr = 0;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_t_attr << \\\;
_outStream << _attrName << \=\\ << m_v_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_MetadataRecord& default_instance(){

    if (!CT_MetadataRecord::default_instance_)
    {
        CT_MetadataRecord::default_instance_ = new CT_MetadataRecord();
    }
    return *CT_MetadataRecord::default_instance_;

        }
        bool has_t_attr(){

            return m_has_t_attr;
        
        }
        void set_t_attr(const unsignedInt& _t_attr ){

        m_has_t_attr = true;
        m_t_attr = _t_attr;
        
        }
        const unsignedInt& t_attr(){

            return type: \unsignedInt\nname: \m_t_attr\n;
        
        }
        bool has_v_attr(){

            return m_has_v_attr;
        
        }
        void set_v_attr(const unsignedInt& _v_attr ){

        m_has_v_attr = true;
        m_v_attr = _v_attr;
        
        }
        const unsignedInt& v_attr(){

            return type: \unsignedInt\nname: \m_v_attr\n;
        
        }

    private:
        static CT_MetadataRecord* default_instance_ ;
        bool m_has_t_attr ;
        unsignedInt m_t_attr ;
        bool m_has_v_attr ;
        unsignedInt m_v_attr ;

    }

    class CT_FutureMetadata : public XSD::ComplexType{
    public:
        bool has_bk(){

            return m_has_bk;
        
        }
        CT_FutureMetadataBlock* mutable_bk(){

                m_has_bk = true;
                if (!m_bk)
                {
                    m_bk = new CT_FutureMetadataBlock();
                }
                return m_bk;
            
        }
        const CT_FutureMetadataBlock& bk(){

            if (m_bk)
            {
                return *m_bk;
            }
            return CT_FutureMetadataBlock::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_bk = false;
                
        if (m_bk)
        {
            delete m_bk;
            m_bk = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_name_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_bk)
                {
                    m_bk->toXml(bk, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_bk->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_FutureMetadata& default_instance(){

    if (!CT_FutureMetadata::default_instance_)
    {
        CT_FutureMetadata::default_instance_ = new CT_FutureMetadata();
    }
    return *CT_FutureMetadata::default_instance_;

        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_bk ;
        CT_FutureMetadataBlock* m_bk ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_FutureMetadata* default_instance_ ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_FutureMetadataBlock : public XSD::ComplexType{
    public:
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_extLst)
                {
                    m_extLst->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_FutureMetadataBlock& default_instance(){

    if (!CT_FutureMetadataBlock::default_instance_)
    {
        CT_FutureMetadataBlock::default_instance_ = new CT_FutureMetadataBlock();
    }
    return *CT_FutureMetadataBlock::default_instance_;

        }

    private:
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_FutureMetadataBlock* default_instance_ ;

    }

    class CT_MdxMetadata : public XSD::ComplexType{
    public:
        bool has_mdx(){

            return m_has_mdx;
        
        }
        CT_Mdx* mutable_mdx(){

                m_has_mdx = true;
                if (!m_mdx)
                {
                    m_mdx = new CT_Mdx();
                }
                return m_mdx;
            
        }
        const CT_Mdx& mdx(){

            if (m_mdx)
            {
                return *m_mdx;
            }
            return CT_Mdx::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_mdx = false;
                
        if (m_mdx)
        {
            delete m_mdx;
            m_mdx = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_mdx)
                {
                    m_mdx->toXml(mdx, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_MdxMetadata& default_instance(){

    if (!CT_MdxMetadata::default_instance_)
    {
        CT_MdxMetadata::default_instance_ = new CT_MdxMetadata();
    }
    return *CT_MdxMetadata::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_mdx ;
        CT_Mdx* m_mdx ;
        static CT_MdxMetadata* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_Mdx : public XSD::ComplexType{
    public:
        bool has_t(){

            return m_has_t;
        
        }
        CT_MdxTuple* mutable_t(){

                
                m_has_ms = false;
                
        if (m_ms)
        {
            delete m_ms;
            m_ms = NULL;
        }
    ;
            
                m_has_p = false;
                
        if (m_p)
        {
            delete m_p;
            m_p = NULL;
        }
    ;
            
                m_has_k = false;
                
        if (m_k)
        {
            delete m_k;
            m_k = NULL;
        }
    ;
            
                m_has_t = true;
                if (!m_t)
                {
                    m_t = new CT_MdxTuple();
                }
                return m_t;
            
        }
        const CT_MdxTuple& t(){

            if (m_t)
            {
                return *m_t;
            }
            return CT_MdxTuple::default_instance();
        
        }
        bool has_ms(){

            return m_has_ms;
        
        }
        CT_MdxSet* mutable_ms(){

                
                m_has_t = false;
                
        if (m_t)
        {
            delete m_t;
            m_t = NULL;
        }
    ;
            
                m_has_p = false;
                
        if (m_p)
        {
            delete m_p;
            m_p = NULL;
        }
    ;
            
                m_has_k = false;
                
        if (m_k)
        {
            delete m_k;
            m_k = NULL;
        }
    ;
            
                m_has_ms = true;
                if (!m_ms)
                {
                    m_ms = new CT_MdxSet();
                }
                return m_ms;
            
        }
        const CT_MdxSet& ms(){

            if (m_ms)
            {
                return *m_ms;
            }
            return CT_MdxSet::default_instance();
        
        }
        bool has_p(){

            return m_has_p;
        
        }
        CT_MdxMemeberProp* mutable_p(){

                
                m_has_t = false;
                
        if (m_t)
        {
            delete m_t;
            m_t = NULL;
        }
    ;
            
                m_has_ms = false;
                
        if (m_ms)
        {
            delete m_ms;
            m_ms = NULL;
        }
    ;
            
                m_has_k = false;
                
        if (m_k)
        {
            delete m_k;
            m_k = NULL;
        }
    ;
            
                m_has_p = true;
                if (!m_p)
                {
                    m_p = new CT_MdxMemeberProp();
                }
                return m_p;
            
        }
        const CT_MdxMemeberProp& p(){

            if (m_p)
            {
                return *m_p;
            }
            return CT_MdxMemeberProp::default_instance();
        
        }
        bool has_k(){

            return m_has_k;
        
        }
        CT_MdxKPI* mutable_k(){

                
                m_has_t = false;
                
        if (m_t)
        {
            delete m_t;
            m_t = NULL;
        }
    ;
            
                m_has_ms = false;
                
        if (m_ms)
        {
            delete m_ms;
            m_ms = NULL;
        }
    ;
            
                m_has_p = false;
                
        if (m_p)
        {
            delete m_p;
            m_p = NULL;
        }
    ;
            
                m_has_k = true;
                if (!m_k)
                {
                    m_k = new CT_MdxKPI();
                }
                return m_k;
            
        }
        const CT_MdxKPI& k(){

            if (m_k)
            {
                return *m_k;
            }
            return CT_MdxKPI::default_instance();
        
        }
        void clear(){

                m_has_n_attr = false;
                m_n_attr = 0;
            
                m_has_f_attr = false;
                
        if (m_f_attr)
        {
            delete m_f_attr;
            m_f_attr = NULL;
        }
    
            
                m_has_t = false;
                
        if (m_t)
        {
            delete m_t;
            m_t = NULL;
        }
    
            
                m_has_ms = false;
                
        if (m_ms)
        {
            delete m_ms;
            m_ms = NULL;
        }
    
            
                m_has_p = false;
                
        if (m_p)
        {
            delete m_p;
            m_p = NULL;
        }
    
            
                m_has_k = false;
                
        if (m_k)
        {
            delete m_k;
            m_k = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_n_attr << \\\;
m_f_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_t)
                {
                    m_t->toXml(t, _outStream);;
                }
            
                if (m_has_ms)
                {
                    m_t->toXml(ms, _outStream);;
                }
            
                if (m_has_p)
                {
                    m_t->toXml(p, _outStream);;
                }
            
                if (m_has_k)
                {
                    m_t->toXml(k, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Mdx& default_instance(){

    if (!CT_Mdx::default_instance_)
    {
        CT_Mdx::default_instance_ = new CT_Mdx();
    }
    return *CT_Mdx::default_instance_;

        }
        bool has_n_attr(){

            return m_has_n_attr;
        
        }
        void set_n_attr(const unsignedInt& _n_attr ){

        m_has_n_attr = true;
        m_n_attr = _n_attr;
        
        }
        const unsignedInt& n_attr(){

            return type: \unsignedInt\nname: \m_n_attr\n;
        
        }
        bool has_f_attr(){

            return m_has_f_attr;
        
        }
        void set_f_attr(const ST_MdxFunctionType& _f_attr ){

            m_has_f_attr = true;
            m_f_attr = new ST_MdxFunctionType(_f_attr);
        
        }
        const ST_MdxFunctionType& f_attr(){

            if (m_f_attr)
            {
                return *m_f_attr;
            }
            return ST_MdxFunctionType::default_instance();
        
        }

    private:
        bool m_has_t ;
        CT_MdxTuple* m_t ;
        bool m_has_ms ;
        CT_MdxSet* m_ms ;
        bool m_has_p ;
        CT_MdxMemeberProp* m_p ;
        bool m_has_k ;
        CT_MdxKPI* m_k ;
        static CT_Mdx* default_instance_ ;
        bool m_has_n_attr ;
        unsignedInt m_n_attr ;
        bool m_has_f_attr ;
        ST_MdxFunctionType* m_f_attr ;

    }

    class CT_MdxTuple : public XSD::ComplexType{
    public:
        bool has_n(){

            return m_has_n;
        
        }
        CT_MetadataStringIndex* mutable_n(){

                m_has_n = true;
                if (!m_n)
                {
                    m_n = new CT_MetadataStringIndex();
                }
                return m_n;
            
        }
        const CT_MetadataStringIndex& n(){

            if (m_n)
            {
                return *m_n;
            }
            return CT_MetadataStringIndex::default_instance();
        
        }
        void clear(){

                m_has_c_attr = false;
                m_c_attr = 0;
            
                m_has_ct_attr = false;
                
        if (m_ct_attr)
        {
            delete m_ct_attr;
            m_ct_attr = NULL;
        }
    
            
                m_has_si_attr = false;
                m_si_attr = 0;
            
                m_has_fi_attr = false;
                m_fi_attr = 0;
            
                m_has_bc_attr = false;
                
        if (m_bc_attr)
        {
            delete m_bc_attr;
            m_bc_attr = NULL;
        }
    
            
                m_has_fc_attr = false;
                
        if (m_fc_attr)
        {
            delete m_fc_attr;
            m_fc_attr = NULL;
        }
    
            
                m_has_i_attr = false;
                m_i_attr = false;
            
                m_has_u_attr = false;
                m_u_attr = false;
            
                m_has_st_attr = false;
                m_st_attr = false;
            
                m_has_b_attr = false;
                m_b_attr = false;
            
                m_has_n = false;
                
        if (m_n)
        {
            delete m_n;
            m_n = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_c_attr << \\\;
m_ct_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_si_attr << \\\;
_outStream << _attrName << \=\\ << m_fi_attr << \\\;
m_bc_attr->toXml(_attrName, _outStream);
m_fc_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_i_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_u_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_st_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_b_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_n)
                {
                    m_n->toXml(n, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_MdxTuple& default_instance(){

    if (!CT_MdxTuple::default_instance_)
    {
        CT_MdxTuple::default_instance_ = new CT_MdxTuple();
    }
    return *CT_MdxTuple::default_instance_;

        }
        bool has_c_attr(){

            return m_has_c_attr;
        
        }
        void set_c_attr(const unsignedInt& _c_attr ){

        m_has_c_attr = true;
        m_c_attr = _c_attr;
        
        }
        const unsignedInt& c_attr(){

            return type: \unsignedInt\nname: \m_c_attr\n;
        
        }
        bool has_ct_attr(){

            return m_has_ct_attr;
        
        }
        void set_ct_attr(const ns_s::ST_Xstring& _ct_attr ){

            m_has_ct_attr = true;
            m_ct_attr = new ns_s::ST_Xstring(_ct_attr);
        
        }
        const ns_s::ST_Xstring& ct_attr(){

            if (m_ct_attr)
            {
                return *m_ct_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_si_attr(){

            return m_has_si_attr;
        
        }
        void set_si_attr(const unsignedInt& _si_attr ){

        m_has_si_attr = true;
        m_si_attr = _si_attr;
        
        }
        const unsignedInt& si_attr(){

            return type: \unsignedInt\nname: \m_si_attr\n;
        
        }
        bool has_fi_attr(){

            return m_has_fi_attr;
        
        }
        void set_fi_attr(const unsignedInt& _fi_attr ){

        m_has_fi_attr = true;
        m_fi_attr = _fi_attr;
        
        }
        const unsignedInt& fi_attr(){

            return type: \unsignedInt\nname: \m_fi_attr\n;
        
        }
        bool has_bc_attr(){

            return m_has_bc_attr;
        
        }
        void set_bc_attr(const ST_UnsignedIntHex& _bc_attr ){

            m_has_bc_attr = true;
            m_bc_attr = new ST_UnsignedIntHex(_bc_attr);
        
        }
        const ST_UnsignedIntHex& bc_attr(){

            if (m_bc_attr)
            {
                return *m_bc_attr;
            }
            return ST_UnsignedIntHex::default_instance();
        
        }
        bool has_fc_attr(){

            return m_has_fc_attr;
        
        }
        void set_fc_attr(const ST_UnsignedIntHex& _fc_attr ){

            m_has_fc_attr = true;
            m_fc_attr = new ST_UnsignedIntHex(_fc_attr);
        
        }
        const ST_UnsignedIntHex& fc_attr(){

            if (m_fc_attr)
            {
                return *m_fc_attr;
            }
            return ST_UnsignedIntHex::default_instance();
        
        }
        bool has_i_attr(){

            return m_has_i_attr;
        
        }
        void set_i_attr(const boolean& _i_attr ){

        m_has_i_attr = true;
        m_i_attr = _i_attr;
        
        }
        const boolean& i_attr(){

            return type: oolean\nname: \m_i_attr\n;
        
        }
        bool has_u_attr(){

            return m_has_u_attr;
        
        }
        void set_u_attr(const boolean& _u_attr ){

        m_has_u_attr = true;
        m_u_attr = _u_attr;
        
        }
        const boolean& u_attr(){

            return type: oolean\nname: \m_u_attr\n;
        
        }
        bool has_st_attr(){

            return m_has_st_attr;
        
        }
        void set_st_attr(const boolean& _st_attr ){

        m_has_st_attr = true;
        m_st_attr = _st_attr;
        
        }
        const boolean& st_attr(){

            return type: oolean\nname: \m_st_attr\n;
        
        }
        bool has_b_attr(){

            return m_has_b_attr;
        
        }
        void set_b_attr(const boolean& _b_attr ){

        m_has_b_attr = true;
        m_b_attr = _b_attr;
        
        }
        const boolean& b_attr(){

            return type: oolean\nname: \m_b_attr\n;
        
        }

    private:
        bool m_has_n ;
        CT_MetadataStringIndex* m_n ;
        static CT_MdxTuple* default_instance_ ;
        bool m_has_c_attr ;
        unsignedInt m_c_attr ;
        bool m_has_ct_attr ;
        ns_s::ST_Xstring* m_ct_attr ;
        bool m_has_si_attr ;
        unsignedInt m_si_attr ;
        bool m_has_fi_attr ;
        unsignedInt m_fi_attr ;
        bool m_has_bc_attr ;
        ST_UnsignedIntHex* m_bc_attr ;
        bool m_has_fc_attr ;
        ST_UnsignedIntHex* m_fc_attr ;
        bool m_has_i_attr ;
        boolean m_i_attr ;
        bool m_has_u_attr ;
        boolean m_u_attr ;
        bool m_has_st_attr ;
        boolean m_st_attr ;
        bool m_has_b_attr ;
        boolean m_b_attr ;

    }

    class CT_MdxSet : public XSD::ComplexType{
    public:
        bool has_n(){

            return m_has_n;
        
        }
        CT_MetadataStringIndex* mutable_n(){

                m_has_n = true;
                if (!m_n)
                {
                    m_n = new CT_MetadataStringIndex();
                }
                return m_n;
            
        }
        const CT_MetadataStringIndex& n(){

            if (m_n)
            {
                return *m_n;
            }
            return CT_MetadataStringIndex::default_instance();
        
        }
        void clear(){

                m_has_ns_attr = false;
                m_ns_attr = 0;
            
                m_has_c_attr = false;
                m_c_attr = 0;
            
                m_has_o_attr = false;
                
        if (m_o_attr)
        {
            delete m_o_attr;
            m_o_attr = NULL;
        }
    
            
                m_has_n = false;
                
        if (m_n)
        {
            delete m_n;
            m_n = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_ns_attr << \\\;
_outStream << _attrName << \=\\ << m_c_attr << \\\;
m_o_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_n)
                {
                    m_n->toXml(n, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_MdxSet& default_instance(){

    if (!CT_MdxSet::default_instance_)
    {
        CT_MdxSet::default_instance_ = new CT_MdxSet();
    }
    return *CT_MdxSet::default_instance_;

        }
        bool has_ns_attr(){

            return m_has_ns_attr;
        
        }
        void set_ns_attr(const unsignedInt& _ns_attr ){

        m_has_ns_attr = true;
        m_ns_attr = _ns_attr;
        
        }
        const unsignedInt& ns_attr(){

            return type: \unsignedInt\nname: \m_ns_attr\n;
        
        }
        bool has_c_attr(){

            return m_has_c_attr;
        
        }
        void set_c_attr(const unsignedInt& _c_attr ){

        m_has_c_attr = true;
        m_c_attr = _c_attr;
        
        }
        const unsignedInt& c_attr(){

            return type: \unsignedInt\nname: \m_c_attr\n;
        
        }
        bool has_o_attr(){

            return m_has_o_attr;
        
        }
        void set_o_attr(const ST_MdxSetOrder& _o_attr ){

            m_has_o_attr = true;
            m_o_attr = new ST_MdxSetOrder(_o_attr);
        
        }
        const ST_MdxSetOrder& o_attr(){

            if (m_o_attr)
            {
                return *m_o_attr;
            }
            return ST_MdxSetOrder::default_instance();
        
        }

    private:
        bool m_has_n ;
        CT_MetadataStringIndex* m_n ;
        static CT_MdxSet* default_instance_ ;
        bool m_has_ns_attr ;
        unsignedInt m_ns_attr ;
        bool m_has_c_attr ;
        unsignedInt m_c_attr ;
        bool m_has_o_attr ;
        ST_MdxSetOrder* m_o_attr ;

    }

    class CT_MdxMemeberProp : public XSD::ComplexType{
    public:
        void clear(){

                m_has_n_attr = false;
                m_n_attr = 0;
            
                m_has_np_attr = false;
                m_np_attr = 0;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_n_attr << \\\;
_outStream << _attrName << \=\\ << m_np_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_MdxMemeberProp& default_instance(){

    if (!CT_MdxMemeberProp::default_instance_)
    {
        CT_MdxMemeberProp::default_instance_ = new CT_MdxMemeberProp();
    }
    return *CT_MdxMemeberProp::default_instance_;

        }
        bool has_n_attr(){

            return m_has_n_attr;
        
        }
        void set_n_attr(const unsignedInt& _n_attr ){

        m_has_n_attr = true;
        m_n_attr = _n_attr;
        
        }
        const unsignedInt& n_attr(){

            return type: \unsignedInt\nname: \m_n_attr\n;
        
        }
        bool has_np_attr(){

            return m_has_np_attr;
        
        }
        void set_np_attr(const unsignedInt& _np_attr ){

        m_has_np_attr = true;
        m_np_attr = _np_attr;
        
        }
        const unsignedInt& np_attr(){

            return type: \unsignedInt\nname: \m_np_attr\n;
        
        }

    private:
        static CT_MdxMemeberProp* default_instance_ ;
        bool m_has_n_attr ;
        unsignedInt m_n_attr ;
        bool m_has_np_attr ;
        unsignedInt m_np_attr ;

    }

    class CT_MdxKPI : public XSD::ComplexType{
    public:
        void clear(){

                m_has_n_attr = false;
                m_n_attr = 0;
            
                m_has_np_attr = false;
                m_np_attr = 0;
            
                m_has_p_attr = false;
                
        if (m_p_attr)
        {
            delete m_p_attr;
            m_p_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_n_attr << \\\;
_outStream << _attrName << \=\\ << m_np_attr << \\\;
m_p_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_MdxKPI& default_instance(){

    if (!CT_MdxKPI::default_instance_)
    {
        CT_MdxKPI::default_instance_ = new CT_MdxKPI();
    }
    return *CT_MdxKPI::default_instance_;

        }
        bool has_n_attr(){

            return m_has_n_attr;
        
        }
        void set_n_attr(const unsignedInt& _n_attr ){

        m_has_n_attr = true;
        m_n_attr = _n_attr;
        
        }
        const unsignedInt& n_attr(){

            return type: \unsignedInt\nname: \m_n_attr\n;
        
        }
        bool has_np_attr(){

            return m_has_np_attr;
        
        }
        void set_np_attr(const unsignedInt& _np_attr ){

        m_has_np_attr = true;
        m_np_attr = _np_attr;
        
        }
        const unsignedInt& np_attr(){

            return type: \unsignedInt\nname: \m_np_attr\n;
        
        }
        bool has_p_attr(){

            return m_has_p_attr;
        
        }
        void set_p_attr(const ST_MdxKPIProperty& _p_attr ){

            m_has_p_attr = true;
            m_p_attr = new ST_MdxKPIProperty(_p_attr);
        
        }
        const ST_MdxKPIProperty& p_attr(){

            if (m_p_attr)
            {
                return *m_p_attr;
            }
            return ST_MdxKPIProperty::default_instance();
        
        }

    private:
        static CT_MdxKPI* default_instance_ ;
        bool m_has_n_attr ;
        unsignedInt m_n_attr ;
        bool m_has_np_attr ;
        unsignedInt m_np_attr ;
        bool m_has_p_attr ;
        ST_MdxKPIProperty* m_p_attr ;

    }

    class CT_MetadataStringIndex : public XSD::ComplexType{
    public:
        void clear(){

                m_has_x_attr = false;
                m_x_attr = 0;
            
                m_has_s_attr = false;
                m_s_attr = false;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_x_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_s_attr) << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_MetadataStringIndex& default_instance(){

    if (!CT_MetadataStringIndex::default_instance_)
    {
        CT_MetadataStringIndex::default_instance_ = new CT_MetadataStringIndex();
    }
    return *CT_MetadataStringIndex::default_instance_;

        }
        bool has_x_attr(){

            return m_has_x_attr;
        
        }
        void set_x_attr(const unsignedInt& _x_attr ){

        m_has_x_attr = true;
        m_x_attr = _x_attr;
        
        }
        const unsignedInt& x_attr(){

            return type: \unsignedInt\nname: \m_x_attr\n;
        
        }
        bool has_s_attr(){

            return m_has_s_attr;
        
        }
        void set_s_attr(const boolean& _s_attr ){

        m_has_s_attr = true;
        m_s_attr = _s_attr;
        
        }
        const boolean& s_attr(){

            return type: oolean\nname: \m_s_attr\n;
        
        }

    private:
        static CT_MetadataStringIndex* default_instance_ ;
        bool m_has_x_attr ;
        unsignedInt m_x_attr ;
        bool m_has_s_attr ;
        boolean m_s_attr ;

    }

    class CT_MetadataStrings : public XSD::ComplexType{
    public:
        bool has_s(){

            return m_has_s;
        
        }
        CT_XStringElement* mutable_s(){

                m_has_s = true;
                if (!m_s)
                {
                    m_s = new CT_XStringElement();
                }
                return m_s;
            
        }
        const CT_XStringElement& s(){

            if (m_s)
            {
                return *m_s;
            }
            return CT_XStringElement::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_s = false;
                
        if (m_s)
        {
            delete m_s;
            m_s = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_s)
                {
                    m_s->toXml(s, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_MetadataStrings& default_instance(){

    if (!CT_MetadataStrings::default_instance_)
    {
        CT_MetadataStrings::default_instance_ = new CT_MetadataStrings();
    }
    return *CT_MetadataStrings::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_s ;
        CT_XStringElement* m_s ;
        static CT_MetadataStrings* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_SingleXmlCells : public XSD::ComplexType{
    public:
        bool has_singleXmlCell(){

            return m_has_singleXmlCell;
        
        }
        CT_SingleXmlCell* mutable_singleXmlCell(){

                m_has_singleXmlCell = true;
                if (!m_singleXmlCell)
                {
                    m_singleXmlCell = new CT_SingleXmlCell();
                }
                return m_singleXmlCell;
            
        }
        const CT_SingleXmlCell& singleXmlCell(){

            if (m_singleXmlCell)
            {
                return *m_singleXmlCell;
            }
            return CT_SingleXmlCell::default_instance();
        
        }
        void clear(){

                m_has_singleXmlCell = false;
                
        if (m_singleXmlCell)
        {
            delete m_singleXmlCell;
            m_singleXmlCell = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_singleXmlCell)
                {
                    m_singleXmlCell->toXml(singleXmlCell, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_SingleXmlCells& default_instance(){

    if (!CT_SingleXmlCells::default_instance_)
    {
        CT_SingleXmlCells::default_instance_ = new CT_SingleXmlCells();
    }
    return *CT_SingleXmlCells::default_instance_;

        }

    private:
        bool m_has_singleXmlCell ;
        CT_SingleXmlCell* m_singleXmlCell ;
        static CT_SingleXmlCells* default_instance_ ;

    }

    class CT_SingleXmlCell : public XSD::ComplexType{
    public:
        bool has_xmlCellPr(){

            return m_has_xmlCellPr;
        
        }
        CT_XmlCellPr* mutable_xmlCellPr(){

                m_has_xmlCellPr = true;
                if (!m_xmlCellPr)
                {
                    m_xmlCellPr = new CT_XmlCellPr();
                }
                return m_xmlCellPr;
            
        }
        const CT_XmlCellPr& xmlCellPr(){

            if (m_xmlCellPr)
            {
                return *m_xmlCellPr;
            }
            return CT_XmlCellPr::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_id_attr = false;
                m_id_attr = 0;
            
                m_has_r_attr = false;
                
        if (m_r_attr)
        {
            delete m_r_attr;
            m_r_attr = NULL;
        }
    
            
                m_has_connectionId_attr = false;
                m_connectionId_attr = 0;
            
                m_has_xmlCellPr = false;
                
        if (m_xmlCellPr)
        {
            delete m_xmlCellPr;
            m_xmlCellPr = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_id_attr << \\\;
m_r_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_connectionId_attr << \\\;
        _outStream << \>\;
    
                if (m_has_xmlCellPr)
                {
                    m_xmlCellPr->toXml(xmlCellPr, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_xmlCellPr->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_SingleXmlCell& default_instance(){

    if (!CT_SingleXmlCell::default_instance_)
    {
        CT_SingleXmlCell::default_instance_ = new CT_SingleXmlCell();
    }
    return *CT_SingleXmlCell::default_instance_;

        }
        bool has_id_attr(){

            return m_has_id_attr;
        
        }
        void set_id_attr(const unsignedInt& _id_attr ){

        m_has_id_attr = true;
        m_id_attr = _id_attr;
        
        }
        const unsignedInt& id_attr(){

            return type: \unsignedInt\nname: \m_id_attr\n;
        
        }
        bool has_r_attr(){

            return m_has_r_attr;
        
        }
        void set_r_attr(const ST_CellRef& _r_attr ){

            m_has_r_attr = true;
            m_r_attr = new ST_CellRef(_r_attr);
        
        }
        const ST_CellRef& r_attr(){

            if (m_r_attr)
            {
                return *m_r_attr;
            }
            return ST_CellRef::default_instance();
        
        }
        bool has_connectionId_attr(){

            return m_has_connectionId_attr;
        
        }
        void set_connectionId_attr(const unsignedInt& _connectionId_attr ){

        m_has_connectionId_attr = true;
        m_connectionId_attr = _connectionId_attr;
        
        }
        const unsignedInt& connectionId_attr(){

            return type: \unsignedInt\nname: \m_connectionId_attr\n;
        
        }

    private:
        bool m_has_xmlCellPr ;
        CT_XmlCellPr* m_xmlCellPr ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_SingleXmlCell* default_instance_ ;
        bool m_has_id_attr ;
        unsignedInt m_id_attr ;
        bool m_has_r_attr ;
        ST_CellRef* m_r_attr ;
        bool m_has_connectionId_attr ;
        unsignedInt m_connectionId_attr ;

    }

    class CT_XmlCellPr : public XSD::ComplexType{
    public:
        bool has_xmlPr(){

            return m_has_xmlPr;
        
        }
        CT_XmlPr* mutable_xmlPr(){

                m_has_xmlPr = true;
                if (!m_xmlPr)
                {
                    m_xmlPr = new CT_XmlPr();
                }
                return m_xmlPr;
            
        }
        const CT_XmlPr& xmlPr(){

            if (m_xmlPr)
            {
                return *m_xmlPr;
            }
            return CT_XmlPr::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_id_attr = false;
                m_id_attr = 0;
            
                m_has_uniqueName_attr = false;
                
        if (m_uniqueName_attr)
        {
            delete m_uniqueName_attr;
            m_uniqueName_attr = NULL;
        }
    
            
                m_has_xmlPr = false;
                
        if (m_xmlPr)
        {
            delete m_xmlPr;
            m_xmlPr = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_id_attr << \\\;
m_uniqueName_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_xmlPr)
                {
                    m_xmlPr->toXml(xmlPr, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_xmlPr->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_XmlCellPr& default_instance(){

    if (!CT_XmlCellPr::default_instance_)
    {
        CT_XmlCellPr::default_instance_ = new CT_XmlCellPr();
    }
    return *CT_XmlCellPr::default_instance_;

        }
        bool has_id_attr(){

            return m_has_id_attr;
        
        }
        void set_id_attr(const unsignedInt& _id_attr ){

        m_has_id_attr = true;
        m_id_attr = _id_attr;
        
        }
        const unsignedInt& id_attr(){

            return type: \unsignedInt\nname: \m_id_attr\n;
        
        }
        bool has_uniqueName_attr(){

            return m_has_uniqueName_attr;
        
        }
        void set_uniqueName_attr(const ns_s::ST_Xstring& _uniqueName_attr ){

            m_has_uniqueName_attr = true;
            m_uniqueName_attr = new ns_s::ST_Xstring(_uniqueName_attr);
        
        }
        const ns_s::ST_Xstring& uniqueName_attr(){

            if (m_uniqueName_attr)
            {
                return *m_uniqueName_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }

    private:
        bool m_has_xmlPr ;
        CT_XmlPr* m_xmlPr ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_XmlCellPr* default_instance_ ;
        bool m_has_id_attr ;
        unsignedInt m_id_attr ;
        bool m_has_uniqueName_attr ;
        ns_s::ST_Xstring* m_uniqueName_attr ;

    }

    class CT_XmlPr : public XSD::ComplexType{
    public:
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_mapId_attr = false;
                m_mapId_attr = 0;
            
                m_has_xpath_attr = false;
                
        if (m_xpath_attr)
        {
            delete m_xpath_attr;
            m_xpath_attr = NULL;
        }
    
            
                m_has_xmlDataType_attr = false;
                
        if (m_xmlDataType_attr)
        {
            delete m_xmlDataType_attr;
            m_xmlDataType_attr = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_mapId_attr << \\\;
m_xpath_attr->toXml(_attrName, _outStream);
m_xmlDataType_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_extLst)
                {
                    m_extLst->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_XmlPr& default_instance(){

    if (!CT_XmlPr::default_instance_)
    {
        CT_XmlPr::default_instance_ = new CT_XmlPr();
    }
    return *CT_XmlPr::default_instance_;

        }
        bool has_mapId_attr(){

            return m_has_mapId_attr;
        
        }
        void set_mapId_attr(const unsignedInt& _mapId_attr ){

        m_has_mapId_attr = true;
        m_mapId_attr = _mapId_attr;
        
        }
        const unsignedInt& mapId_attr(){

            return type: \unsignedInt\nname: \m_mapId_attr\n;
        
        }
        bool has_xpath_attr(){

            return m_has_xpath_attr;
        
        }
        void set_xpath_attr(const ns_s::ST_Xstring& _xpath_attr ){

            m_has_xpath_attr = true;
            m_xpath_attr = new ns_s::ST_Xstring(_xpath_attr);
        
        }
        const ns_s::ST_Xstring& xpath_attr(){

            if (m_xpath_attr)
            {
                return *m_xpath_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_xmlDataType_attr(){

            return m_has_xmlDataType_attr;
        
        }
        void set_xmlDataType_attr(const ST_XmlDataType& _xmlDataType_attr ){

            m_has_xmlDataType_attr = true;
            m_xmlDataType_attr = new ST_XmlDataType(_xmlDataType_attr);
        
        }
        const ST_XmlDataType& xmlDataType_attr(){

            if (m_xmlDataType_attr)
            {
                return *m_xmlDataType_attr;
            }
            return ST_XmlDataType::default_instance();
        
        }

    private:
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_XmlPr* default_instance_ ;
        bool m_has_mapId_attr ;
        unsignedInt m_mapId_attr ;
        bool m_has_xpath_attr ;
        ns_s::ST_Xstring* m_xpath_attr ;
        bool m_has_xmlDataType_attr ;
        ST_XmlDataType* m_xmlDataType_attr ;

    }

    class CT_Stylesheet : public XSD::ComplexType{
    public:
        bool has_numFmts(){

            return m_has_numFmts;
        
        }
        CT_NumFmts* mutable_numFmts(){

                m_has_numFmts = true;
                if (!m_numFmts)
                {
                    m_numFmts = new CT_NumFmts();
                }
                return m_numFmts;
            
        }
        const CT_NumFmts& numFmts(){

            if (m_numFmts)
            {
                return *m_numFmts;
            }
            return CT_NumFmts::default_instance();
        
        }
        bool has_fonts(){

            return m_has_fonts;
        
        }
        CT_Fonts* mutable_fonts(){

                m_has_fonts = true;
                if (!m_fonts)
                {
                    m_fonts = new CT_Fonts();
                }
                return m_fonts;
            
        }
        const CT_Fonts& fonts(){

            if (m_fonts)
            {
                return *m_fonts;
            }
            return CT_Fonts::default_instance();
        
        }
        bool has_fills(){

            return m_has_fills;
        
        }
        CT_Fills* mutable_fills(){

                m_has_fills = true;
                if (!m_fills)
                {
                    m_fills = new CT_Fills();
                }
                return m_fills;
            
        }
        const CT_Fills& fills(){

            if (m_fills)
            {
                return *m_fills;
            }
            return CT_Fills::default_instance();
        
        }
        bool has_borders(){

            return m_has_borders;
        
        }
        CT_Borders* mutable_borders(){

                m_has_borders = true;
                if (!m_borders)
                {
                    m_borders = new CT_Borders();
                }
                return m_borders;
            
        }
        const CT_Borders& borders(){

            if (m_borders)
            {
                return *m_borders;
            }
            return CT_Borders::default_instance();
        
        }
        bool has_cellStyleXfs(){

            return m_has_cellStyleXfs;
        
        }
        CT_CellStyleXfs* mutable_cellStyleXfs(){

                m_has_cellStyleXfs = true;
                if (!m_cellStyleXfs)
                {
                    m_cellStyleXfs = new CT_CellStyleXfs();
                }
                return m_cellStyleXfs;
            
        }
        const CT_CellStyleXfs& cellStyleXfs(){

            if (m_cellStyleXfs)
            {
                return *m_cellStyleXfs;
            }
            return CT_CellStyleXfs::default_instance();
        
        }
        bool has_cellXfs(){

            return m_has_cellXfs;
        
        }
        CT_CellXfs* mutable_cellXfs(){

                m_has_cellXfs = true;
                if (!m_cellXfs)
                {
                    m_cellXfs = new CT_CellXfs();
                }
                return m_cellXfs;
            
        }
        const CT_CellXfs& cellXfs(){

            if (m_cellXfs)
            {
                return *m_cellXfs;
            }
            return CT_CellXfs::default_instance();
        
        }
        bool has_cellStyles(){

            return m_has_cellStyles;
        
        }
        CT_CellStyles* mutable_cellStyles(){

                m_has_cellStyles = true;
                if (!m_cellStyles)
                {
                    m_cellStyles = new CT_CellStyles();
                }
                return m_cellStyles;
            
        }
        const CT_CellStyles& cellStyles(){

            if (m_cellStyles)
            {
                return *m_cellStyles;
            }
            return CT_CellStyles::default_instance();
        
        }
        bool has_dxfs(){

            return m_has_dxfs;
        
        }
        CT_Dxfs* mutable_dxfs(){

                m_has_dxfs = true;
                if (!m_dxfs)
                {
                    m_dxfs = new CT_Dxfs();
                }
                return m_dxfs;
            
        }
        const CT_Dxfs& dxfs(){

            if (m_dxfs)
            {
                return *m_dxfs;
            }
            return CT_Dxfs::default_instance();
        
        }
        bool has_tableStyles(){

            return m_has_tableStyles;
        
        }
        CT_TableStyles* mutable_tableStyles(){

                m_has_tableStyles = true;
                if (!m_tableStyles)
                {
                    m_tableStyles = new CT_TableStyles();
                }
                return m_tableStyles;
            
        }
        const CT_TableStyles& tableStyles(){

            if (m_tableStyles)
            {
                return *m_tableStyles;
            }
            return CT_TableStyles::default_instance();
        
        }
        bool has_colors(){

            return m_has_colors;
        
        }
        CT_Colors* mutable_colors(){

                m_has_colors = true;
                if (!m_colors)
                {
                    m_colors = new CT_Colors();
                }
                return m_colors;
            
        }
        const CT_Colors& colors(){

            if (m_colors)
            {
                return *m_colors;
            }
            return CT_Colors::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_numFmts = false;
                
        if (m_numFmts)
        {
            delete m_numFmts;
            m_numFmts = NULL;
        }
    
            
                m_has_fonts = false;
                
        if (m_fonts)
        {
            delete m_fonts;
            m_fonts = NULL;
        }
    
            
                m_has_fills = false;
                
        if (m_fills)
        {
            delete m_fills;
            m_fills = NULL;
        }
    
            
                m_has_borders = false;
                
        if (m_borders)
        {
            delete m_borders;
            m_borders = NULL;
        }
    
            
                m_has_cellStyleXfs = false;
                
        if (m_cellStyleXfs)
        {
            delete m_cellStyleXfs;
            m_cellStyleXfs = NULL;
        }
    
            
                m_has_cellXfs = false;
                
        if (m_cellXfs)
        {
            delete m_cellXfs;
            m_cellXfs = NULL;
        }
    
            
                m_has_cellStyles = false;
                
        if (m_cellStyles)
        {
            delete m_cellStyles;
            m_cellStyles = NULL;
        }
    
            
                m_has_dxfs = false;
                
        if (m_dxfs)
        {
            delete m_dxfs;
            m_dxfs = NULL;
        }
    
            
                m_has_tableStyles = false;
                
        if (m_tableStyles)
        {
            delete m_tableStyles;
            m_tableStyles = NULL;
        }
    
            
                m_has_colors = false;
                
        if (m_colors)
        {
            delete m_colors;
            m_colors = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_numFmts)
                {
                    m_numFmts->toXml(numFmts, _outStream);;
                }
            
                if (m_has_fonts)
                {
                    m_numFmts->toXml(fonts, _outStream);;
                }
            
                if (m_has_fills)
                {
                    m_numFmts->toXml(fills, _outStream);;
                }
            
                if (m_has_borders)
                {
                    m_numFmts->toXml(borders, _outStream);;
                }
            
                if (m_has_cellStyleXfs)
                {
                    m_numFmts->toXml(cellStyleXfs, _outStream);;
                }
            
                if (m_has_cellXfs)
                {
                    m_numFmts->toXml(cellXfs, _outStream);;
                }
            
                if (m_has_cellStyles)
                {
                    m_numFmts->toXml(cellStyles, _outStream);;
                }
            
                if (m_has_dxfs)
                {
                    m_numFmts->toXml(dxfs, _outStream);;
                }
            
                if (m_has_tableStyles)
                {
                    m_numFmts->toXml(tableStyles, _outStream);;
                }
            
                if (m_has_colors)
                {
                    m_numFmts->toXml(colors, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_numFmts->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Stylesheet& default_instance(){

    if (!CT_Stylesheet::default_instance_)
    {
        CT_Stylesheet::default_instance_ = new CT_Stylesheet();
    }
    return *CT_Stylesheet::default_instance_;

        }

    private:
        bool m_has_numFmts ;
        CT_NumFmts* m_numFmts ;
        bool m_has_fonts ;
        CT_Fonts* m_fonts ;
        bool m_has_fills ;
        CT_Fills* m_fills ;
        bool m_has_borders ;
        CT_Borders* m_borders ;
        bool m_has_cellStyleXfs ;
        CT_CellStyleXfs* m_cellStyleXfs ;
        bool m_has_cellXfs ;
        CT_CellXfs* m_cellXfs ;
        bool m_has_cellStyles ;
        CT_CellStyles* m_cellStyles ;
        bool m_has_dxfs ;
        CT_Dxfs* m_dxfs ;
        bool m_has_tableStyles ;
        CT_TableStyles* m_tableStyles ;
        bool m_has_colors ;
        CT_Colors* m_colors ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_Stylesheet* default_instance_ ;

    }

    class CT_CellAlignment : public XSD::ComplexType{
    public:
        void clear(){

                m_has_horizontal_attr = false;
                
        if (m_horizontal_attr)
        {
            delete m_horizontal_attr;
            m_horizontal_attr = NULL;
        }
    
            
                m_has_vertical_attr = false;
                
        if (m_vertical_attr)
        {
            delete m_vertical_attr;
            m_vertical_attr = NULL;
        }
    
            
                m_has_textRotation_attr = false;
                m_textRotation_attr = 0;
            
                m_has_wrapText_attr = false;
                m_wrapText_attr = false;
            
                m_has_indent_attr = false;
                m_indent_attr = 0;
            
                m_has_relativeIndent_attr = false;
                m_relativeIndent_attr = 0;
            
                m_has_justifyLastLine_attr = false;
                m_justifyLastLine_attr = false;
            
                m_has_shrinkToFit_attr = false;
                m_shrinkToFit_attr = false;
            
                m_has_readingOrder_attr = false;
                m_readingOrder_attr = 0;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_horizontal_attr->toXml(_attrName, _outStream);
m_vertical_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_textRotation_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_wrapText_attr) << \\\;
_outStream << _attrName << \=\\ << m_indent_attr << \\\;
_outStream << _attrName << \=\\ << m_relativeIndent_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_justifyLastLine_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_shrinkToFit_attr) << \\\;
_outStream << _attrName << \=\\ << m_readingOrder_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CellAlignment& default_instance(){

    if (!CT_CellAlignment::default_instance_)
    {
        CT_CellAlignment::default_instance_ = new CT_CellAlignment();
    }
    return *CT_CellAlignment::default_instance_;

        }
        bool has_horizontal_attr(){

            return m_has_horizontal_attr;
        
        }
        void set_horizontal_attr(const ST_HorizontalAlignment& _horizontal_attr ){

            m_has_horizontal_attr = true;
            m_horizontal_attr = new ST_HorizontalAlignment(_horizontal_attr);
        
        }
        const ST_HorizontalAlignment& horizontal_attr(){

            if (m_horizontal_attr)
            {
                return *m_horizontal_attr;
            }
            return ST_HorizontalAlignment::default_instance();
        
        }
        bool has_vertical_attr(){

            return m_has_vertical_attr;
        
        }
        void set_vertical_attr(const ST_VerticalAlignment& _vertical_attr ){

            m_has_vertical_attr = true;
            m_vertical_attr = new ST_VerticalAlignment(_vertical_attr);
        
        }
        const ST_VerticalAlignment& vertical_attr(){

            if (m_vertical_attr)
            {
                return *m_vertical_attr;
            }
            return ST_VerticalAlignment::default_instance();
        
        }
        bool has_textRotation_attr(){

            return m_has_textRotation_attr;
        
        }
        void set_textRotation_attr(const unsignedInt& _textRotation_attr ){

        m_has_textRotation_attr = true;
        m_textRotation_attr = _textRotation_attr;
        
        }
        const unsignedInt& textRotation_attr(){

            return type: \unsignedInt\nname: \m_textRotation_attr\n;
        
        }
        bool has_wrapText_attr(){

            return m_has_wrapText_attr;
        
        }
        void set_wrapText_attr(const boolean& _wrapText_attr ){

        m_has_wrapText_attr = true;
        m_wrapText_attr = _wrapText_attr;
        
        }
        const boolean& wrapText_attr(){

            return type: oolean\nname: \m_wrapText_attr\n;
        
        }
        bool has_indent_attr(){

            return m_has_indent_attr;
        
        }
        void set_indent_attr(const unsignedInt& _indent_attr ){

        m_has_indent_attr = true;
        m_indent_attr = _indent_attr;
        
        }
        const unsignedInt& indent_attr(){

            return type: \unsignedInt\nname: \m_indent_attr\n;
        
        }
        bool has_relativeIndent_attr(){

            return m_has_relativeIndent_attr;
        
        }
        void set_relativeIndent_attr(const int& _relativeIndent_attr ){

        m_has_relativeIndent_attr = true;
        m_relativeIndent_attr = _relativeIndent_attr;
        
        }
        const int& relativeIndent_attr(){

            return type: \int\nname: \m_relativeIndent_attr\n;
        
        }
        bool has_justifyLastLine_attr(){

            return m_has_justifyLastLine_attr;
        
        }
        void set_justifyLastLine_attr(const boolean& _justifyLastLine_attr ){

        m_has_justifyLastLine_attr = true;
        m_justifyLastLine_attr = _justifyLastLine_attr;
        
        }
        const boolean& justifyLastLine_attr(){

            return type: oolean\nname: \m_justifyLastLine_attr\n;
        
        }
        bool has_shrinkToFit_attr(){

            return m_has_shrinkToFit_attr;
        
        }
        void set_shrinkToFit_attr(const boolean& _shrinkToFit_attr ){

        m_has_shrinkToFit_attr = true;
        m_shrinkToFit_attr = _shrinkToFit_attr;
        
        }
        const boolean& shrinkToFit_attr(){

            return type: oolean\nname: \m_shrinkToFit_attr\n;
        
        }
        bool has_readingOrder_attr(){

            return m_has_readingOrder_attr;
        
        }
        void set_readingOrder_attr(const unsignedInt& _readingOrder_attr ){

        m_has_readingOrder_attr = true;
        m_readingOrder_attr = _readingOrder_attr;
        
        }
        const unsignedInt& readingOrder_attr(){

            return type: \unsignedInt\nname: \m_readingOrder_attr\n;
        
        }

    private:
        static CT_CellAlignment* default_instance_ ;
        bool m_has_horizontal_attr ;
        ST_HorizontalAlignment* m_horizontal_attr ;
        bool m_has_vertical_attr ;
        ST_VerticalAlignment* m_vertical_attr ;
        bool m_has_textRotation_attr ;
        unsignedInt m_textRotation_attr ;
        bool m_has_wrapText_attr ;
        boolean m_wrapText_attr ;
        bool m_has_indent_attr ;
        unsignedInt m_indent_attr ;
        bool m_has_relativeIndent_attr ;
        int m_relativeIndent_attr ;
        bool m_has_justifyLastLine_attr ;
        boolean m_justifyLastLine_attr ;
        bool m_has_shrinkToFit_attr ;
        boolean m_shrinkToFit_attr ;
        bool m_has_readingOrder_attr ;
        unsignedInt m_readingOrder_attr ;

    }

    class CT_Borders : public XSD::ComplexType{
    public:
        bool has_border(){

            return m_has_border;
        
        }
        CT_Border* mutable_border(){

                m_has_border = true;
                if (!m_border)
                {
                    m_border = new CT_Border();
                }
                return m_border;
            
        }
        const CT_Border& border(){

            if (m_border)
            {
                return *m_border;
            }
            return CT_Border::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_border = false;
                
        if (m_border)
        {
            delete m_border;
            m_border = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_border)
                {
                    m_border->toXml(border, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Borders& default_instance(){

    if (!CT_Borders::default_instance_)
    {
        CT_Borders::default_instance_ = new CT_Borders();
    }
    return *CT_Borders::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_border ;
        CT_Border* m_border ;
        static CT_Borders* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_Border : public XSD::ComplexType{
    public:
        bool has_start(){

            return m_has_start;
        
        }
        CT_BorderPr* mutable_start(){

                m_has_start = true;
                if (!m_start)
                {
                    m_start = new CT_BorderPr();
                }
                return m_start;
            
        }
        const CT_BorderPr& start(){

            if (m_start)
            {
                return *m_start;
            }
            return CT_BorderPr::default_instance();
        
        }
        bool has_end(){

            return m_has_end;
        
        }
        CT_BorderPr* mutable_end(){

                m_has_end = true;
                if (!m_end)
                {
                    m_end = new CT_BorderPr();
                }
                return m_end;
            
        }
        const CT_BorderPr& end(){

            if (m_end)
            {
                return *m_end;
            }
            return CT_BorderPr::default_instance();
        
        }
        bool has_left(){

            return m_has_left;
        
        }
        CT_BorderPr* mutable_left(){

                m_has_left = true;
                if (!m_left)
                {
                    m_left = new CT_BorderPr();
                }
                return m_left;
            
        }
        const CT_BorderPr& left(){

            if (m_left)
            {
                return *m_left;
            }
            return CT_BorderPr::default_instance();
        
        }
        bool has_right(){

            return m_has_right;
        
        }
        CT_BorderPr* mutable_right(){

                m_has_right = true;
                if (!m_right)
                {
                    m_right = new CT_BorderPr();
                }
                return m_right;
            
        }
        const CT_BorderPr& right(){

            if (m_right)
            {
                return *m_right;
            }
            return CT_BorderPr::default_instance();
        
        }
        bool has_top(){

            return m_has_top;
        
        }
        CT_BorderPr* mutable_top(){

                m_has_top = true;
                if (!m_top)
                {
                    m_top = new CT_BorderPr();
                }
                return m_top;
            
        }
        const CT_BorderPr& top(){

            if (m_top)
            {
                return *m_top;
            }
            return CT_BorderPr::default_instance();
        
        }
        bool has_bottom(){

            return m_has_bottom;
        
        }
        CT_BorderPr* mutable_bottom(){

                m_has_bottom = true;
                if (!m_bottom)
                {
                    m_bottom = new CT_BorderPr();
                }
                return m_bottom;
            
        }
        const CT_BorderPr& bottom(){

            if (m_bottom)
            {
                return *m_bottom;
            }
            return CT_BorderPr::default_instance();
        
        }
        bool has_diagonal(){

            return m_has_diagonal;
        
        }
        CT_BorderPr* mutable_diagonal(){

                m_has_diagonal = true;
                if (!m_diagonal)
                {
                    m_diagonal = new CT_BorderPr();
                }
                return m_diagonal;
            
        }
        const CT_BorderPr& diagonal(){

            if (m_diagonal)
            {
                return *m_diagonal;
            }
            return CT_BorderPr::default_instance();
        
        }
        bool has_vertical(){

            return m_has_vertical;
        
        }
        CT_BorderPr* mutable_vertical(){

                m_has_vertical = true;
                if (!m_vertical)
                {
                    m_vertical = new CT_BorderPr();
                }
                return m_vertical;
            
        }
        const CT_BorderPr& vertical(){

            if (m_vertical)
            {
                return *m_vertical;
            }
            return CT_BorderPr::default_instance();
        
        }
        bool has_horizontal(){

            return m_has_horizontal;
        
        }
        CT_BorderPr* mutable_horizontal(){

                m_has_horizontal = true;
                if (!m_horizontal)
                {
                    m_horizontal = new CT_BorderPr();
                }
                return m_horizontal;
            
        }
        const CT_BorderPr& horizontal(){

            if (m_horizontal)
            {
                return *m_horizontal;
            }
            return CT_BorderPr::default_instance();
        
        }
        void clear(){

                m_has_diagonalUp_attr = false;
                m_diagonalUp_attr = false;
            
                m_has_diagonalDown_attr = false;
                m_diagonalDown_attr = false;
            
                m_has_outline_attr = false;
                m_outline_attr = false;
            
                m_has_start = false;
                
        if (m_start)
        {
            delete m_start;
            m_start = NULL;
        }
    
            
                m_has_end = false;
                
        if (m_end)
        {
            delete m_end;
            m_end = NULL;
        }
    
            
                m_has_left = false;
                
        if (m_left)
        {
            delete m_left;
            m_left = NULL;
        }
    
            
                m_has_right = false;
                
        if (m_right)
        {
            delete m_right;
            m_right = NULL;
        }
    
            
                m_has_top = false;
                
        if (m_top)
        {
            delete m_top;
            m_top = NULL;
        }
    
            
                m_has_bottom = false;
                
        if (m_bottom)
        {
            delete m_bottom;
            m_bottom = NULL;
        }
    
            
                m_has_diagonal = false;
                
        if (m_diagonal)
        {
            delete m_diagonal;
            m_diagonal = NULL;
        }
    
            
                m_has_vertical = false;
                
        if (m_vertical)
        {
            delete m_vertical;
            m_vertical = NULL;
        }
    
            
                m_has_horizontal = false;
                
        if (m_horizontal)
        {
            delete m_horizontal;
            m_horizontal = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_diagonalUp_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_diagonalDown_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_outline_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_start)
                {
                    m_start->toXml(start, _outStream);;
                }
            
                if (m_has_end)
                {
                    m_start->toXml(end, _outStream);;
                }
            
                if (m_has_left)
                {
                    m_start->toXml(left, _outStream);;
                }
            
                if (m_has_right)
                {
                    m_start->toXml(right, _outStream);;
                }
            
                if (m_has_top)
                {
                    m_start->toXml(top, _outStream);;
                }
            
                if (m_has_bottom)
                {
                    m_start->toXml(bottom, _outStream);;
                }
            
                if (m_has_diagonal)
                {
                    m_start->toXml(diagonal, _outStream);;
                }
            
                if (m_has_vertical)
                {
                    m_start->toXml(vertical, _outStream);;
                }
            
                if (m_has_horizontal)
                {
                    m_start->toXml(horizontal, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Border& default_instance(){

    if (!CT_Border::default_instance_)
    {
        CT_Border::default_instance_ = new CT_Border();
    }
    return *CT_Border::default_instance_;

        }
        bool has_diagonalUp_attr(){

            return m_has_diagonalUp_attr;
        
        }
        void set_diagonalUp_attr(const boolean& _diagonalUp_attr ){

        m_has_diagonalUp_attr = true;
        m_diagonalUp_attr = _diagonalUp_attr;
        
        }
        const boolean& diagonalUp_attr(){

            return type: oolean\nname: \m_diagonalUp_attr\n;
        
        }
        bool has_diagonalDown_attr(){

            return m_has_diagonalDown_attr;
        
        }
        void set_diagonalDown_attr(const boolean& _diagonalDown_attr ){

        m_has_diagonalDown_attr = true;
        m_diagonalDown_attr = _diagonalDown_attr;
        
        }
        const boolean& diagonalDown_attr(){

            return type: oolean\nname: \m_diagonalDown_attr\n;
        
        }
        bool has_outline_attr(){

            return m_has_outline_attr;
        
        }
        void set_outline_attr(const boolean& _outline_attr ){

        m_has_outline_attr = true;
        m_outline_attr = _outline_attr;
        
        }
        const boolean& outline_attr(){

            return type: oolean\nname: \m_outline_attr\n;
        
        }

    private:
        bool m_has_start ;
        CT_BorderPr* m_start ;
        bool m_has_end ;
        CT_BorderPr* m_end ;
        bool m_has_left ;
        CT_BorderPr* m_left ;
        bool m_has_right ;
        CT_BorderPr* m_right ;
        bool m_has_top ;
        CT_BorderPr* m_top ;
        bool m_has_bottom ;
        CT_BorderPr* m_bottom ;
        bool m_has_diagonal ;
        CT_BorderPr* m_diagonal ;
        bool m_has_vertical ;
        CT_BorderPr* m_vertical ;
        bool m_has_horizontal ;
        CT_BorderPr* m_horizontal ;
        static CT_Border* default_instance_ ;
        bool m_has_diagonalUp_attr ;
        boolean m_diagonalUp_attr ;
        bool m_has_diagonalDown_attr ;
        boolean m_diagonalDown_attr ;
        bool m_has_outline_attr ;
        boolean m_outline_attr ;

    }

    class CT_BorderPr : public XSD::ComplexType{
    public:
        bool has_color(){

            return m_has_color;
        
        }
        CT_Color* mutable_color(){

                m_has_color = true;
                if (!m_color)
                {
                    m_color = new CT_Color();
                }
                return m_color;
            
        }
        const CT_Color& color(){

            if (m_color)
            {
                return *m_color;
            }
            return CT_Color::default_instance();
        
        }
        void clear(){

                m_has_style_attr = false;
                
        if (m_style_attr)
        {
            delete m_style_attr;
            m_style_attr = NULL;
        }
    
            
                m_has_color = false;
                
        if (m_color)
        {
            delete m_color;
            m_color = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_style_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_color)
                {
                    m_color->toXml(color, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_BorderPr& default_instance(){

    if (!CT_BorderPr::default_instance_)
    {
        CT_BorderPr::default_instance_ = new CT_BorderPr();
    }
    return *CT_BorderPr::default_instance_;

        }
        bool has_style_attr(){

            return m_has_style_attr;
        
        }
        void set_style_attr(const ST_BorderStyle& _style_attr ){

            m_has_style_attr = true;
            m_style_attr = new ST_BorderStyle(_style_attr);
        
        }
        const ST_BorderStyle& style_attr(){

            if (m_style_attr)
            {
                return *m_style_attr;
            }
            return ST_BorderStyle::default_instance();
        
        }

    private:
        bool m_has_color ;
        CT_Color* m_color ;
        static CT_BorderPr* default_instance_ ;
        bool m_has_style_attr ;
        ST_BorderStyle* m_style_attr ;

    }

    class CT_CellProtection : public XSD::ComplexType{
    public:
        void clear(){

                m_has_locked_attr = false;
                m_locked_attr = false;
            
                m_has_hidden_attr = false;
                m_hidden_attr = false;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_locked_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_hidden_attr) << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CellProtection& default_instance(){

    if (!CT_CellProtection::default_instance_)
    {
        CT_CellProtection::default_instance_ = new CT_CellProtection();
    }
    return *CT_CellProtection::default_instance_;

        }
        bool has_locked_attr(){

            return m_has_locked_attr;
        
        }
        void set_locked_attr(const boolean& _locked_attr ){

        m_has_locked_attr = true;
        m_locked_attr = _locked_attr;
        
        }
        const boolean& locked_attr(){

            return type: oolean\nname: \m_locked_attr\n;
        
        }
        bool has_hidden_attr(){

            return m_has_hidden_attr;
        
        }
        void set_hidden_attr(const boolean& _hidden_attr ){

        m_has_hidden_attr = true;
        m_hidden_attr = _hidden_attr;
        
        }
        const boolean& hidden_attr(){

            return type: oolean\nname: \m_hidden_attr\n;
        
        }

    private:
        static CT_CellProtection* default_instance_ ;
        bool m_has_locked_attr ;
        boolean m_locked_attr ;
        bool m_has_hidden_attr ;
        boolean m_hidden_attr ;

    }

    class CT_Fonts : public XSD::ComplexType{
    public:
        bool has_font(){

            return m_has_font;
        
        }
        CT_Font* mutable_font(){

                m_has_font = true;
                if (!m_font)
                {
                    m_font = new CT_Font();
                }
                return m_font;
            
        }
        const CT_Font& font(){

            if (m_font)
            {
                return *m_font;
            }
            return CT_Font::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_font = false;
                
        if (m_font)
        {
            delete m_font;
            m_font = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_font)
                {
                    m_font->toXml(font, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Fonts& default_instance(){

    if (!CT_Fonts::default_instance_)
    {
        CT_Fonts::default_instance_ = new CT_Fonts();
    }
    return *CT_Fonts::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_font ;
        CT_Font* m_font ;
        static CT_Fonts* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_Fills : public XSD::ComplexType{
    public:
        bool has_fill(){

            return m_has_fill;
        
        }
        CT_Fill* mutable_fill(){

                m_has_fill = true;
                if (!m_fill)
                {
                    m_fill = new CT_Fill();
                }
                return m_fill;
            
        }
        const CT_Fill& fill(){

            if (m_fill)
            {
                return *m_fill;
            }
            return CT_Fill::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_fill = false;
                
        if (m_fill)
        {
            delete m_fill;
            m_fill = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_fill)
                {
                    m_fill->toXml(fill, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Fills& default_instance(){

    if (!CT_Fills::default_instance_)
    {
        CT_Fills::default_instance_ = new CT_Fills();
    }
    return *CT_Fills::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_fill ;
        CT_Fill* m_fill ;
        static CT_Fills* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_Fill : public XSD::ComplexType{
    public:
        bool has_patternFill(){

            return m_has_patternFill;
        
        }
        CT_PatternFill* mutable_patternFill(){

                
                m_has_gradientFill = false;
                
        if (m_gradientFill)
        {
            delete m_gradientFill;
            m_gradientFill = NULL;
        }
    ;
            
                m_has_patternFill = true;
                if (!m_patternFill)
                {
                    m_patternFill = new CT_PatternFill();
                }
                return m_patternFill;
            
        }
        const CT_PatternFill& patternFill(){

            if (m_patternFill)
            {
                return *m_patternFill;
            }
            return CT_PatternFill::default_instance();
        
        }
        bool has_gradientFill(){

            return m_has_gradientFill;
        
        }
        CT_GradientFill* mutable_gradientFill(){

                
                m_has_patternFill = false;
                
        if (m_patternFill)
        {
            delete m_patternFill;
            m_patternFill = NULL;
        }
    ;
            
                m_has_gradientFill = true;
                if (!m_gradientFill)
                {
                    m_gradientFill = new CT_GradientFill();
                }
                return m_gradientFill;
            
        }
        const CT_GradientFill& gradientFill(){

            if (m_gradientFill)
            {
                return *m_gradientFill;
            }
            return CT_GradientFill::default_instance();
        
        }
        void clear(){

                m_has_patternFill = false;
                
        if (m_patternFill)
        {
            delete m_patternFill;
            m_patternFill = NULL;
        }
    
            
                m_has_gradientFill = false;
                
        if (m_gradientFill)
        {
            delete m_gradientFill;
            m_gradientFill = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_patternFill)
                {
                    m_patternFill->toXml(patternFill, _outStream);;
                }
            
                if (m_has_gradientFill)
                {
                    m_patternFill->toXml(gradientFill, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Fill& default_instance(){

    if (!CT_Fill::default_instance_)
    {
        CT_Fill::default_instance_ = new CT_Fill();
    }
    return *CT_Fill::default_instance_;

        }

    private:
        bool m_has_patternFill ;
        CT_PatternFill* m_patternFill ;
        bool m_has_gradientFill ;
        CT_GradientFill* m_gradientFill ;
        static CT_Fill* default_instance_ ;

    }

    class CT_PatternFill : public XSD::ComplexType{
    public:
        bool has_fgColor(){

            return m_has_fgColor;
        
        }
        CT_Color* mutable_fgColor(){

                m_has_fgColor = true;
                if (!m_fgColor)
                {
                    m_fgColor = new CT_Color();
                }
                return m_fgColor;
            
        }
        const CT_Color& fgColor(){

            if (m_fgColor)
            {
                return *m_fgColor;
            }
            return CT_Color::default_instance();
        
        }
        bool has_bgColor(){

            return m_has_bgColor;
        
        }
        CT_Color* mutable_bgColor(){

                m_has_bgColor = true;
                if (!m_bgColor)
                {
                    m_bgColor = new CT_Color();
                }
                return m_bgColor;
            
        }
        const CT_Color& bgColor(){

            if (m_bgColor)
            {
                return *m_bgColor;
            }
            return CT_Color::default_instance();
        
        }
        void clear(){

                m_has_patternType_attr = false;
                
        if (m_patternType_attr)
        {
            delete m_patternType_attr;
            m_patternType_attr = NULL;
        }
    
            
                m_has_fgColor = false;
                
        if (m_fgColor)
        {
            delete m_fgColor;
            m_fgColor = NULL;
        }
    
            
                m_has_bgColor = false;
                
        if (m_bgColor)
        {
            delete m_bgColor;
            m_bgColor = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_patternType_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_fgColor)
                {
                    m_fgColor->toXml(fgColor, _outStream);;
                }
            
                if (m_has_bgColor)
                {
                    m_fgColor->toXml(bgColor, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_PatternFill& default_instance(){

    if (!CT_PatternFill::default_instance_)
    {
        CT_PatternFill::default_instance_ = new CT_PatternFill();
    }
    return *CT_PatternFill::default_instance_;

        }
        bool has_patternType_attr(){

            return m_has_patternType_attr;
        
        }
        void set_patternType_attr(const ST_PatternType& _patternType_attr ){

            m_has_patternType_attr = true;
            m_patternType_attr = new ST_PatternType(_patternType_attr);
        
        }
        const ST_PatternType& patternType_attr(){

            if (m_patternType_attr)
            {
                return *m_patternType_attr;
            }
            return ST_PatternType::default_instance();
        
        }

    private:
        bool m_has_fgColor ;
        CT_Color* m_fgColor ;
        bool m_has_bgColor ;
        CT_Color* m_bgColor ;
        static CT_PatternFill* default_instance_ ;
        bool m_has_patternType_attr ;
        ST_PatternType* m_patternType_attr ;

    }

    class CT_Color : public XSD::ComplexType{
    public:
        void clear(){

                m_has_auto_attr = false;
                m_auto_attr = false;
            
                m_has_indexed_attr = false;
                m_indexed_attr = 0;
            
                m_has_rgb_attr = false;
                
        if (m_rgb_attr)
        {
            delete m_rgb_attr;
            m_rgb_attr = NULL;
        }
    
            
                m_has_theme_attr = false;
                m_theme_attr = 0;
            
                m_has_tint_attr = false;
                m_tint_attr = 0;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_auto_attr) << \\\;
_outStream << _attrName << \=\\ << m_indexed_attr << \\\;
m_rgb_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_theme_attr << \\\;
_outStream << _attrName << \=\\ << m_tint_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Color& default_instance(){

    if (!CT_Color::default_instance_)
    {
        CT_Color::default_instance_ = new CT_Color();
    }
    return *CT_Color::default_instance_;

        }
        bool has_auto_attr(){

            return m_has_auto_attr;
        
        }
        void set_auto_attr(const boolean& _auto_attr ){

        m_has_auto_attr = true;
        m_auto_attr = _auto_attr;
        
        }
        const boolean& auto_attr(){

            return type: oolean\nname: \m_auto_attr\n;
        
        }
        bool has_indexed_attr(){

            return m_has_indexed_attr;
        
        }
        void set_indexed_attr(const unsignedInt& _indexed_attr ){

        m_has_indexed_attr = true;
        m_indexed_attr = _indexed_attr;
        
        }
        const unsignedInt& indexed_attr(){

            return type: \unsignedInt\nname: \m_indexed_attr\n;
        
        }
        bool has_rgb_attr(){

            return m_has_rgb_attr;
        
        }
        void set_rgb_attr(const ST_UnsignedIntHex& _rgb_attr ){

            m_has_rgb_attr = true;
            m_rgb_attr = new ST_UnsignedIntHex(_rgb_attr);
        
        }
        const ST_UnsignedIntHex& rgb_attr(){

            if (m_rgb_attr)
            {
                return *m_rgb_attr;
            }
            return ST_UnsignedIntHex::default_instance();
        
        }
        bool has_theme_attr(){

            return m_has_theme_attr;
        
        }
        void set_theme_attr(const unsignedInt& _theme_attr ){

        m_has_theme_attr = true;
        m_theme_attr = _theme_attr;
        
        }
        const unsignedInt& theme_attr(){

            return type: \unsignedInt\nname: \m_theme_attr\n;
        
        }
        bool has_tint_attr(){

            return m_has_tint_attr;
        
        }
        void set_tint_attr(const double& _tint_attr ){

        m_has_tint_attr = true;
        m_tint_attr = _tint_attr;
        
        }
        const double& tint_attr(){

            return type: \double\nname: \m_tint_attr\n;
        
        }

    private:
        static CT_Color* default_instance_ ;
        bool m_has_auto_attr ;
        boolean m_auto_attr ;
        bool m_has_indexed_attr ;
        unsignedInt m_indexed_attr ;
        bool m_has_rgb_attr ;
        ST_UnsignedIntHex* m_rgb_attr ;
        bool m_has_theme_attr ;
        unsignedInt m_theme_attr ;
        bool m_has_tint_attr ;
        double m_tint_attr ;

    }

    class CT_GradientFill : public XSD::ComplexType{
    public:
        bool has_stop(){

            return m_has_stop;
        
        }
        CT_GradientStop* mutable_stop(){

                m_has_stop = true;
                if (!m_stop)
                {
                    m_stop = new CT_GradientStop();
                }
                return m_stop;
            
        }
        const CT_GradientStop& stop(){

            if (m_stop)
            {
                return *m_stop;
            }
            return CT_GradientStop::default_instance();
        
        }
        void clear(){

                m_has_type_attr = false;
                
        if (m_type_attr)
        {
            delete m_type_attr;
            m_type_attr = NULL;
        }
    
            
                m_has_degree_attr = false;
                m_degree_attr = 0;
            
                m_has_left_attr = false;
                m_left_attr = 0;
            
                m_has_right_attr = false;
                m_right_attr = 0;
            
                m_has_top_attr = false;
                m_top_attr = 0;
            
                m_has_bottom_attr = false;
                m_bottom_attr = 0;
            
                m_has_stop = false;
                
        if (m_stop)
        {
            delete m_stop;
            m_stop = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_type_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_degree_attr << \\\;
_outStream << _attrName << \=\\ << m_left_attr << \\\;
_outStream << _attrName << \=\\ << m_right_attr << \\\;
_outStream << _attrName << \=\\ << m_top_attr << \\\;
_outStream << _attrName << \=\\ << m_bottom_attr << \\\;
        _outStream << \>\;
    
                if (m_has_stop)
                {
                    m_stop->toXml(stop, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_GradientFill& default_instance(){

    if (!CT_GradientFill::default_instance_)
    {
        CT_GradientFill::default_instance_ = new CT_GradientFill();
    }
    return *CT_GradientFill::default_instance_;

        }
        bool has_type_attr(){

            return m_has_type_attr;
        
        }
        void set_type_attr(const ST_GradientType& _type_attr ){

            m_has_type_attr = true;
            m_type_attr = new ST_GradientType(_type_attr);
        
        }
        const ST_GradientType& type_attr(){

            if (m_type_attr)
            {
                return *m_type_attr;
            }
            return ST_GradientType::default_instance();
        
        }
        bool has_degree_attr(){

            return m_has_degree_attr;
        
        }
        void set_degree_attr(const double& _degree_attr ){

        m_has_degree_attr = true;
        m_degree_attr = _degree_attr;
        
        }
        const double& degree_attr(){

            return type: \double\nname: \m_degree_attr\n;
        
        }
        bool has_left_attr(){

            return m_has_left_attr;
        
        }
        void set_left_attr(const double& _left_attr ){

        m_has_left_attr = true;
        m_left_attr = _left_attr;
        
        }
        const double& left_attr(){

            return type: \double\nname: \m_left_attr\n;
        
        }
        bool has_right_attr(){

            return m_has_right_attr;
        
        }
        void set_right_attr(const double& _right_attr ){

        m_has_right_attr = true;
        m_right_attr = _right_attr;
        
        }
        const double& right_attr(){

            return type: \double\nname: \m_right_attr\n;
        
        }
        bool has_top_attr(){

            return m_has_top_attr;
        
        }
        void set_top_attr(const double& _top_attr ){

        m_has_top_attr = true;
        m_top_attr = _top_attr;
        
        }
        const double& top_attr(){

            return type: \double\nname: \m_top_attr\n;
        
        }
        bool has_bottom_attr(){

            return m_has_bottom_attr;
        
        }
        void set_bottom_attr(const double& _bottom_attr ){

        m_has_bottom_attr = true;
        m_bottom_attr = _bottom_attr;
        
        }
        const double& bottom_attr(){

            return type: \double\nname: \m_bottom_attr\n;
        
        }

    private:
        bool m_has_stop ;
        CT_GradientStop* m_stop ;
        static CT_GradientFill* default_instance_ ;
        bool m_has_type_attr ;
        ST_GradientType* m_type_attr ;
        bool m_has_degree_attr ;
        double m_degree_attr ;
        bool m_has_left_attr ;
        double m_left_attr ;
        bool m_has_right_attr ;
        double m_right_attr ;
        bool m_has_top_attr ;
        double m_top_attr ;
        bool m_has_bottom_attr ;
        double m_bottom_attr ;

    }

    class CT_GradientStop : public XSD::ComplexType{
    public:
        bool has_color(){

            return m_has_color;
        
        }
        CT_Color* mutable_color(){

                m_has_color = true;
                if (!m_color)
                {
                    m_color = new CT_Color();
                }
                return m_color;
            
        }
        const CT_Color& color(){

            if (m_color)
            {
                return *m_color;
            }
            return CT_Color::default_instance();
        
        }
        void clear(){

                m_has_position_attr = false;
                m_position_attr = 0;
            
                m_has_color = false;
                
        if (m_color)
        {
            delete m_color;
            m_color = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_position_attr << \\\;
        _outStream << \>\;
    
                if (m_has_color)
                {
                    m_color->toXml(color, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_GradientStop& default_instance(){

    if (!CT_GradientStop::default_instance_)
    {
        CT_GradientStop::default_instance_ = new CT_GradientStop();
    }
    return *CT_GradientStop::default_instance_;

        }
        bool has_position_attr(){

            return m_has_position_attr;
        
        }
        void set_position_attr(const double& _position_attr ){

        m_has_position_attr = true;
        m_position_attr = _position_attr;
        
        }
        const double& position_attr(){

            return type: \double\nname: \m_position_attr\n;
        
        }

    private:
        bool m_has_color ;
        CT_Color* m_color ;
        static CT_GradientStop* default_instance_ ;
        bool m_has_position_attr ;
        double m_position_attr ;

    }

    class CT_NumFmts : public XSD::ComplexType{
    public:
        bool has_numFmt(){

            return m_has_numFmt;
        
        }
        CT_NumFmt* mutable_numFmt(){

                m_has_numFmt = true;
                if (!m_numFmt)
                {
                    m_numFmt = new CT_NumFmt();
                }
                return m_numFmt;
            
        }
        const CT_NumFmt& numFmt(){

            if (m_numFmt)
            {
                return *m_numFmt;
            }
            return CT_NumFmt::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_numFmt = false;
                
        if (m_numFmt)
        {
            delete m_numFmt;
            m_numFmt = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_numFmt)
                {
                    m_numFmt->toXml(numFmt, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_NumFmts& default_instance(){

    if (!CT_NumFmts::default_instance_)
    {
        CT_NumFmts::default_instance_ = new CT_NumFmts();
    }
    return *CT_NumFmts::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_numFmt ;
        CT_NumFmt* m_numFmt ;
        static CT_NumFmts* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_NumFmt : public XSD::ComplexType{
    public:
        void clear(){

                m_has_numFmtId_attr = false;
                
        if (m_numFmtId_attr)
        {
            delete m_numFmtId_attr;
            m_numFmtId_attr = NULL;
        }
    
            
                m_has_formatCode_attr = false;
                
        if (m_formatCode_attr)
        {
            delete m_formatCode_attr;
            m_formatCode_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_numFmtId_attr->toXml(_attrName, _outStream);
m_formatCode_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_NumFmt& default_instance(){

    if (!CT_NumFmt::default_instance_)
    {
        CT_NumFmt::default_instance_ = new CT_NumFmt();
    }
    return *CT_NumFmt::default_instance_;

        }
        bool has_numFmtId_attr(){

            return m_has_numFmtId_attr;
        
        }
        void set_numFmtId_attr(const ST_NumFmtId& _numFmtId_attr ){

            m_has_numFmtId_attr = true;
            m_numFmtId_attr = new ST_NumFmtId(_numFmtId_attr);
        
        }
        const ST_NumFmtId& numFmtId_attr(){

            if (m_numFmtId_attr)
            {
                return *m_numFmtId_attr;
            }
            return ST_NumFmtId::default_instance();
        
        }
        bool has_formatCode_attr(){

            return m_has_formatCode_attr;
        
        }
        void set_formatCode_attr(const ns_s::ST_Xstring& _formatCode_attr ){

            m_has_formatCode_attr = true;
            m_formatCode_attr = new ns_s::ST_Xstring(_formatCode_attr);
        
        }
        const ns_s::ST_Xstring& formatCode_attr(){

            if (m_formatCode_attr)
            {
                return *m_formatCode_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }

    private:
        static CT_NumFmt* default_instance_ ;
        bool m_has_numFmtId_attr ;
        ST_NumFmtId* m_numFmtId_attr ;
        bool m_has_formatCode_attr ;
        ns_s::ST_Xstring* m_formatCode_attr ;

    }

    class CT_CellStyleXfs : public XSD::ComplexType{
    public:
        bool has_xf(){

            return m_has_xf;
        
        }
        CT_Xf* mutable_xf(){

                m_has_xf = true;
                if (!m_xf)
                {
                    m_xf = new CT_Xf();
                }
                return m_xf;
            
        }
        const CT_Xf& xf(){

            if (m_xf)
            {
                return *m_xf;
            }
            return CT_Xf::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_xf = false;
                
        if (m_xf)
        {
            delete m_xf;
            m_xf = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_xf)
                {
                    m_xf->toXml(xf, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CellStyleXfs& default_instance(){

    if (!CT_CellStyleXfs::default_instance_)
    {
        CT_CellStyleXfs::default_instance_ = new CT_CellStyleXfs();
    }
    return *CT_CellStyleXfs::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_xf ;
        CT_Xf* m_xf ;
        static CT_CellStyleXfs* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_CellXfs : public XSD::ComplexType{
    public:
        bool has_xf(){

            return m_has_xf;
        
        }
        CT_Xf* mutable_xf(){

                m_has_xf = true;
                if (!m_xf)
                {
                    m_xf = new CT_Xf();
                }
                return m_xf;
            
        }
        const CT_Xf& xf(){

            if (m_xf)
            {
                return *m_xf;
            }
            return CT_Xf::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_xf = false;
                
        if (m_xf)
        {
            delete m_xf;
            m_xf = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_xf)
                {
                    m_xf->toXml(xf, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CellXfs& default_instance(){

    if (!CT_CellXfs::default_instance_)
    {
        CT_CellXfs::default_instance_ = new CT_CellXfs();
    }
    return *CT_CellXfs::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_xf ;
        CT_Xf* m_xf ;
        static CT_CellXfs* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_Xf : public XSD::ComplexType{
    public:
        bool has_alignment(){

            return m_has_alignment;
        
        }
        CT_CellAlignment* mutable_alignment(){

                m_has_alignment = true;
                if (!m_alignment)
                {
                    m_alignment = new CT_CellAlignment();
                }
                return m_alignment;
            
        }
        const CT_CellAlignment& alignment(){

            if (m_alignment)
            {
                return *m_alignment;
            }
            return CT_CellAlignment::default_instance();
        
        }
        bool has_protection(){

            return m_has_protection;
        
        }
        CT_CellProtection* mutable_protection(){

                m_has_protection = true;
                if (!m_protection)
                {
                    m_protection = new CT_CellProtection();
                }
                return m_protection;
            
        }
        const CT_CellProtection& protection(){

            if (m_protection)
            {
                return *m_protection;
            }
            return CT_CellProtection::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_numFmtId_attr = false;
                
        if (m_numFmtId_attr)
        {
            delete m_numFmtId_attr;
            m_numFmtId_attr = NULL;
        }
    
            
                m_has_fontId_attr = false;
                
        if (m_fontId_attr)
        {
            delete m_fontId_attr;
            m_fontId_attr = NULL;
        }
    
            
                m_has_fillId_attr = false;
                
        if (m_fillId_attr)
        {
            delete m_fillId_attr;
            m_fillId_attr = NULL;
        }
    
            
                m_has_borderId_attr = false;
                
        if (m_borderId_attr)
        {
            delete m_borderId_attr;
            m_borderId_attr = NULL;
        }
    
            
                m_has_xfId_attr = false;
                
        if (m_xfId_attr)
        {
            delete m_xfId_attr;
            m_xfId_attr = NULL;
        }
    
            
                m_has_quotePrefix_attr = false;
                m_quotePrefix_attr = false;
            
                m_has_pivotButton_attr = false;
                m_pivotButton_attr = false;
            
                m_has_applyNumberFormat_attr = false;
                m_applyNumberFormat_attr = false;
            
                m_has_applyFont_attr = false;
                m_applyFont_attr = false;
            
                m_has_applyFill_attr = false;
                m_applyFill_attr = false;
            
                m_has_applyBorder_attr = false;
                m_applyBorder_attr = false;
            
                m_has_applyAlignment_attr = false;
                m_applyAlignment_attr = false;
            
                m_has_applyProtection_attr = false;
                m_applyProtection_attr = false;
            
                m_has_alignment = false;
                
        if (m_alignment)
        {
            delete m_alignment;
            m_alignment = NULL;
        }
    
            
                m_has_protection = false;
                
        if (m_protection)
        {
            delete m_protection;
            m_protection = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_numFmtId_attr->toXml(_attrName, _outStream);
m_fontId_attr->toXml(_attrName, _outStream);
m_fillId_attr->toXml(_attrName, _outStream);
m_borderId_attr->toXml(_attrName, _outStream);
m_xfId_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_quotePrefix_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_pivotButton_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_applyNumberFormat_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_applyFont_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_applyFill_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_applyBorder_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_applyAlignment_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_applyProtection_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_alignment)
                {
                    m_alignment->toXml(alignment, _outStream);;
                }
            
                if (m_has_protection)
                {
                    m_alignment->toXml(protection, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_alignment->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Xf& default_instance(){

    if (!CT_Xf::default_instance_)
    {
        CT_Xf::default_instance_ = new CT_Xf();
    }
    return *CT_Xf::default_instance_;

        }
        bool has_numFmtId_attr(){

            return m_has_numFmtId_attr;
        
        }
        void set_numFmtId_attr(const ST_NumFmtId& _numFmtId_attr ){

            m_has_numFmtId_attr = true;
            m_numFmtId_attr = new ST_NumFmtId(_numFmtId_attr);
        
        }
        const ST_NumFmtId& numFmtId_attr(){

            if (m_numFmtId_attr)
            {
                return *m_numFmtId_attr;
            }
            return ST_NumFmtId::default_instance();
        
        }
        bool has_fontId_attr(){

            return m_has_fontId_attr;
        
        }
        void set_fontId_attr(const ST_FontId& _fontId_attr ){

            m_has_fontId_attr = true;
            m_fontId_attr = new ST_FontId(_fontId_attr);
        
        }
        const ST_FontId& fontId_attr(){

            if (m_fontId_attr)
            {
                return *m_fontId_attr;
            }
            return ST_FontId::default_instance();
        
        }
        bool has_fillId_attr(){

            return m_has_fillId_attr;
        
        }
        void set_fillId_attr(const ST_FillId& _fillId_attr ){

            m_has_fillId_attr = true;
            m_fillId_attr = new ST_FillId(_fillId_attr);
        
        }
        const ST_FillId& fillId_attr(){

            if (m_fillId_attr)
            {
                return *m_fillId_attr;
            }
            return ST_FillId::default_instance();
        
        }
        bool has_borderId_attr(){

            return m_has_borderId_attr;
        
        }
        void set_borderId_attr(const ST_BorderId& _borderId_attr ){

            m_has_borderId_attr = true;
            m_borderId_attr = new ST_BorderId(_borderId_attr);
        
        }
        const ST_BorderId& borderId_attr(){

            if (m_borderId_attr)
            {
                return *m_borderId_attr;
            }
            return ST_BorderId::default_instance();
        
        }
        bool has_xfId_attr(){

            return m_has_xfId_attr;
        
        }
        void set_xfId_attr(const ST_CellStyleXfId& _xfId_attr ){

            m_has_xfId_attr = true;
            m_xfId_attr = new ST_CellStyleXfId(_xfId_attr);
        
        }
        const ST_CellStyleXfId& xfId_attr(){

            if (m_xfId_attr)
            {
                return *m_xfId_attr;
            }
            return ST_CellStyleXfId::default_instance();
        
        }
        bool has_quotePrefix_attr(){

            return m_has_quotePrefix_attr;
        
        }
        void set_quotePrefix_attr(const boolean& _quotePrefix_attr ){

        m_has_quotePrefix_attr = true;
        m_quotePrefix_attr = _quotePrefix_attr;
        
        }
        const boolean& quotePrefix_attr(){

            return type: oolean\nname: \m_quotePrefix_attr\n;
        
        }
        bool has_pivotButton_attr(){

            return m_has_pivotButton_attr;
        
        }
        void set_pivotButton_attr(const boolean& _pivotButton_attr ){

        m_has_pivotButton_attr = true;
        m_pivotButton_attr = _pivotButton_attr;
        
        }
        const boolean& pivotButton_attr(){

            return type: oolean\nname: \m_pivotButton_attr\n;
        
        }
        bool has_applyNumberFormat_attr(){

            return m_has_applyNumberFormat_attr;
        
        }
        void set_applyNumberFormat_attr(const boolean& _applyNumberFormat_attr ){

        m_has_applyNumberFormat_attr = true;
        m_applyNumberFormat_attr = _applyNumberFormat_attr;
        
        }
        const boolean& applyNumberFormat_attr(){

            return type: oolean\nname: \m_applyNumberFormat_attr\n;
        
        }
        bool has_applyFont_attr(){

            return m_has_applyFont_attr;
        
        }
        void set_applyFont_attr(const boolean& _applyFont_attr ){

        m_has_applyFont_attr = true;
        m_applyFont_attr = _applyFont_attr;
        
        }
        const boolean& applyFont_attr(){

            return type: oolean\nname: \m_applyFont_attr\n;
        
        }
        bool has_applyFill_attr(){

            return m_has_applyFill_attr;
        
        }
        void set_applyFill_attr(const boolean& _applyFill_attr ){

        m_has_applyFill_attr = true;
        m_applyFill_attr = _applyFill_attr;
        
        }
        const boolean& applyFill_attr(){

            return type: oolean\nname: \m_applyFill_attr\n;
        
        }
        bool has_applyBorder_attr(){

            return m_has_applyBorder_attr;
        
        }
        void set_applyBorder_attr(const boolean& _applyBorder_attr ){

        m_has_applyBorder_attr = true;
        m_applyBorder_attr = _applyBorder_attr;
        
        }
        const boolean& applyBorder_attr(){

            return type: oolean\nname: \m_applyBorder_attr\n;
        
        }
        bool has_applyAlignment_attr(){

            return m_has_applyAlignment_attr;
        
        }
        void set_applyAlignment_attr(const boolean& _applyAlignment_attr ){

        m_has_applyAlignment_attr = true;
        m_applyAlignment_attr = _applyAlignment_attr;
        
        }
        const boolean& applyAlignment_attr(){

            return type: oolean\nname: \m_applyAlignment_attr\n;
        
        }
        bool has_applyProtection_attr(){

            return m_has_applyProtection_attr;
        
        }
        void set_applyProtection_attr(const boolean& _applyProtection_attr ){

        m_has_applyProtection_attr = true;
        m_applyProtection_attr = _applyProtection_attr;
        
        }
        const boolean& applyProtection_attr(){

            return type: oolean\nname: \m_applyProtection_attr\n;
        
        }

    private:
        bool m_has_alignment ;
        CT_CellAlignment* m_alignment ;
        bool m_has_protection ;
        CT_CellProtection* m_protection ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_Xf* default_instance_ ;
        bool m_has_numFmtId_attr ;
        ST_NumFmtId* m_numFmtId_attr ;
        bool m_has_fontId_attr ;
        ST_FontId* m_fontId_attr ;
        bool m_has_fillId_attr ;
        ST_FillId* m_fillId_attr ;
        bool m_has_borderId_attr ;
        ST_BorderId* m_borderId_attr ;
        bool m_has_xfId_attr ;
        ST_CellStyleXfId* m_xfId_attr ;
        bool m_has_quotePrefix_attr ;
        boolean m_quotePrefix_attr ;
        bool m_has_pivotButton_attr ;
        boolean m_pivotButton_attr ;
        bool m_has_applyNumberFormat_attr ;
        boolean m_applyNumberFormat_attr ;
        bool m_has_applyFont_attr ;
        boolean m_applyFont_attr ;
        bool m_has_applyFill_attr ;
        boolean m_applyFill_attr ;
        bool m_has_applyBorder_attr ;
        boolean m_applyBorder_attr ;
        bool m_has_applyAlignment_attr ;
        boolean m_applyAlignment_attr ;
        bool m_has_applyProtection_attr ;
        boolean m_applyProtection_attr ;

    }

    class CT_CellStyles : public XSD::ComplexType{
    public:
        bool has_cellStyle(){

            return m_has_cellStyle;
        
        }
        CT_CellStyle* mutable_cellStyle(){

                m_has_cellStyle = true;
                if (!m_cellStyle)
                {
                    m_cellStyle = new CT_CellStyle();
                }
                return m_cellStyle;
            
        }
        const CT_CellStyle& cellStyle(){

            if (m_cellStyle)
            {
                return *m_cellStyle;
            }
            return CT_CellStyle::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_cellStyle = false;
                
        if (m_cellStyle)
        {
            delete m_cellStyle;
            m_cellStyle = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_cellStyle)
                {
                    m_cellStyle->toXml(cellStyle, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CellStyles& default_instance(){

    if (!CT_CellStyles::default_instance_)
    {
        CT_CellStyles::default_instance_ = new CT_CellStyles();
    }
    return *CT_CellStyles::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_cellStyle ;
        CT_CellStyle* m_cellStyle ;
        static CT_CellStyles* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_CellStyle : public XSD::ComplexType{
    public:
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
                m_has_xfId_attr = false;
                
        if (m_xfId_attr)
        {
            delete m_xfId_attr;
            m_xfId_attr = NULL;
        }
    
            
                m_has_builtinId_attr = false;
                m_builtinId_attr = 0;
            
                m_has_iLevel_attr = false;
                m_iLevel_attr = 0;
            
                m_has_hidden_attr = false;
                m_hidden_attr = false;
            
                m_has_customBuiltin_attr = false;
                m_customBuiltin_attr = false;
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_name_attr->toXml(_attrName, _outStream);
m_xfId_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_builtinId_attr << \\\;
_outStream << _attrName << \=\\ << m_iLevel_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_hidden_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_customBuiltin_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_extLst)
                {
                    m_extLst->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CellStyle& default_instance(){

    if (!CT_CellStyle::default_instance_)
    {
        CT_CellStyle::default_instance_ = new CT_CellStyle();
    }
    return *CT_CellStyle::default_instance_;

        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_xfId_attr(){

            return m_has_xfId_attr;
        
        }
        void set_xfId_attr(const ST_CellStyleXfId& _xfId_attr ){

            m_has_xfId_attr = true;
            m_xfId_attr = new ST_CellStyleXfId(_xfId_attr);
        
        }
        const ST_CellStyleXfId& xfId_attr(){

            if (m_xfId_attr)
            {
                return *m_xfId_attr;
            }
            return ST_CellStyleXfId::default_instance();
        
        }
        bool has_builtinId_attr(){

            return m_has_builtinId_attr;
        
        }
        void set_builtinId_attr(const unsignedInt& _builtinId_attr ){

        m_has_builtinId_attr = true;
        m_builtinId_attr = _builtinId_attr;
        
        }
        const unsignedInt& builtinId_attr(){

            return type: \unsignedInt\nname: \m_builtinId_attr\n;
        
        }
        bool has_iLevel_attr(){

            return m_has_iLevel_attr;
        
        }
        void set_iLevel_attr(const unsignedInt& _iLevel_attr ){

        m_has_iLevel_attr = true;
        m_iLevel_attr = _iLevel_attr;
        
        }
        const unsignedInt& iLevel_attr(){

            return type: \unsignedInt\nname: \m_iLevel_attr\n;
        
        }
        bool has_hidden_attr(){

            return m_has_hidden_attr;
        
        }
        void set_hidden_attr(const boolean& _hidden_attr ){

        m_has_hidden_attr = true;
        m_hidden_attr = _hidden_attr;
        
        }
        const boolean& hidden_attr(){

            return type: oolean\nname: \m_hidden_attr\n;
        
        }
        bool has_customBuiltin_attr(){

            return m_has_customBuiltin_attr;
        
        }
        void set_customBuiltin_attr(const boolean& _customBuiltin_attr ){

        m_has_customBuiltin_attr = true;
        m_customBuiltin_attr = _customBuiltin_attr;
        
        }
        const boolean& customBuiltin_attr(){

            return type: oolean\nname: \m_customBuiltin_attr\n;
        
        }

    private:
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_CellStyle* default_instance_ ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;
        bool m_has_xfId_attr ;
        ST_CellStyleXfId* m_xfId_attr ;
        bool m_has_builtinId_attr ;
        unsignedInt m_builtinId_attr ;
        bool m_has_iLevel_attr ;
        unsignedInt m_iLevel_attr ;
        bool m_has_hidden_attr ;
        boolean m_hidden_attr ;
        bool m_has_customBuiltin_attr ;
        boolean m_customBuiltin_attr ;

    }

    class CT_Dxfs : public XSD::ComplexType{
    public:
        bool has_dxf(){

            return m_has_dxf;
        
        }
        CT_Dxf* mutable_dxf(){

                m_has_dxf = true;
                if (!m_dxf)
                {
                    m_dxf = new CT_Dxf();
                }
                return m_dxf;
            
        }
        const CT_Dxf& dxf(){

            if (m_dxf)
            {
                return *m_dxf;
            }
            return CT_Dxf::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_dxf = false;
                
        if (m_dxf)
        {
            delete m_dxf;
            m_dxf = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_dxf)
                {
                    m_dxf->toXml(dxf, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Dxfs& default_instance(){

    if (!CT_Dxfs::default_instance_)
    {
        CT_Dxfs::default_instance_ = new CT_Dxfs();
    }
    return *CT_Dxfs::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_dxf ;
        CT_Dxf* m_dxf ;
        static CT_Dxfs* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_Dxf : public XSD::ComplexType{
    public:
        bool has_font(){

            return m_has_font;
        
        }
        CT_Font* mutable_font(){

                m_has_font = true;
                if (!m_font)
                {
                    m_font = new CT_Font();
                }
                return m_font;
            
        }
        const CT_Font& font(){

            if (m_font)
            {
                return *m_font;
            }
            return CT_Font::default_instance();
        
        }
        bool has_numFmt(){

            return m_has_numFmt;
        
        }
        CT_NumFmt* mutable_numFmt(){

                m_has_numFmt = true;
                if (!m_numFmt)
                {
                    m_numFmt = new CT_NumFmt();
                }
                return m_numFmt;
            
        }
        const CT_NumFmt& numFmt(){

            if (m_numFmt)
            {
                return *m_numFmt;
            }
            return CT_NumFmt::default_instance();
        
        }
        bool has_fill(){

            return m_has_fill;
        
        }
        CT_Fill* mutable_fill(){

                m_has_fill = true;
                if (!m_fill)
                {
                    m_fill = new CT_Fill();
                }
                return m_fill;
            
        }
        const CT_Fill& fill(){

            if (m_fill)
            {
                return *m_fill;
            }
            return CT_Fill::default_instance();
        
        }
        bool has_alignment(){

            return m_has_alignment;
        
        }
        CT_CellAlignment* mutable_alignment(){

                m_has_alignment = true;
                if (!m_alignment)
                {
                    m_alignment = new CT_CellAlignment();
                }
                return m_alignment;
            
        }
        const CT_CellAlignment& alignment(){

            if (m_alignment)
            {
                return *m_alignment;
            }
            return CT_CellAlignment::default_instance();
        
        }
        bool has_border(){

            return m_has_border;
        
        }
        CT_Border* mutable_border(){

                m_has_border = true;
                if (!m_border)
                {
                    m_border = new CT_Border();
                }
                return m_border;
            
        }
        const CT_Border& border(){

            if (m_border)
            {
                return *m_border;
            }
            return CT_Border::default_instance();
        
        }
        bool has_protection(){

            return m_has_protection;
        
        }
        CT_CellProtection* mutable_protection(){

                m_has_protection = true;
                if (!m_protection)
                {
                    m_protection = new CT_CellProtection();
                }
                return m_protection;
            
        }
        const CT_CellProtection& protection(){

            if (m_protection)
            {
                return *m_protection;
            }
            return CT_CellProtection::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_font = false;
                
        if (m_font)
        {
            delete m_font;
            m_font = NULL;
        }
    
            
                m_has_numFmt = false;
                
        if (m_numFmt)
        {
            delete m_numFmt;
            m_numFmt = NULL;
        }
    
            
                m_has_fill = false;
                
        if (m_fill)
        {
            delete m_fill;
            m_fill = NULL;
        }
    
            
                m_has_alignment = false;
                
        if (m_alignment)
        {
            delete m_alignment;
            m_alignment = NULL;
        }
    
            
                m_has_border = false;
                
        if (m_border)
        {
            delete m_border;
            m_border = NULL;
        }
    
            
                m_has_protection = false;
                
        if (m_protection)
        {
            delete m_protection;
            m_protection = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_font)
                {
                    m_font->toXml(font, _outStream);;
                }
            
                if (m_has_numFmt)
                {
                    m_font->toXml(numFmt, _outStream);;
                }
            
                if (m_has_fill)
                {
                    m_font->toXml(fill, _outStream);;
                }
            
                if (m_has_alignment)
                {
                    m_font->toXml(alignment, _outStream);;
                }
            
                if (m_has_border)
                {
                    m_font->toXml(border, _outStream);;
                }
            
                if (m_has_protection)
                {
                    m_font->toXml(protection, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_font->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Dxf& default_instance(){

    if (!CT_Dxf::default_instance_)
    {
        CT_Dxf::default_instance_ = new CT_Dxf();
    }
    return *CT_Dxf::default_instance_;

        }

    private:
        bool m_has_font ;
        CT_Font* m_font ;
        bool m_has_numFmt ;
        CT_NumFmt* m_numFmt ;
        bool m_has_fill ;
        CT_Fill* m_fill ;
        bool m_has_alignment ;
        CT_CellAlignment* m_alignment ;
        bool m_has_border ;
        CT_Border* m_border ;
        bool m_has_protection ;
        CT_CellProtection* m_protection ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_Dxf* default_instance_ ;

    }

    class CT_Colors : public XSD::ComplexType{
    public:
        bool has_indexedColors(){

            return m_has_indexedColors;
        
        }
        CT_IndexedColors* mutable_indexedColors(){

                m_has_indexedColors = true;
                if (!m_indexedColors)
                {
                    m_indexedColors = new CT_IndexedColors();
                }
                return m_indexedColors;
            
        }
        const CT_IndexedColors& indexedColors(){

            if (m_indexedColors)
            {
                return *m_indexedColors;
            }
            return CT_IndexedColors::default_instance();
        
        }
        bool has_mruColors(){

            return m_has_mruColors;
        
        }
        CT_MRUColors* mutable_mruColors(){

                m_has_mruColors = true;
                if (!m_mruColors)
                {
                    m_mruColors = new CT_MRUColors();
                }
                return m_mruColors;
            
        }
        const CT_MRUColors& mruColors(){

            if (m_mruColors)
            {
                return *m_mruColors;
            }
            return CT_MRUColors::default_instance();
        
        }
        void clear(){

                m_has_indexedColors = false;
                
        if (m_indexedColors)
        {
            delete m_indexedColors;
            m_indexedColors = NULL;
        }
    
            
                m_has_mruColors = false;
                
        if (m_mruColors)
        {
            delete m_mruColors;
            m_mruColors = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_indexedColors)
                {
                    m_indexedColors->toXml(indexedColors, _outStream);;
                }
            
                if (m_has_mruColors)
                {
                    m_indexedColors->toXml(mruColors, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Colors& default_instance(){

    if (!CT_Colors::default_instance_)
    {
        CT_Colors::default_instance_ = new CT_Colors();
    }
    return *CT_Colors::default_instance_;

        }

    private:
        bool m_has_indexedColors ;
        CT_IndexedColors* m_indexedColors ;
        bool m_has_mruColors ;
        CT_MRUColors* m_mruColors ;
        static CT_Colors* default_instance_ ;

    }

    class CT_IndexedColors : public XSD::ComplexType{
    public:
        bool has_rgbColor(){

            return m_has_rgbColor;
        
        }
        CT_RgbColor* mutable_rgbColor(){

                m_has_rgbColor = true;
                if (!m_rgbColor)
                {
                    m_rgbColor = new CT_RgbColor();
                }
                return m_rgbColor;
            
        }
        const CT_RgbColor& rgbColor(){

            if (m_rgbColor)
            {
                return *m_rgbColor;
            }
            return CT_RgbColor::default_instance();
        
        }
        void clear(){

                m_has_rgbColor = false;
                
        if (m_rgbColor)
        {
            delete m_rgbColor;
            m_rgbColor = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_rgbColor)
                {
                    m_rgbColor->toXml(rgbColor, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_IndexedColors& default_instance(){

    if (!CT_IndexedColors::default_instance_)
    {
        CT_IndexedColors::default_instance_ = new CT_IndexedColors();
    }
    return *CT_IndexedColors::default_instance_;

        }

    private:
        bool m_has_rgbColor ;
        CT_RgbColor* m_rgbColor ;
        static CT_IndexedColors* default_instance_ ;

    }

    class CT_MRUColors : public XSD::ComplexType{
    public:
        bool has_color(){

            return m_has_color;
        
        }
        CT_Color* mutable_color(){

                m_has_color = true;
                if (!m_color)
                {
                    m_color = new CT_Color();
                }
                return m_color;
            
        }
        const CT_Color& color(){

            if (m_color)
            {
                return *m_color;
            }
            return CT_Color::default_instance();
        
        }
        void clear(){

                m_has_color = false;
                
        if (m_color)
        {
            delete m_color;
            m_color = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_color)
                {
                    m_color->toXml(color, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_MRUColors& default_instance(){

    if (!CT_MRUColors::default_instance_)
    {
        CT_MRUColors::default_instance_ = new CT_MRUColors();
    }
    return *CT_MRUColors::default_instance_;

        }

    private:
        bool m_has_color ;
        CT_Color* m_color ;
        static CT_MRUColors* default_instance_ ;

    }

    class CT_RgbColor : public XSD::ComplexType{
    public:
        void clear(){

                m_has_rgb_attr = false;
                
        if (m_rgb_attr)
        {
            delete m_rgb_attr;
            m_rgb_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_rgb_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_RgbColor& default_instance(){

    if (!CT_RgbColor::default_instance_)
    {
        CT_RgbColor::default_instance_ = new CT_RgbColor();
    }
    return *CT_RgbColor::default_instance_;

        }
        bool has_rgb_attr(){

            return m_has_rgb_attr;
        
        }
        void set_rgb_attr(const ST_UnsignedIntHex& _rgb_attr ){

            m_has_rgb_attr = true;
            m_rgb_attr = new ST_UnsignedIntHex(_rgb_attr);
        
        }
        const ST_UnsignedIntHex& rgb_attr(){

            if (m_rgb_attr)
            {
                return *m_rgb_attr;
            }
            return ST_UnsignedIntHex::default_instance();
        
        }

    private:
        static CT_RgbColor* default_instance_ ;
        bool m_has_rgb_attr ;
        ST_UnsignedIntHex* m_rgb_attr ;

    }

    class CT_TableStyles : public XSD::ComplexType{
    public:
        bool has_tableStyle(){

            return m_has_tableStyle;
        
        }
        CT_TableStyle* mutable_tableStyle(){

                m_has_tableStyle = true;
                if (!m_tableStyle)
                {
                    m_tableStyle = new CT_TableStyle();
                }
                return m_tableStyle;
            
        }
        const CT_TableStyle& tableStyle(){

            if (m_tableStyle)
            {
                return *m_tableStyle;
            }
            return CT_TableStyle::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_defaultTableStyle_attr = false;
                m_defaultTableStyle_attr.clear();
            
                m_has_defaultPivotStyle_attr = false;
                m_defaultPivotStyle_attr.clear();
            
                m_has_tableStyle = false;
                
        if (m_tableStyle)
        {
            delete m_tableStyle;
            m_tableStyle = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
_outStream << _attrName << \=\\ << m_defaultTableStyle_attr << \\\;
_outStream << _attrName << \=\\ << m_defaultPivotStyle_attr << \\\;
        _outStream << \>\;
    
                if (m_has_tableStyle)
                {
                    m_tableStyle->toXml(tableStyle, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_TableStyles& default_instance(){

    if (!CT_TableStyles::default_instance_)
    {
        CT_TableStyles::default_instance_ = new CT_TableStyles();
    }
    return *CT_TableStyles::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }
        bool has_defaultTableStyle_attr(){

            return m_has_defaultTableStyle_attr;
        
        }
        void set_defaultTableStyle_attr(const string& _defaultTableStyle_attr ){

        m_has_defaultTableStyle_attr = true;
        m_defaultTableStyle_attr = _defaultTableStyle_attr;
        
        }
        const string& defaultTableStyle_attr(){

            return type: \string\nname: \m_defaultTableStyle_attr\n;
        
        }
        bool has_defaultPivotStyle_attr(){

            return m_has_defaultPivotStyle_attr;
        
        }
        void set_defaultPivotStyle_attr(const string& _defaultPivotStyle_attr ){

        m_has_defaultPivotStyle_attr = true;
        m_defaultPivotStyle_attr = _defaultPivotStyle_attr;
        
        }
        const string& defaultPivotStyle_attr(){

            return type: \string\nname: \m_defaultPivotStyle_attr\n;
        
        }

    private:
        bool m_has_tableStyle ;
        CT_TableStyle* m_tableStyle ;
        static CT_TableStyles* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;
        bool m_has_defaultTableStyle_attr ;
        string m_defaultTableStyle_attr ;
        bool m_has_defaultPivotStyle_attr ;
        string m_defaultPivotStyle_attr ;

    }

    class CT_TableStyle : public XSD::ComplexType{
    public:
        bool has_tableStyleElement(){

            return m_has_tableStyleElement;
        
        }
        CT_TableStyleElement* mutable_tableStyleElement(){

                m_has_tableStyleElement = true;
                if (!m_tableStyleElement)
                {
                    m_tableStyleElement = new CT_TableStyleElement();
                }
                return m_tableStyleElement;
            
        }
        const CT_TableStyleElement& tableStyleElement(){

            if (m_tableStyleElement)
            {
                return *m_tableStyleElement;
            }
            return CT_TableStyleElement::default_instance();
        
        }
        void clear(){

                m_has_name_attr = false;
                m_name_attr.clear();
            
                m_has_pivot_attr = false;
                m_pivot_attr = false;
            
                m_has_table_attr = false;
                m_table_attr = false;
            
                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_tableStyleElement = false;
                
        if (m_tableStyleElement)
        {
            delete m_tableStyleElement;
            m_tableStyleElement = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_name_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_pivot_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_table_attr) << \\\;
_outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_tableStyleElement)
                {
                    m_tableStyleElement->toXml(tableStyleElement, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_TableStyle& default_instance(){

    if (!CT_TableStyle::default_instance_)
    {
        CT_TableStyle::default_instance_ = new CT_TableStyle();
    }
    return *CT_TableStyle::default_instance_;

        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const string& _name_attr ){

        m_has_name_attr = true;
        m_name_attr = _name_attr;
        
        }
        const string& name_attr(){

            return type: \string\nname: \m_name_attr\n;
        
        }
        bool has_pivot_attr(){

            return m_has_pivot_attr;
        
        }
        void set_pivot_attr(const boolean& _pivot_attr ){

        m_has_pivot_attr = true;
        m_pivot_attr = _pivot_attr;
        
        }
        const boolean& pivot_attr(){

            return type: oolean\nname: \m_pivot_attr\n;
        
        }
        bool has_table_attr(){

            return m_has_table_attr;
        
        }
        void set_table_attr(const boolean& _table_attr ){

        m_has_table_attr = true;
        m_table_attr = _table_attr;
        
        }
        const boolean& table_attr(){

            return type: oolean\nname: \m_table_attr\n;
        
        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_tableStyleElement ;
        CT_TableStyleElement* m_tableStyleElement ;
        static CT_TableStyle* default_instance_ ;
        bool m_has_name_attr ;
        string m_name_attr ;
        bool m_has_pivot_attr ;
        boolean m_pivot_attr ;
        bool m_has_table_attr ;
        boolean m_table_attr ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_TableStyleElement : public XSD::ComplexType{
    public:
        void clear(){

                m_has_type_attr = false;
                
        if (m_type_attr)
        {
            delete m_type_attr;
            m_type_attr = NULL;
        }
    
            
                m_has_size_attr = false;
                m_size_attr = 0;
            
                m_has_dxfId_attr = false;
                
        if (m_dxfId_attr)
        {
            delete m_dxfId_attr;
            m_dxfId_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_type_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_size_attr << \\\;
m_dxfId_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_TableStyleElement& default_instance(){

    if (!CT_TableStyleElement::default_instance_)
    {
        CT_TableStyleElement::default_instance_ = new CT_TableStyleElement();
    }
    return *CT_TableStyleElement::default_instance_;

        }
        bool has_type_attr(){

            return m_has_type_attr;
        
        }
        void set_type_attr(const ST_TableStyleType& _type_attr ){

            m_has_type_attr = true;
            m_type_attr = new ST_TableStyleType(_type_attr);
        
        }
        const ST_TableStyleType& type_attr(){

            if (m_type_attr)
            {
                return *m_type_attr;
            }
            return ST_TableStyleType::default_instance();
        
        }
        bool has_size_attr(){

            return m_has_size_attr;
        
        }
        void set_size_attr(const unsignedInt& _size_attr ){

        m_has_size_attr = true;
        m_size_attr = _size_attr;
        
        }
        const unsignedInt& size_attr(){

            return type: \unsignedInt\nname: \m_size_attr\n;
        
        }
        bool has_dxfId_attr(){

            return m_has_dxfId_attr;
        
        }
        void set_dxfId_attr(const ST_DxfId& _dxfId_attr ){

            m_has_dxfId_attr = true;
            m_dxfId_attr = new ST_DxfId(_dxfId_attr);
        
        }
        const ST_DxfId& dxfId_attr(){

            if (m_dxfId_attr)
            {
                return *m_dxfId_attr;
            }
            return ST_DxfId::default_instance();
        
        }

    private:
        static CT_TableStyleElement* default_instance_ ;
        bool m_has_type_attr ;
        ST_TableStyleType* m_type_attr ;
        bool m_has_size_attr ;
        unsignedInt m_size_attr ;
        bool m_has_dxfId_attr ;
        ST_DxfId* m_dxfId_attr ;

    }

    class CT_BooleanProperty : public XSD::ComplexType{
    public:
        void clear(){

                m_has_val_attr = false;
                m_val_attr = false;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_val_attr) << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_BooleanProperty& default_instance(){

    if (!CT_BooleanProperty::default_instance_)
    {
        CT_BooleanProperty::default_instance_ = new CT_BooleanProperty();
    }
    return *CT_BooleanProperty::default_instance_;

        }
        bool has_val_attr(){

            return m_has_val_attr;
        
        }
        void set_val_attr(const boolean& _val_attr ){

        m_has_val_attr = true;
        m_val_attr = _val_attr;
        
        }
        const boolean& val_attr(){

            return type: oolean\nname: \m_val_attr\n;
        
        }

    private:
        static CT_BooleanProperty* default_instance_ ;
        bool m_has_val_attr ;
        boolean m_val_attr ;

    }

    class CT_FontSize : public XSD::ComplexType{
    public:
        void clear(){

                m_has_val_attr = false;
                m_val_attr = 0;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_val_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_FontSize& default_instance(){

    if (!CT_FontSize::default_instance_)
    {
        CT_FontSize::default_instance_ = new CT_FontSize();
    }
    return *CT_FontSize::default_instance_;

        }
        bool has_val_attr(){

            return m_has_val_attr;
        
        }
        void set_val_attr(const double& _val_attr ){

        m_has_val_attr = true;
        m_val_attr = _val_attr;
        
        }
        const double& val_attr(){

            return type: \double\nname: \m_val_attr\n;
        
        }

    private:
        static CT_FontSize* default_instance_ ;
        bool m_has_val_attr ;
        double m_val_attr ;

    }

    class CT_IntProperty : public XSD::ComplexType{
    public:
        void clear(){

                m_has_val_attr = false;
                m_val_attr = 0;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_val_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_IntProperty& default_instance(){

    if (!CT_IntProperty::default_instance_)
    {
        CT_IntProperty::default_instance_ = new CT_IntProperty();
    }
    return *CT_IntProperty::default_instance_;

        }
        bool has_val_attr(){

            return m_has_val_attr;
        
        }
        void set_val_attr(const int& _val_attr ){

        m_has_val_attr = true;
        m_val_attr = _val_attr;
        
        }
        const int& val_attr(){

            return type: \int\nname: \m_val_attr\n;
        
        }

    private:
        static CT_IntProperty* default_instance_ ;
        bool m_has_val_attr ;
        int m_val_attr ;

    }

    class CT_FontName : public XSD::ComplexType{
    public:
        void clear(){

                m_has_val_attr = false;
                
        if (m_val_attr)
        {
            delete m_val_attr;
            m_val_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_val_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_FontName& default_instance(){

    if (!CT_FontName::default_instance_)
    {
        CT_FontName::default_instance_ = new CT_FontName();
    }
    return *CT_FontName::default_instance_;

        }
        bool has_val_attr(){

            return m_has_val_attr;
        
        }
        void set_val_attr(const ns_s::ST_Xstring& _val_attr ){

            m_has_val_attr = true;
            m_val_attr = new ns_s::ST_Xstring(_val_attr);
        
        }
        const ns_s::ST_Xstring& val_attr(){

            if (m_val_attr)
            {
                return *m_val_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }

    private:
        static CT_FontName* default_instance_ ;
        bool m_has_val_attr ;
        ns_s::ST_Xstring* m_val_attr ;

    }

    class CT_VerticalAlignFontProperty : public XSD::ComplexType{
    public:
        void clear(){

                m_has_val_attr = false;
                
        if (m_val_attr)
        {
            delete m_val_attr;
            m_val_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_val_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_VerticalAlignFontProperty& default_instance(){

    if (!CT_VerticalAlignFontProperty::default_instance_)
    {
        CT_VerticalAlignFontProperty::default_instance_ = new CT_VerticalAlignFontProperty();
    }
    return *CT_VerticalAlignFontProperty::default_instance_;

        }
        bool has_val_attr(){

            return m_has_val_attr;
        
        }
        void set_val_attr(const ns_s::ST_VerticalAlignRun& _val_attr ){

            m_has_val_attr = true;
            m_val_attr = new ns_s::ST_VerticalAlignRun(_val_attr);
        
        }
        const ns_s::ST_VerticalAlignRun& val_attr(){

            if (m_val_attr)
            {
                return *m_val_attr;
            }
            return ns_s::ST_VerticalAlignRun::default_instance();
        
        }

    private:
        static CT_VerticalAlignFontProperty* default_instance_ ;
        bool m_has_val_attr ;
        ns_s::ST_VerticalAlignRun* m_val_attr ;

    }

    class CT_FontScheme : public XSD::ComplexType{
    public:
        void clear(){

                m_has_val_attr = false;
                
        if (m_val_attr)
        {
            delete m_val_attr;
            m_val_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_val_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_FontScheme& default_instance(){

    if (!CT_FontScheme::default_instance_)
    {
        CT_FontScheme::default_instance_ = new CT_FontScheme();
    }
    return *CT_FontScheme::default_instance_;

        }
        bool has_val_attr(){

            return m_has_val_attr;
        
        }
        void set_val_attr(const ST_FontScheme& _val_attr ){

            m_has_val_attr = true;
            m_val_attr = new ST_FontScheme(_val_attr);
        
        }
        const ST_FontScheme& val_attr(){

            if (m_val_attr)
            {
                return *m_val_attr;
            }
            return ST_FontScheme::default_instance();
        
        }

    private:
        static CT_FontScheme* default_instance_ ;
        bool m_has_val_attr ;
        ST_FontScheme* m_val_attr ;

    }

    class CT_UnderlineProperty : public XSD::ComplexType{
    public:
        void clear(){

                m_has_val_attr = false;
                
        if (m_val_attr)
        {
            delete m_val_attr;
            m_val_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_val_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_UnderlineProperty& default_instance(){

    if (!CT_UnderlineProperty::default_instance_)
    {
        CT_UnderlineProperty::default_instance_ = new CT_UnderlineProperty();
    }
    return *CT_UnderlineProperty::default_instance_;

        }
        bool has_val_attr(){

            return m_has_val_attr;
        
        }
        void set_val_attr(const ST_UnderlineValues& _val_attr ){

            m_has_val_attr = true;
            m_val_attr = new ST_UnderlineValues(_val_attr);
        
        }
        const ST_UnderlineValues& val_attr(){

            if (m_val_attr)
            {
                return *m_val_attr;
            }
            return ST_UnderlineValues::default_instance();
        
        }

    private:
        static CT_UnderlineProperty* default_instance_ ;
        bool m_has_val_attr ;
        ST_UnderlineValues* m_val_attr ;

    }

    class CT_Font : public XSD::ComplexType{
    public:
        CT_FontName* add_name(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_FontName* pNewChild = pChildGroup->mutable_name();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_IntProperty* add_charset(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_IntProperty* pNewChild = pChildGroup->mutable_charset();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_FontFamily* add_family(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_FontFamily* pNewChild = pChildGroup->mutable_family();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_BooleanProperty* add_b(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_BooleanProperty* pNewChild = pChildGroup->mutable_b();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_BooleanProperty* add_i(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_BooleanProperty* pNewChild = pChildGroup->mutable_i();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_BooleanProperty* add_strike(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_BooleanProperty* pNewChild = pChildGroup->mutable_strike();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_BooleanProperty* add_outline(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_BooleanProperty* pNewChild = pChildGroup->mutable_outline();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_BooleanProperty* add_shadow(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_BooleanProperty* pNewChild = pChildGroup->mutable_shadow();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_BooleanProperty* add_condense(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_BooleanProperty* pNewChild = pChildGroup->mutable_condense();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_BooleanProperty* add_extend(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_BooleanProperty* pNewChild = pChildGroup->mutable_extend();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_Color* add_color(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_Color* pNewChild = pChildGroup->mutable_color();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_FontSize* add_sz(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_FontSize* pNewChild = pChildGroup->mutable_sz();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_UnderlineProperty* add_u(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_UnderlineProperty* pNewChild = pChildGroup->mutable_u();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_VerticalAlignFontProperty* add_vertAlign(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_VerticalAlignFontProperty* pNewChild = pChildGroup->mutable_vertAlign();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        CT_FontScheme* add_scheme(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_FontScheme* pNewChild = pChildGroup->mutable_scheme();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        void clear(){

            vector<ChildGroup_1*>::iterator iter;
            for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
            {
                delete *iter;
            }
            m_childGroupList_1.clear();
        
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_name())
            {
                (*iter)->toXml(name, _outStream);
            }
            else if ((*iter)->has_charset())
            {
                (*iter)->toXml(charset, _outStream);
            }
            else if ((*iter)->has_family())
            {
                (*iter)->toXml(family, _outStream);
            }
            else if ((*iter)->has_b())
            {
                (*iter)->toXml(b, _outStream);
            }
            else if ((*iter)->has_i())
            {
                (*iter)->toXml(i, _outStream);
            }
            else if ((*iter)->has_strike())
            {
                (*iter)->toXml(strike, _outStream);
            }
            else if ((*iter)->has_outline())
            {
                (*iter)->toXml(outline, _outStream);
            }
            else if ((*iter)->has_shadow())
            {
                (*iter)->toXml(shadow, _outStream);
            }
            else if ((*iter)->has_condense())
            {
                (*iter)->toXml(condense, _outStream);
            }
            else if ((*iter)->has_extend())
            {
                (*iter)->toXml(extend, _outStream);
            }
            else if ((*iter)->has_color())
            {
                (*iter)->toXml(color, _outStream);
            }
            else if ((*iter)->has_sz())
            {
                (*iter)->toXml(sz, _outStream);
            }
            else if ((*iter)->has_u())
            {
                (*iter)->toXml(u, _outStream);
            }
            else if ((*iter)->has_vertAlign())
            {
                (*iter)->toXml(vertAlign, _outStream);
            }
            else if ((*iter)->has_scheme())
            {
                (*iter)->toXml(scheme, _outStream);
            }
        }
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Font& default_instance(){

    if (!CT_Font::default_instance_)
    {
        CT_Font::default_instance_ = new CT_Font();
    }
    return *CT_Font::default_instance_;

        }

    private:
        vector<ChildGroup_1*> m_childGroupList_1 ;
        static CT_Font* default_instance_ ;
        class ChildGroup_1{
        public:
            bool has_name(){

            return m_has_name;
        
            }
            CT_FontName* mutable_name(){

                
                m_has_charset = false;
                
        if (m_charset)
        {
            delete m_charset;
            m_charset = NULL;
        }
    ;
            
                m_has_family = false;
                
        if (m_family)
        {
            delete m_family;
            m_family = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_i = false;
                
        if (m_i)
        {
            delete m_i;
            m_i = NULL;
        }
    ;
            
                m_has_strike = false;
                
        if (m_strike)
        {
            delete m_strike;
            m_strike = NULL;
        }
    ;
            
                m_has_outline = false;
                
        if (m_outline)
        {
            delete m_outline;
            m_outline = NULL;
        }
    ;
            
                m_has_shadow = false;
                
        if (m_shadow)
        {
            delete m_shadow;
            m_shadow = NULL;
        }
    ;
            
                m_has_condense = false;
                
        if (m_condense)
        {
            delete m_condense;
            m_condense = NULL;
        }
    ;
            
                m_has_extend = false;
                
        if (m_extend)
        {
            delete m_extend;
            m_extend = NULL;
        }
    ;
            
                m_has_color = false;
                
        if (m_color)
        {
            delete m_color;
            m_color = NULL;
        }
    ;
            
                m_has_sz = false;
                
        if (m_sz)
        {
            delete m_sz;
            m_sz = NULL;
        }
    ;
            
                m_has_u = false;
                
        if (m_u)
        {
            delete m_u;
            m_u = NULL;
        }
    ;
            
                m_has_vertAlign = false;
                
        if (m_vertAlign)
        {
            delete m_vertAlign;
            m_vertAlign = NULL;
        }
    ;
            
                m_has_scheme = false;
                
        if (m_scheme)
        {
            delete m_scheme;
            m_scheme = NULL;
        }
    ;
            
                m_has_name = true;
                if (!m_name)
                {
                    m_name = new CT_FontName();
                }
                return m_name;
            
            }
            const CT_FontName& name(){

            if (m_name)
            {
                return *m_name;
            }
            return CT_FontName::default_instance();
        
            }
            bool has_charset(){

            return m_has_charset;
        
            }
            CT_IntProperty* mutable_charset(){

                
                m_has_name = false;
                
        if (m_name)
        {
            delete m_name;
            m_name = NULL;
        }
    ;
            
                m_has_family = false;
                
        if (m_family)
        {
            delete m_family;
            m_family = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_i = false;
                
        if (m_i)
        {
            delete m_i;
            m_i = NULL;
        }
    ;
            
                m_has_strike = false;
                
        if (m_strike)
        {
            delete m_strike;
            m_strike = NULL;
        }
    ;
            
                m_has_outline = false;
                
        if (m_outline)
        {
            delete m_outline;
            m_outline = NULL;
        }
    ;
            
                m_has_shadow = false;
                
        if (m_shadow)
        {
            delete m_shadow;
            m_shadow = NULL;
        }
    ;
            
                m_has_condense = false;
                
        if (m_condense)
        {
            delete m_condense;
            m_condense = NULL;
        }
    ;
            
                m_has_extend = false;
                
        if (m_extend)
        {
            delete m_extend;
            m_extend = NULL;
        }
    ;
            
                m_has_color = false;
                
        if (m_color)
        {
            delete m_color;
            m_color = NULL;
        }
    ;
            
                m_has_sz = false;
                
        if (m_sz)
        {
            delete m_sz;
            m_sz = NULL;
        }
    ;
            
                m_has_u = false;
                
        if (m_u)
        {
            delete m_u;
            m_u = NULL;
        }
    ;
            
                m_has_vertAlign = false;
                
        if (m_vertAlign)
        {
            delete m_vertAlign;
            m_vertAlign = NULL;
        }
    ;
            
                m_has_scheme = false;
                
        if (m_scheme)
        {
            delete m_scheme;
            m_scheme = NULL;
        }
    ;
            
                m_has_charset = true;
                if (!m_charset)
                {
                    m_charset = new CT_IntProperty();
                }
                return m_charset;
            
            }
            const CT_IntProperty& charset(){

            if (m_charset)
            {
                return *m_charset;
            }
            return CT_IntProperty::default_instance();
        
            }
            bool has_family(){

            return m_has_family;
        
            }
            CT_FontFamily* mutable_family(){

                
                m_has_name = false;
                
        if (m_name)
        {
            delete m_name;
            m_name = NULL;
        }
    ;
            
                m_has_charset = false;
                
        if (m_charset)
        {
            delete m_charset;
            m_charset = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_i = false;
                
        if (m_i)
        {
            delete m_i;
            m_i = NULL;
        }
    ;
            
                m_has_strike = false;
                
        if (m_strike)
        {
            delete m_strike;
            m_strike = NULL;
        }
    ;
            
                m_has_outline = false;
                
        if (m_outline)
        {
            delete m_outline;
            m_outline = NULL;
        }
    ;
            
                m_has_shadow = false;
                
        if (m_shadow)
        {
            delete m_shadow;
            m_shadow = NULL;
        }
    ;
            
                m_has_condense = false;
                
        if (m_condense)
        {
            delete m_condense;
            m_condense = NULL;
        }
    ;
            
                m_has_extend = false;
                
        if (m_extend)
        {
            delete m_extend;
            m_extend = NULL;
        }
    ;
            
                m_has_color = false;
                
        if (m_color)
        {
            delete m_color;
            m_color = NULL;
        }
    ;
            
                m_has_sz = false;
                
        if (m_sz)
        {
            delete m_sz;
            m_sz = NULL;
        }
    ;
            
                m_has_u = false;
                
        if (m_u)
        {
            delete m_u;
            m_u = NULL;
        }
    ;
            
                m_has_vertAlign = false;
                
        if (m_vertAlign)
        {
            delete m_vertAlign;
            m_vertAlign = NULL;
        }
    ;
            
                m_has_scheme = false;
                
        if (m_scheme)
        {
            delete m_scheme;
            m_scheme = NULL;
        }
    ;
            
                m_has_family = true;
                if (!m_family)
                {
                    m_family = new CT_FontFamily();
                }
                return m_family;
            
            }
            const CT_FontFamily& family(){

            if (m_family)
            {
                return *m_family;
            }
            return CT_FontFamily::default_instance();
        
            }
            bool has_b(){

            return m_has_b;
        
            }
            CT_BooleanProperty* mutable_b(){

                
                m_has_name = false;
                
        if (m_name)
        {
            delete m_name;
            m_name = NULL;
        }
    ;
            
                m_has_charset = false;
                
        if (m_charset)
        {
            delete m_charset;
            m_charset = NULL;
        }
    ;
            
                m_has_family = false;
                
        if (m_family)
        {
            delete m_family;
            m_family = NULL;
        }
    ;
            
                m_has_i = false;
                
        if (m_i)
        {
            delete m_i;
            m_i = NULL;
        }
    ;
            
                m_has_strike = false;
                
        if (m_strike)
        {
            delete m_strike;
            m_strike = NULL;
        }
    ;
            
                m_has_outline = false;
                
        if (m_outline)
        {
            delete m_outline;
            m_outline = NULL;
        }
    ;
            
                m_has_shadow = false;
                
        if (m_shadow)
        {
            delete m_shadow;
            m_shadow = NULL;
        }
    ;
            
                m_has_condense = false;
                
        if (m_condense)
        {
            delete m_condense;
            m_condense = NULL;
        }
    ;
            
                m_has_extend = false;
                
        if (m_extend)
        {
            delete m_extend;
            m_extend = NULL;
        }
    ;
            
                m_has_color = false;
                
        if (m_color)
        {
            delete m_color;
            m_color = NULL;
        }
    ;
            
                m_has_sz = false;
                
        if (m_sz)
        {
            delete m_sz;
            m_sz = NULL;
        }
    ;
            
                m_has_u = false;
                
        if (m_u)
        {
            delete m_u;
            m_u = NULL;
        }
    ;
            
                m_has_vertAlign = false;
                
        if (m_vertAlign)
        {
            delete m_vertAlign;
            m_vertAlign = NULL;
        }
    ;
            
                m_has_scheme = false;
                
        if (m_scheme)
        {
            delete m_scheme;
            m_scheme = NULL;
        }
    ;
            
                m_has_b = true;
                if (!m_b)
                {
                    m_b = new CT_BooleanProperty();
                }
                return m_b;
            
            }
            const CT_BooleanProperty& b(){

            if (m_b)
            {
                return *m_b;
            }
            return CT_BooleanProperty::default_instance();
        
            }
            bool has_i(){

            return m_has_i;
        
            }
            CT_BooleanProperty* mutable_i(){

                
                m_has_name = false;
                
        if (m_name)
        {
            delete m_name;
            m_name = NULL;
        }
    ;
            
                m_has_charset = false;
                
        if (m_charset)
        {
            delete m_charset;
            m_charset = NULL;
        }
    ;
            
                m_has_family = false;
                
        if (m_family)
        {
            delete m_family;
            m_family = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_strike = false;
                
        if (m_strike)
        {
            delete m_strike;
            m_strike = NULL;
        }
    ;
            
                m_has_outline = false;
                
        if (m_outline)
        {
            delete m_outline;
            m_outline = NULL;
        }
    ;
            
                m_has_shadow = false;
                
        if (m_shadow)
        {
            delete m_shadow;
            m_shadow = NULL;
        }
    ;
            
                m_has_condense = false;
                
        if (m_condense)
        {
            delete m_condense;
            m_condense = NULL;
        }
    ;
            
                m_has_extend = false;
                
        if (m_extend)
        {
            delete m_extend;
            m_extend = NULL;
        }
    ;
            
                m_has_color = false;
                
        if (m_color)
        {
            delete m_color;
            m_color = NULL;
        }
    ;
            
                m_has_sz = false;
                
        if (m_sz)
        {
            delete m_sz;
            m_sz = NULL;
        }
    ;
            
                m_has_u = false;
                
        if (m_u)
        {
            delete m_u;
            m_u = NULL;
        }
    ;
            
                m_has_vertAlign = false;
                
        if (m_vertAlign)
        {
            delete m_vertAlign;
            m_vertAlign = NULL;
        }
    ;
            
                m_has_scheme = false;
                
        if (m_scheme)
        {
            delete m_scheme;
            m_scheme = NULL;
        }
    ;
            
                m_has_i = true;
                if (!m_i)
                {
                    m_i = new CT_BooleanProperty();
                }
                return m_i;
            
            }
            const CT_BooleanProperty& i(){

            if (m_i)
            {
                return *m_i;
            }
            return CT_BooleanProperty::default_instance();
        
            }
            bool has_strike(){

            return m_has_strike;
        
            }
            CT_BooleanProperty* mutable_strike(){

                
                m_has_name = false;
                
        if (m_name)
        {
            delete m_name;
            m_name = NULL;
        }
    ;
            
                m_has_charset = false;
                
        if (m_charset)
        {
            delete m_charset;
            m_charset = NULL;
        }
    ;
            
                m_has_family = false;
                
        if (m_family)
        {
            delete m_family;
            m_family = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_i = false;
                
        if (m_i)
        {
            delete m_i;
            m_i = NULL;
        }
    ;
            
                m_has_outline = false;
                
        if (m_outline)
        {
            delete m_outline;
            m_outline = NULL;
        }
    ;
            
                m_has_shadow = false;
                
        if (m_shadow)
        {
            delete m_shadow;
            m_shadow = NULL;
        }
    ;
            
                m_has_condense = false;
                
        if (m_condense)
        {
            delete m_condense;
            m_condense = NULL;
        }
    ;
            
                m_has_extend = false;
                
        if (m_extend)
        {
            delete m_extend;
            m_extend = NULL;
        }
    ;
            
                m_has_color = false;
                
        if (m_color)
        {
            delete m_color;
            m_color = NULL;
        }
    ;
            
                m_has_sz = false;
                
        if (m_sz)
        {
            delete m_sz;
            m_sz = NULL;
        }
    ;
            
                m_has_u = false;
                
        if (m_u)
        {
            delete m_u;
            m_u = NULL;
        }
    ;
            
                m_has_vertAlign = false;
                
        if (m_vertAlign)
        {
            delete m_vertAlign;
            m_vertAlign = NULL;
        }
    ;
            
                m_has_scheme = false;
                
        if (m_scheme)
        {
            delete m_scheme;
            m_scheme = NULL;
        }
    ;
            
                m_has_strike = true;
                if (!m_strike)
                {
                    m_strike = new CT_BooleanProperty();
                }
                return m_strike;
            
            }
            const CT_BooleanProperty& strike(){

            if (m_strike)
            {
                return *m_strike;
            }
            return CT_BooleanProperty::default_instance();
        
            }
            bool has_outline(){

            return m_has_outline;
        
            }
            CT_BooleanProperty* mutable_outline(){

                
                m_has_name = false;
                
        if (m_name)
        {
            delete m_name;
            m_name = NULL;
        }
    ;
            
                m_has_charset = false;
                
        if (m_charset)
        {
            delete m_charset;
            m_charset = NULL;
        }
    ;
            
                m_has_family = false;
                
        if (m_family)
        {
            delete m_family;
            m_family = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_i = false;
                
        if (m_i)
        {
            delete m_i;
            m_i = NULL;
        }
    ;
            
                m_has_strike = false;
                
        if (m_strike)
        {
            delete m_strike;
            m_strike = NULL;
        }
    ;
            
                m_has_shadow = false;
                
        if (m_shadow)
        {
            delete m_shadow;
            m_shadow = NULL;
        }
    ;
            
                m_has_condense = false;
                
        if (m_condense)
        {
            delete m_condense;
            m_condense = NULL;
        }
    ;
            
                m_has_extend = false;
                
        if (m_extend)
        {
            delete m_extend;
            m_extend = NULL;
        }
    ;
            
                m_has_color = false;
                
        if (m_color)
        {
            delete m_color;
            m_color = NULL;
        }
    ;
            
                m_has_sz = false;
                
        if (m_sz)
        {
            delete m_sz;
            m_sz = NULL;
        }
    ;
            
                m_has_u = false;
                
        if (m_u)
        {
            delete m_u;
            m_u = NULL;
        }
    ;
            
                m_has_vertAlign = false;
                
        if (m_vertAlign)
        {
            delete m_vertAlign;
            m_vertAlign = NULL;
        }
    ;
            
                m_has_scheme = false;
                
        if (m_scheme)
        {
            delete m_scheme;
            m_scheme = NULL;
        }
    ;
            
                m_has_outline = true;
                if (!m_outline)
                {
                    m_outline = new CT_BooleanProperty();
                }
                return m_outline;
            
            }
            const CT_BooleanProperty& outline(){

            if (m_outline)
            {
                return *m_outline;
            }
            return CT_BooleanProperty::default_instance();
        
            }
            bool has_shadow(){

            return m_has_shadow;
        
            }
            CT_BooleanProperty* mutable_shadow(){

                
                m_has_name = false;
                
        if (m_name)
        {
            delete m_name;
            m_name = NULL;
        }
    ;
            
                m_has_charset = false;
                
        if (m_charset)
        {
            delete m_charset;
            m_charset = NULL;
        }
    ;
            
                m_has_family = false;
                
        if (m_family)
        {
            delete m_family;
            m_family = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_i = false;
                
        if (m_i)
        {
            delete m_i;
            m_i = NULL;
        }
    ;
            
                m_has_strike = false;
                
        if (m_strike)
        {
            delete m_strike;
            m_strike = NULL;
        }
    ;
            
                m_has_outline = false;
                
        if (m_outline)
        {
            delete m_outline;
            m_outline = NULL;
        }
    ;
            
                m_has_condense = false;
                
        if (m_condense)
        {
            delete m_condense;
            m_condense = NULL;
        }
    ;
            
                m_has_extend = false;
                
        if (m_extend)
        {
            delete m_extend;
            m_extend = NULL;
        }
    ;
            
                m_has_color = false;
                
        if (m_color)
        {
            delete m_color;
            m_color = NULL;
        }
    ;
            
                m_has_sz = false;
                
        if (m_sz)
        {
            delete m_sz;
            m_sz = NULL;
        }
    ;
            
                m_has_u = false;
                
        if (m_u)
        {
            delete m_u;
            m_u = NULL;
        }
    ;
            
                m_has_vertAlign = false;
                
        if (m_vertAlign)
        {
            delete m_vertAlign;
            m_vertAlign = NULL;
        }
    ;
            
                m_has_scheme = false;
                
        if (m_scheme)
        {
            delete m_scheme;
            m_scheme = NULL;
        }
    ;
            
                m_has_shadow = true;
                if (!m_shadow)
                {
                    m_shadow = new CT_BooleanProperty();
                }
                return m_shadow;
            
            }
            const CT_BooleanProperty& shadow(){

            if (m_shadow)
            {
                return *m_shadow;
            }
            return CT_BooleanProperty::default_instance();
        
            }
            bool has_condense(){

            return m_has_condense;
        
            }
            CT_BooleanProperty* mutable_condense(){

                
                m_has_name = false;
                
        if (m_name)
        {
            delete m_name;
            m_name = NULL;
        }
    ;
            
                m_has_charset = false;
                
        if (m_charset)
        {
            delete m_charset;
            m_charset = NULL;
        }
    ;
            
                m_has_family = false;
                
        if (m_family)
        {
            delete m_family;
            m_family = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_i = false;
                
        if (m_i)
        {
            delete m_i;
            m_i = NULL;
        }
    ;
            
                m_has_strike = false;
                
        if (m_strike)
        {
            delete m_strike;
            m_strike = NULL;
        }
    ;
            
                m_has_outline = false;
                
        if (m_outline)
        {
            delete m_outline;
            m_outline = NULL;
        }
    ;
            
                m_has_shadow = false;
                
        if (m_shadow)
        {
            delete m_shadow;
            m_shadow = NULL;
        }
    ;
            
                m_has_extend = false;
                
        if (m_extend)
        {
            delete m_extend;
            m_extend = NULL;
        }
    ;
            
                m_has_color = false;
                
        if (m_color)
        {
            delete m_color;
            m_color = NULL;
        }
    ;
            
                m_has_sz = false;
                
        if (m_sz)
        {
            delete m_sz;
            m_sz = NULL;
        }
    ;
            
                m_has_u = false;
                
        if (m_u)
        {
            delete m_u;
            m_u = NULL;
        }
    ;
            
                m_has_vertAlign = false;
                
        if (m_vertAlign)
        {
            delete m_vertAlign;
            m_vertAlign = NULL;
        }
    ;
            
                m_has_scheme = false;
                
        if (m_scheme)
        {
            delete m_scheme;
            m_scheme = NULL;
        }
    ;
            
                m_has_condense = true;
                if (!m_condense)
                {
                    m_condense = new CT_BooleanProperty();
                }
                return m_condense;
            
            }
            const CT_BooleanProperty& condense(){

            if (m_condense)
            {
                return *m_condense;
            }
            return CT_BooleanProperty::default_instance();
        
            }
            bool has_extend(){

            return m_has_extend;
        
            }
            CT_BooleanProperty* mutable_extend(){

                
                m_has_name = false;
                
        if (m_name)
        {
            delete m_name;
            m_name = NULL;
        }
    ;
            
                m_has_charset = false;
                
        if (m_charset)
        {
            delete m_charset;
            m_charset = NULL;
        }
    ;
            
                m_has_family = false;
                
        if (m_family)
        {
            delete m_family;
            m_family = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_i = false;
                
        if (m_i)
        {
            delete m_i;
            m_i = NULL;
        }
    ;
            
                m_has_strike = false;
                
        if (m_strike)
        {
            delete m_strike;
            m_strike = NULL;
        }
    ;
            
                m_has_outline = false;
                
        if (m_outline)
        {
            delete m_outline;
            m_outline = NULL;
        }
    ;
            
                m_has_shadow = false;
                
        if (m_shadow)
        {
            delete m_shadow;
            m_shadow = NULL;
        }
    ;
            
                m_has_condense = false;
                
        if (m_condense)
        {
            delete m_condense;
            m_condense = NULL;
        }
    ;
            
                m_has_color = false;
                
        if (m_color)
        {
            delete m_color;
            m_color = NULL;
        }
    ;
            
                m_has_sz = false;
                
        if (m_sz)
        {
            delete m_sz;
            m_sz = NULL;
        }
    ;
            
                m_has_u = false;
                
        if (m_u)
        {
            delete m_u;
            m_u = NULL;
        }
    ;
            
                m_has_vertAlign = false;
                
        if (m_vertAlign)
        {
            delete m_vertAlign;
            m_vertAlign = NULL;
        }
    ;
            
                m_has_scheme = false;
                
        if (m_scheme)
        {
            delete m_scheme;
            m_scheme = NULL;
        }
    ;
            
                m_has_extend = true;
                if (!m_extend)
                {
                    m_extend = new CT_BooleanProperty();
                }
                return m_extend;
            
            }
            const CT_BooleanProperty& extend(){

            if (m_extend)
            {
                return *m_extend;
            }
            return CT_BooleanProperty::default_instance();
        
            }
            bool has_color(){

            return m_has_color;
        
            }
            CT_Color* mutable_color(){

                
                m_has_name = false;
                
        if (m_name)
        {
            delete m_name;
            m_name = NULL;
        }
    ;
            
                m_has_charset = false;
                
        if (m_charset)
        {
            delete m_charset;
            m_charset = NULL;
        }
    ;
            
                m_has_family = false;
                
        if (m_family)
        {
            delete m_family;
            m_family = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_i = false;
                
        if (m_i)
        {
            delete m_i;
            m_i = NULL;
        }
    ;
            
                m_has_strike = false;
                
        if (m_strike)
        {
            delete m_strike;
            m_strike = NULL;
        }
    ;
            
                m_has_outline = false;
                
        if (m_outline)
        {
            delete m_outline;
            m_outline = NULL;
        }
    ;
            
                m_has_shadow = false;
                
        if (m_shadow)
        {
            delete m_shadow;
            m_shadow = NULL;
        }
    ;
            
                m_has_condense = false;
                
        if (m_condense)
        {
            delete m_condense;
            m_condense = NULL;
        }
    ;
            
                m_has_extend = false;
                
        if (m_extend)
        {
            delete m_extend;
            m_extend = NULL;
        }
    ;
            
                m_has_sz = false;
                
        if (m_sz)
        {
            delete m_sz;
            m_sz = NULL;
        }
    ;
            
                m_has_u = false;
                
        if (m_u)
        {
            delete m_u;
            m_u = NULL;
        }
    ;
            
                m_has_vertAlign = false;
                
        if (m_vertAlign)
        {
            delete m_vertAlign;
            m_vertAlign = NULL;
        }
    ;
            
                m_has_scheme = false;
                
        if (m_scheme)
        {
            delete m_scheme;
            m_scheme = NULL;
        }
    ;
            
                m_has_color = true;
                if (!m_color)
                {
                    m_color = new CT_Color();
                }
                return m_color;
            
            }
            const CT_Color& color(){

            if (m_color)
            {
                return *m_color;
            }
            return CT_Color::default_instance();
        
            }
            bool has_sz(){

            return m_has_sz;
        
            }
            CT_FontSize* mutable_sz(){

                
                m_has_name = false;
                
        if (m_name)
        {
            delete m_name;
            m_name = NULL;
        }
    ;
            
                m_has_charset = false;
                
        if (m_charset)
        {
            delete m_charset;
            m_charset = NULL;
        }
    ;
            
                m_has_family = false;
                
        if (m_family)
        {
            delete m_family;
            m_family = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_i = false;
                
        if (m_i)
        {
            delete m_i;
            m_i = NULL;
        }
    ;
            
                m_has_strike = false;
                
        if (m_strike)
        {
            delete m_strike;
            m_strike = NULL;
        }
    ;
            
                m_has_outline = false;
                
        if (m_outline)
        {
            delete m_outline;
            m_outline = NULL;
        }
    ;
            
                m_has_shadow = false;
                
        if (m_shadow)
        {
            delete m_shadow;
            m_shadow = NULL;
        }
    ;
            
                m_has_condense = false;
                
        if (m_condense)
        {
            delete m_condense;
            m_condense = NULL;
        }
    ;
            
                m_has_extend = false;
                
        if (m_extend)
        {
            delete m_extend;
            m_extend = NULL;
        }
    ;
            
                m_has_color = false;
                
        if (m_color)
        {
            delete m_color;
            m_color = NULL;
        }
    ;
            
                m_has_u = false;
                
        if (m_u)
        {
            delete m_u;
            m_u = NULL;
        }
    ;
            
                m_has_vertAlign = false;
                
        if (m_vertAlign)
        {
            delete m_vertAlign;
            m_vertAlign = NULL;
        }
    ;
            
                m_has_scheme = false;
                
        if (m_scheme)
        {
            delete m_scheme;
            m_scheme = NULL;
        }
    ;
            
                m_has_sz = true;
                if (!m_sz)
                {
                    m_sz = new CT_FontSize();
                }
                return m_sz;
            
            }
            const CT_FontSize& sz(){

            if (m_sz)
            {
                return *m_sz;
            }
            return CT_FontSize::default_instance();
        
            }
            bool has_u(){

            return m_has_u;
        
            }
            CT_UnderlineProperty* mutable_u(){

                
                m_has_name = false;
                
        if (m_name)
        {
            delete m_name;
            m_name = NULL;
        }
    ;
            
                m_has_charset = false;
                
        if (m_charset)
        {
            delete m_charset;
            m_charset = NULL;
        }
    ;
            
                m_has_family = false;
                
        if (m_family)
        {
            delete m_family;
            m_family = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_i = false;
                
        if (m_i)
        {
            delete m_i;
            m_i = NULL;
        }
    ;
            
                m_has_strike = false;
                
        if (m_strike)
        {
            delete m_strike;
            m_strike = NULL;
        }
    ;
            
                m_has_outline = false;
                
        if (m_outline)
        {
            delete m_outline;
            m_outline = NULL;
        }
    ;
            
                m_has_shadow = false;
                
        if (m_shadow)
        {
            delete m_shadow;
            m_shadow = NULL;
        }
    ;
            
                m_has_condense = false;
                
        if (m_condense)
        {
            delete m_condense;
            m_condense = NULL;
        }
    ;
            
                m_has_extend = false;
                
        if (m_extend)
        {
            delete m_extend;
            m_extend = NULL;
        }
    ;
            
                m_has_color = false;
                
        if (m_color)
        {
            delete m_color;
            m_color = NULL;
        }
    ;
            
                m_has_sz = false;
                
        if (m_sz)
        {
            delete m_sz;
            m_sz = NULL;
        }
    ;
            
                m_has_vertAlign = false;
                
        if (m_vertAlign)
        {
            delete m_vertAlign;
            m_vertAlign = NULL;
        }
    ;
            
                m_has_scheme = false;
                
        if (m_scheme)
        {
            delete m_scheme;
            m_scheme = NULL;
        }
    ;
            
                m_has_u = true;
                if (!m_u)
                {
                    m_u = new CT_UnderlineProperty();
                }
                return m_u;
            
            }
            const CT_UnderlineProperty& u(){

            if (m_u)
            {
                return *m_u;
            }
            return CT_UnderlineProperty::default_instance();
        
            }
            bool has_vertAlign(){

            return m_has_vertAlign;
        
            }
            CT_VerticalAlignFontProperty* mutable_vertAlign(){

                
                m_has_name = false;
                
        if (m_name)
        {
            delete m_name;
            m_name = NULL;
        }
    ;
            
                m_has_charset = false;
                
        if (m_charset)
        {
            delete m_charset;
            m_charset = NULL;
        }
    ;
            
                m_has_family = false;
                
        if (m_family)
        {
            delete m_family;
            m_family = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_i = false;
                
        if (m_i)
        {
            delete m_i;
            m_i = NULL;
        }
    ;
            
                m_has_strike = false;
                
        if (m_strike)
        {
            delete m_strike;
            m_strike = NULL;
        }
    ;
            
                m_has_outline = false;
                
        if (m_outline)
        {
            delete m_outline;
            m_outline = NULL;
        }
    ;
            
                m_has_shadow = false;
                
        if (m_shadow)
        {
            delete m_shadow;
            m_shadow = NULL;
        }
    ;
            
                m_has_condense = false;
                
        if (m_condense)
        {
            delete m_condense;
            m_condense = NULL;
        }
    ;
            
                m_has_extend = false;
                
        if (m_extend)
        {
            delete m_extend;
            m_extend = NULL;
        }
    ;
            
                m_has_color = false;
                
        if (m_color)
        {
            delete m_color;
            m_color = NULL;
        }
    ;
            
                m_has_sz = false;
                
        if (m_sz)
        {
            delete m_sz;
            m_sz = NULL;
        }
    ;
            
                m_has_u = false;
                
        if (m_u)
        {
            delete m_u;
            m_u = NULL;
        }
    ;
            
                m_has_scheme = false;
                
        if (m_scheme)
        {
            delete m_scheme;
            m_scheme = NULL;
        }
    ;
            
                m_has_vertAlign = true;
                if (!m_vertAlign)
                {
                    m_vertAlign = new CT_VerticalAlignFontProperty();
                }
                return m_vertAlign;
            
            }
            const CT_VerticalAlignFontProperty& vertAlign(){

            if (m_vertAlign)
            {
                return *m_vertAlign;
            }
            return CT_VerticalAlignFontProperty::default_instance();
        
            }
            bool has_scheme(){

            return m_has_scheme;
        
            }
            CT_FontScheme* mutable_scheme(){

                
                m_has_name = false;
                
        if (m_name)
        {
            delete m_name;
            m_name = NULL;
        }
    ;
            
                m_has_charset = false;
                
        if (m_charset)
        {
            delete m_charset;
            m_charset = NULL;
        }
    ;
            
                m_has_family = false;
                
        if (m_family)
        {
            delete m_family;
            m_family = NULL;
        }
    ;
            
                m_has_b = false;
                
        if (m_b)
        {
            delete m_b;
            m_b = NULL;
        }
    ;
            
                m_has_i = false;
                
        if (m_i)
        {
            delete m_i;
            m_i = NULL;
        }
    ;
            
                m_has_strike = false;
                
        if (m_strike)
        {
            delete m_strike;
            m_strike = NULL;
        }
    ;
            
                m_has_outline = false;
                
        if (m_outline)
        {
            delete m_outline;
            m_outline = NULL;
        }
    ;
            
                m_has_shadow = false;
                
        if (m_shadow)
        {
            delete m_shadow;
            m_shadow = NULL;
        }
    ;
            
                m_has_condense = false;
                
        if (m_condense)
        {
            delete m_condense;
            m_condense = NULL;
        }
    ;
            
                m_has_extend = false;
                
        if (m_extend)
        {
            delete m_extend;
            m_extend = NULL;
        }
    ;
            
                m_has_color = false;
                
        if (m_color)
        {
            delete m_color;
            m_color = NULL;
        }
    ;
            
                m_has_sz = false;
                
        if (m_sz)
        {
            delete m_sz;
            m_sz = NULL;
        }
    ;
            
                m_has_u = false;
                
        if (m_u)
        {
            delete m_u;
            m_u = NULL;
        }
    ;
            
                m_has_vertAlign = false;
                
        if (m_vertAlign)
        {
            delete m_vertAlign;
            m_vertAlign = NULL;
        }
    ;
            
                m_has_scheme = true;
                if (!m_scheme)
                {
                    m_scheme = new CT_FontScheme();
                }
                return m_scheme;
            
            }
            const CT_FontScheme& scheme(){

            if (m_scheme)
            {
                return *m_scheme;
            }
            return CT_FontScheme::default_instance();
        
            }

        private:
            bool m_has_name ;
            CT_FontName* m_name ;
            bool m_has_charset ;
            CT_IntProperty* m_charset ;
            bool m_has_family ;
            CT_FontFamily* m_family ;
            bool m_has_b ;
            CT_BooleanProperty* m_b ;
            bool m_has_i ;
            CT_BooleanProperty* m_i ;
            bool m_has_strike ;
            CT_BooleanProperty* m_strike ;
            bool m_has_outline ;
            CT_BooleanProperty* m_outline ;
            bool m_has_shadow ;
            CT_BooleanProperty* m_shadow ;
            bool m_has_condense ;
            CT_BooleanProperty* m_condense ;
            bool m_has_extend ;
            CT_BooleanProperty* m_extend ;
            bool m_has_color ;
            CT_Color* m_color ;
            bool m_has_sz ;
            CT_FontSize* m_sz ;
            bool m_has_u ;
            CT_UnderlineProperty* m_u ;
            bool m_has_vertAlign ;
            CT_VerticalAlignFontProperty* m_vertAlign ;
            bool m_has_scheme ;
            CT_FontScheme* m_scheme ;

        }


    }

    class CT_FontFamily : public XSD::ComplexType{
    public:
        void clear(){

                m_has_val_attr = false;
                
        if (m_val_attr)
        {
            delete m_val_attr;
            m_val_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_val_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_FontFamily& default_instance(){

    if (!CT_FontFamily::default_instance_)
    {
        CT_FontFamily::default_instance_ = new CT_FontFamily();
    }
    return *CT_FontFamily::default_instance_;

        }
        bool has_val_attr(){

            return m_has_val_attr;
        
        }
        void set_val_attr(const ST_FontFamily& _val_attr ){

            m_has_val_attr = true;
            m_val_attr = new ST_FontFamily(_val_attr);
        
        }
        const ST_FontFamily& val_attr(){

            if (m_val_attr)
            {
                return *m_val_attr;
            }
            return ST_FontFamily::default_instance();
        
        }

    private:
        static CT_FontFamily* default_instance_ ;
        bool m_has_val_attr ;
        ST_FontFamily* m_val_attr ;

    }

    class CT_ExternalLink : public XSD::ComplexType{
    public:
        bool has_externalBook(){

            return m_has_externalBook;
        
        }
        CT_ExternalBook* mutable_externalBook(){

                
                m_has_ddeLink = false;
                
        if (m_ddeLink)
        {
            delete m_ddeLink;
            m_ddeLink = NULL;
        }
    ;
            
                m_has_oleLink = false;
                
        if (m_oleLink)
        {
            delete m_oleLink;
            m_oleLink = NULL;
        }
    ;
            
                m_has_externalBook = true;
                if (!m_externalBook)
                {
                    m_externalBook = new CT_ExternalBook();
                }
                return m_externalBook;
            
        }
        const CT_ExternalBook& externalBook(){

            if (m_externalBook)
            {
                return *m_externalBook;
            }
            return CT_ExternalBook::default_instance();
        
        }
        bool has_ddeLink(){

            return m_has_ddeLink;
        
        }
        CT_DdeLink* mutable_ddeLink(){

                
                m_has_externalBook = false;
                
        if (m_externalBook)
        {
            delete m_externalBook;
            m_externalBook = NULL;
        }
    ;
            
                m_has_oleLink = false;
                
        if (m_oleLink)
        {
            delete m_oleLink;
            m_oleLink = NULL;
        }
    ;
            
                m_has_ddeLink = true;
                if (!m_ddeLink)
                {
                    m_ddeLink = new CT_DdeLink();
                }
                return m_ddeLink;
            
        }
        const CT_DdeLink& ddeLink(){

            if (m_ddeLink)
            {
                return *m_ddeLink;
            }
            return CT_DdeLink::default_instance();
        
        }
        bool has_oleLink(){

            return m_has_oleLink;
        
        }
        CT_OleLink* mutable_oleLink(){

                
                m_has_externalBook = false;
                
        if (m_externalBook)
        {
            delete m_externalBook;
            m_externalBook = NULL;
        }
    ;
            
                m_has_ddeLink = false;
                
        if (m_ddeLink)
        {
            delete m_ddeLink;
            m_ddeLink = NULL;
        }
    ;
            
                m_has_oleLink = true;
                if (!m_oleLink)
                {
                    m_oleLink = new CT_OleLink();
                }
                return m_oleLink;
            
        }
        const CT_OleLink& oleLink(){

            if (m_oleLink)
            {
                return *m_oleLink;
            }
            return CT_OleLink::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_externalBook = false;
                
        if (m_externalBook)
        {
            delete m_externalBook;
            m_externalBook = NULL;
        }
    
            
                m_has_ddeLink = false;
                
        if (m_ddeLink)
        {
            delete m_ddeLink;
            m_ddeLink = NULL;
        }
    
            
                m_has_oleLink = false;
                
        if (m_oleLink)
        {
            delete m_oleLink;
            m_oleLink = NULL;
        }
    
             
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_externalBook)
                {
                    m_externalBook->toXml(externalBook, _outStream);;
                }
            
                if (m_has_ddeLink)
                {
                    m_externalBook->toXml(ddeLink, _outStream);;
                }
            
                if (m_has_oleLink)
                {
                    m_externalBook->toXml(oleLink, _outStream);;
                }
             
                if (m_has_extLst)
                {
                    m_extLst->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_ExternalLink& default_instance(){

    if (!CT_ExternalLink::default_instance_)
    {
        CT_ExternalLink::default_instance_ = new CT_ExternalLink();
    }
    return *CT_ExternalLink::default_instance_;

        }

    private:
        bool m_has_externalBook ;
        CT_ExternalBook* m_externalBook ;
        bool m_has_ddeLink ;
        CT_DdeLink* m_ddeLink ;
        bool m_has_oleLink ;
        CT_OleLink* m_oleLink ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_ExternalLink* default_instance_ ;

    }

    class CT_ExternalBook : public XSD::ComplexType{
    public:
        bool has_sheetNames(){

            return m_has_sheetNames;
        
        }
        CT_ExternalSheetNames* mutable_sheetNames(){

                m_has_sheetNames = true;
                if (!m_sheetNames)
                {
                    m_sheetNames = new CT_ExternalSheetNames();
                }
                return m_sheetNames;
            
        }
        const CT_ExternalSheetNames& sheetNames(){

            if (m_sheetNames)
            {
                return *m_sheetNames;
            }
            return CT_ExternalSheetNames::default_instance();
        
        }
        bool has_definedNames(){

            return m_has_definedNames;
        
        }
        CT_ExternalDefinedNames* mutable_definedNames(){

                m_has_definedNames = true;
                if (!m_definedNames)
                {
                    m_definedNames = new CT_ExternalDefinedNames();
                }
                return m_definedNames;
            
        }
        const CT_ExternalDefinedNames& definedNames(){

            if (m_definedNames)
            {
                return *m_definedNames;
            }
            return CT_ExternalDefinedNames::default_instance();
        
        }
        bool has_sheetDataSet(){

            return m_has_sheetDataSet;
        
        }
        CT_ExternalSheetDataSet* mutable_sheetDataSet(){

                m_has_sheetDataSet = true;
                if (!m_sheetDataSet)
                {
                    m_sheetDataSet = new CT_ExternalSheetDataSet();
                }
                return m_sheetDataSet;
            
        }
        const CT_ExternalSheetDataSet& sheetDataSet(){

            if (m_sheetDataSet)
            {
                return *m_sheetDataSet;
            }
            return CT_ExternalSheetDataSet::default_instance();
        
        }
        void clear(){

                m_has_id_attr = false;
                
        if (m_id_attr)
        {
            delete m_id_attr;
            m_id_attr = NULL;
        }
    
            
                m_has_sheetNames = false;
                
        if (m_sheetNames)
        {
            delete m_sheetNames;
            m_sheetNames = NULL;
        }
    
            
                m_has_definedNames = false;
                
        if (m_definedNames)
        {
            delete m_definedNames;
            m_definedNames = NULL;
        }
    
            
                m_has_sheetDataSet = false;
                
        if (m_sheetDataSet)
        {
            delete m_sheetDataSet;
            m_sheetDataSet = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_id_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_sheetNames)
                {
                    m_sheetNames->toXml(sheetNames, _outStream);;
                }
            
                if (m_has_definedNames)
                {
                    m_sheetNames->toXml(definedNames, _outStream);;
                }
            
                if (m_has_sheetDataSet)
                {
                    m_sheetNames->toXml(sheetDataSet, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_ExternalBook& default_instance(){

    if (!CT_ExternalBook::default_instance_)
    {
        CT_ExternalBook::default_instance_ = new CT_ExternalBook();
    }
    return *CT_ExternalBook::default_instance_;

        }
        bool has_id_attr(){

            return m_has_id_attr;
        
        }
        void set_id_attr(const ST_RelationshipId& _id_attr ){

            m_has_id_attr = true;
            m_id_attr = new ST_RelationshipId(_id_attr);
        
        }
        const ST_RelationshipId& id_attr(){

            if (m_id_attr)
            {
                return *m_id_attr;
            }
            return ST_RelationshipId::default_instance();
        
        }

    private:
        bool m_has_sheetNames ;
        CT_ExternalSheetNames* m_sheetNames ;
        bool m_has_definedNames ;
        CT_ExternalDefinedNames* m_definedNames ;
        bool m_has_sheetDataSet ;
        CT_ExternalSheetDataSet* m_sheetDataSet ;
        static CT_ExternalBook* default_instance_ ;
        bool m_has_id_attr ;
        ST_RelationshipId* m_id_attr ;

    }

    class CT_ExternalSheetNames : public XSD::ComplexType{
    public:
        bool has_sheetName(){

            return m_has_sheetName;
        
        }
        CT_ExternalSheetName* mutable_sheetName(){

                m_has_sheetName = true;
                if (!m_sheetName)
                {
                    m_sheetName = new CT_ExternalSheetName();
                }
                return m_sheetName;
            
        }
        const CT_ExternalSheetName& sheetName(){

            if (m_sheetName)
            {
                return *m_sheetName;
            }
            return CT_ExternalSheetName::default_instance();
        
        }
        void clear(){

                m_has_sheetName = false;
                
        if (m_sheetName)
        {
            delete m_sheetName;
            m_sheetName = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_sheetName)
                {
                    m_sheetName->toXml(sheetName, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_ExternalSheetNames& default_instance(){

    if (!CT_ExternalSheetNames::default_instance_)
    {
        CT_ExternalSheetNames::default_instance_ = new CT_ExternalSheetNames();
    }
    return *CT_ExternalSheetNames::default_instance_;

        }

    private:
        bool m_has_sheetName ;
        CT_ExternalSheetName* m_sheetName ;
        static CT_ExternalSheetNames* default_instance_ ;

    }

    class CT_ExternalSheetName : public XSD::ComplexType{
    public:
        void clear(){

                m_has_val_attr = false;
                
        if (m_val_attr)
        {
            delete m_val_attr;
            m_val_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_val_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_ExternalSheetName& default_instance(){

    if (!CT_ExternalSheetName::default_instance_)
    {
        CT_ExternalSheetName::default_instance_ = new CT_ExternalSheetName();
    }
    return *CT_ExternalSheetName::default_instance_;

        }
        bool has_val_attr(){

            return m_has_val_attr;
        
        }
        void set_val_attr(const ns_s::ST_Xstring& _val_attr ){

            m_has_val_attr = true;
            m_val_attr = new ns_s::ST_Xstring(_val_attr);
        
        }
        const ns_s::ST_Xstring& val_attr(){

            if (m_val_attr)
            {
                return *m_val_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }

    private:
        static CT_ExternalSheetName* default_instance_ ;
        bool m_has_val_attr ;
        ns_s::ST_Xstring* m_val_attr ;

    }

    class CT_ExternalDefinedNames : public XSD::ComplexType{
    public:
        bool has_definedName(){

            return m_has_definedName;
        
        }
        CT_ExternalDefinedName* mutable_definedName(){

                m_has_definedName = true;
                if (!m_definedName)
                {
                    m_definedName = new CT_ExternalDefinedName();
                }
                return m_definedName;
            
        }
        const CT_ExternalDefinedName& definedName(){

            if (m_definedName)
            {
                return *m_definedName;
            }
            return CT_ExternalDefinedName::default_instance();
        
        }
        void clear(){

                m_has_definedName = false;
                
        if (m_definedName)
        {
            delete m_definedName;
            m_definedName = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_definedName)
                {
                    m_definedName->toXml(definedName, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_ExternalDefinedNames& default_instance(){

    if (!CT_ExternalDefinedNames::default_instance_)
    {
        CT_ExternalDefinedNames::default_instance_ = new CT_ExternalDefinedNames();
    }
    return *CT_ExternalDefinedNames::default_instance_;

        }

    private:
        bool m_has_definedName ;
        CT_ExternalDefinedName* m_definedName ;
        static CT_ExternalDefinedNames* default_instance_ ;

    }

    class CT_ExternalDefinedName : public XSD::ComplexType{
    public:
        void clear(){

                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
                m_has_refersTo_attr = false;
                
        if (m_refersTo_attr)
        {
            delete m_refersTo_attr;
            m_refersTo_attr = NULL;
        }
    
            
                m_has_sheetId_attr = false;
                m_sheetId_attr = 0;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_name_attr->toXml(_attrName, _outStream);
m_refersTo_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_sheetId_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_ExternalDefinedName& default_instance(){

    if (!CT_ExternalDefinedName::default_instance_)
    {
        CT_ExternalDefinedName::default_instance_ = new CT_ExternalDefinedName();
    }
    return *CT_ExternalDefinedName::default_instance_;

        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_refersTo_attr(){

            return m_has_refersTo_attr;
        
        }
        void set_refersTo_attr(const ns_s::ST_Xstring& _refersTo_attr ){

            m_has_refersTo_attr = true;
            m_refersTo_attr = new ns_s::ST_Xstring(_refersTo_attr);
        
        }
        const ns_s::ST_Xstring& refersTo_attr(){

            if (m_refersTo_attr)
            {
                return *m_refersTo_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_sheetId_attr(){

            return m_has_sheetId_attr;
        
        }
        void set_sheetId_attr(const unsignedInt& _sheetId_attr ){

        m_has_sheetId_attr = true;
        m_sheetId_attr = _sheetId_attr;
        
        }
        const unsignedInt& sheetId_attr(){

            return type: \unsignedInt\nname: \m_sheetId_attr\n;
        
        }

    private:
        static CT_ExternalDefinedName* default_instance_ ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;
        bool m_has_refersTo_attr ;
        ns_s::ST_Xstring* m_refersTo_attr ;
        bool m_has_sheetId_attr ;
        unsignedInt m_sheetId_attr ;

    }

    class CT_ExternalSheetDataSet : public XSD::ComplexType{
    public:
        bool has_sheetData(){

            return m_has_sheetData;
        
        }
        CT_ExternalSheetData* mutable_sheetData(){

                m_has_sheetData = true;
                if (!m_sheetData)
                {
                    m_sheetData = new CT_ExternalSheetData();
                }
                return m_sheetData;
            
        }
        const CT_ExternalSheetData& sheetData(){

            if (m_sheetData)
            {
                return *m_sheetData;
            }
            return CT_ExternalSheetData::default_instance();
        
        }
        void clear(){

                m_has_sheetData = false;
                
        if (m_sheetData)
        {
            delete m_sheetData;
            m_sheetData = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_sheetData)
                {
                    m_sheetData->toXml(sheetData, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_ExternalSheetDataSet& default_instance(){

    if (!CT_ExternalSheetDataSet::default_instance_)
    {
        CT_ExternalSheetDataSet::default_instance_ = new CT_ExternalSheetDataSet();
    }
    return *CT_ExternalSheetDataSet::default_instance_;

        }

    private:
        bool m_has_sheetData ;
        CT_ExternalSheetData* m_sheetData ;
        static CT_ExternalSheetDataSet* default_instance_ ;

    }

    class CT_ExternalSheetData : public XSD::ComplexType{
    public:
        bool has_row(){

            return m_has_row;
        
        }
        CT_ExternalRow* mutable_row(){

                m_has_row = true;
                if (!m_row)
                {
                    m_row = new CT_ExternalRow();
                }
                return m_row;
            
        }
        const CT_ExternalRow& row(){

            if (m_row)
            {
                return *m_row;
            }
            return CT_ExternalRow::default_instance();
        
        }
        void clear(){

                m_has_sheetId_attr = false;
                m_sheetId_attr = 0;
            
                m_has_refreshError_attr = false;
                m_refreshError_attr = false;
            
                m_has_row = false;
                
        if (m_row)
        {
            delete m_row;
            m_row = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_sheetId_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_refreshError_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_row)
                {
                    m_row->toXml(row, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_ExternalSheetData& default_instance(){

    if (!CT_ExternalSheetData::default_instance_)
    {
        CT_ExternalSheetData::default_instance_ = new CT_ExternalSheetData();
    }
    return *CT_ExternalSheetData::default_instance_;

        }
        bool has_sheetId_attr(){

            return m_has_sheetId_attr;
        
        }
        void set_sheetId_attr(const unsignedInt& _sheetId_attr ){

        m_has_sheetId_attr = true;
        m_sheetId_attr = _sheetId_attr;
        
        }
        const unsignedInt& sheetId_attr(){

            return type: \unsignedInt\nname: \m_sheetId_attr\n;
        
        }
        bool has_refreshError_attr(){

            return m_has_refreshError_attr;
        
        }
        void set_refreshError_attr(const boolean& _refreshError_attr ){

        m_has_refreshError_attr = true;
        m_refreshError_attr = _refreshError_attr;
        
        }
        const boolean& refreshError_attr(){

            return type: oolean\nname: \m_refreshError_attr\n;
        
        }

    private:
        bool m_has_row ;
        CT_ExternalRow* m_row ;
        static CT_ExternalSheetData* default_instance_ ;
        bool m_has_sheetId_attr ;
        unsignedInt m_sheetId_attr ;
        bool m_has_refreshError_attr ;
        boolean m_refreshError_attr ;

    }

    class CT_ExternalRow : public XSD::ComplexType{
    public:
        bool has_cell(){

            return m_has_cell;
        
        }
        CT_ExternalCell* mutable_cell(){

                m_has_cell = true;
                if (!m_cell)
                {
                    m_cell = new CT_ExternalCell();
                }
                return m_cell;
            
        }
        const CT_ExternalCell& cell(){

            if (m_cell)
            {
                return *m_cell;
            }
            return CT_ExternalCell::default_instance();
        
        }
        void clear(){

                m_has_r_attr = false;
                m_r_attr = 0;
            
                m_has_cell = false;
                
        if (m_cell)
        {
            delete m_cell;
            m_cell = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_r_attr << \\\;
        _outStream << \>\;
    
                if (m_has_cell)
                {
                    m_cell->toXml(cell, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_ExternalRow& default_instance(){

    if (!CT_ExternalRow::default_instance_)
    {
        CT_ExternalRow::default_instance_ = new CT_ExternalRow();
    }
    return *CT_ExternalRow::default_instance_;

        }
        bool has_r_attr(){

            return m_has_r_attr;
        
        }
        void set_r_attr(const unsignedInt& _r_attr ){

        m_has_r_attr = true;
        m_r_attr = _r_attr;
        
        }
        const unsignedInt& r_attr(){

            return type: \unsignedInt\nname: \m_r_attr\n;
        
        }

    private:
        bool m_has_cell ;
        CT_ExternalCell* m_cell ;
        static CT_ExternalRow* default_instance_ ;
        bool m_has_r_attr ;
        unsignedInt m_r_attr ;

    }

    class CT_ExternalCell : public XSD::ComplexType{
    public:
        bool has_v(){

            return m_has_v;
        
        }
        ns_s::ST_Xstring* mutable_v(){

                m_has_v = true;
                if (!m_v)
                {
                    m_v = new ns_s::ST_Xstring();
                }
                return m_v;
            
        }
        const ns_s::ST_Xstring& v(){

            if (m_v)
            {
                return *m_v;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        void clear(){

                m_has_r_attr = false;
                
        if (m_r_attr)
        {
            delete m_r_attr;
            m_r_attr = NULL;
        }
    
            
                m_has_t_attr = false;
                
        if (m_t_attr)
        {
            delete m_t_attr;
            m_t_attr = NULL;
        }
    
            
                m_has_vm_attr = false;
                m_vm_attr = 0;
            
                m_has_v = false;
                
        if (m_v)
        {
            delete m_v;
            m_v = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_r_attr->toXml(_attrName, _outStream);
m_t_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_vm_attr << \\\;
        _outStream << \>\;
    
                if (m_has_v)
                {
                    _outStream << \<v>\ << m_v->toString() << \</v>\;;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_ExternalCell& default_instance(){

    if (!CT_ExternalCell::default_instance_)
    {
        CT_ExternalCell::default_instance_ = new CT_ExternalCell();
    }
    return *CT_ExternalCell::default_instance_;

        }
        bool has_r_attr(){

            return m_has_r_attr;
        
        }
        void set_r_attr(const ST_CellRef& _r_attr ){

            m_has_r_attr = true;
            m_r_attr = new ST_CellRef(_r_attr);
        
        }
        const ST_CellRef& r_attr(){

            if (m_r_attr)
            {
                return *m_r_attr;
            }
            return ST_CellRef::default_instance();
        
        }
        bool has_t_attr(){

            return m_has_t_attr;
        
        }
        void set_t_attr(const ST_CellType& _t_attr ){

            m_has_t_attr = true;
            m_t_attr = new ST_CellType(_t_attr);
        
        }
        const ST_CellType& t_attr(){

            if (m_t_attr)
            {
                return *m_t_attr;
            }
            return ST_CellType::default_instance();
        
        }
        bool has_vm_attr(){

            return m_has_vm_attr;
        
        }
        void set_vm_attr(const unsignedInt& _vm_attr ){

        m_has_vm_attr = true;
        m_vm_attr = _vm_attr;
        
        }
        const unsignedInt& vm_attr(){

            return type: \unsignedInt\nname: \m_vm_attr\n;
        
        }

    private:
        bool m_has_v ;
        ns_s::ST_Xstring* m_v ;
        static CT_ExternalCell* default_instance_ ;
        bool m_has_r_attr ;
        ST_CellRef* m_r_attr ;
        bool m_has_t_attr ;
        ST_CellType* m_t_attr ;
        bool m_has_vm_attr ;
        unsignedInt m_vm_attr ;

    }

    class CT_DdeLink : public XSD::ComplexType{
    public:
        bool has_ddeItems(){

            return m_has_ddeItems;
        
        }
        CT_DdeItems* mutable_ddeItems(){

                m_has_ddeItems = true;
                if (!m_ddeItems)
                {
                    m_ddeItems = new CT_DdeItems();
                }
                return m_ddeItems;
            
        }
        const CT_DdeItems& ddeItems(){

            if (m_ddeItems)
            {
                return *m_ddeItems;
            }
            return CT_DdeItems::default_instance();
        
        }
        void clear(){

                m_has_ddeService_attr = false;
                
        if (m_ddeService_attr)
        {
            delete m_ddeService_attr;
            m_ddeService_attr = NULL;
        }
    
            
                m_has_ddeTopic_attr = false;
                
        if (m_ddeTopic_attr)
        {
            delete m_ddeTopic_attr;
            m_ddeTopic_attr = NULL;
        }
    
            
                m_has_ddeItems = false;
                
        if (m_ddeItems)
        {
            delete m_ddeItems;
            m_ddeItems = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_ddeService_attr->toXml(_attrName, _outStream);
m_ddeTopic_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_ddeItems)
                {
                    m_ddeItems->toXml(ddeItems, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_DdeLink& default_instance(){

    if (!CT_DdeLink::default_instance_)
    {
        CT_DdeLink::default_instance_ = new CT_DdeLink();
    }
    return *CT_DdeLink::default_instance_;

        }
        bool has_ddeService_attr(){

            return m_has_ddeService_attr;
        
        }
        void set_ddeService_attr(const ns_s::ST_Xstring& _ddeService_attr ){

            m_has_ddeService_attr = true;
            m_ddeService_attr = new ns_s::ST_Xstring(_ddeService_attr);
        
        }
        const ns_s::ST_Xstring& ddeService_attr(){

            if (m_ddeService_attr)
            {
                return *m_ddeService_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_ddeTopic_attr(){

            return m_has_ddeTopic_attr;
        
        }
        void set_ddeTopic_attr(const ns_s::ST_Xstring& _ddeTopic_attr ){

            m_has_ddeTopic_attr = true;
            m_ddeTopic_attr = new ns_s::ST_Xstring(_ddeTopic_attr);
        
        }
        const ns_s::ST_Xstring& ddeTopic_attr(){

            if (m_ddeTopic_attr)
            {
                return *m_ddeTopic_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }

    private:
        bool m_has_ddeItems ;
        CT_DdeItems* m_ddeItems ;
        static CT_DdeLink* default_instance_ ;
        bool m_has_ddeService_attr ;
        ns_s::ST_Xstring* m_ddeService_attr ;
        bool m_has_ddeTopic_attr ;
        ns_s::ST_Xstring* m_ddeTopic_attr ;

    }

    class CT_DdeItems : public XSD::ComplexType{
    public:
        bool has_ddeItem(){

            return m_has_ddeItem;
        
        }
        CT_DdeItem* mutable_ddeItem(){

                m_has_ddeItem = true;
                if (!m_ddeItem)
                {
                    m_ddeItem = new CT_DdeItem();
                }
                return m_ddeItem;
            
        }
        const CT_DdeItem& ddeItem(){

            if (m_ddeItem)
            {
                return *m_ddeItem;
            }
            return CT_DdeItem::default_instance();
        
        }
        void clear(){

                m_has_ddeItem = false;
                
        if (m_ddeItem)
        {
            delete m_ddeItem;
            m_ddeItem = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_ddeItem)
                {
                    m_ddeItem->toXml(ddeItem, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_DdeItems& default_instance(){

    if (!CT_DdeItems::default_instance_)
    {
        CT_DdeItems::default_instance_ = new CT_DdeItems();
    }
    return *CT_DdeItems::default_instance_;

        }

    private:
        bool m_has_ddeItem ;
        CT_DdeItem* m_ddeItem ;
        static CT_DdeItems* default_instance_ ;

    }

    class CT_DdeItem : public XSD::ComplexType{
    public:
        bool has_values(){

            return m_has_values;
        
        }
        CT_DdeValues* mutable_values(){

                m_has_values = true;
                if (!m_values)
                {
                    m_values = new CT_DdeValues();
                }
                return m_values;
            
        }
        const CT_DdeValues& values(){

            if (m_values)
            {
                return *m_values;
            }
            return CT_DdeValues::default_instance();
        
        }
        void clear(){

                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
                m_has_ole_attr = false;
                m_ole_attr = false;
            
                m_has_advise_attr = false;
                m_advise_attr = false;
            
                m_has_preferPic_attr = false;
                m_preferPic_attr = false;
            
                m_has_values = false;
                
        if (m_values)
        {
            delete m_values;
            m_values = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_name_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_ole_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_advise_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_preferPic_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_values)
                {
                    m_values->toXml(values, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_DdeItem& default_instance(){

    if (!CT_DdeItem::default_instance_)
    {
        CT_DdeItem::default_instance_ = new CT_DdeItem();
    }
    return *CT_DdeItem::default_instance_;

        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_ole_attr(){

            return m_has_ole_attr;
        
        }
        void set_ole_attr(const boolean& _ole_attr ){

        m_has_ole_attr = true;
        m_ole_attr = _ole_attr;
        
        }
        const boolean& ole_attr(){

            return type: oolean\nname: \m_ole_attr\n;
        
        }
        bool has_advise_attr(){

            return m_has_advise_attr;
        
        }
        void set_advise_attr(const boolean& _advise_attr ){

        m_has_advise_attr = true;
        m_advise_attr = _advise_attr;
        
        }
        const boolean& advise_attr(){

            return type: oolean\nname: \m_advise_attr\n;
        
        }
        bool has_preferPic_attr(){

            return m_has_preferPic_attr;
        
        }
        void set_preferPic_attr(const boolean& _preferPic_attr ){

        m_has_preferPic_attr = true;
        m_preferPic_attr = _preferPic_attr;
        
        }
        const boolean& preferPic_attr(){

            return type: oolean\nname: \m_preferPic_attr\n;
        
        }

    private:
        bool m_has_values ;
        CT_DdeValues* m_values ;
        static CT_DdeItem* default_instance_ ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;
        bool m_has_ole_attr ;
        boolean m_ole_attr ;
        bool m_has_advise_attr ;
        boolean m_advise_attr ;
        bool m_has_preferPic_attr ;
        boolean m_preferPic_attr ;

    }

    class CT_DdeValues : public XSD::ComplexType{
    public:
        bool has_value(){

            return m_has_value;
        
        }
        CT_DdeValue* mutable_value(){

                m_has_value = true;
                if (!m_value)
                {
                    m_value = new CT_DdeValue();
                }
                return m_value;
            
        }
        const CT_DdeValue& value(){

            if (m_value)
            {
                return *m_value;
            }
            return CT_DdeValue::default_instance();
        
        }
        void clear(){

                m_has_rows_attr = false;
                m_rows_attr = 0;
            
                m_has_cols_attr = false;
                m_cols_attr = 0;
            
                m_has_value = false;
                
        if (m_value)
        {
            delete m_value;
            m_value = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_rows_attr << \\\;
_outStream << _attrName << \=\\ << m_cols_attr << \\\;
        _outStream << \>\;
    
                if (m_has_value)
                {
                    m_value->toXml(value, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_DdeValues& default_instance(){

    if (!CT_DdeValues::default_instance_)
    {
        CT_DdeValues::default_instance_ = new CT_DdeValues();
    }
    return *CT_DdeValues::default_instance_;

        }
        bool has_rows_attr(){

            return m_has_rows_attr;
        
        }
        void set_rows_attr(const unsignedInt& _rows_attr ){

        m_has_rows_attr = true;
        m_rows_attr = _rows_attr;
        
        }
        const unsignedInt& rows_attr(){

            return type: \unsignedInt\nname: \m_rows_attr\n;
        
        }
        bool has_cols_attr(){

            return m_has_cols_attr;
        
        }
        void set_cols_attr(const unsignedInt& _cols_attr ){

        m_has_cols_attr = true;
        m_cols_attr = _cols_attr;
        
        }
        const unsignedInt& cols_attr(){

            return type: \unsignedInt\nname: \m_cols_attr\n;
        
        }

    private:
        bool m_has_value ;
        CT_DdeValue* m_value ;
        static CT_DdeValues* default_instance_ ;
        bool m_has_rows_attr ;
        unsignedInt m_rows_attr ;
        bool m_has_cols_attr ;
        unsignedInt m_cols_attr ;

    }

    class CT_DdeValue : public XSD::ComplexType{
    public:
        bool has_val(){

            return m_has_val;
        
        }
        ns_s::ST_Xstring* mutable_val(){

                m_has_val = true;
                if (!m_val)
                {
                    m_val = new ns_s::ST_Xstring();
                }
                return m_val;
            
        }
        const ns_s::ST_Xstring& val(){

            if (m_val)
            {
                return *m_val;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        void clear(){

                m_has_t_attr = false;
                
        if (m_t_attr)
        {
            delete m_t_attr;
            m_t_attr = NULL;
        }
    
            
                m_has_val = false;
                
        if (m_val)
        {
            delete m_val;
            m_val = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_t_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_val)
                {
                    _outStream << \<val>\ << m_val->toString() << \</val>\;;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_DdeValue& default_instance(){

    if (!CT_DdeValue::default_instance_)
    {
        CT_DdeValue::default_instance_ = new CT_DdeValue();
    }
    return *CT_DdeValue::default_instance_;

        }
        bool has_t_attr(){

            return m_has_t_attr;
        
        }
        void set_t_attr(const ST_DdeValueType& _t_attr ){

            m_has_t_attr = true;
            m_t_attr = new ST_DdeValueType(_t_attr);
        
        }
        const ST_DdeValueType& t_attr(){

            if (m_t_attr)
            {
                return *m_t_attr;
            }
            return ST_DdeValueType::default_instance();
        
        }

    private:
        bool m_has_val ;
        ns_s::ST_Xstring* m_val ;
        static CT_DdeValue* default_instance_ ;
        bool m_has_t_attr ;
        ST_DdeValueType* m_t_attr ;

    }

    class CT_OleLink : public XSD::ComplexType{
    public:
        bool has_oleItems(){

            return m_has_oleItems;
        
        }
        CT_OleItems* mutable_oleItems(){

                m_has_oleItems = true;
                if (!m_oleItems)
                {
                    m_oleItems = new CT_OleItems();
                }
                return m_oleItems;
            
        }
        const CT_OleItems& oleItems(){

            if (m_oleItems)
            {
                return *m_oleItems;
            }
            return CT_OleItems::default_instance();
        
        }
        void clear(){

                m_has_id_attr = false;
                
        if (m_id_attr)
        {
            delete m_id_attr;
            m_id_attr = NULL;
        }
    
            
                m_has_progId_attr = false;
                
        if (m_progId_attr)
        {
            delete m_progId_attr;
            m_progId_attr = NULL;
        }
    
            
                m_has_oleItems = false;
                
        if (m_oleItems)
        {
            delete m_oleItems;
            m_oleItems = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_id_attr->toXml(_attrName, _outStream);
m_progId_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_oleItems)
                {
                    m_oleItems->toXml(oleItems, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_OleLink& default_instance(){

    if (!CT_OleLink::default_instance_)
    {
        CT_OleLink::default_instance_ = new CT_OleLink();
    }
    return *CT_OleLink::default_instance_;

        }
        bool has_id_attr(){

            return m_has_id_attr;
        
        }
        void set_id_attr(const ST_RelationshipId& _id_attr ){

            m_has_id_attr = true;
            m_id_attr = new ST_RelationshipId(_id_attr);
        
        }
        const ST_RelationshipId& id_attr(){

            if (m_id_attr)
            {
                return *m_id_attr;
            }
            return ST_RelationshipId::default_instance();
        
        }
        bool has_progId_attr(){

            return m_has_progId_attr;
        
        }
        void set_progId_attr(const ns_s::ST_Xstring& _progId_attr ){

            m_has_progId_attr = true;
            m_progId_attr = new ns_s::ST_Xstring(_progId_attr);
        
        }
        const ns_s::ST_Xstring& progId_attr(){

            if (m_progId_attr)
            {
                return *m_progId_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }

    private:
        bool m_has_oleItems ;
        CT_OleItems* m_oleItems ;
        static CT_OleLink* default_instance_ ;
        bool m_has_id_attr ;
        ST_RelationshipId* m_id_attr ;
        bool m_has_progId_attr ;
        ns_s::ST_Xstring* m_progId_attr ;

    }

    class CT_OleItems : public XSD::ComplexType{
    public:
        bool has_oleItem(){

            return m_has_oleItem;
        
        }
        CT_OleItem* mutable_oleItem(){

                m_has_oleItem = true;
                if (!m_oleItem)
                {
                    m_oleItem = new CT_OleItem();
                }
                return m_oleItem;
            
        }
        const CT_OleItem& oleItem(){

            if (m_oleItem)
            {
                return *m_oleItem;
            }
            return CT_OleItem::default_instance();
        
        }
        void clear(){

                m_has_oleItem = false;
                
        if (m_oleItem)
        {
            delete m_oleItem;
            m_oleItem = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_oleItem)
                {
                    m_oleItem->toXml(oleItem, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_OleItems& default_instance(){

    if (!CT_OleItems::default_instance_)
    {
        CT_OleItems::default_instance_ = new CT_OleItems();
    }
    return *CT_OleItems::default_instance_;

        }

    private:
        bool m_has_oleItem ;
        CT_OleItem* m_oleItem ;
        static CT_OleItems* default_instance_ ;

    }

    class CT_OleItem : public XSD::ComplexType{
    public:
        void clear(){

                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
                m_has_icon_attr = false;
                m_icon_attr = false;
            
                m_has_advise_attr = false;
                m_advise_attr = false;
            
                m_has_preferPic_attr = false;
                m_preferPic_attr = false;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_name_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_icon_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_advise_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_preferPic_attr) << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_OleItem& default_instance(){

    if (!CT_OleItem::default_instance_)
    {
        CT_OleItem::default_instance_ = new CT_OleItem();
    }
    return *CT_OleItem::default_instance_;

        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_icon_attr(){

            return m_has_icon_attr;
        
        }
        void set_icon_attr(const boolean& _icon_attr ){

        m_has_icon_attr = true;
        m_icon_attr = _icon_attr;
        
        }
        const boolean& icon_attr(){

            return type: oolean\nname: \m_icon_attr\n;
        
        }
        bool has_advise_attr(){

            return m_has_advise_attr;
        
        }
        void set_advise_attr(const boolean& _advise_attr ){

        m_has_advise_attr = true;
        m_advise_attr = _advise_attr;
        
        }
        const boolean& advise_attr(){

            return type: oolean\nname: \m_advise_attr\n;
        
        }
        bool has_preferPic_attr(){

            return m_has_preferPic_attr;
        
        }
        void set_preferPic_attr(const boolean& _preferPic_attr ){

        m_has_preferPic_attr = true;
        m_preferPic_attr = _preferPic_attr;
        
        }
        const boolean& preferPic_attr(){

            return type: oolean\nname: \m_preferPic_attr\n;
        
        }

    private:
        static CT_OleItem* default_instance_ ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;
        bool m_has_icon_attr ;
        boolean m_icon_attr ;
        bool m_has_advise_attr ;
        boolean m_advise_attr ;
        bool m_has_preferPic_attr ;
        boolean m_preferPic_attr ;

    }

    class CT_Table : public XSD::ComplexType{
    public:
        bool has_autoFilter(){

            return m_has_autoFilter;
        
        }
        CT_AutoFilter* mutable_autoFilter(){

                m_has_autoFilter = true;
                if (!m_autoFilter)
                {
                    m_autoFilter = new CT_AutoFilter();
                }
                return m_autoFilter;
            
        }
        const CT_AutoFilter& autoFilter(){

            if (m_autoFilter)
            {
                return *m_autoFilter;
            }
            return CT_AutoFilter::default_instance();
        
        }
        bool has_sortState(){

            return m_has_sortState;
        
        }
        CT_SortState* mutable_sortState(){

                m_has_sortState = true;
                if (!m_sortState)
                {
                    m_sortState = new CT_SortState();
                }
                return m_sortState;
            
        }
        const CT_SortState& sortState(){

            if (m_sortState)
            {
                return *m_sortState;
            }
            return CT_SortState::default_instance();
        
        }
        bool has_tableColumns(){

            return m_has_tableColumns;
        
        }
        CT_TableColumns* mutable_tableColumns(){

                m_has_tableColumns = true;
                if (!m_tableColumns)
                {
                    m_tableColumns = new CT_TableColumns();
                }
                return m_tableColumns;
            
        }
        const CT_TableColumns& tableColumns(){

            if (m_tableColumns)
            {
                return *m_tableColumns;
            }
            return CT_TableColumns::default_instance();
        
        }
        bool has_tableStyleInfo(){

            return m_has_tableStyleInfo;
        
        }
        CT_TableStyleInfo* mutable_tableStyleInfo(){

                m_has_tableStyleInfo = true;
                if (!m_tableStyleInfo)
                {
                    m_tableStyleInfo = new CT_TableStyleInfo();
                }
                return m_tableStyleInfo;
            
        }
        const CT_TableStyleInfo& tableStyleInfo(){

            if (m_tableStyleInfo)
            {
                return *m_tableStyleInfo;
            }
            return CT_TableStyleInfo::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_id_attr = false;
                m_id_attr = 0;
            
                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
                m_has_displayName_attr = false;
                
        if (m_displayName_attr)
        {
            delete m_displayName_attr;
            m_displayName_attr = NULL;
        }
    
            
                m_has_comment_attr = false;
                
        if (m_comment_attr)
        {
            delete m_comment_attr;
            m_comment_attr = NULL;
        }
    
            
                m_has_ref_attr = false;
                
        if (m_ref_attr)
        {
            delete m_ref_attr;
            m_ref_attr = NULL;
        }
    
            
                m_has_tableType_attr = false;
                
        if (m_tableType_attr)
        {
            delete m_tableType_attr;
            m_tableType_attr = NULL;
        }
    
            
                m_has_headerRowCount_attr = false;
                m_headerRowCount_attr = 0;
            
                m_has_insertRow_attr = false;
                m_insertRow_attr = false;
            
                m_has_insertRowShift_attr = false;
                m_insertRowShift_attr = false;
            
                m_has_totalsRowCount_attr = false;
                m_totalsRowCount_attr = 0;
            
                m_has_totalsRowShown_attr = false;
                m_totalsRowShown_attr = false;
            
                m_has_published_attr = false;
                m_published_attr = false;
            
                m_has_headerRowDxfId_attr = false;
                
        if (m_headerRowDxfId_attr)
        {
            delete m_headerRowDxfId_attr;
            m_headerRowDxfId_attr = NULL;
        }
    
            
                m_has_dataDxfId_attr = false;
                
        if (m_dataDxfId_attr)
        {
            delete m_dataDxfId_attr;
            m_dataDxfId_attr = NULL;
        }
    
            
                m_has_totalsRowDxfId_attr = false;
                
        if (m_totalsRowDxfId_attr)
        {
            delete m_totalsRowDxfId_attr;
            m_totalsRowDxfId_attr = NULL;
        }
    
            
                m_has_headerRowBorderDxfId_attr = false;
                
        if (m_headerRowBorderDxfId_attr)
        {
            delete m_headerRowBorderDxfId_attr;
            m_headerRowBorderDxfId_attr = NULL;
        }
    
            
                m_has_tableBorderDxfId_attr = false;
                
        if (m_tableBorderDxfId_attr)
        {
            delete m_tableBorderDxfId_attr;
            m_tableBorderDxfId_attr = NULL;
        }
    
            
                m_has_totalsRowBorderDxfId_attr = false;
                
        if (m_totalsRowBorderDxfId_attr)
        {
            delete m_totalsRowBorderDxfId_attr;
            m_totalsRowBorderDxfId_attr = NULL;
        }
    
            
                m_has_headerRowCellStyle_attr = false;
                
        if (m_headerRowCellStyle_attr)
        {
            delete m_headerRowCellStyle_attr;
            m_headerRowCellStyle_attr = NULL;
        }
    
            
                m_has_dataCellStyle_attr = false;
                
        if (m_dataCellStyle_attr)
        {
            delete m_dataCellStyle_attr;
            m_dataCellStyle_attr = NULL;
        }
    
            
                m_has_totalsRowCellStyle_attr = false;
                
        if (m_totalsRowCellStyle_attr)
        {
            delete m_totalsRowCellStyle_attr;
            m_totalsRowCellStyle_attr = NULL;
        }
    
            
                m_has_connectionId_attr = false;
                m_connectionId_attr = 0;
            
                m_has_autoFilter = false;
                
        if (m_autoFilter)
        {
            delete m_autoFilter;
            m_autoFilter = NULL;
        }
    
            
                m_has_sortState = false;
                
        if (m_sortState)
        {
            delete m_sortState;
            m_sortState = NULL;
        }
    
            
                m_has_tableColumns = false;
                
        if (m_tableColumns)
        {
            delete m_tableColumns;
            m_tableColumns = NULL;
        }
    
            
                m_has_tableStyleInfo = false;
                
        if (m_tableStyleInfo)
        {
            delete m_tableStyleInfo;
            m_tableStyleInfo = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_id_attr << \\\;
m_name_attr->toXml(_attrName, _outStream);
m_displayName_attr->toXml(_attrName, _outStream);
m_comment_attr->toXml(_attrName, _outStream);
m_ref_attr->toXml(_attrName, _outStream);
m_tableType_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_headerRowCount_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_insertRow_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_insertRowShift_attr) << \\\;
_outStream << _attrName << \=\\ << m_totalsRowCount_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_totalsRowShown_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_published_attr) << \\\;
m_headerRowDxfId_attr->toXml(_attrName, _outStream);
m_dataDxfId_attr->toXml(_attrName, _outStream);
m_totalsRowDxfId_attr->toXml(_attrName, _outStream);
m_headerRowBorderDxfId_attr->toXml(_attrName, _outStream);
m_tableBorderDxfId_attr->toXml(_attrName, _outStream);
m_totalsRowBorderDxfId_attr->toXml(_attrName, _outStream);
m_headerRowCellStyle_attr->toXml(_attrName, _outStream);
m_dataCellStyle_attr->toXml(_attrName, _outStream);
m_totalsRowCellStyle_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_connectionId_attr << \\\;
        _outStream << \>\;
    
                if (m_has_autoFilter)
                {
                    m_autoFilter->toXml(autoFilter, _outStream);;
                }
            
                if (m_has_sortState)
                {
                    m_autoFilter->toXml(sortState, _outStream);;
                }
            
                if (m_has_tableColumns)
                {
                    m_autoFilter->toXml(tableColumns, _outStream);;
                }
            
                if (m_has_tableStyleInfo)
                {
                    m_autoFilter->toXml(tableStyleInfo, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_autoFilter->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Table& default_instance(){

    if (!CT_Table::default_instance_)
    {
        CT_Table::default_instance_ = new CT_Table();
    }
    return *CT_Table::default_instance_;

        }
        bool has_id_attr(){

            return m_has_id_attr;
        
        }
        void set_id_attr(const unsignedInt& _id_attr ){

        m_has_id_attr = true;
        m_id_attr = _id_attr;
        
        }
        const unsignedInt& id_attr(){

            return type: \unsignedInt\nname: \m_id_attr\n;
        
        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_displayName_attr(){

            return m_has_displayName_attr;
        
        }
        void set_displayName_attr(const ns_s::ST_Xstring& _displayName_attr ){

            m_has_displayName_attr = true;
            m_displayName_attr = new ns_s::ST_Xstring(_displayName_attr);
        
        }
        const ns_s::ST_Xstring& displayName_attr(){

            if (m_displayName_attr)
            {
                return *m_displayName_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_comment_attr(){

            return m_has_comment_attr;
        
        }
        void set_comment_attr(const ns_s::ST_Xstring& _comment_attr ){

            m_has_comment_attr = true;
            m_comment_attr = new ns_s::ST_Xstring(_comment_attr);
        
        }
        const ns_s::ST_Xstring& comment_attr(){

            if (m_comment_attr)
            {
                return *m_comment_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_ref_attr(){

            return m_has_ref_attr;
        
        }
        void set_ref_attr(const ST_Ref& _ref_attr ){

            m_has_ref_attr = true;
            m_ref_attr = new ST_Ref(_ref_attr);
        
        }
        const ST_Ref& ref_attr(){

            if (m_ref_attr)
            {
                return *m_ref_attr;
            }
            return ST_Ref::default_instance();
        
        }
        bool has_tableType_attr(){

            return m_has_tableType_attr;
        
        }
        void set_tableType_attr(const ST_TableType& _tableType_attr ){

            m_has_tableType_attr = true;
            m_tableType_attr = new ST_TableType(_tableType_attr);
        
        }
        const ST_TableType& tableType_attr(){

            if (m_tableType_attr)
            {
                return *m_tableType_attr;
            }
            return ST_TableType::default_instance();
        
        }
        bool has_headerRowCount_attr(){

            return m_has_headerRowCount_attr;
        
        }
        void set_headerRowCount_attr(const unsignedInt& _headerRowCount_attr ){

        m_has_headerRowCount_attr = true;
        m_headerRowCount_attr = _headerRowCount_attr;
        
        }
        const unsignedInt& headerRowCount_attr(){

            return type: \unsignedInt\nname: \m_headerRowCount_attr\n;
        
        }
        bool has_insertRow_attr(){

            return m_has_insertRow_attr;
        
        }
        void set_insertRow_attr(const boolean& _insertRow_attr ){

        m_has_insertRow_attr = true;
        m_insertRow_attr = _insertRow_attr;
        
        }
        const boolean& insertRow_attr(){

            return type: oolean\nname: \m_insertRow_attr\n;
        
        }
        bool has_insertRowShift_attr(){

            return m_has_insertRowShift_attr;
        
        }
        void set_insertRowShift_attr(const boolean& _insertRowShift_attr ){

        m_has_insertRowShift_attr = true;
        m_insertRowShift_attr = _insertRowShift_attr;
        
        }
        const boolean& insertRowShift_attr(){

            return type: oolean\nname: \m_insertRowShift_attr\n;
        
        }
        bool has_totalsRowCount_attr(){

            return m_has_totalsRowCount_attr;
        
        }
        void set_totalsRowCount_attr(const unsignedInt& _totalsRowCount_attr ){

        m_has_totalsRowCount_attr = true;
        m_totalsRowCount_attr = _totalsRowCount_attr;
        
        }
        const unsignedInt& totalsRowCount_attr(){

            return type: \unsignedInt\nname: \m_totalsRowCount_attr\n;
        
        }
        bool has_totalsRowShown_attr(){

            return m_has_totalsRowShown_attr;
        
        }
        void set_totalsRowShown_attr(const boolean& _totalsRowShown_attr ){

        m_has_totalsRowShown_attr = true;
        m_totalsRowShown_attr = _totalsRowShown_attr;
        
        }
        const boolean& totalsRowShown_attr(){

            return type: oolean\nname: \m_totalsRowShown_attr\n;
        
        }
        bool has_published_attr(){

            return m_has_published_attr;
        
        }
        void set_published_attr(const boolean& _published_attr ){

        m_has_published_attr = true;
        m_published_attr = _published_attr;
        
        }
        const boolean& published_attr(){

            return type: oolean\nname: \m_published_attr\n;
        
        }
        bool has_headerRowDxfId_attr(){

            return m_has_headerRowDxfId_attr;
        
        }
        void set_headerRowDxfId_attr(const ST_DxfId& _headerRowDxfId_attr ){

            m_has_headerRowDxfId_attr = true;
            m_headerRowDxfId_attr = new ST_DxfId(_headerRowDxfId_attr);
        
        }
        const ST_DxfId& headerRowDxfId_attr(){

            if (m_headerRowDxfId_attr)
            {
                return *m_headerRowDxfId_attr;
            }
            return ST_DxfId::default_instance();
        
        }
        bool has_dataDxfId_attr(){

            return m_has_dataDxfId_attr;
        
        }
        void set_dataDxfId_attr(const ST_DxfId& _dataDxfId_attr ){

            m_has_dataDxfId_attr = true;
            m_dataDxfId_attr = new ST_DxfId(_dataDxfId_attr);
        
        }
        const ST_DxfId& dataDxfId_attr(){

            if (m_dataDxfId_attr)
            {
                return *m_dataDxfId_attr;
            }
            return ST_DxfId::default_instance();
        
        }
        bool has_totalsRowDxfId_attr(){

            return m_has_totalsRowDxfId_attr;
        
        }
        void set_totalsRowDxfId_attr(const ST_DxfId& _totalsRowDxfId_attr ){

            m_has_totalsRowDxfId_attr = true;
            m_totalsRowDxfId_attr = new ST_DxfId(_totalsRowDxfId_attr);
        
        }
        const ST_DxfId& totalsRowDxfId_attr(){

            if (m_totalsRowDxfId_attr)
            {
                return *m_totalsRowDxfId_attr;
            }
            return ST_DxfId::default_instance();
        
        }
        bool has_headerRowBorderDxfId_attr(){

            return m_has_headerRowBorderDxfId_attr;
        
        }
        void set_headerRowBorderDxfId_attr(const ST_DxfId& _headerRowBorderDxfId_attr ){

            m_has_headerRowBorderDxfId_attr = true;
            m_headerRowBorderDxfId_attr = new ST_DxfId(_headerRowBorderDxfId_attr);
        
        }
        const ST_DxfId& headerRowBorderDxfId_attr(){

            if (m_headerRowBorderDxfId_attr)
            {
                return *m_headerRowBorderDxfId_attr;
            }
            return ST_DxfId::default_instance();
        
        }
        bool has_tableBorderDxfId_attr(){

            return m_has_tableBorderDxfId_attr;
        
        }
        void set_tableBorderDxfId_attr(const ST_DxfId& _tableBorderDxfId_attr ){

            m_has_tableBorderDxfId_attr = true;
            m_tableBorderDxfId_attr = new ST_DxfId(_tableBorderDxfId_attr);
        
        }
        const ST_DxfId& tableBorderDxfId_attr(){

            if (m_tableBorderDxfId_attr)
            {
                return *m_tableBorderDxfId_attr;
            }
            return ST_DxfId::default_instance();
        
        }
        bool has_totalsRowBorderDxfId_attr(){

            return m_has_totalsRowBorderDxfId_attr;
        
        }
        void set_totalsRowBorderDxfId_attr(const ST_DxfId& _totalsRowBorderDxfId_attr ){

            m_has_totalsRowBorderDxfId_attr = true;
            m_totalsRowBorderDxfId_attr = new ST_DxfId(_totalsRowBorderDxfId_attr);
        
        }
        const ST_DxfId& totalsRowBorderDxfId_attr(){

            if (m_totalsRowBorderDxfId_attr)
            {
                return *m_totalsRowBorderDxfId_attr;
            }
            return ST_DxfId::default_instance();
        
        }
        bool has_headerRowCellStyle_attr(){

            return m_has_headerRowCellStyle_attr;
        
        }
        void set_headerRowCellStyle_attr(const ns_s::ST_Xstring& _headerRowCellStyle_attr ){

            m_has_headerRowCellStyle_attr = true;
            m_headerRowCellStyle_attr = new ns_s::ST_Xstring(_headerRowCellStyle_attr);
        
        }
        const ns_s::ST_Xstring& headerRowCellStyle_attr(){

            if (m_headerRowCellStyle_attr)
            {
                return *m_headerRowCellStyle_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_dataCellStyle_attr(){

            return m_has_dataCellStyle_attr;
        
        }
        void set_dataCellStyle_attr(const ns_s::ST_Xstring& _dataCellStyle_attr ){

            m_has_dataCellStyle_attr = true;
            m_dataCellStyle_attr = new ns_s::ST_Xstring(_dataCellStyle_attr);
        
        }
        const ns_s::ST_Xstring& dataCellStyle_attr(){

            if (m_dataCellStyle_attr)
            {
                return *m_dataCellStyle_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_totalsRowCellStyle_attr(){

            return m_has_totalsRowCellStyle_attr;
        
        }
        void set_totalsRowCellStyle_attr(const ns_s::ST_Xstring& _totalsRowCellStyle_attr ){

            m_has_totalsRowCellStyle_attr = true;
            m_totalsRowCellStyle_attr = new ns_s::ST_Xstring(_totalsRowCellStyle_attr);
        
        }
        const ns_s::ST_Xstring& totalsRowCellStyle_attr(){

            if (m_totalsRowCellStyle_attr)
            {
                return *m_totalsRowCellStyle_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_connectionId_attr(){

            return m_has_connectionId_attr;
        
        }
        void set_connectionId_attr(const unsignedInt& _connectionId_attr ){

        m_has_connectionId_attr = true;
        m_connectionId_attr = _connectionId_attr;
        
        }
        const unsignedInt& connectionId_attr(){

            return type: \unsignedInt\nname: \m_connectionId_attr\n;
        
        }

    private:
        bool m_has_autoFilter ;
        CT_AutoFilter* m_autoFilter ;
        bool m_has_sortState ;
        CT_SortState* m_sortState ;
        bool m_has_tableColumns ;
        CT_TableColumns* m_tableColumns ;
        bool m_has_tableStyleInfo ;
        CT_TableStyleInfo* m_tableStyleInfo ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_Table* default_instance_ ;
        bool m_has_id_attr ;
        unsignedInt m_id_attr ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;
        bool m_has_displayName_attr ;
        ns_s::ST_Xstring* m_displayName_attr ;
        bool m_has_comment_attr ;
        ns_s::ST_Xstring* m_comment_attr ;
        bool m_has_ref_attr ;
        ST_Ref* m_ref_attr ;
        bool m_has_tableType_attr ;
        ST_TableType* m_tableType_attr ;
        bool m_has_headerRowCount_attr ;
        unsignedInt m_headerRowCount_attr ;
        bool m_has_insertRow_attr ;
        boolean m_insertRow_attr ;
        bool m_has_insertRowShift_attr ;
        boolean m_insertRowShift_attr ;
        bool m_has_totalsRowCount_attr ;
        unsignedInt m_totalsRowCount_attr ;
        bool m_has_totalsRowShown_attr ;
        boolean m_totalsRowShown_attr ;
        bool m_has_published_attr ;
        boolean m_published_attr ;
        bool m_has_headerRowDxfId_attr ;
        ST_DxfId* m_headerRowDxfId_attr ;
        bool m_has_dataDxfId_attr ;
        ST_DxfId* m_dataDxfId_attr ;
        bool m_has_totalsRowDxfId_attr ;
        ST_DxfId* m_totalsRowDxfId_attr ;
        bool m_has_headerRowBorderDxfId_attr ;
        ST_DxfId* m_headerRowBorderDxfId_attr ;
        bool m_has_tableBorderDxfId_attr ;
        ST_DxfId* m_tableBorderDxfId_attr ;
        bool m_has_totalsRowBorderDxfId_attr ;
        ST_DxfId* m_totalsRowBorderDxfId_attr ;
        bool m_has_headerRowCellStyle_attr ;
        ns_s::ST_Xstring* m_headerRowCellStyle_attr ;
        bool m_has_dataCellStyle_attr ;
        ns_s::ST_Xstring* m_dataCellStyle_attr ;
        bool m_has_totalsRowCellStyle_attr ;
        ns_s::ST_Xstring* m_totalsRowCellStyle_attr ;
        bool m_has_connectionId_attr ;
        unsignedInt m_connectionId_attr ;

    }

    class CT_TableStyleInfo : public XSD::ComplexType{
    public:
        void clear(){

                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
                m_has_showFirstColumn_attr = false;
                m_showFirstColumn_attr = false;
            
                m_has_showLastColumn_attr = false;
                m_showLastColumn_attr = false;
            
                m_has_showRowStripes_attr = false;
                m_showRowStripes_attr = false;
            
                m_has_showColumnStripes_attr = false;
                m_showColumnStripes_attr = false;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_name_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showFirstColumn_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showLastColumn_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showRowStripes_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showColumnStripes_attr) << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_TableStyleInfo& default_instance(){

    if (!CT_TableStyleInfo::default_instance_)
    {
        CT_TableStyleInfo::default_instance_ = new CT_TableStyleInfo();
    }
    return *CT_TableStyleInfo::default_instance_;

        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_showFirstColumn_attr(){

            return m_has_showFirstColumn_attr;
        
        }
        void set_showFirstColumn_attr(const boolean& _showFirstColumn_attr ){

        m_has_showFirstColumn_attr = true;
        m_showFirstColumn_attr = _showFirstColumn_attr;
        
        }
        const boolean& showFirstColumn_attr(){

            return type: oolean\nname: \m_showFirstColumn_attr\n;
        
        }
        bool has_showLastColumn_attr(){

            return m_has_showLastColumn_attr;
        
        }
        void set_showLastColumn_attr(const boolean& _showLastColumn_attr ){

        m_has_showLastColumn_attr = true;
        m_showLastColumn_attr = _showLastColumn_attr;
        
        }
        const boolean& showLastColumn_attr(){

            return type: oolean\nname: \m_showLastColumn_attr\n;
        
        }
        bool has_showRowStripes_attr(){

            return m_has_showRowStripes_attr;
        
        }
        void set_showRowStripes_attr(const boolean& _showRowStripes_attr ){

        m_has_showRowStripes_attr = true;
        m_showRowStripes_attr = _showRowStripes_attr;
        
        }
        const boolean& showRowStripes_attr(){

            return type: oolean\nname: \m_showRowStripes_attr\n;
        
        }
        bool has_showColumnStripes_attr(){

            return m_has_showColumnStripes_attr;
        
        }
        void set_showColumnStripes_attr(const boolean& _showColumnStripes_attr ){

        m_has_showColumnStripes_attr = true;
        m_showColumnStripes_attr = _showColumnStripes_attr;
        
        }
        const boolean& showColumnStripes_attr(){

            return type: oolean\nname: \m_showColumnStripes_attr\n;
        
        }

    private:
        static CT_TableStyleInfo* default_instance_ ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;
        bool m_has_showFirstColumn_attr ;
        boolean m_showFirstColumn_attr ;
        bool m_has_showLastColumn_attr ;
        boolean m_showLastColumn_attr ;
        bool m_has_showRowStripes_attr ;
        boolean m_showRowStripes_attr ;
        bool m_has_showColumnStripes_attr ;
        boolean m_showColumnStripes_attr ;

    }

    class CT_TableColumns : public XSD::ComplexType{
    public:
        bool has_tableColumn(){

            return m_has_tableColumn;
        
        }
        CT_TableColumn* mutable_tableColumn(){

                m_has_tableColumn = true;
                if (!m_tableColumn)
                {
                    m_tableColumn = new CT_TableColumn();
                }
                return m_tableColumn;
            
        }
        const CT_TableColumn& tableColumn(){

            if (m_tableColumn)
            {
                return *m_tableColumn;
            }
            return CT_TableColumn::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_tableColumn = false;
                
        if (m_tableColumn)
        {
            delete m_tableColumn;
            m_tableColumn = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_tableColumn)
                {
                    m_tableColumn->toXml(tableColumn, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_TableColumns& default_instance(){

    if (!CT_TableColumns::default_instance_)
    {
        CT_TableColumns::default_instance_ = new CT_TableColumns();
    }
    return *CT_TableColumns::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_tableColumn ;
        CT_TableColumn* m_tableColumn ;
        static CT_TableColumns* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_TableColumn : public XSD::ComplexType{
    public:
        bool has_calculatedColumnFormula(){

            return m_has_calculatedColumnFormula;
        
        }
        CT_TableFormula* mutable_calculatedColumnFormula(){

                m_has_calculatedColumnFormula = true;
                if (!m_calculatedColumnFormula)
                {
                    m_calculatedColumnFormula = new CT_TableFormula();
                }
                return m_calculatedColumnFormula;
            
        }
        const CT_TableFormula& calculatedColumnFormula(){

            if (m_calculatedColumnFormula)
            {
                return *m_calculatedColumnFormula;
            }
            return CT_TableFormula::default_instance();
        
        }
        bool has_totalsRowFormula(){

            return m_has_totalsRowFormula;
        
        }
        CT_TableFormula* mutable_totalsRowFormula(){

                m_has_totalsRowFormula = true;
                if (!m_totalsRowFormula)
                {
                    m_totalsRowFormula = new CT_TableFormula();
                }
                return m_totalsRowFormula;
            
        }
        const CT_TableFormula& totalsRowFormula(){

            if (m_totalsRowFormula)
            {
                return *m_totalsRowFormula;
            }
            return CT_TableFormula::default_instance();
        
        }
        bool has_xmlColumnPr(){

            return m_has_xmlColumnPr;
        
        }
        CT_XmlColumnPr* mutable_xmlColumnPr(){

                m_has_xmlColumnPr = true;
                if (!m_xmlColumnPr)
                {
                    m_xmlColumnPr = new CT_XmlColumnPr();
                }
                return m_xmlColumnPr;
            
        }
        const CT_XmlColumnPr& xmlColumnPr(){

            if (m_xmlColumnPr)
            {
                return *m_xmlColumnPr;
            }
            return CT_XmlColumnPr::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_id_attr = false;
                m_id_attr = 0;
            
                m_has_uniqueName_attr = false;
                
        if (m_uniqueName_attr)
        {
            delete m_uniqueName_attr;
            m_uniqueName_attr = NULL;
        }
    
            
                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
                m_has_totalsRowFunction_attr = false;
                
        if (m_totalsRowFunction_attr)
        {
            delete m_totalsRowFunction_attr;
            m_totalsRowFunction_attr = NULL;
        }
    
            
                m_has_totalsRowLabel_attr = false;
                
        if (m_totalsRowLabel_attr)
        {
            delete m_totalsRowLabel_attr;
            m_totalsRowLabel_attr = NULL;
        }
    
            
                m_has_queryTableFieldId_attr = false;
                m_queryTableFieldId_attr = 0;
            
                m_has_headerRowDxfId_attr = false;
                
        if (m_headerRowDxfId_attr)
        {
            delete m_headerRowDxfId_attr;
            m_headerRowDxfId_attr = NULL;
        }
    
            
                m_has_dataDxfId_attr = false;
                
        if (m_dataDxfId_attr)
        {
            delete m_dataDxfId_attr;
            m_dataDxfId_attr = NULL;
        }
    
            
                m_has_totalsRowDxfId_attr = false;
                
        if (m_totalsRowDxfId_attr)
        {
            delete m_totalsRowDxfId_attr;
            m_totalsRowDxfId_attr = NULL;
        }
    
            
                m_has_headerRowCellStyle_attr = false;
                
        if (m_headerRowCellStyle_attr)
        {
            delete m_headerRowCellStyle_attr;
            m_headerRowCellStyle_attr = NULL;
        }
    
            
                m_has_dataCellStyle_attr = false;
                
        if (m_dataCellStyle_attr)
        {
            delete m_dataCellStyle_attr;
            m_dataCellStyle_attr = NULL;
        }
    
            
                m_has_totalsRowCellStyle_attr = false;
                
        if (m_totalsRowCellStyle_attr)
        {
            delete m_totalsRowCellStyle_attr;
            m_totalsRowCellStyle_attr = NULL;
        }
    
            
                m_has_calculatedColumnFormula = false;
                
        if (m_calculatedColumnFormula)
        {
            delete m_calculatedColumnFormula;
            m_calculatedColumnFormula = NULL;
        }
    
            
                m_has_totalsRowFormula = false;
                
        if (m_totalsRowFormula)
        {
            delete m_totalsRowFormula;
            m_totalsRowFormula = NULL;
        }
    
            
                m_has_xmlColumnPr = false;
                
        if (m_xmlColumnPr)
        {
            delete m_xmlColumnPr;
            m_xmlColumnPr = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_id_attr << \\\;
m_uniqueName_attr->toXml(_attrName, _outStream);
m_name_attr->toXml(_attrName, _outStream);
m_totalsRowFunction_attr->toXml(_attrName, _outStream);
m_totalsRowLabel_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_queryTableFieldId_attr << \\\;
m_headerRowDxfId_attr->toXml(_attrName, _outStream);
m_dataDxfId_attr->toXml(_attrName, _outStream);
m_totalsRowDxfId_attr->toXml(_attrName, _outStream);
m_headerRowCellStyle_attr->toXml(_attrName, _outStream);
m_dataCellStyle_attr->toXml(_attrName, _outStream);
m_totalsRowCellStyle_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_calculatedColumnFormula)
                {
                    m_calculatedColumnFormula->toXml(calculatedColumnFormula, _outStream);;
                }
            
                if (m_has_totalsRowFormula)
                {
                    m_calculatedColumnFormula->toXml(totalsRowFormula, _outStream);;
                }
            
                if (m_has_xmlColumnPr)
                {
                    m_calculatedColumnFormula->toXml(xmlColumnPr, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_calculatedColumnFormula->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_TableColumn& default_instance(){

    if (!CT_TableColumn::default_instance_)
    {
        CT_TableColumn::default_instance_ = new CT_TableColumn();
    }
    return *CT_TableColumn::default_instance_;

        }
        bool has_id_attr(){

            return m_has_id_attr;
        
        }
        void set_id_attr(const unsignedInt& _id_attr ){

        m_has_id_attr = true;
        m_id_attr = _id_attr;
        
        }
        const unsignedInt& id_attr(){

            return type: \unsignedInt\nname: \m_id_attr\n;
        
        }
        bool has_uniqueName_attr(){

            return m_has_uniqueName_attr;
        
        }
        void set_uniqueName_attr(const ns_s::ST_Xstring& _uniqueName_attr ){

            m_has_uniqueName_attr = true;
            m_uniqueName_attr = new ns_s::ST_Xstring(_uniqueName_attr);
        
        }
        const ns_s::ST_Xstring& uniqueName_attr(){

            if (m_uniqueName_attr)
            {
                return *m_uniqueName_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_totalsRowFunction_attr(){

            return m_has_totalsRowFunction_attr;
        
        }
        void set_totalsRowFunction_attr(const ST_TotalsRowFunction& _totalsRowFunction_attr ){

            m_has_totalsRowFunction_attr = true;
            m_totalsRowFunction_attr = new ST_TotalsRowFunction(_totalsRowFunction_attr);
        
        }
        const ST_TotalsRowFunction& totalsRowFunction_attr(){

            if (m_totalsRowFunction_attr)
            {
                return *m_totalsRowFunction_attr;
            }
            return ST_TotalsRowFunction::default_instance();
        
        }
        bool has_totalsRowLabel_attr(){

            return m_has_totalsRowLabel_attr;
        
        }
        void set_totalsRowLabel_attr(const ns_s::ST_Xstring& _totalsRowLabel_attr ){

            m_has_totalsRowLabel_attr = true;
            m_totalsRowLabel_attr = new ns_s::ST_Xstring(_totalsRowLabel_attr);
        
        }
        const ns_s::ST_Xstring& totalsRowLabel_attr(){

            if (m_totalsRowLabel_attr)
            {
                return *m_totalsRowLabel_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_queryTableFieldId_attr(){

            return m_has_queryTableFieldId_attr;
        
        }
        void set_queryTableFieldId_attr(const unsignedInt& _queryTableFieldId_attr ){

        m_has_queryTableFieldId_attr = true;
        m_queryTableFieldId_attr = _queryTableFieldId_attr;
        
        }
        const unsignedInt& queryTableFieldId_attr(){

            return type: \unsignedInt\nname: \m_queryTableFieldId_attr\n;
        
        }
        bool has_headerRowDxfId_attr(){

            return m_has_headerRowDxfId_attr;
        
        }
        void set_headerRowDxfId_attr(const ST_DxfId& _headerRowDxfId_attr ){

            m_has_headerRowDxfId_attr = true;
            m_headerRowDxfId_attr = new ST_DxfId(_headerRowDxfId_attr);
        
        }
        const ST_DxfId& headerRowDxfId_attr(){

            if (m_headerRowDxfId_attr)
            {
                return *m_headerRowDxfId_attr;
            }
            return ST_DxfId::default_instance();
        
        }
        bool has_dataDxfId_attr(){

            return m_has_dataDxfId_attr;
        
        }
        void set_dataDxfId_attr(const ST_DxfId& _dataDxfId_attr ){

            m_has_dataDxfId_attr = true;
            m_dataDxfId_attr = new ST_DxfId(_dataDxfId_attr);
        
        }
        const ST_DxfId& dataDxfId_attr(){

            if (m_dataDxfId_attr)
            {
                return *m_dataDxfId_attr;
            }
            return ST_DxfId::default_instance();
        
        }
        bool has_totalsRowDxfId_attr(){

            return m_has_totalsRowDxfId_attr;
        
        }
        void set_totalsRowDxfId_attr(const ST_DxfId& _totalsRowDxfId_attr ){

            m_has_totalsRowDxfId_attr = true;
            m_totalsRowDxfId_attr = new ST_DxfId(_totalsRowDxfId_attr);
        
        }
        const ST_DxfId& totalsRowDxfId_attr(){

            if (m_totalsRowDxfId_attr)
            {
                return *m_totalsRowDxfId_attr;
            }
            return ST_DxfId::default_instance();
        
        }
        bool has_headerRowCellStyle_attr(){

            return m_has_headerRowCellStyle_attr;
        
        }
        void set_headerRowCellStyle_attr(const ns_s::ST_Xstring& _headerRowCellStyle_attr ){

            m_has_headerRowCellStyle_attr = true;
            m_headerRowCellStyle_attr = new ns_s::ST_Xstring(_headerRowCellStyle_attr);
        
        }
        const ns_s::ST_Xstring& headerRowCellStyle_attr(){

            if (m_headerRowCellStyle_attr)
            {
                return *m_headerRowCellStyle_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_dataCellStyle_attr(){

            return m_has_dataCellStyle_attr;
        
        }
        void set_dataCellStyle_attr(const ns_s::ST_Xstring& _dataCellStyle_attr ){

            m_has_dataCellStyle_attr = true;
            m_dataCellStyle_attr = new ns_s::ST_Xstring(_dataCellStyle_attr);
        
        }
        const ns_s::ST_Xstring& dataCellStyle_attr(){

            if (m_dataCellStyle_attr)
            {
                return *m_dataCellStyle_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_totalsRowCellStyle_attr(){

            return m_has_totalsRowCellStyle_attr;
        
        }
        void set_totalsRowCellStyle_attr(const ns_s::ST_Xstring& _totalsRowCellStyle_attr ){

            m_has_totalsRowCellStyle_attr = true;
            m_totalsRowCellStyle_attr = new ns_s::ST_Xstring(_totalsRowCellStyle_attr);
        
        }
        const ns_s::ST_Xstring& totalsRowCellStyle_attr(){

            if (m_totalsRowCellStyle_attr)
            {
                return *m_totalsRowCellStyle_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }

    private:
        bool m_has_calculatedColumnFormula ;
        CT_TableFormula* m_calculatedColumnFormula ;
        bool m_has_totalsRowFormula ;
        CT_TableFormula* m_totalsRowFormula ;
        bool m_has_xmlColumnPr ;
        CT_XmlColumnPr* m_xmlColumnPr ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_TableColumn* default_instance_ ;
        bool m_has_id_attr ;
        unsignedInt m_id_attr ;
        bool m_has_uniqueName_attr ;
        ns_s::ST_Xstring* m_uniqueName_attr ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;
        bool m_has_totalsRowFunction_attr ;
        ST_TotalsRowFunction* m_totalsRowFunction_attr ;
        bool m_has_totalsRowLabel_attr ;
        ns_s::ST_Xstring* m_totalsRowLabel_attr ;
        bool m_has_queryTableFieldId_attr ;
        unsignedInt m_queryTableFieldId_attr ;
        bool m_has_headerRowDxfId_attr ;
        ST_DxfId* m_headerRowDxfId_attr ;
        bool m_has_dataDxfId_attr ;
        ST_DxfId* m_dataDxfId_attr ;
        bool m_has_totalsRowDxfId_attr ;
        ST_DxfId* m_totalsRowDxfId_attr ;
        bool m_has_headerRowCellStyle_attr ;
        ns_s::ST_Xstring* m_headerRowCellStyle_attr ;
        bool m_has_dataCellStyle_attr ;
        ns_s::ST_Xstring* m_dataCellStyle_attr ;
        bool m_has_totalsRowCellStyle_attr ;
        ns_s::ST_Xstring* m_totalsRowCellStyle_attr ;

    }

    class CT_TableFormula : public XSD::ComplexType{
    public:
        void clear(){

        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_TableFormula& default_instance(){

    if (!CT_TableFormula::default_instance_)
    {
        CT_TableFormula::default_instance_ = new CT_TableFormula();
    }
    return *CT_TableFormula::default_instance_;

        }

    private:
        static CT_TableFormula* default_instance_ ;

    }

    class CT_XmlColumnPr : public XSD::ComplexType{
    public:
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_mapId_attr = false;
                m_mapId_attr = 0;
            
                m_has_xpath_attr = false;
                
        if (m_xpath_attr)
        {
            delete m_xpath_attr;
            m_xpath_attr = NULL;
        }
    
            
                m_has_denormalized_attr = false;
                m_denormalized_attr = false;
            
                m_has_xmlDataType_attr = false;
                
        if (m_xmlDataType_attr)
        {
            delete m_xmlDataType_attr;
            m_xmlDataType_attr = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_mapId_attr << \\\;
m_xpath_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_denormalized_attr) << \\\;
m_xmlDataType_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_extLst)
                {
                    m_extLst->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_XmlColumnPr& default_instance(){

    if (!CT_XmlColumnPr::default_instance_)
    {
        CT_XmlColumnPr::default_instance_ = new CT_XmlColumnPr();
    }
    return *CT_XmlColumnPr::default_instance_;

        }
        bool has_mapId_attr(){

            return m_has_mapId_attr;
        
        }
        void set_mapId_attr(const unsignedInt& _mapId_attr ){

        m_has_mapId_attr = true;
        m_mapId_attr = _mapId_attr;
        
        }
        const unsignedInt& mapId_attr(){

            return type: \unsignedInt\nname: \m_mapId_attr\n;
        
        }
        bool has_xpath_attr(){

            return m_has_xpath_attr;
        
        }
        void set_xpath_attr(const ns_s::ST_Xstring& _xpath_attr ){

            m_has_xpath_attr = true;
            m_xpath_attr = new ns_s::ST_Xstring(_xpath_attr);
        
        }
        const ns_s::ST_Xstring& xpath_attr(){

            if (m_xpath_attr)
            {
                return *m_xpath_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_denormalized_attr(){

            return m_has_denormalized_attr;
        
        }
        void set_denormalized_attr(const boolean& _denormalized_attr ){

        m_has_denormalized_attr = true;
        m_denormalized_attr = _denormalized_attr;
        
        }
        const boolean& denormalized_attr(){

            return type: oolean\nname: \m_denormalized_attr\n;
        
        }
        bool has_xmlDataType_attr(){

            return m_has_xmlDataType_attr;
        
        }
        void set_xmlDataType_attr(const ST_XmlDataType& _xmlDataType_attr ){

            m_has_xmlDataType_attr = true;
            m_xmlDataType_attr = new ST_XmlDataType(_xmlDataType_attr);
        
        }
        const ST_XmlDataType& xmlDataType_attr(){

            if (m_xmlDataType_attr)
            {
                return *m_xmlDataType_attr;
            }
            return ST_XmlDataType::default_instance();
        
        }

    private:
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_XmlColumnPr* default_instance_ ;
        bool m_has_mapId_attr ;
        unsignedInt m_mapId_attr ;
        bool m_has_xpath_attr ;
        ns_s::ST_Xstring* m_xpath_attr ;
        bool m_has_denormalized_attr ;
        boolean m_denormalized_attr ;
        bool m_has_xmlDataType_attr ;
        ST_XmlDataType* m_xmlDataType_attr ;

    }

    class CT_VolTypes : public XSD::ComplexType{
    public:
        bool has_volType(){

            return m_has_volType;
        
        }
        CT_VolType* mutable_volType(){

                m_has_volType = true;
                if (!m_volType)
                {
                    m_volType = new CT_VolType();
                }
                return m_volType;
            
        }
        const CT_VolType& volType(){

            if (m_volType)
            {
                return *m_volType;
            }
            return CT_VolType::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_volType = false;
                
        if (m_volType)
        {
            delete m_volType;
            m_volType = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_volType)
                {
                    m_volType->toXml(volType, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_volType->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_VolTypes& default_instance(){

    if (!CT_VolTypes::default_instance_)
    {
        CT_VolTypes::default_instance_ = new CT_VolTypes();
    }
    return *CT_VolTypes::default_instance_;

        }

    private:
        bool m_has_volType ;
        CT_VolType* m_volType ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_VolTypes* default_instance_ ;

    }

    class CT_VolType : public XSD::ComplexType{
    public:
        bool has_main(){

            return m_has_main;
        
        }
        CT_VolMain* mutable_main(){

                m_has_main = true;
                if (!m_main)
                {
                    m_main = new CT_VolMain();
                }
                return m_main;
            
        }
        const CT_VolMain& main(){

            if (m_main)
            {
                return *m_main;
            }
            return CT_VolMain::default_instance();
        
        }
        void clear(){

                m_has_type_attr = false;
                
        if (m_type_attr)
        {
            delete m_type_attr;
            m_type_attr = NULL;
        }
    
            
                m_has_main = false;
                
        if (m_main)
        {
            delete m_main;
            m_main = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_type_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_main)
                {
                    m_main->toXml(main, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_VolType& default_instance(){

    if (!CT_VolType::default_instance_)
    {
        CT_VolType::default_instance_ = new CT_VolType();
    }
    return *CT_VolType::default_instance_;

        }
        bool has_type_attr(){

            return m_has_type_attr;
        
        }
        void set_type_attr(const ST_VolDepType& _type_attr ){

            m_has_type_attr = true;
            m_type_attr = new ST_VolDepType(_type_attr);
        
        }
        const ST_VolDepType& type_attr(){

            if (m_type_attr)
            {
                return *m_type_attr;
            }
            return ST_VolDepType::default_instance();
        
        }

    private:
        bool m_has_main ;
        CT_VolMain* m_main ;
        static CT_VolType* default_instance_ ;
        bool m_has_type_attr ;
        ST_VolDepType* m_type_attr ;

    }

    class CT_VolMain : public XSD::ComplexType{
    public:
        bool has_tp(){

            return m_has_tp;
        
        }
        CT_VolTopic* mutable_tp(){

                m_has_tp = true;
                if (!m_tp)
                {
                    m_tp = new CT_VolTopic();
                }
                return m_tp;
            
        }
        const CT_VolTopic& tp(){

            if (m_tp)
            {
                return *m_tp;
            }
            return CT_VolTopic::default_instance();
        
        }
        void clear(){

                m_has_first_attr = false;
                
        if (m_first_attr)
        {
            delete m_first_attr;
            m_first_attr = NULL;
        }
    
            
                m_has_tp = false;
                
        if (m_tp)
        {
            delete m_tp;
            m_tp = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_first_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_tp)
                {
                    m_tp->toXml(tp, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_VolMain& default_instance(){

    if (!CT_VolMain::default_instance_)
    {
        CT_VolMain::default_instance_ = new CT_VolMain();
    }
    return *CT_VolMain::default_instance_;

        }
        bool has_first_attr(){

            return m_has_first_attr;
        
        }
        void set_first_attr(const ns_s::ST_Xstring& _first_attr ){

            m_has_first_attr = true;
            m_first_attr = new ns_s::ST_Xstring(_first_attr);
        
        }
        const ns_s::ST_Xstring& first_attr(){

            if (m_first_attr)
            {
                return *m_first_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }

    private:
        bool m_has_tp ;
        CT_VolTopic* m_tp ;
        static CT_VolMain* default_instance_ ;
        bool m_has_first_attr ;
        ns_s::ST_Xstring* m_first_attr ;

    }

    class CT_VolTopic : public XSD::ComplexType{
    public:
        bool has_v(){

            return m_has_v;
        
        }
        ns_s::ST_Xstring* mutable_v(){

                m_has_v = true;
                if (!m_v)
                {
                    m_v = new ns_s::ST_Xstring();
                }
                return m_v;
            
        }
        const ns_s::ST_Xstring& v(){

            if (m_v)
            {
                return *m_v;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_stp(){

            return m_has_stp;
        
        }
        ns_s::ST_Xstring* mutable_stp(){

                m_has_stp = true;
                if (!m_stp)
                {
                    m_stp = new ns_s::ST_Xstring();
                }
                return m_stp;
            
        }
        const ns_s::ST_Xstring& stp(){

            if (m_stp)
            {
                return *m_stp;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_tr(){

            return m_has_tr;
        
        }
        CT_VolTopicRef* mutable_tr(){

                m_has_tr = true;
                if (!m_tr)
                {
                    m_tr = new CT_VolTopicRef();
                }
                return m_tr;
            
        }
        const CT_VolTopicRef& tr(){

            if (m_tr)
            {
                return *m_tr;
            }
            return CT_VolTopicRef::default_instance();
        
        }
        void clear(){

                m_has_t_attr = false;
                
        if (m_t_attr)
        {
            delete m_t_attr;
            m_t_attr = NULL;
        }
    
            
                m_has_v = false;
                
        if (m_v)
        {
            delete m_v;
            m_v = NULL;
        }
    
            
                m_has_stp = false;
                
        if (m_stp)
        {
            delete m_stp;
            m_stp = NULL;
        }
    
            
                m_has_tr = false;
                
        if (m_tr)
        {
            delete m_tr;
            m_tr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_t_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_v)
                {
                    _outStream << \<v>\ << m_v->toString() << \</v>\;;
                }
            
                if (m_has_stp)
                {
                    _outStream << \<stp>\ << m_v->toString() << \</stp>\;;
                }
            
                if (m_has_tr)
                {
                    m_v->toXml(tr, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_VolTopic& default_instance(){

    if (!CT_VolTopic::default_instance_)
    {
        CT_VolTopic::default_instance_ = new CT_VolTopic();
    }
    return *CT_VolTopic::default_instance_;

        }
        bool has_t_attr(){

            return m_has_t_attr;
        
        }
        void set_t_attr(const ST_VolValueType& _t_attr ){

            m_has_t_attr = true;
            m_t_attr = new ST_VolValueType(_t_attr);
        
        }
        const ST_VolValueType& t_attr(){

            if (m_t_attr)
            {
                return *m_t_attr;
            }
            return ST_VolValueType::default_instance();
        
        }

    private:
        bool m_has_v ;
        ns_s::ST_Xstring* m_v ;
        bool m_has_stp ;
        ns_s::ST_Xstring* m_stp ;
        bool m_has_tr ;
        CT_VolTopicRef* m_tr ;
        static CT_VolTopic* default_instance_ ;
        bool m_has_t_attr ;
        ST_VolValueType* m_t_attr ;

    }

    class CT_VolTopicRef : public XSD::ComplexType{
    public:
        void clear(){

                m_has_r_attr = false;
                
        if (m_r_attr)
        {
            delete m_r_attr;
            m_r_attr = NULL;
        }
    
            
                m_has_s_attr = false;
                m_s_attr = 0;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_r_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_s_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_VolTopicRef& default_instance(){

    if (!CT_VolTopicRef::default_instance_)
    {
        CT_VolTopicRef::default_instance_ = new CT_VolTopicRef();
    }
    return *CT_VolTopicRef::default_instance_;

        }
        bool has_r_attr(){

            return m_has_r_attr;
        
        }
        void set_r_attr(const ST_CellRef& _r_attr ){

            m_has_r_attr = true;
            m_r_attr = new ST_CellRef(_r_attr);
        
        }
        const ST_CellRef& r_attr(){

            if (m_r_attr)
            {
                return *m_r_attr;
            }
            return ST_CellRef::default_instance();
        
        }
        bool has_s_attr(){

            return m_has_s_attr;
        
        }
        void set_s_attr(const unsignedInt& _s_attr ){

        m_has_s_attr = true;
        m_s_attr = _s_attr;
        
        }
        const unsignedInt& s_attr(){

            return type: \unsignedInt\nname: \m_s_attr\n;
        
        }

    private:
        static CT_VolTopicRef* default_instance_ ;
        bool m_has_r_attr ;
        ST_CellRef* m_r_attr ;
        bool m_has_s_attr ;
        unsignedInt m_s_attr ;

    }

    class CT_Workbook : public XSD::ComplexType{
    public:
        bool has_fileVersion(){

            return m_has_fileVersion;
        
        }
        CT_FileVersion* mutable_fileVersion(){

                m_has_fileVersion = true;
                if (!m_fileVersion)
                {
                    m_fileVersion = new CT_FileVersion();
                }
                return m_fileVersion;
            
        }
        const CT_FileVersion& fileVersion(){

            if (m_fileVersion)
            {
                return *m_fileVersion;
            }
            return CT_FileVersion::default_instance();
        
        }
        bool has_fileSharing(){

            return m_has_fileSharing;
        
        }
        CT_FileSharing* mutable_fileSharing(){

                m_has_fileSharing = true;
                if (!m_fileSharing)
                {
                    m_fileSharing = new CT_FileSharing();
                }
                return m_fileSharing;
            
        }
        const CT_FileSharing& fileSharing(){

            if (m_fileSharing)
            {
                return *m_fileSharing;
            }
            return CT_FileSharing::default_instance();
        
        }
        bool has_workbookPr(){

            return m_has_workbookPr;
        
        }
        CT_WorkbookPr* mutable_workbookPr(){

                m_has_workbookPr = true;
                if (!m_workbookPr)
                {
                    m_workbookPr = new CT_WorkbookPr();
                }
                return m_workbookPr;
            
        }
        const CT_WorkbookPr& workbookPr(){

            if (m_workbookPr)
            {
                return *m_workbookPr;
            }
            return CT_WorkbookPr::default_instance();
        
        }
        bool has_workbookProtection(){

            return m_has_workbookProtection;
        
        }
        CT_WorkbookProtection* mutable_workbookProtection(){

                m_has_workbookProtection = true;
                if (!m_workbookProtection)
                {
                    m_workbookProtection = new CT_WorkbookProtection();
                }
                return m_workbookProtection;
            
        }
        const CT_WorkbookProtection& workbookProtection(){

            if (m_workbookProtection)
            {
                return *m_workbookProtection;
            }
            return CT_WorkbookProtection::default_instance();
        
        }
        bool has_bookViews(){

            return m_has_bookViews;
        
        }
        CT_BookViews* mutable_bookViews(){

                m_has_bookViews = true;
                if (!m_bookViews)
                {
                    m_bookViews = new CT_BookViews();
                }
                return m_bookViews;
            
        }
        const CT_BookViews& bookViews(){

            if (m_bookViews)
            {
                return *m_bookViews;
            }
            return CT_BookViews::default_instance();
        
        }
        bool has_sheets(){

            return m_has_sheets;
        
        }
        CT_Sheets* mutable_sheets(){

                m_has_sheets = true;
                if (!m_sheets)
                {
                    m_sheets = new CT_Sheets();
                }
                return m_sheets;
            
        }
        const CT_Sheets& sheets(){

            if (m_sheets)
            {
                return *m_sheets;
            }
            return CT_Sheets::default_instance();
        
        }
        bool has_functionGroups(){

            return m_has_functionGroups;
        
        }
        CT_FunctionGroups* mutable_functionGroups(){

                m_has_functionGroups = true;
                if (!m_functionGroups)
                {
                    m_functionGroups = new CT_FunctionGroups();
                }
                return m_functionGroups;
            
        }
        const CT_FunctionGroups& functionGroups(){

            if (m_functionGroups)
            {
                return *m_functionGroups;
            }
            return CT_FunctionGroups::default_instance();
        
        }
        bool has_externalReferences(){

            return m_has_externalReferences;
        
        }
        CT_ExternalReferences* mutable_externalReferences(){

                m_has_externalReferences = true;
                if (!m_externalReferences)
                {
                    m_externalReferences = new CT_ExternalReferences();
                }
                return m_externalReferences;
            
        }
        const CT_ExternalReferences& externalReferences(){

            if (m_externalReferences)
            {
                return *m_externalReferences;
            }
            return CT_ExternalReferences::default_instance();
        
        }
        bool has_definedNames(){

            return m_has_definedNames;
        
        }
        CT_DefinedNames* mutable_definedNames(){

                m_has_definedNames = true;
                if (!m_definedNames)
                {
                    m_definedNames = new CT_DefinedNames();
                }
                return m_definedNames;
            
        }
        const CT_DefinedNames& definedNames(){

            if (m_definedNames)
            {
                return *m_definedNames;
            }
            return CT_DefinedNames::default_instance();
        
        }
        bool has_calcPr(){

            return m_has_calcPr;
        
        }
        CT_CalcPr* mutable_calcPr(){

                m_has_calcPr = true;
                if (!m_calcPr)
                {
                    m_calcPr = new CT_CalcPr();
                }
                return m_calcPr;
            
        }
        const CT_CalcPr& calcPr(){

            if (m_calcPr)
            {
                return *m_calcPr;
            }
            return CT_CalcPr::default_instance();
        
        }
        bool has_oleSize(){

            return m_has_oleSize;
        
        }
        CT_OleSize* mutable_oleSize(){

                m_has_oleSize = true;
                if (!m_oleSize)
                {
                    m_oleSize = new CT_OleSize();
                }
                return m_oleSize;
            
        }
        const CT_OleSize& oleSize(){

            if (m_oleSize)
            {
                return *m_oleSize;
            }
            return CT_OleSize::default_instance();
        
        }
        bool has_customWorkbookViews(){

            return m_has_customWorkbookViews;
        
        }
        CT_CustomWorkbookViews* mutable_customWorkbookViews(){

                m_has_customWorkbookViews = true;
                if (!m_customWorkbookViews)
                {
                    m_customWorkbookViews = new CT_CustomWorkbookViews();
                }
                return m_customWorkbookViews;
            
        }
        const CT_CustomWorkbookViews& customWorkbookViews(){

            if (m_customWorkbookViews)
            {
                return *m_customWorkbookViews;
            }
            return CT_CustomWorkbookViews::default_instance();
        
        }
        bool has_pivotCaches(){

            return m_has_pivotCaches;
        
        }
        CT_PivotCaches* mutable_pivotCaches(){

                m_has_pivotCaches = true;
                if (!m_pivotCaches)
                {
                    m_pivotCaches = new CT_PivotCaches();
                }
                return m_pivotCaches;
            
        }
        const CT_PivotCaches& pivotCaches(){

            if (m_pivotCaches)
            {
                return *m_pivotCaches;
            }
            return CT_PivotCaches::default_instance();
        
        }
        bool has_smartTagPr(){

            return m_has_smartTagPr;
        
        }
        CT_SmartTagPr* mutable_smartTagPr(){

                m_has_smartTagPr = true;
                if (!m_smartTagPr)
                {
                    m_smartTagPr = new CT_SmartTagPr();
                }
                return m_smartTagPr;
            
        }
        const CT_SmartTagPr& smartTagPr(){

            if (m_smartTagPr)
            {
                return *m_smartTagPr;
            }
            return CT_SmartTagPr::default_instance();
        
        }
        bool has_smartTagTypes(){

            return m_has_smartTagTypes;
        
        }
        CT_SmartTagTypes* mutable_smartTagTypes(){

                m_has_smartTagTypes = true;
                if (!m_smartTagTypes)
                {
                    m_smartTagTypes = new CT_SmartTagTypes();
                }
                return m_smartTagTypes;
            
        }
        const CT_SmartTagTypes& smartTagTypes(){

            if (m_smartTagTypes)
            {
                return *m_smartTagTypes;
            }
            return CT_SmartTagTypes::default_instance();
        
        }
        bool has_webPublishing(){

            return m_has_webPublishing;
        
        }
        CT_WebPublishing* mutable_webPublishing(){

                m_has_webPublishing = true;
                if (!m_webPublishing)
                {
                    m_webPublishing = new CT_WebPublishing();
                }
                return m_webPublishing;
            
        }
        const CT_WebPublishing& webPublishing(){

            if (m_webPublishing)
            {
                return *m_webPublishing;
            }
            return CT_WebPublishing::default_instance();
        
        }
        bool has_fileRecoveryPr(){

            return m_has_fileRecoveryPr;
        
        }
        CT_FileRecoveryPr* mutable_fileRecoveryPr(){

                m_has_fileRecoveryPr = true;
                if (!m_fileRecoveryPr)
                {
                    m_fileRecoveryPr = new CT_FileRecoveryPr();
                }
                return m_fileRecoveryPr;
            
        }
        const CT_FileRecoveryPr& fileRecoveryPr(){

            if (m_fileRecoveryPr)
            {
                return *m_fileRecoveryPr;
            }
            return CT_FileRecoveryPr::default_instance();
        
        }
        bool has_webPublishObjects(){

            return m_has_webPublishObjects;
        
        }
        CT_WebPublishObjects* mutable_webPublishObjects(){

                m_has_webPublishObjects = true;
                if (!m_webPublishObjects)
                {
                    m_webPublishObjects = new CT_WebPublishObjects();
                }
                return m_webPublishObjects;
            
        }
        const CT_WebPublishObjects& webPublishObjects(){

            if (m_webPublishObjects)
            {
                return *m_webPublishObjects;
            }
            return CT_WebPublishObjects::default_instance();
        
        }
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_conformance_attr = false;
                
        if (m_conformance_attr)
        {
            delete m_conformance_attr;
            m_conformance_attr = NULL;
        }
    
            
                m_has_fileVersion = false;
                
        if (m_fileVersion)
        {
            delete m_fileVersion;
            m_fileVersion = NULL;
        }
    
            
                m_has_fileSharing = false;
                
        if (m_fileSharing)
        {
            delete m_fileSharing;
            m_fileSharing = NULL;
        }
    
            
                m_has_workbookPr = false;
                
        if (m_workbookPr)
        {
            delete m_workbookPr;
            m_workbookPr = NULL;
        }
    
            
                m_has_workbookProtection = false;
                
        if (m_workbookProtection)
        {
            delete m_workbookProtection;
            m_workbookProtection = NULL;
        }
    
            
                m_has_bookViews = false;
                
        if (m_bookViews)
        {
            delete m_bookViews;
            m_bookViews = NULL;
        }
    
            
                m_has_sheets = false;
                
        if (m_sheets)
        {
            delete m_sheets;
            m_sheets = NULL;
        }
    
            
                m_has_functionGroups = false;
                
        if (m_functionGroups)
        {
            delete m_functionGroups;
            m_functionGroups = NULL;
        }
    
            
                m_has_externalReferences = false;
                
        if (m_externalReferences)
        {
            delete m_externalReferences;
            m_externalReferences = NULL;
        }
    
            
                m_has_definedNames = false;
                
        if (m_definedNames)
        {
            delete m_definedNames;
            m_definedNames = NULL;
        }
    
            
                m_has_calcPr = false;
                
        if (m_calcPr)
        {
            delete m_calcPr;
            m_calcPr = NULL;
        }
    
            
                m_has_oleSize = false;
                
        if (m_oleSize)
        {
            delete m_oleSize;
            m_oleSize = NULL;
        }
    
            
                m_has_customWorkbookViews = false;
                
        if (m_customWorkbookViews)
        {
            delete m_customWorkbookViews;
            m_customWorkbookViews = NULL;
        }
    
            
                m_has_pivotCaches = false;
                
        if (m_pivotCaches)
        {
            delete m_pivotCaches;
            m_pivotCaches = NULL;
        }
    
            
                m_has_smartTagPr = false;
                
        if (m_smartTagPr)
        {
            delete m_smartTagPr;
            m_smartTagPr = NULL;
        }
    
            
                m_has_smartTagTypes = false;
                
        if (m_smartTagTypes)
        {
            delete m_smartTagTypes;
            m_smartTagTypes = NULL;
        }
    
            
                m_has_webPublishing = false;
                
        if (m_webPublishing)
        {
            delete m_webPublishing;
            m_webPublishing = NULL;
        }
    
            
                m_has_fileRecoveryPr = false;
                
        if (m_fileRecoveryPr)
        {
            delete m_fileRecoveryPr;
            m_fileRecoveryPr = NULL;
        }
    
            
                m_has_webPublishObjects = false;
                
        if (m_webPublishObjects)
        {
            delete m_webPublishObjects;
            m_webPublishObjects = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_conformance_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_fileVersion)
                {
                    m_fileVersion->toXml(fileVersion, _outStream);;
                }
            
                if (m_has_fileSharing)
                {
                    m_fileVersion->toXml(fileSharing, _outStream);;
                }
            
                if (m_has_workbookPr)
                {
                    m_fileVersion->toXml(workbookPr, _outStream);;
                }
            
                if (m_has_workbookProtection)
                {
                    m_fileVersion->toXml(workbookProtection, _outStream);;
                }
            
                if (m_has_bookViews)
                {
                    m_fileVersion->toXml(bookViews, _outStream);;
                }
            
                if (m_has_sheets)
                {
                    m_fileVersion->toXml(sheets, _outStream);;
                }
            
                if (m_has_functionGroups)
                {
                    m_fileVersion->toXml(functionGroups, _outStream);;
                }
            
                if (m_has_externalReferences)
                {
                    m_fileVersion->toXml(externalReferences, _outStream);;
                }
            
                if (m_has_definedNames)
                {
                    m_fileVersion->toXml(definedNames, _outStream);;
                }
            
                if (m_has_calcPr)
                {
                    m_fileVersion->toXml(calcPr, _outStream);;
                }
            
                if (m_has_oleSize)
                {
                    m_fileVersion->toXml(oleSize, _outStream);;
                }
            
                if (m_has_customWorkbookViews)
                {
                    m_fileVersion->toXml(customWorkbookViews, _outStream);;
                }
            
                if (m_has_pivotCaches)
                {
                    m_fileVersion->toXml(pivotCaches, _outStream);;
                }
            
                if (m_has_smartTagPr)
                {
                    m_fileVersion->toXml(smartTagPr, _outStream);;
                }
            
                if (m_has_smartTagTypes)
                {
                    m_fileVersion->toXml(smartTagTypes, _outStream);;
                }
            
                if (m_has_webPublishing)
                {
                    m_fileVersion->toXml(webPublishing, _outStream);;
                }
            
                if (m_has_fileRecoveryPr)
                {
                    m_fileVersion->toXml(fileRecoveryPr, _outStream);;
                }
            
                if (m_has_webPublishObjects)
                {
                    m_fileVersion->toXml(webPublishObjects, _outStream);;
                }
            
                if (m_has_extLst)
                {
                    m_fileVersion->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Workbook& default_instance(){

    if (!CT_Workbook::default_instance_)
    {
        CT_Workbook::default_instance_ = new CT_Workbook();
    }
    return *CT_Workbook::default_instance_;

        }
        bool has_conformance_attr(){

            return m_has_conformance_attr;
        
        }
        void set_conformance_attr(const ns_s::ST_ConformanceClass& _conformance_attr ){

            m_has_conformance_attr = true;
            m_conformance_attr = new ns_s::ST_ConformanceClass(_conformance_attr);
        
        }
        const ns_s::ST_ConformanceClass& conformance_attr(){

            if (m_conformance_attr)
            {
                return *m_conformance_attr;
            }
            return ns_s::ST_ConformanceClass::default_instance();
        
        }

    private:
        bool m_has_fileVersion ;
        CT_FileVersion* m_fileVersion ;
        bool m_has_fileSharing ;
        CT_FileSharing* m_fileSharing ;
        bool m_has_workbookPr ;
        CT_WorkbookPr* m_workbookPr ;
        bool m_has_workbookProtection ;
        CT_WorkbookProtection* m_workbookProtection ;
        bool m_has_bookViews ;
        CT_BookViews* m_bookViews ;
        bool m_has_sheets ;
        CT_Sheets* m_sheets ;
        bool m_has_functionGroups ;
        CT_FunctionGroups* m_functionGroups ;
        bool m_has_externalReferences ;
        CT_ExternalReferences* m_externalReferences ;
        bool m_has_definedNames ;
        CT_DefinedNames* m_definedNames ;
        bool m_has_calcPr ;
        CT_CalcPr* m_calcPr ;
        bool m_has_oleSize ;
        CT_OleSize* m_oleSize ;
        bool m_has_customWorkbookViews ;
        CT_CustomWorkbookViews* m_customWorkbookViews ;
        bool m_has_pivotCaches ;
        CT_PivotCaches* m_pivotCaches ;
        bool m_has_smartTagPr ;
        CT_SmartTagPr* m_smartTagPr ;
        bool m_has_smartTagTypes ;
        CT_SmartTagTypes* m_smartTagTypes ;
        bool m_has_webPublishing ;
        CT_WebPublishing* m_webPublishing ;
        bool m_has_fileRecoveryPr ;
        CT_FileRecoveryPr* m_fileRecoveryPr ;
        bool m_has_webPublishObjects ;
        CT_WebPublishObjects* m_webPublishObjects ;
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_Workbook* default_instance_ ;
        bool m_has_conformance_attr ;
        ns_s::ST_ConformanceClass* m_conformance_attr ;

    }

    class CT_FileVersion : public XSD::ComplexType{
    public:
        void clear(){

                m_has_appName_attr = false;
                m_appName_attr.clear();
            
                m_has_lastEdited_attr = false;
                m_lastEdited_attr.clear();
            
                m_has_lowestEdited_attr = false;
                m_lowestEdited_attr.clear();
            
                m_has_rupBuild_attr = false;
                m_rupBuild_attr.clear();
            
                m_has_codeName_attr = false;
                
        if (m_codeName_attr)
        {
            delete m_codeName_attr;
            m_codeName_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_appName_attr << \\\;
_outStream << _attrName << \=\\ << m_lastEdited_attr << \\\;
_outStream << _attrName << \=\\ << m_lowestEdited_attr << \\\;
_outStream << _attrName << \=\\ << m_rupBuild_attr << \\\;
m_codeName_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_FileVersion& default_instance(){

    if (!CT_FileVersion::default_instance_)
    {
        CT_FileVersion::default_instance_ = new CT_FileVersion();
    }
    return *CT_FileVersion::default_instance_;

        }
        bool has_appName_attr(){

            return m_has_appName_attr;
        
        }
        void set_appName_attr(const string& _appName_attr ){

        m_has_appName_attr = true;
        m_appName_attr = _appName_attr;
        
        }
        const string& appName_attr(){

            return type: \string\nname: \m_appName_attr\n;
        
        }
        bool has_lastEdited_attr(){

            return m_has_lastEdited_attr;
        
        }
        void set_lastEdited_attr(const string& _lastEdited_attr ){

        m_has_lastEdited_attr = true;
        m_lastEdited_attr = _lastEdited_attr;
        
        }
        const string& lastEdited_attr(){

            return type: \string\nname: \m_lastEdited_attr\n;
        
        }
        bool has_lowestEdited_attr(){

            return m_has_lowestEdited_attr;
        
        }
        void set_lowestEdited_attr(const string& _lowestEdited_attr ){

        m_has_lowestEdited_attr = true;
        m_lowestEdited_attr = _lowestEdited_attr;
        
        }
        const string& lowestEdited_attr(){

            return type: \string\nname: \m_lowestEdited_attr\n;
        
        }
        bool has_rupBuild_attr(){

            return m_has_rupBuild_attr;
        
        }
        void set_rupBuild_attr(const string& _rupBuild_attr ){

        m_has_rupBuild_attr = true;
        m_rupBuild_attr = _rupBuild_attr;
        
        }
        const string& rupBuild_attr(){

            return type: \string\nname: \m_rupBuild_attr\n;
        
        }
        bool has_codeName_attr(){

            return m_has_codeName_attr;
        
        }
        void set_codeName_attr(const ns_s::ST_Guid& _codeName_attr ){

            m_has_codeName_attr = true;
            m_codeName_attr = new ns_s::ST_Guid(_codeName_attr);
        
        }
        const ns_s::ST_Guid& codeName_attr(){

            if (m_codeName_attr)
            {
                return *m_codeName_attr;
            }
            return ns_s::ST_Guid::default_instance();
        
        }

    private:
        static CT_FileVersion* default_instance_ ;
        bool m_has_appName_attr ;
        string m_appName_attr ;
        bool m_has_lastEdited_attr ;
        string m_lastEdited_attr ;
        bool m_has_lowestEdited_attr ;
        string m_lowestEdited_attr ;
        bool m_has_rupBuild_attr ;
        string m_rupBuild_attr ;
        bool m_has_codeName_attr ;
        ns_s::ST_Guid* m_codeName_attr ;

    }

    class CT_BookViews : public XSD::ComplexType{
    public:
        bool has_workbookView(){

            return m_has_workbookView;
        
        }
        CT_BookView* mutable_workbookView(){

                m_has_workbookView = true;
                if (!m_workbookView)
                {
                    m_workbookView = new CT_BookView();
                }
                return m_workbookView;
            
        }
        const CT_BookView& workbookView(){

            if (m_workbookView)
            {
                return *m_workbookView;
            }
            return CT_BookView::default_instance();
        
        }
        void clear(){

                m_has_workbookView = false;
                
        if (m_workbookView)
        {
            delete m_workbookView;
            m_workbookView = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_workbookView)
                {
                    m_workbookView->toXml(workbookView, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_BookViews& default_instance(){

    if (!CT_BookViews::default_instance_)
    {
        CT_BookViews::default_instance_ = new CT_BookViews();
    }
    return *CT_BookViews::default_instance_;

        }

    private:
        bool m_has_workbookView ;
        CT_BookView* m_workbookView ;
        static CT_BookViews* default_instance_ ;

    }

    class CT_BookView : public XSD::ComplexType{
    public:
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_visibility_attr = false;
                
        if (m_visibility_attr)
        {
            delete m_visibility_attr;
            m_visibility_attr = NULL;
        }
    
            
                m_has_minimized_attr = false;
                m_minimized_attr = false;
            
                m_has_showHorizontalScroll_attr = false;
                m_showHorizontalScroll_attr = false;
            
                m_has_showVerticalScroll_attr = false;
                m_showVerticalScroll_attr = false;
            
                m_has_showSheetTabs_attr = false;
                m_showSheetTabs_attr = false;
            
                m_has_xWindow_attr = false;
                m_xWindow_attr = 0;
            
                m_has_yWindow_attr = false;
                m_yWindow_attr = 0;
            
                m_has_windowWidth_attr = false;
                m_windowWidth_attr = 0;
            
                m_has_windowHeight_attr = false;
                m_windowHeight_attr = 0;
            
                m_has_tabRatio_attr = false;
                m_tabRatio_attr = 0;
            
                m_has_firstSheet_attr = false;
                m_firstSheet_attr = 0;
            
                m_has_activeTab_attr = false;
                m_activeTab_attr = 0;
            
                m_has_autoFilterDateGrouping_attr = false;
                m_autoFilterDateGrouping_attr = false;
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_visibility_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_minimized_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showHorizontalScroll_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showVerticalScroll_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showSheetTabs_attr) << \\\;
_outStream << _attrName << \=\\ << m_xWindow_attr << \\\;
_outStream << _attrName << \=\\ << m_yWindow_attr << \\\;
_outStream << _attrName << \=\\ << m_windowWidth_attr << \\\;
_outStream << _attrName << \=\\ << m_windowHeight_attr << \\\;
_outStream << _attrName << \=\\ << m_tabRatio_attr << \\\;
_outStream << _attrName << \=\\ << m_firstSheet_attr << \\\;
_outStream << _attrName << \=\\ << m_activeTab_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_autoFilterDateGrouping_attr) << \\\;
        _outStream << \>\;
    
                if (m_has_extLst)
                {
                    m_extLst->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_BookView& default_instance(){

    if (!CT_BookView::default_instance_)
    {
        CT_BookView::default_instance_ = new CT_BookView();
    }
    return *CT_BookView::default_instance_;

        }
        bool has_visibility_attr(){

            return m_has_visibility_attr;
        
        }
        void set_visibility_attr(const ST_Visibility& _visibility_attr ){

            m_has_visibility_attr = true;
            m_visibility_attr = new ST_Visibility(_visibility_attr);
        
        }
        const ST_Visibility& visibility_attr(){

            if (m_visibility_attr)
            {
                return *m_visibility_attr;
            }
            return ST_Visibility::default_instance();
        
        }
        bool has_minimized_attr(){

            return m_has_minimized_attr;
        
        }
        void set_minimized_attr(const boolean& _minimized_attr ){

        m_has_minimized_attr = true;
        m_minimized_attr = _minimized_attr;
        
        }
        const boolean& minimized_attr(){

            return type: oolean\nname: \m_minimized_attr\n;
        
        }
        bool has_showHorizontalScroll_attr(){

            return m_has_showHorizontalScroll_attr;
        
        }
        void set_showHorizontalScroll_attr(const boolean& _showHorizontalScroll_attr ){

        m_has_showHorizontalScroll_attr = true;
        m_showHorizontalScroll_attr = _showHorizontalScroll_attr;
        
        }
        const boolean& showHorizontalScroll_attr(){

            return type: oolean\nname: \m_showHorizontalScroll_attr\n;
        
        }
        bool has_showVerticalScroll_attr(){

            return m_has_showVerticalScroll_attr;
        
        }
        void set_showVerticalScroll_attr(const boolean& _showVerticalScroll_attr ){

        m_has_showVerticalScroll_attr = true;
        m_showVerticalScroll_attr = _showVerticalScroll_attr;
        
        }
        const boolean& showVerticalScroll_attr(){

            return type: oolean\nname: \m_showVerticalScroll_attr\n;
        
        }
        bool has_showSheetTabs_attr(){

            return m_has_showSheetTabs_attr;
        
        }
        void set_showSheetTabs_attr(const boolean& _showSheetTabs_attr ){

        m_has_showSheetTabs_attr = true;
        m_showSheetTabs_attr = _showSheetTabs_attr;
        
        }
        const boolean& showSheetTabs_attr(){

            return type: oolean\nname: \m_showSheetTabs_attr\n;
        
        }
        bool has_xWindow_attr(){

            return m_has_xWindow_attr;
        
        }
        void set_xWindow_attr(const int& _xWindow_attr ){

        m_has_xWindow_attr = true;
        m_xWindow_attr = _xWindow_attr;
        
        }
        const int& xWindow_attr(){

            return type: \int\nname: \m_xWindow_attr\n;
        
        }
        bool has_yWindow_attr(){

            return m_has_yWindow_attr;
        
        }
        void set_yWindow_attr(const int& _yWindow_attr ){

        m_has_yWindow_attr = true;
        m_yWindow_attr = _yWindow_attr;
        
        }
        const int& yWindow_attr(){

            return type: \int\nname: \m_yWindow_attr\n;
        
        }
        bool has_windowWidth_attr(){

            return m_has_windowWidth_attr;
        
        }
        void set_windowWidth_attr(const unsignedInt& _windowWidth_attr ){

        m_has_windowWidth_attr = true;
        m_windowWidth_attr = _windowWidth_attr;
        
        }
        const unsignedInt& windowWidth_attr(){

            return type: \unsignedInt\nname: \m_windowWidth_attr\n;
        
        }
        bool has_windowHeight_attr(){

            return m_has_windowHeight_attr;
        
        }
        void set_windowHeight_attr(const unsignedInt& _windowHeight_attr ){

        m_has_windowHeight_attr = true;
        m_windowHeight_attr = _windowHeight_attr;
        
        }
        const unsignedInt& windowHeight_attr(){

            return type: \unsignedInt\nname: \m_windowHeight_attr\n;
        
        }
        bool has_tabRatio_attr(){

            return m_has_tabRatio_attr;
        
        }
        void set_tabRatio_attr(const unsignedInt& _tabRatio_attr ){

        m_has_tabRatio_attr = true;
        m_tabRatio_attr = _tabRatio_attr;
        
        }
        const unsignedInt& tabRatio_attr(){

            return type: \unsignedInt\nname: \m_tabRatio_attr\n;
        
        }
        bool has_firstSheet_attr(){

            return m_has_firstSheet_attr;
        
        }
        void set_firstSheet_attr(const unsignedInt& _firstSheet_attr ){

        m_has_firstSheet_attr = true;
        m_firstSheet_attr = _firstSheet_attr;
        
        }
        const unsignedInt& firstSheet_attr(){

            return type: \unsignedInt\nname: \m_firstSheet_attr\n;
        
        }
        bool has_activeTab_attr(){

            return m_has_activeTab_attr;
        
        }
        void set_activeTab_attr(const unsignedInt& _activeTab_attr ){

        m_has_activeTab_attr = true;
        m_activeTab_attr = _activeTab_attr;
        
        }
        const unsignedInt& activeTab_attr(){

            return type: \unsignedInt\nname: \m_activeTab_attr\n;
        
        }
        bool has_autoFilterDateGrouping_attr(){

            return m_has_autoFilterDateGrouping_attr;
        
        }
        void set_autoFilterDateGrouping_attr(const boolean& _autoFilterDateGrouping_attr ){

        m_has_autoFilterDateGrouping_attr = true;
        m_autoFilterDateGrouping_attr = _autoFilterDateGrouping_attr;
        
        }
        const boolean& autoFilterDateGrouping_attr(){

            return type: oolean\nname: \m_autoFilterDateGrouping_attr\n;
        
        }

    private:
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_BookView* default_instance_ ;
        bool m_has_visibility_attr ;
        ST_Visibility* m_visibility_attr ;
        bool m_has_minimized_attr ;
        boolean m_minimized_attr ;
        bool m_has_showHorizontalScroll_attr ;
        boolean m_showHorizontalScroll_attr ;
        bool m_has_showVerticalScroll_attr ;
        boolean m_showVerticalScroll_attr ;
        bool m_has_showSheetTabs_attr ;
        boolean m_showSheetTabs_attr ;
        bool m_has_xWindow_attr ;
        int m_xWindow_attr ;
        bool m_has_yWindow_attr ;
        int m_yWindow_attr ;
        bool m_has_windowWidth_attr ;
        unsignedInt m_windowWidth_attr ;
        bool m_has_windowHeight_attr ;
        unsignedInt m_windowHeight_attr ;
        bool m_has_tabRatio_attr ;
        unsignedInt m_tabRatio_attr ;
        bool m_has_firstSheet_attr ;
        unsignedInt m_firstSheet_attr ;
        bool m_has_activeTab_attr ;
        unsignedInt m_activeTab_attr ;
        bool m_has_autoFilterDateGrouping_attr ;
        boolean m_autoFilterDateGrouping_attr ;

    }

    class CT_CustomWorkbookViews : public XSD::ComplexType{
    public:
        bool has_customWorkbookView(){

            return m_has_customWorkbookView;
        
        }
        CT_CustomWorkbookView* mutable_customWorkbookView(){

                m_has_customWorkbookView = true;
                if (!m_customWorkbookView)
                {
                    m_customWorkbookView = new CT_CustomWorkbookView();
                }
                return m_customWorkbookView;
            
        }
        const CT_CustomWorkbookView& customWorkbookView(){

            if (m_customWorkbookView)
            {
                return *m_customWorkbookView;
            }
            return CT_CustomWorkbookView::default_instance();
        
        }
        void clear(){

                m_has_customWorkbookView = false;
                
        if (m_customWorkbookView)
        {
            delete m_customWorkbookView;
            m_customWorkbookView = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_customWorkbookView)
                {
                    m_customWorkbookView->toXml(customWorkbookView, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CustomWorkbookViews& default_instance(){

    if (!CT_CustomWorkbookViews::default_instance_)
    {
        CT_CustomWorkbookViews::default_instance_ = new CT_CustomWorkbookViews();
    }
    return *CT_CustomWorkbookViews::default_instance_;

        }

    private:
        bool m_has_customWorkbookView ;
        CT_CustomWorkbookView* m_customWorkbookView ;
        static CT_CustomWorkbookViews* default_instance_ ;

    }

    class CT_CustomWorkbookView : public XSD::ComplexType{
    public:
        bool has_extLst(){

            return m_has_extLst;
        
        }
        CT_ExtensionList* mutable_extLst(){

                m_has_extLst = true;
                if (!m_extLst)
                {
                    m_extLst = new CT_ExtensionList();
                }
                return m_extLst;
            
        }
        const CT_ExtensionList& extLst(){

            if (m_extLst)
            {
                return *m_extLst;
            }
            return CT_ExtensionList::default_instance();
        
        }
        void clear(){

                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
                m_has_guid_attr = false;
                
        if (m_guid_attr)
        {
            delete m_guid_attr;
            m_guid_attr = NULL;
        }
    
            
                m_has_autoUpdate_attr = false;
                m_autoUpdate_attr = false;
            
                m_has_mergeInterval_attr = false;
                m_mergeInterval_attr = 0;
            
                m_has_changesSavedWin_attr = false;
                m_changesSavedWin_attr = false;
            
                m_has_onlySync_attr = false;
                m_onlySync_attr = false;
            
                m_has_personalView_attr = false;
                m_personalView_attr = false;
            
                m_has_includePrintSettings_attr = false;
                m_includePrintSettings_attr = false;
            
                m_has_includeHiddenRowCol_attr = false;
                m_includeHiddenRowCol_attr = false;
            
                m_has_maximized_attr = false;
                m_maximized_attr = false;
            
                m_has_minimized_attr = false;
                m_minimized_attr = false;
            
                m_has_showHorizontalScroll_attr = false;
                m_showHorizontalScroll_attr = false;
            
                m_has_showVerticalScroll_attr = false;
                m_showVerticalScroll_attr = false;
            
                m_has_showSheetTabs_attr = false;
                m_showSheetTabs_attr = false;
            
                m_has_xWindow_attr = false;
                m_xWindow_attr = 0;
            
                m_has_yWindow_attr = false;
                m_yWindow_attr = 0;
            
                m_has_windowWidth_attr = false;
                m_windowWidth_attr = 0;
            
                m_has_windowHeight_attr = false;
                m_windowHeight_attr = 0;
            
                m_has_tabRatio_attr = false;
                m_tabRatio_attr = 0;
            
                m_has_activeSheetId_attr = false;
                m_activeSheetId_attr = 0;
            
                m_has_showFormulaBar_attr = false;
                m_showFormulaBar_attr = false;
            
                m_has_showStatusbar_attr = false;
                m_showStatusbar_attr = false;
            
                m_has_showComments_attr = false;
                
        if (m_showComments_attr)
        {
            delete m_showComments_attr;
            m_showComments_attr = NULL;
        }
    
            
                m_has_showObjects_attr = false;
                
        if (m_showObjects_attr)
        {
            delete m_showObjects_attr;
            m_showObjects_attr = NULL;
        }
    
            
                m_has_extLst = false;
                
        if (m_extLst)
        {
            delete m_extLst;
            m_extLst = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_name_attr->toXml(_attrName, _outStream);
m_guid_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_autoUpdate_attr) << \\\;
_outStream << _attrName << \=\\ << m_mergeInterval_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_changesSavedWin_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_onlySync_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_personalView_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_includePrintSettings_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_includeHiddenRowCol_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_maximized_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_minimized_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showHorizontalScroll_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showVerticalScroll_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showSheetTabs_attr) << \\\;
_outStream << _attrName << \=\\ << m_xWindow_attr << \\\;
_outStream << _attrName << \=\\ << m_yWindow_attr << \\\;
_outStream << _attrName << \=\\ << m_windowWidth_attr << \\\;
_outStream << _attrName << \=\\ << m_windowHeight_attr << \\\;
_outStream << _attrName << \=\\ << m_tabRatio_attr << \\\;
_outStream << _attrName << \=\\ << m_activeSheetId_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showFormulaBar_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showStatusbar_attr) << \\\;
m_showComments_attr->toXml(_attrName, _outStream);
m_showObjects_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
                if (m_has_extLst)
                {
                    m_extLst->toXml(extLst, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CustomWorkbookView& default_instance(){

    if (!CT_CustomWorkbookView::default_instance_)
    {
        CT_CustomWorkbookView::default_instance_ = new CT_CustomWorkbookView();
    }
    return *CT_CustomWorkbookView::default_instance_;

        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_guid_attr(){

            return m_has_guid_attr;
        
        }
        void set_guid_attr(const ns_s::ST_Guid& _guid_attr ){

            m_has_guid_attr = true;
            m_guid_attr = new ns_s::ST_Guid(_guid_attr);
        
        }
        const ns_s::ST_Guid& guid_attr(){

            if (m_guid_attr)
            {
                return *m_guid_attr;
            }
            return ns_s::ST_Guid::default_instance();
        
        }
        bool has_autoUpdate_attr(){

            return m_has_autoUpdate_attr;
        
        }
        void set_autoUpdate_attr(const boolean& _autoUpdate_attr ){

        m_has_autoUpdate_attr = true;
        m_autoUpdate_attr = _autoUpdate_attr;
        
        }
        const boolean& autoUpdate_attr(){

            return type: oolean\nname: \m_autoUpdate_attr\n;
        
        }
        bool has_mergeInterval_attr(){

            return m_has_mergeInterval_attr;
        
        }
        void set_mergeInterval_attr(const unsignedInt& _mergeInterval_attr ){

        m_has_mergeInterval_attr = true;
        m_mergeInterval_attr = _mergeInterval_attr;
        
        }
        const unsignedInt& mergeInterval_attr(){

            return type: \unsignedInt\nname: \m_mergeInterval_attr\n;
        
        }
        bool has_changesSavedWin_attr(){

            return m_has_changesSavedWin_attr;
        
        }
        void set_changesSavedWin_attr(const boolean& _changesSavedWin_attr ){

        m_has_changesSavedWin_attr = true;
        m_changesSavedWin_attr = _changesSavedWin_attr;
        
        }
        const boolean& changesSavedWin_attr(){

            return type: oolean\nname: \m_changesSavedWin_attr\n;
        
        }
        bool has_onlySync_attr(){

            return m_has_onlySync_attr;
        
        }
        void set_onlySync_attr(const boolean& _onlySync_attr ){

        m_has_onlySync_attr = true;
        m_onlySync_attr = _onlySync_attr;
        
        }
        const boolean& onlySync_attr(){

            return type: oolean\nname: \m_onlySync_attr\n;
        
        }
        bool has_personalView_attr(){

            return m_has_personalView_attr;
        
        }
        void set_personalView_attr(const boolean& _personalView_attr ){

        m_has_personalView_attr = true;
        m_personalView_attr = _personalView_attr;
        
        }
        const boolean& personalView_attr(){

            return type: oolean\nname: \m_personalView_attr\n;
        
        }
        bool has_includePrintSettings_attr(){

            return m_has_includePrintSettings_attr;
        
        }
        void set_includePrintSettings_attr(const boolean& _includePrintSettings_attr ){

        m_has_includePrintSettings_attr = true;
        m_includePrintSettings_attr = _includePrintSettings_attr;
        
        }
        const boolean& includePrintSettings_attr(){

            return type: oolean\nname: \m_includePrintSettings_attr\n;
        
        }
        bool has_includeHiddenRowCol_attr(){

            return m_has_includeHiddenRowCol_attr;
        
        }
        void set_includeHiddenRowCol_attr(const boolean& _includeHiddenRowCol_attr ){

        m_has_includeHiddenRowCol_attr = true;
        m_includeHiddenRowCol_attr = _includeHiddenRowCol_attr;
        
        }
        const boolean& includeHiddenRowCol_attr(){

            return type: oolean\nname: \m_includeHiddenRowCol_attr\n;
        
        }
        bool has_maximized_attr(){

            return m_has_maximized_attr;
        
        }
        void set_maximized_attr(const boolean& _maximized_attr ){

        m_has_maximized_attr = true;
        m_maximized_attr = _maximized_attr;
        
        }
        const boolean& maximized_attr(){

            return type: oolean\nname: \m_maximized_attr\n;
        
        }
        bool has_minimized_attr(){

            return m_has_minimized_attr;
        
        }
        void set_minimized_attr(const boolean& _minimized_attr ){

        m_has_minimized_attr = true;
        m_minimized_attr = _minimized_attr;
        
        }
        const boolean& minimized_attr(){

            return type: oolean\nname: \m_minimized_attr\n;
        
        }
        bool has_showHorizontalScroll_attr(){

            return m_has_showHorizontalScroll_attr;
        
        }
        void set_showHorizontalScroll_attr(const boolean& _showHorizontalScroll_attr ){

        m_has_showHorizontalScroll_attr = true;
        m_showHorizontalScroll_attr = _showHorizontalScroll_attr;
        
        }
        const boolean& showHorizontalScroll_attr(){

            return type: oolean\nname: \m_showHorizontalScroll_attr\n;
        
        }
        bool has_showVerticalScroll_attr(){

            return m_has_showVerticalScroll_attr;
        
        }
        void set_showVerticalScroll_attr(const boolean& _showVerticalScroll_attr ){

        m_has_showVerticalScroll_attr = true;
        m_showVerticalScroll_attr = _showVerticalScroll_attr;
        
        }
        const boolean& showVerticalScroll_attr(){

            return type: oolean\nname: \m_showVerticalScroll_attr\n;
        
        }
        bool has_showSheetTabs_attr(){

            return m_has_showSheetTabs_attr;
        
        }
        void set_showSheetTabs_attr(const boolean& _showSheetTabs_attr ){

        m_has_showSheetTabs_attr = true;
        m_showSheetTabs_attr = _showSheetTabs_attr;
        
        }
        const boolean& showSheetTabs_attr(){

            return type: oolean\nname: \m_showSheetTabs_attr\n;
        
        }
        bool has_xWindow_attr(){

            return m_has_xWindow_attr;
        
        }
        void set_xWindow_attr(const int& _xWindow_attr ){

        m_has_xWindow_attr = true;
        m_xWindow_attr = _xWindow_attr;
        
        }
        const int& xWindow_attr(){

            return type: \int\nname: \m_xWindow_attr\n;
        
        }
        bool has_yWindow_attr(){

            return m_has_yWindow_attr;
        
        }
        void set_yWindow_attr(const int& _yWindow_attr ){

        m_has_yWindow_attr = true;
        m_yWindow_attr = _yWindow_attr;
        
        }
        const int& yWindow_attr(){

            return type: \int\nname: \m_yWindow_attr\n;
        
        }
        bool has_windowWidth_attr(){

            return m_has_windowWidth_attr;
        
        }
        void set_windowWidth_attr(const unsignedInt& _windowWidth_attr ){

        m_has_windowWidth_attr = true;
        m_windowWidth_attr = _windowWidth_attr;
        
        }
        const unsignedInt& windowWidth_attr(){

            return type: \unsignedInt\nname: \m_windowWidth_attr\n;
        
        }
        bool has_windowHeight_attr(){

            return m_has_windowHeight_attr;
        
        }
        void set_windowHeight_attr(const unsignedInt& _windowHeight_attr ){

        m_has_windowHeight_attr = true;
        m_windowHeight_attr = _windowHeight_attr;
        
        }
        const unsignedInt& windowHeight_attr(){

            return type: \unsignedInt\nname: \m_windowHeight_attr\n;
        
        }
        bool has_tabRatio_attr(){

            return m_has_tabRatio_attr;
        
        }
        void set_tabRatio_attr(const unsignedInt& _tabRatio_attr ){

        m_has_tabRatio_attr = true;
        m_tabRatio_attr = _tabRatio_attr;
        
        }
        const unsignedInt& tabRatio_attr(){

            return type: \unsignedInt\nname: \m_tabRatio_attr\n;
        
        }
        bool has_activeSheetId_attr(){

            return m_has_activeSheetId_attr;
        
        }
        void set_activeSheetId_attr(const unsignedInt& _activeSheetId_attr ){

        m_has_activeSheetId_attr = true;
        m_activeSheetId_attr = _activeSheetId_attr;
        
        }
        const unsignedInt& activeSheetId_attr(){

            return type: \unsignedInt\nname: \m_activeSheetId_attr\n;
        
        }
        bool has_showFormulaBar_attr(){

            return m_has_showFormulaBar_attr;
        
        }
        void set_showFormulaBar_attr(const boolean& _showFormulaBar_attr ){

        m_has_showFormulaBar_attr = true;
        m_showFormulaBar_attr = _showFormulaBar_attr;
        
        }
        const boolean& showFormulaBar_attr(){

            return type: oolean\nname: \m_showFormulaBar_attr\n;
        
        }
        bool has_showStatusbar_attr(){

            return m_has_showStatusbar_attr;
        
        }
        void set_showStatusbar_attr(const boolean& _showStatusbar_attr ){

        m_has_showStatusbar_attr = true;
        m_showStatusbar_attr = _showStatusbar_attr;
        
        }
        const boolean& showStatusbar_attr(){

            return type: oolean\nname: \m_showStatusbar_attr\n;
        
        }
        bool has_showComments_attr(){

            return m_has_showComments_attr;
        
        }
        void set_showComments_attr(const ST_Comments& _showComments_attr ){

            m_has_showComments_attr = true;
            m_showComments_attr = new ST_Comments(_showComments_attr);
        
        }
        const ST_Comments& showComments_attr(){

            if (m_showComments_attr)
            {
                return *m_showComments_attr;
            }
            return ST_Comments::default_instance();
        
        }
        bool has_showObjects_attr(){

            return m_has_showObjects_attr;
        
        }
        void set_showObjects_attr(const ST_Objects& _showObjects_attr ){

            m_has_showObjects_attr = true;
            m_showObjects_attr = new ST_Objects(_showObjects_attr);
        
        }
        const ST_Objects& showObjects_attr(){

            if (m_showObjects_attr)
            {
                return *m_showObjects_attr;
            }
            return ST_Objects::default_instance();
        
        }

    private:
        bool m_has_extLst ;
        CT_ExtensionList* m_extLst ;
        static CT_CustomWorkbookView* default_instance_ ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;
        bool m_has_guid_attr ;
        ns_s::ST_Guid* m_guid_attr ;
        bool m_has_autoUpdate_attr ;
        boolean m_autoUpdate_attr ;
        bool m_has_mergeInterval_attr ;
        unsignedInt m_mergeInterval_attr ;
        bool m_has_changesSavedWin_attr ;
        boolean m_changesSavedWin_attr ;
        bool m_has_onlySync_attr ;
        boolean m_onlySync_attr ;
        bool m_has_personalView_attr ;
        boolean m_personalView_attr ;
        bool m_has_includePrintSettings_attr ;
        boolean m_includePrintSettings_attr ;
        bool m_has_includeHiddenRowCol_attr ;
        boolean m_includeHiddenRowCol_attr ;
        bool m_has_maximized_attr ;
        boolean m_maximized_attr ;
        bool m_has_minimized_attr ;
        boolean m_minimized_attr ;
        bool m_has_showHorizontalScroll_attr ;
        boolean m_showHorizontalScroll_attr ;
        bool m_has_showVerticalScroll_attr ;
        boolean m_showVerticalScroll_attr ;
        bool m_has_showSheetTabs_attr ;
        boolean m_showSheetTabs_attr ;
        bool m_has_xWindow_attr ;
        int m_xWindow_attr ;
        bool m_has_yWindow_attr ;
        int m_yWindow_attr ;
        bool m_has_windowWidth_attr ;
        unsignedInt m_windowWidth_attr ;
        bool m_has_windowHeight_attr ;
        unsignedInt m_windowHeight_attr ;
        bool m_has_tabRatio_attr ;
        unsignedInt m_tabRatio_attr ;
        bool m_has_activeSheetId_attr ;
        unsignedInt m_activeSheetId_attr ;
        bool m_has_showFormulaBar_attr ;
        boolean m_showFormulaBar_attr ;
        bool m_has_showStatusbar_attr ;
        boolean m_showStatusbar_attr ;
        bool m_has_showComments_attr ;
        ST_Comments* m_showComments_attr ;
        bool m_has_showObjects_attr ;
        ST_Objects* m_showObjects_attr ;

    }

    class CT_Sheets : public XSD::ComplexType{
    public:
        bool has_sheet(){

            return m_has_sheet;
        
        }
        CT_Sheet* mutable_sheet(){

                m_has_sheet = true;
                if (!m_sheet)
                {
                    m_sheet = new CT_Sheet();
                }
                return m_sheet;
            
        }
        const CT_Sheet& sheet(){

            if (m_sheet)
            {
                return *m_sheet;
            }
            return CT_Sheet::default_instance();
        
        }
        void clear(){

                m_has_sheet = false;
                
        if (m_sheet)
        {
            delete m_sheet;
            m_sheet = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_sheet)
                {
                    m_sheet->toXml(sheet, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Sheets& default_instance(){

    if (!CT_Sheets::default_instance_)
    {
        CT_Sheets::default_instance_ = new CT_Sheets();
    }
    return *CT_Sheets::default_instance_;

        }

    private:
        bool m_has_sheet ;
        CT_Sheet* m_sheet ;
        static CT_Sheets* default_instance_ ;

    }

    class CT_Sheet : public XSD::ComplexType{
    public:
        void clear(){

                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
                m_has_sheetId_attr = false;
                m_sheetId_attr = 0;
            
                m_has_state_attr = false;
                
        if (m_state_attr)
        {
            delete m_state_attr;
            m_state_attr = NULL;
        }
    
            
                m_has_id_attr = false;
                
        if (m_id_attr)
        {
            delete m_id_attr;
            m_id_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_name_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_sheetId_attr << \\\;
m_state_attr->toXml(_attrName, _outStream);
m_id_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_Sheet& default_instance(){

    if (!CT_Sheet::default_instance_)
    {
        CT_Sheet::default_instance_ = new CT_Sheet();
    }
    return *CT_Sheet::default_instance_;

        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_sheetId_attr(){

            return m_has_sheetId_attr;
        
        }
        void set_sheetId_attr(const unsignedInt& _sheetId_attr ){

        m_has_sheetId_attr = true;
        m_sheetId_attr = _sheetId_attr;
        
        }
        const unsignedInt& sheetId_attr(){

            return type: \unsignedInt\nname: \m_sheetId_attr\n;
        
        }
        bool has_state_attr(){

            return m_has_state_attr;
        
        }
        void set_state_attr(const ST_SheetState& _state_attr ){

            m_has_state_attr = true;
            m_state_attr = new ST_SheetState(_state_attr);
        
        }
        const ST_SheetState& state_attr(){

            if (m_state_attr)
            {
                return *m_state_attr;
            }
            return ST_SheetState::default_instance();
        
        }
        bool has_id_attr(){

            return m_has_id_attr;
        
        }
        void set_id_attr(const ST_RelationshipId& _id_attr ){

            m_has_id_attr = true;
            m_id_attr = new ST_RelationshipId(_id_attr);
        
        }
        const ST_RelationshipId& id_attr(){

            if (m_id_attr)
            {
                return *m_id_attr;
            }
            return ST_RelationshipId::default_instance();
        
        }

    private:
        static CT_Sheet* default_instance_ ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;
        bool m_has_sheetId_attr ;
        unsignedInt m_sheetId_attr ;
        bool m_has_state_attr ;
        ST_SheetState* m_state_attr ;
        bool m_has_id_attr ;
        ST_RelationshipId* m_id_attr ;

    }

    class CT_WorkbookPr : public XSD::ComplexType{
    public:
        void clear(){

                m_has_date1904_attr = false;
                m_date1904_attr = false;
            
                m_has_showObjects_attr = false;
                
        if (m_showObjects_attr)
        {
            delete m_showObjects_attr;
            m_showObjects_attr = NULL;
        }
    
            
                m_has_showBorderUnselectedTables_attr = false;
                m_showBorderUnselectedTables_attr = false;
            
                m_has_filterPrivacy_attr = false;
                m_filterPrivacy_attr = false;
            
                m_has_promptedSolutions_attr = false;
                m_promptedSolutions_attr = false;
            
                m_has_showInkAnnotation_attr = false;
                m_showInkAnnotation_attr = false;
            
                m_has_backupFile_attr = false;
                m_backupFile_attr = false;
            
                m_has_saveExternalLinkValues_attr = false;
                m_saveExternalLinkValues_attr = false;
            
                m_has_updateLinks_attr = false;
                
        if (m_updateLinks_attr)
        {
            delete m_updateLinks_attr;
            m_updateLinks_attr = NULL;
        }
    
            
                m_has_codeName_attr = false;
                m_codeName_attr.clear();
            
                m_has_hidePivotFieldList_attr = false;
                m_hidePivotFieldList_attr = false;
            
                m_has_showPivotChartFilter_attr = false;
                m_showPivotChartFilter_attr = false;
            
                m_has_allowRefreshQuery_attr = false;
                m_allowRefreshQuery_attr = false;
            
                m_has_publishItems_attr = false;
                m_publishItems_attr = false;
            
                m_has_checkCompatibility_attr = false;
                m_checkCompatibility_attr = false;
            
                m_has_autoCompressPictures_attr = false;
                m_autoCompressPictures_attr = false;
            
                m_has_refreshAllConnections_attr = false;
                m_refreshAllConnections_attr = false;
            
                m_has_defaultThemeVersion_attr = false;
                m_defaultThemeVersion_attr = 0;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_date1904_attr) << \\\;
m_showObjects_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showBorderUnselectedTables_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_filterPrivacy_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_promptedSolutions_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showInkAnnotation_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_backupFile_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_saveExternalLinkValues_attr) << \\\;
m_updateLinks_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_codeName_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_hidePivotFieldList_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_showPivotChartFilter_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_allowRefreshQuery_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_publishItems_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_checkCompatibility_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_autoCompressPictures_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_refreshAllConnections_attr) << \\\;
_outStream << _attrName << \=\\ << m_defaultThemeVersion_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_WorkbookPr& default_instance(){

    if (!CT_WorkbookPr::default_instance_)
    {
        CT_WorkbookPr::default_instance_ = new CT_WorkbookPr();
    }
    return *CT_WorkbookPr::default_instance_;

        }
        bool has_date1904_attr(){

            return m_has_date1904_attr;
        
        }
        void set_date1904_attr(const boolean& _date1904_attr ){

        m_has_date1904_attr = true;
        m_date1904_attr = _date1904_attr;
        
        }
        const boolean& date1904_attr(){

            return type: oolean\nname: \m_date1904_attr\n;
        
        }
        bool has_showObjects_attr(){

            return m_has_showObjects_attr;
        
        }
        void set_showObjects_attr(const ST_Objects& _showObjects_attr ){

            m_has_showObjects_attr = true;
            m_showObjects_attr = new ST_Objects(_showObjects_attr);
        
        }
        const ST_Objects& showObjects_attr(){

            if (m_showObjects_attr)
            {
                return *m_showObjects_attr;
            }
            return ST_Objects::default_instance();
        
        }
        bool has_showBorderUnselectedTables_attr(){

            return m_has_showBorderUnselectedTables_attr;
        
        }
        void set_showBorderUnselectedTables_attr(const boolean& _showBorderUnselectedTables_attr ){

        m_has_showBorderUnselectedTables_attr = true;
        m_showBorderUnselectedTables_attr = _showBorderUnselectedTables_attr;
        
        }
        const boolean& showBorderUnselectedTables_attr(){

            return type: oolean\nname: \m_showBorderUnselectedTables_attr\n;
        
        }
        bool has_filterPrivacy_attr(){

            return m_has_filterPrivacy_attr;
        
        }
        void set_filterPrivacy_attr(const boolean& _filterPrivacy_attr ){

        m_has_filterPrivacy_attr = true;
        m_filterPrivacy_attr = _filterPrivacy_attr;
        
        }
        const boolean& filterPrivacy_attr(){

            return type: oolean\nname: \m_filterPrivacy_attr\n;
        
        }
        bool has_promptedSolutions_attr(){

            return m_has_promptedSolutions_attr;
        
        }
        void set_promptedSolutions_attr(const boolean& _promptedSolutions_attr ){

        m_has_promptedSolutions_attr = true;
        m_promptedSolutions_attr = _promptedSolutions_attr;
        
        }
        const boolean& promptedSolutions_attr(){

            return type: oolean\nname: \m_promptedSolutions_attr\n;
        
        }
        bool has_showInkAnnotation_attr(){

            return m_has_showInkAnnotation_attr;
        
        }
        void set_showInkAnnotation_attr(const boolean& _showInkAnnotation_attr ){

        m_has_showInkAnnotation_attr = true;
        m_showInkAnnotation_attr = _showInkAnnotation_attr;
        
        }
        const boolean& showInkAnnotation_attr(){

            return type: oolean\nname: \m_showInkAnnotation_attr\n;
        
        }
        bool has_backupFile_attr(){

            return m_has_backupFile_attr;
        
        }
        void set_backupFile_attr(const boolean& _backupFile_attr ){

        m_has_backupFile_attr = true;
        m_backupFile_attr = _backupFile_attr;
        
        }
        const boolean& backupFile_attr(){

            return type: oolean\nname: \m_backupFile_attr\n;
        
        }
        bool has_saveExternalLinkValues_attr(){

            return m_has_saveExternalLinkValues_attr;
        
        }
        void set_saveExternalLinkValues_attr(const boolean& _saveExternalLinkValues_attr ){

        m_has_saveExternalLinkValues_attr = true;
        m_saveExternalLinkValues_attr = _saveExternalLinkValues_attr;
        
        }
        const boolean& saveExternalLinkValues_attr(){

            return type: oolean\nname: \m_saveExternalLinkValues_attr\n;
        
        }
        bool has_updateLinks_attr(){

            return m_has_updateLinks_attr;
        
        }
        void set_updateLinks_attr(const ST_UpdateLinks& _updateLinks_attr ){

            m_has_updateLinks_attr = true;
            m_updateLinks_attr = new ST_UpdateLinks(_updateLinks_attr);
        
        }
        const ST_UpdateLinks& updateLinks_attr(){

            if (m_updateLinks_attr)
            {
                return *m_updateLinks_attr;
            }
            return ST_UpdateLinks::default_instance();
        
        }
        bool has_codeName_attr(){

            return m_has_codeName_attr;
        
        }
        void set_codeName_attr(const string& _codeName_attr ){

        m_has_codeName_attr = true;
        m_codeName_attr = _codeName_attr;
        
        }
        const string& codeName_attr(){

            return type: \string\nname: \m_codeName_attr\n;
        
        }
        bool has_hidePivotFieldList_attr(){

            return m_has_hidePivotFieldList_attr;
        
        }
        void set_hidePivotFieldList_attr(const boolean& _hidePivotFieldList_attr ){

        m_has_hidePivotFieldList_attr = true;
        m_hidePivotFieldList_attr = _hidePivotFieldList_attr;
        
        }
        const boolean& hidePivotFieldList_attr(){

            return type: oolean\nname: \m_hidePivotFieldList_attr\n;
        
        }
        bool has_showPivotChartFilter_attr(){

            return m_has_showPivotChartFilter_attr;
        
        }
        void set_showPivotChartFilter_attr(const boolean& _showPivotChartFilter_attr ){

        m_has_showPivotChartFilter_attr = true;
        m_showPivotChartFilter_attr = _showPivotChartFilter_attr;
        
        }
        const boolean& showPivotChartFilter_attr(){

            return type: oolean\nname: \m_showPivotChartFilter_attr\n;
        
        }
        bool has_allowRefreshQuery_attr(){

            return m_has_allowRefreshQuery_attr;
        
        }
        void set_allowRefreshQuery_attr(const boolean& _allowRefreshQuery_attr ){

        m_has_allowRefreshQuery_attr = true;
        m_allowRefreshQuery_attr = _allowRefreshQuery_attr;
        
        }
        const boolean& allowRefreshQuery_attr(){

            return type: oolean\nname: \m_allowRefreshQuery_attr\n;
        
        }
        bool has_publishItems_attr(){

            return m_has_publishItems_attr;
        
        }
        void set_publishItems_attr(const boolean& _publishItems_attr ){

        m_has_publishItems_attr = true;
        m_publishItems_attr = _publishItems_attr;
        
        }
        const boolean& publishItems_attr(){

            return type: oolean\nname: \m_publishItems_attr\n;
        
        }
        bool has_checkCompatibility_attr(){

            return m_has_checkCompatibility_attr;
        
        }
        void set_checkCompatibility_attr(const boolean& _checkCompatibility_attr ){

        m_has_checkCompatibility_attr = true;
        m_checkCompatibility_attr = _checkCompatibility_attr;
        
        }
        const boolean& checkCompatibility_attr(){

            return type: oolean\nname: \m_checkCompatibility_attr\n;
        
        }
        bool has_autoCompressPictures_attr(){

            return m_has_autoCompressPictures_attr;
        
        }
        void set_autoCompressPictures_attr(const boolean& _autoCompressPictures_attr ){

        m_has_autoCompressPictures_attr = true;
        m_autoCompressPictures_attr = _autoCompressPictures_attr;
        
        }
        const boolean& autoCompressPictures_attr(){

            return type: oolean\nname: \m_autoCompressPictures_attr\n;
        
        }
        bool has_refreshAllConnections_attr(){

            return m_has_refreshAllConnections_attr;
        
        }
        void set_refreshAllConnections_attr(const boolean& _refreshAllConnections_attr ){

        m_has_refreshAllConnections_attr = true;
        m_refreshAllConnections_attr = _refreshAllConnections_attr;
        
        }
        const boolean& refreshAllConnections_attr(){

            return type: oolean\nname: \m_refreshAllConnections_attr\n;
        
        }
        bool has_defaultThemeVersion_attr(){

            return m_has_defaultThemeVersion_attr;
        
        }
        void set_defaultThemeVersion_attr(const unsignedInt& _defaultThemeVersion_attr ){

        m_has_defaultThemeVersion_attr = true;
        m_defaultThemeVersion_attr = _defaultThemeVersion_attr;
        
        }
        const unsignedInt& defaultThemeVersion_attr(){

            return type: \unsignedInt\nname: \m_defaultThemeVersion_attr\n;
        
        }

    private:
        static CT_WorkbookPr* default_instance_ ;
        bool m_has_date1904_attr ;
        boolean m_date1904_attr ;
        bool m_has_showObjects_attr ;
        ST_Objects* m_showObjects_attr ;
        bool m_has_showBorderUnselectedTables_attr ;
        boolean m_showBorderUnselectedTables_attr ;
        bool m_has_filterPrivacy_attr ;
        boolean m_filterPrivacy_attr ;
        bool m_has_promptedSolutions_attr ;
        boolean m_promptedSolutions_attr ;
        bool m_has_showInkAnnotation_attr ;
        boolean m_showInkAnnotation_attr ;
        bool m_has_backupFile_attr ;
        boolean m_backupFile_attr ;
        bool m_has_saveExternalLinkValues_attr ;
        boolean m_saveExternalLinkValues_attr ;
        bool m_has_updateLinks_attr ;
        ST_UpdateLinks* m_updateLinks_attr ;
        bool m_has_codeName_attr ;
        string m_codeName_attr ;
        bool m_has_hidePivotFieldList_attr ;
        boolean m_hidePivotFieldList_attr ;
        bool m_has_showPivotChartFilter_attr ;
        boolean m_showPivotChartFilter_attr ;
        bool m_has_allowRefreshQuery_attr ;
        boolean m_allowRefreshQuery_attr ;
        bool m_has_publishItems_attr ;
        boolean m_publishItems_attr ;
        bool m_has_checkCompatibility_attr ;
        boolean m_checkCompatibility_attr ;
        bool m_has_autoCompressPictures_attr ;
        boolean m_autoCompressPictures_attr ;
        bool m_has_refreshAllConnections_attr ;
        boolean m_refreshAllConnections_attr ;
        bool m_has_defaultThemeVersion_attr ;
        unsignedInt m_defaultThemeVersion_attr ;

    }

    class CT_SmartTagPr : public XSD::ComplexType{
    public:
        void clear(){

                m_has_embed_attr = false;
                m_embed_attr = false;
            
                m_has_show_attr = false;
                
        if (m_show_attr)
        {
            delete m_show_attr;
            m_show_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_embed_attr) << \\\;
m_show_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_SmartTagPr& default_instance(){

    if (!CT_SmartTagPr::default_instance_)
    {
        CT_SmartTagPr::default_instance_ = new CT_SmartTagPr();
    }
    return *CT_SmartTagPr::default_instance_;

        }
        bool has_embed_attr(){

            return m_has_embed_attr;
        
        }
        void set_embed_attr(const boolean& _embed_attr ){

        m_has_embed_attr = true;
        m_embed_attr = _embed_attr;
        
        }
        const boolean& embed_attr(){

            return type: oolean\nname: \m_embed_attr\n;
        
        }
        bool has_show_attr(){

            return m_has_show_attr;
        
        }
        void set_show_attr(const ST_SmartTagShow& _show_attr ){

            m_has_show_attr = true;
            m_show_attr = new ST_SmartTagShow(_show_attr);
        
        }
        const ST_SmartTagShow& show_attr(){

            if (m_show_attr)
            {
                return *m_show_attr;
            }
            return ST_SmartTagShow::default_instance();
        
        }

    private:
        static CT_SmartTagPr* default_instance_ ;
        bool m_has_embed_attr ;
        boolean m_embed_attr ;
        bool m_has_show_attr ;
        ST_SmartTagShow* m_show_attr ;

    }

    class CT_SmartTagTypes : public XSD::ComplexType{
    public:
        bool has_smartTagType(){

            return m_has_smartTagType;
        
        }
        CT_SmartTagType* mutable_smartTagType(){

                m_has_smartTagType = true;
                if (!m_smartTagType)
                {
                    m_smartTagType = new CT_SmartTagType();
                }
                return m_smartTagType;
            
        }
        const CT_SmartTagType& smartTagType(){

            if (m_smartTagType)
            {
                return *m_smartTagType;
            }
            return CT_SmartTagType::default_instance();
        
        }
        void clear(){

                m_has_smartTagType = false;
                
        if (m_smartTagType)
        {
            delete m_smartTagType;
            m_smartTagType = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_smartTagType)
                {
                    m_smartTagType->toXml(smartTagType, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_SmartTagTypes& default_instance(){

    if (!CT_SmartTagTypes::default_instance_)
    {
        CT_SmartTagTypes::default_instance_ = new CT_SmartTagTypes();
    }
    return *CT_SmartTagTypes::default_instance_;

        }

    private:
        bool m_has_smartTagType ;
        CT_SmartTagType* m_smartTagType ;
        static CT_SmartTagTypes* default_instance_ ;

    }

    class CT_SmartTagType : public XSD::ComplexType{
    public:
        void clear(){

                m_has_namespaceUri_attr = false;
                
        if (m_namespaceUri_attr)
        {
            delete m_namespaceUri_attr;
            m_namespaceUri_attr = NULL;
        }
    
            
                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
                m_has_url_attr = false;
                
        if (m_url_attr)
        {
            delete m_url_attr;
            m_url_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_namespaceUri_attr->toXml(_attrName, _outStream);
m_name_attr->toXml(_attrName, _outStream);
m_url_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_SmartTagType& default_instance(){

    if (!CT_SmartTagType::default_instance_)
    {
        CT_SmartTagType::default_instance_ = new CT_SmartTagType();
    }
    return *CT_SmartTagType::default_instance_;

        }
        bool has_namespaceUri_attr(){

            return m_has_namespaceUri_attr;
        
        }
        void set_namespaceUri_attr(const ns_s::ST_Xstring& _namespaceUri_attr ){

            m_has_namespaceUri_attr = true;
            m_namespaceUri_attr = new ns_s::ST_Xstring(_namespaceUri_attr);
        
        }
        const ns_s::ST_Xstring& namespaceUri_attr(){

            if (m_namespaceUri_attr)
            {
                return *m_namespaceUri_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_url_attr(){

            return m_has_url_attr;
        
        }
        void set_url_attr(const ns_s::ST_Xstring& _url_attr ){

            m_has_url_attr = true;
            m_url_attr = new ns_s::ST_Xstring(_url_attr);
        
        }
        const ns_s::ST_Xstring& url_attr(){

            if (m_url_attr)
            {
                return *m_url_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }

    private:
        static CT_SmartTagType* default_instance_ ;
        bool m_has_namespaceUri_attr ;
        ns_s::ST_Xstring* m_namespaceUri_attr ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;
        bool m_has_url_attr ;
        ns_s::ST_Xstring* m_url_attr ;

    }

    class CT_FileRecoveryPr : public XSD::ComplexType{
    public:
        void clear(){

                m_has_autoRecover_attr = false;
                m_autoRecover_attr = false;
            
                m_has_crashSave_attr = false;
                m_crashSave_attr = false;
            
                m_has_dataExtractLoad_attr = false;
                m_dataExtractLoad_attr = false;
            
                m_has_repairLoad_attr = false;
                m_repairLoad_attr = false;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_autoRecover_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_crashSave_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_dataExtractLoad_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_repairLoad_attr) << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_FileRecoveryPr& default_instance(){

    if (!CT_FileRecoveryPr::default_instance_)
    {
        CT_FileRecoveryPr::default_instance_ = new CT_FileRecoveryPr();
    }
    return *CT_FileRecoveryPr::default_instance_;

        }
        bool has_autoRecover_attr(){

            return m_has_autoRecover_attr;
        
        }
        void set_autoRecover_attr(const boolean& _autoRecover_attr ){

        m_has_autoRecover_attr = true;
        m_autoRecover_attr = _autoRecover_attr;
        
        }
        const boolean& autoRecover_attr(){

            return type: oolean\nname: \m_autoRecover_attr\n;
        
        }
        bool has_crashSave_attr(){

            return m_has_crashSave_attr;
        
        }
        void set_crashSave_attr(const boolean& _crashSave_attr ){

        m_has_crashSave_attr = true;
        m_crashSave_attr = _crashSave_attr;
        
        }
        const boolean& crashSave_attr(){

            return type: oolean\nname: \m_crashSave_attr\n;
        
        }
        bool has_dataExtractLoad_attr(){

            return m_has_dataExtractLoad_attr;
        
        }
        void set_dataExtractLoad_attr(const boolean& _dataExtractLoad_attr ){

        m_has_dataExtractLoad_attr = true;
        m_dataExtractLoad_attr = _dataExtractLoad_attr;
        
        }
        const boolean& dataExtractLoad_attr(){

            return type: oolean\nname: \m_dataExtractLoad_attr\n;
        
        }
        bool has_repairLoad_attr(){

            return m_has_repairLoad_attr;
        
        }
        void set_repairLoad_attr(const boolean& _repairLoad_attr ){

        m_has_repairLoad_attr = true;
        m_repairLoad_attr = _repairLoad_attr;
        
        }
        const boolean& repairLoad_attr(){

            return type: oolean\nname: \m_repairLoad_attr\n;
        
        }

    private:
        static CT_FileRecoveryPr* default_instance_ ;
        bool m_has_autoRecover_attr ;
        boolean m_autoRecover_attr ;
        bool m_has_crashSave_attr ;
        boolean m_crashSave_attr ;
        bool m_has_dataExtractLoad_attr ;
        boolean m_dataExtractLoad_attr ;
        bool m_has_repairLoad_attr ;
        boolean m_repairLoad_attr ;

    }

    class CT_CalcPr : public XSD::ComplexType{
    public:
        void clear(){

                m_has_calcId_attr = false;
                m_calcId_attr = 0;
            
                m_has_calcMode_attr = false;
                
        if (m_calcMode_attr)
        {
            delete m_calcMode_attr;
            m_calcMode_attr = NULL;
        }
    
            
                m_has_fullCalcOnLoad_attr = false;
                m_fullCalcOnLoad_attr = false;
            
                m_has_refMode_attr = false;
                
        if (m_refMode_attr)
        {
            delete m_refMode_attr;
            m_refMode_attr = NULL;
        }
    
            
                m_has_iterate_attr = false;
                m_iterate_attr = false;
            
                m_has_iterateCount_attr = false;
                m_iterateCount_attr = 0;
            
                m_has_iterateDelta_attr = false;
                m_iterateDelta_attr = 0;
            
                m_has_fullPrecision_attr = false;
                m_fullPrecision_attr = false;
            
                m_has_calcCompleted_attr = false;
                m_calcCompleted_attr = false;
            
                m_has_calcOnSave_attr = false;
                m_calcOnSave_attr = false;
            
                m_has_concurrentCalc_attr = false;
                m_concurrentCalc_attr = false;
            
                m_has_concurrentManualCount_attr = false;
                m_concurrentManualCount_attr = 0;
            
                m_has_forceFullCalc_attr = false;
                m_forceFullCalc_attr = false;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_calcId_attr << \\\;
m_calcMode_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_fullCalcOnLoad_attr) << \\\;
m_refMode_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_iterate_attr) << \\\;
_outStream << _attrName << \=\\ << m_iterateCount_attr << \\\;
_outStream << _attrName << \=\\ << m_iterateDelta_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_fullPrecision_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_calcCompleted_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_calcOnSave_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_concurrentCalc_attr) << \\\;
_outStream << _attrName << \=\\ << m_concurrentManualCount_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_forceFullCalc_attr) << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_CalcPr& default_instance(){

    if (!CT_CalcPr::default_instance_)
    {
        CT_CalcPr::default_instance_ = new CT_CalcPr();
    }
    return *CT_CalcPr::default_instance_;

        }
        bool has_calcId_attr(){

            return m_has_calcId_attr;
        
        }
        void set_calcId_attr(const unsignedInt& _calcId_attr ){

        m_has_calcId_attr = true;
        m_calcId_attr = _calcId_attr;
        
        }
        const unsignedInt& calcId_attr(){

            return type: \unsignedInt\nname: \m_calcId_attr\n;
        
        }
        bool has_calcMode_attr(){

            return m_has_calcMode_attr;
        
        }
        void set_calcMode_attr(const ST_CalcMode& _calcMode_attr ){

            m_has_calcMode_attr = true;
            m_calcMode_attr = new ST_CalcMode(_calcMode_attr);
        
        }
        const ST_CalcMode& calcMode_attr(){

            if (m_calcMode_attr)
            {
                return *m_calcMode_attr;
            }
            return ST_CalcMode::default_instance();
        
        }
        bool has_fullCalcOnLoad_attr(){

            return m_has_fullCalcOnLoad_attr;
        
        }
        void set_fullCalcOnLoad_attr(const boolean& _fullCalcOnLoad_attr ){

        m_has_fullCalcOnLoad_attr = true;
        m_fullCalcOnLoad_attr = _fullCalcOnLoad_attr;
        
        }
        const boolean& fullCalcOnLoad_attr(){

            return type: oolean\nname: \m_fullCalcOnLoad_attr\n;
        
        }
        bool has_refMode_attr(){

            return m_has_refMode_attr;
        
        }
        void set_refMode_attr(const ST_RefMode& _refMode_attr ){

            m_has_refMode_attr = true;
            m_refMode_attr = new ST_RefMode(_refMode_attr);
        
        }
        const ST_RefMode& refMode_attr(){

            if (m_refMode_attr)
            {
                return *m_refMode_attr;
            }
            return ST_RefMode::default_instance();
        
        }
        bool has_iterate_attr(){

            return m_has_iterate_attr;
        
        }
        void set_iterate_attr(const boolean& _iterate_attr ){

        m_has_iterate_attr = true;
        m_iterate_attr = _iterate_attr;
        
        }
        const boolean& iterate_attr(){

            return type: oolean\nname: \m_iterate_attr\n;
        
        }
        bool has_iterateCount_attr(){

            return m_has_iterateCount_attr;
        
        }
        void set_iterateCount_attr(const unsignedInt& _iterateCount_attr ){

        m_has_iterateCount_attr = true;
        m_iterateCount_attr = _iterateCount_attr;
        
        }
        const unsignedInt& iterateCount_attr(){

            return type: \unsignedInt\nname: \m_iterateCount_attr\n;
        
        }
        bool has_iterateDelta_attr(){

            return m_has_iterateDelta_attr;
        
        }
        void set_iterateDelta_attr(const double& _iterateDelta_attr ){

        m_has_iterateDelta_attr = true;
        m_iterateDelta_attr = _iterateDelta_attr;
        
        }
        const double& iterateDelta_attr(){

            return type: \double\nname: \m_iterateDelta_attr\n;
        
        }
        bool has_fullPrecision_attr(){

            return m_has_fullPrecision_attr;
        
        }
        void set_fullPrecision_attr(const boolean& _fullPrecision_attr ){

        m_has_fullPrecision_attr = true;
        m_fullPrecision_attr = _fullPrecision_attr;
        
        }
        const boolean& fullPrecision_attr(){

            return type: oolean\nname: \m_fullPrecision_attr\n;
        
        }
        bool has_calcCompleted_attr(){

            return m_has_calcCompleted_attr;
        
        }
        void set_calcCompleted_attr(const boolean& _calcCompleted_attr ){

        m_has_calcCompleted_attr = true;
        m_calcCompleted_attr = _calcCompleted_attr;
        
        }
        const boolean& calcCompleted_attr(){

            return type: oolean\nname: \m_calcCompleted_attr\n;
        
        }
        bool has_calcOnSave_attr(){

            return m_has_calcOnSave_attr;
        
        }
        void set_calcOnSave_attr(const boolean& _calcOnSave_attr ){

        m_has_calcOnSave_attr = true;
        m_calcOnSave_attr = _calcOnSave_attr;
        
        }
        const boolean& calcOnSave_attr(){

            return type: oolean\nname: \m_calcOnSave_attr\n;
        
        }
        bool has_concurrentCalc_attr(){

            return m_has_concurrentCalc_attr;
        
        }
        void set_concurrentCalc_attr(const boolean& _concurrentCalc_attr ){

        m_has_concurrentCalc_attr = true;
        m_concurrentCalc_attr = _concurrentCalc_attr;
        
        }
        const boolean& concurrentCalc_attr(){

            return type: oolean\nname: \m_concurrentCalc_attr\n;
        
        }
        bool has_concurrentManualCount_attr(){

            return m_has_concurrentManualCount_attr;
        
        }
        void set_concurrentManualCount_attr(const unsignedInt& _concurrentManualCount_attr ){

        m_has_concurrentManualCount_attr = true;
        m_concurrentManualCount_attr = _concurrentManualCount_attr;
        
        }
        const unsignedInt& concurrentManualCount_attr(){

            return type: \unsignedInt\nname: \m_concurrentManualCount_attr\n;
        
        }
        bool has_forceFullCalc_attr(){

            return m_has_forceFullCalc_attr;
        
        }
        void set_forceFullCalc_attr(const boolean& _forceFullCalc_attr ){

        m_has_forceFullCalc_attr = true;
        m_forceFullCalc_attr = _forceFullCalc_attr;
        
        }
        const boolean& forceFullCalc_attr(){

            return type: oolean\nname: \m_forceFullCalc_attr\n;
        
        }

    private:
        static CT_CalcPr* default_instance_ ;
        bool m_has_calcId_attr ;
        unsignedInt m_calcId_attr ;
        bool m_has_calcMode_attr ;
        ST_CalcMode* m_calcMode_attr ;
        bool m_has_fullCalcOnLoad_attr ;
        boolean m_fullCalcOnLoad_attr ;
        bool m_has_refMode_attr ;
        ST_RefMode* m_refMode_attr ;
        bool m_has_iterate_attr ;
        boolean m_iterate_attr ;
        bool m_has_iterateCount_attr ;
        unsignedInt m_iterateCount_attr ;
        bool m_has_iterateDelta_attr ;
        double m_iterateDelta_attr ;
        bool m_has_fullPrecision_attr ;
        boolean m_fullPrecision_attr ;
        bool m_has_calcCompleted_attr ;
        boolean m_calcCompleted_attr ;
        bool m_has_calcOnSave_attr ;
        boolean m_calcOnSave_attr ;
        bool m_has_concurrentCalc_attr ;
        boolean m_concurrentCalc_attr ;
        bool m_has_concurrentManualCount_attr ;
        unsignedInt m_concurrentManualCount_attr ;
        bool m_has_forceFullCalc_attr ;
        boolean m_forceFullCalc_attr ;

    }

    class CT_DefinedNames : public XSD::ComplexType{
    public:
        bool has_definedName(){

            return m_has_definedName;
        
        }
        CT_DefinedName* mutable_definedName(){

                m_has_definedName = true;
                if (!m_definedName)
                {
                    m_definedName = new CT_DefinedName();
                }
                return m_definedName;
            
        }
        const CT_DefinedName& definedName(){

            if (m_definedName)
            {
                return *m_definedName;
            }
            return CT_DefinedName::default_instance();
        
        }
        void clear(){

                m_has_definedName = false;
                
        if (m_definedName)
        {
            delete m_definedName;
            m_definedName = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_definedName)
                {
                    m_definedName->toXml(definedName, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_DefinedNames& default_instance(){

    if (!CT_DefinedNames::default_instance_)
    {
        CT_DefinedNames::default_instance_ = new CT_DefinedNames();
    }
    return *CT_DefinedNames::default_instance_;

        }

    private:
        bool m_has_definedName ;
        CT_DefinedName* m_definedName ;
        static CT_DefinedNames* default_instance_ ;

    }

    class CT_DefinedName : public XSD::ComplexType{
    public:
        void clear(){

        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_DefinedName& default_instance(){

    if (!CT_DefinedName::default_instance_)
    {
        CT_DefinedName::default_instance_ = new CT_DefinedName();
    }
    return *CT_DefinedName::default_instance_;

        }

    private:
        static CT_DefinedName* default_instance_ ;

    }

    class CT_ExternalReferences : public XSD::ComplexType{
    public:
        bool has_externalReference(){

            return m_has_externalReference;
        
        }
        CT_ExternalReference* mutable_externalReference(){

                m_has_externalReference = true;
                if (!m_externalReference)
                {
                    m_externalReference = new CT_ExternalReference();
                }
                return m_externalReference;
            
        }
        const CT_ExternalReference& externalReference(){

            if (m_externalReference)
            {
                return *m_externalReference;
            }
            return CT_ExternalReference::default_instance();
        
        }
        void clear(){

                m_has_externalReference = false;
                
        if (m_externalReference)
        {
            delete m_externalReference;
            m_externalReference = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_externalReference)
                {
                    m_externalReference->toXml(externalReference, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_ExternalReferences& default_instance(){

    if (!CT_ExternalReferences::default_instance_)
    {
        CT_ExternalReferences::default_instance_ = new CT_ExternalReferences();
    }
    return *CT_ExternalReferences::default_instance_;

        }

    private:
        bool m_has_externalReference ;
        CT_ExternalReference* m_externalReference ;
        static CT_ExternalReferences* default_instance_ ;

    }

    class CT_ExternalReference : public XSD::ComplexType{
    public:
        void clear(){

                m_has_id_attr = false;
                
        if (m_id_attr)
        {
            delete m_id_attr;
            m_id_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_id_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_ExternalReference& default_instance(){

    if (!CT_ExternalReference::default_instance_)
    {
        CT_ExternalReference::default_instance_ = new CT_ExternalReference();
    }
    return *CT_ExternalReference::default_instance_;

        }
        bool has_id_attr(){

            return m_has_id_attr;
        
        }
        void set_id_attr(const ST_RelationshipId& _id_attr ){

            m_has_id_attr = true;
            m_id_attr = new ST_RelationshipId(_id_attr);
        
        }
        const ST_RelationshipId& id_attr(){

            if (m_id_attr)
            {
                return *m_id_attr;
            }
            return ST_RelationshipId::default_instance();
        
        }

    private:
        static CT_ExternalReference* default_instance_ ;
        bool m_has_id_attr ;
        ST_RelationshipId* m_id_attr ;

    }

    class CT_SheetBackgroundPicture : public XSD::ComplexType{
    public:
        void clear(){

                m_has_id_attr = false;
                
        if (m_id_attr)
        {
            delete m_id_attr;
            m_id_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_id_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_SheetBackgroundPicture& default_instance(){

    if (!CT_SheetBackgroundPicture::default_instance_)
    {
        CT_SheetBackgroundPicture::default_instance_ = new CT_SheetBackgroundPicture();
    }
    return *CT_SheetBackgroundPicture::default_instance_;

        }
        bool has_id_attr(){

            return m_has_id_attr;
        
        }
        void set_id_attr(const ST_RelationshipId& _id_attr ){

            m_has_id_attr = true;
            m_id_attr = new ST_RelationshipId(_id_attr);
        
        }
        const ST_RelationshipId& id_attr(){

            if (m_id_attr)
            {
                return *m_id_attr;
            }
            return ST_RelationshipId::default_instance();
        
        }

    private:
        static CT_SheetBackgroundPicture* default_instance_ ;
        bool m_has_id_attr ;
        ST_RelationshipId* m_id_attr ;

    }

    class CT_PivotCaches : public XSD::ComplexType{
    public:
        bool has_pivotCache(){

            return m_has_pivotCache;
        
        }
        CT_PivotCache* mutable_pivotCache(){

                m_has_pivotCache = true;
                if (!m_pivotCache)
                {
                    m_pivotCache = new CT_PivotCache();
                }
                return m_pivotCache;
            
        }
        const CT_PivotCache& pivotCache(){

            if (m_pivotCache)
            {
                return *m_pivotCache;
            }
            return CT_PivotCache::default_instance();
        
        }
        void clear(){

                m_has_pivotCache = false;
                
        if (m_pivotCache)
        {
            delete m_pivotCache;
            m_pivotCache = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    
        _outStream << \>\;
    
                if (m_has_pivotCache)
                {
                    m_pivotCache->toXml(pivotCache, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_PivotCaches& default_instance(){

    if (!CT_PivotCaches::default_instance_)
    {
        CT_PivotCaches::default_instance_ = new CT_PivotCaches();
    }
    return *CT_PivotCaches::default_instance_;

        }

    private:
        bool m_has_pivotCache ;
        CT_PivotCache* m_pivotCache ;
        static CT_PivotCaches* default_instance_ ;

    }

    class CT_PivotCache : public XSD::ComplexType{
    public:
        void clear(){

                m_has_cacheId_attr = false;
                m_cacheId_attr = 0;
            
                m_has_id_attr = false;
                
        if (m_id_attr)
        {
            delete m_id_attr;
            m_id_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_cacheId_attr << \\\;
m_id_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_PivotCache& default_instance(){

    if (!CT_PivotCache::default_instance_)
    {
        CT_PivotCache::default_instance_ = new CT_PivotCache();
    }
    return *CT_PivotCache::default_instance_;

        }
        bool has_cacheId_attr(){

            return m_has_cacheId_attr;
        
        }
        void set_cacheId_attr(const unsignedInt& _cacheId_attr ){

        m_has_cacheId_attr = true;
        m_cacheId_attr = _cacheId_attr;
        
        }
        const unsignedInt& cacheId_attr(){

            return type: \unsignedInt\nname: \m_cacheId_attr\n;
        
        }
        bool has_id_attr(){

            return m_has_id_attr;
        
        }
        void set_id_attr(const ST_RelationshipId& _id_attr ){

            m_has_id_attr = true;
            m_id_attr = new ST_RelationshipId(_id_attr);
        
        }
        const ST_RelationshipId& id_attr(){

            if (m_id_attr)
            {
                return *m_id_attr;
            }
            return ST_RelationshipId::default_instance();
        
        }

    private:
        static CT_PivotCache* default_instance_ ;
        bool m_has_cacheId_attr ;
        unsignedInt m_cacheId_attr ;
        bool m_has_id_attr ;
        ST_RelationshipId* m_id_attr ;

    }

    class CT_FileSharing : public XSD::ComplexType{
    public:
        void clear(){

                m_has_readOnlyRecommended_attr = false;
                m_readOnlyRecommended_attr = false;
            
                m_has_userName_attr = false;
                
        if (m_userName_attr)
        {
            delete m_userName_attr;
            m_userName_attr = NULL;
        }
    
            
                m_has_reservationPassword_attr = false;
                
        if (m_reservationPassword_attr)
        {
            delete m_reservationPassword_attr;
            m_reservationPassword_attr = NULL;
        }
    
            
                m_has_algorithmName_attr = false;
                
        if (m_algorithmName_attr)
        {
            delete m_algorithmName_attr;
            m_algorithmName_attr = NULL;
        }
    
            
                m_has_hashValue_attr = false;
                m_hashValue_attr.clear();
            
                m_has_saltValue_attr = false;
                m_saltValue_attr.clear();
            
                m_has_spinCount_attr = false;
                m_spinCount_attr = 0;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_readOnlyRecommended_attr) << \\\;
m_userName_attr->toXml(_attrName, _outStream);
m_reservationPassword_attr->toXml(_attrName, _outStream);
m_algorithmName_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_hashValue_attr << \\\;
_outStream << _attrName << \=\\ << m_saltValue_attr << \\\;
_outStream << _attrName << \=\\ << m_spinCount_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_FileSharing& default_instance(){

    if (!CT_FileSharing::default_instance_)
    {
        CT_FileSharing::default_instance_ = new CT_FileSharing();
    }
    return *CT_FileSharing::default_instance_;

        }
        bool has_readOnlyRecommended_attr(){

            return m_has_readOnlyRecommended_attr;
        
        }
        void set_readOnlyRecommended_attr(const boolean& _readOnlyRecommended_attr ){

        m_has_readOnlyRecommended_attr = true;
        m_readOnlyRecommended_attr = _readOnlyRecommended_attr;
        
        }
        const boolean& readOnlyRecommended_attr(){

            return type: oolean\nname: \m_readOnlyRecommended_attr\n;
        
        }
        bool has_userName_attr(){

            return m_has_userName_attr;
        
        }
        void set_userName_attr(const ns_s::ST_Xstring& _userName_attr ){

            m_has_userName_attr = true;
            m_userName_attr = new ns_s::ST_Xstring(_userName_attr);
        
        }
        const ns_s::ST_Xstring& userName_attr(){

            if (m_userName_attr)
            {
                return *m_userName_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_reservationPassword_attr(){

            return m_has_reservationPassword_attr;
        
        }
        void set_reservationPassword_attr(const ST_UnsignedShortHex& _reservationPassword_attr ){

            m_has_reservationPassword_attr = true;
            m_reservationPassword_attr = new ST_UnsignedShortHex(_reservationPassword_attr);
        
        }
        const ST_UnsignedShortHex& reservationPassword_attr(){

            if (m_reservationPassword_attr)
            {
                return *m_reservationPassword_attr;
            }
            return ST_UnsignedShortHex::default_instance();
        
        }
        bool has_algorithmName_attr(){

            return m_has_algorithmName_attr;
        
        }
        void set_algorithmName_attr(const ns_s::ST_Xstring& _algorithmName_attr ){

            m_has_algorithmName_attr = true;
            m_algorithmName_attr = new ns_s::ST_Xstring(_algorithmName_attr);
        
        }
        const ns_s::ST_Xstring& algorithmName_attr(){

            if (m_algorithmName_attr)
            {
                return *m_algorithmName_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_hashValue_attr(){

            return m_has_hashValue_attr;
        
        }
        void set_hashValue_attr(const base64Binary& _hashValue_attr ){

        m_has_hashValue_attr = true;
        m_hashValue_attr = _hashValue_attr;
        
        }
        const base64Binary& hashValue_attr(){

            return type: ase64Binary\nname: \m_hashValue_attr\n;
        
        }
        bool has_saltValue_attr(){

            return m_has_saltValue_attr;
        
        }
        void set_saltValue_attr(const base64Binary& _saltValue_attr ){

        m_has_saltValue_attr = true;
        m_saltValue_attr = _saltValue_attr;
        
        }
        const base64Binary& saltValue_attr(){

            return type: ase64Binary\nname: \m_saltValue_attr\n;
        
        }
        bool has_spinCount_attr(){

            return m_has_spinCount_attr;
        
        }
        void set_spinCount_attr(const unsignedInt& _spinCount_attr ){

        m_has_spinCount_attr = true;
        m_spinCount_attr = _spinCount_attr;
        
        }
        const unsignedInt& spinCount_attr(){

            return type: \unsignedInt\nname: \m_spinCount_attr\n;
        
        }

    private:
        static CT_FileSharing* default_instance_ ;
        bool m_has_readOnlyRecommended_attr ;
        boolean m_readOnlyRecommended_attr ;
        bool m_has_userName_attr ;
        ns_s::ST_Xstring* m_userName_attr ;
        bool m_has_reservationPassword_attr ;
        ST_UnsignedShortHex* m_reservationPassword_attr ;
        bool m_has_algorithmName_attr ;
        ns_s::ST_Xstring* m_algorithmName_attr ;
        bool m_has_hashValue_attr ;
        base64Binary m_hashValue_attr ;
        bool m_has_saltValue_attr ;
        base64Binary m_saltValue_attr ;
        bool m_has_spinCount_attr ;
        unsignedInt m_spinCount_attr ;

    }

    class CT_OleSize : public XSD::ComplexType{
    public:
        void clear(){

                m_has_ref_attr = false;
                
        if (m_ref_attr)
        {
            delete m_ref_attr;
            m_ref_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_ref_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_OleSize& default_instance(){

    if (!CT_OleSize::default_instance_)
    {
        CT_OleSize::default_instance_ = new CT_OleSize();
    }
    return *CT_OleSize::default_instance_;

        }
        bool has_ref_attr(){

            return m_has_ref_attr;
        
        }
        void set_ref_attr(const ST_Ref& _ref_attr ){

            m_has_ref_attr = true;
            m_ref_attr = new ST_Ref(_ref_attr);
        
        }
        const ST_Ref& ref_attr(){

            if (m_ref_attr)
            {
                return *m_ref_attr;
            }
            return ST_Ref::default_instance();
        
        }

    private:
        static CT_OleSize* default_instance_ ;
        bool m_has_ref_attr ;
        ST_Ref* m_ref_attr ;

    }

    class CT_WorkbookProtection : public XSD::ComplexType{
    public:
        void clear(){

                m_has_workbookPassword_attr = false;
                
        if (m_workbookPassword_attr)
        {
            delete m_workbookPassword_attr;
            m_workbookPassword_attr = NULL;
        }
    
            
                m_has_workbookPasswordCharacterSet_attr = false;
                m_workbookPasswordCharacterSet_attr.clear();
            
                m_has_revisionsPassword_attr = false;
                
        if (m_revisionsPassword_attr)
        {
            delete m_revisionsPassword_attr;
            m_revisionsPassword_attr = NULL;
        }
    
            
                m_has_revisionsPasswordCharacterSet_attr = false;
                m_revisionsPasswordCharacterSet_attr.clear();
            
                m_has_lockStructure_attr = false;
                m_lockStructure_attr = false;
            
                m_has_lockWindows_attr = false;
                m_lockWindows_attr = false;
            
                m_has_lockRevision_attr = false;
                m_lockRevision_attr = false;
            
                m_has_revisionsAlgorithmName_attr = false;
                
        if (m_revisionsAlgorithmName_attr)
        {
            delete m_revisionsAlgorithmName_attr;
            m_revisionsAlgorithmName_attr = NULL;
        }
    
            
                m_has_revisionsHashValue_attr = false;
                m_revisionsHashValue_attr.clear();
            
                m_has_revisionsSaltValue_attr = false;
                m_revisionsSaltValue_attr.clear();
            
                m_has_revisionsSpinCount_attr = false;
                m_revisionsSpinCount_attr = 0;
            
                m_has_workbookAlgorithmName_attr = false;
                
        if (m_workbookAlgorithmName_attr)
        {
            delete m_workbookAlgorithmName_attr;
            m_workbookAlgorithmName_attr = NULL;
        }
    
            
                m_has_workbookHashValue_attr = false;
                m_workbookHashValue_attr.clear();
            
                m_has_workbookSaltValue_attr = false;
                m_workbookSaltValue_attr.clear();
            
                m_has_workbookSpinCount_attr = false;
                m_workbookSpinCount_attr = 0;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_workbookPassword_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_workbookPasswordCharacterSet_attr << \\\;
m_revisionsPassword_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_revisionsPasswordCharacterSet_attr << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_lockStructure_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_lockWindows_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_lockRevision_attr) << \\\;
m_revisionsAlgorithmName_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_revisionsHashValue_attr << \\\;
_outStream << _attrName << \=\\ << m_revisionsSaltValue_attr << \\\;
_outStream << _attrName << \=\\ << m_revisionsSpinCount_attr << \\\;
m_workbookAlgorithmName_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_workbookHashValue_attr << \\\;
_outStream << _attrName << \=\\ << m_workbookSaltValue_attr << \\\;
_outStream << _attrName << \=\\ << m_workbookSpinCount_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_WorkbookProtection& default_instance(){

    if (!CT_WorkbookProtection::default_instance_)
    {
        CT_WorkbookProtection::default_instance_ = new CT_WorkbookProtection();
    }
    return *CT_WorkbookProtection::default_instance_;

        }
        bool has_workbookPassword_attr(){

            return m_has_workbookPassword_attr;
        
        }
        void set_workbookPassword_attr(const ST_UnsignedShortHex& _workbookPassword_attr ){

            m_has_workbookPassword_attr = true;
            m_workbookPassword_attr = new ST_UnsignedShortHex(_workbookPassword_attr);
        
        }
        const ST_UnsignedShortHex& workbookPassword_attr(){

            if (m_workbookPassword_attr)
            {
                return *m_workbookPassword_attr;
            }
            return ST_UnsignedShortHex::default_instance();
        
        }
        bool has_workbookPasswordCharacterSet_attr(){

            return m_has_workbookPasswordCharacterSet_attr;
        
        }
        void set_workbookPasswordCharacterSet_attr(const string& _workbookPasswordCharacterSet_attr ){

        m_has_workbookPasswordCharacterSet_attr = true;
        m_workbookPasswordCharacterSet_attr = _workbookPasswordCharacterSet_attr;
        
        }
        const string& workbookPasswordCharacterSet_attr(){

            return type: \string\nname: \m_workbookPasswordCharacterSet_attr\n;
        
        }
        bool has_revisionsPassword_attr(){

            return m_has_revisionsPassword_attr;
        
        }
        void set_revisionsPassword_attr(const ST_UnsignedShortHex& _revisionsPassword_attr ){

            m_has_revisionsPassword_attr = true;
            m_revisionsPassword_attr = new ST_UnsignedShortHex(_revisionsPassword_attr);
        
        }
        const ST_UnsignedShortHex& revisionsPassword_attr(){

            if (m_revisionsPassword_attr)
            {
                return *m_revisionsPassword_attr;
            }
            return ST_UnsignedShortHex::default_instance();
        
        }
        bool has_revisionsPasswordCharacterSet_attr(){

            return m_has_revisionsPasswordCharacterSet_attr;
        
        }
        void set_revisionsPasswordCharacterSet_attr(const string& _revisionsPasswordCharacterSet_attr ){

        m_has_revisionsPasswordCharacterSet_attr = true;
        m_revisionsPasswordCharacterSet_attr = _revisionsPasswordCharacterSet_attr;
        
        }
        const string& revisionsPasswordCharacterSet_attr(){

            return type: \string\nname: \m_revisionsPasswordCharacterSet_attr\n;
        
        }
        bool has_lockStructure_attr(){

            return m_has_lockStructure_attr;
        
        }
        void set_lockStructure_attr(const boolean& _lockStructure_attr ){

        m_has_lockStructure_attr = true;
        m_lockStructure_attr = _lockStructure_attr;
        
        }
        const boolean& lockStructure_attr(){

            return type: oolean\nname: \m_lockStructure_attr\n;
        
        }
        bool has_lockWindows_attr(){

            return m_has_lockWindows_attr;
        
        }
        void set_lockWindows_attr(const boolean& _lockWindows_attr ){

        m_has_lockWindows_attr = true;
        m_lockWindows_attr = _lockWindows_attr;
        
        }
        const boolean& lockWindows_attr(){

            return type: oolean\nname: \m_lockWindows_attr\n;
        
        }
        bool has_lockRevision_attr(){

            return m_has_lockRevision_attr;
        
        }
        void set_lockRevision_attr(const boolean& _lockRevision_attr ){

        m_has_lockRevision_attr = true;
        m_lockRevision_attr = _lockRevision_attr;
        
        }
        const boolean& lockRevision_attr(){

            return type: oolean\nname: \m_lockRevision_attr\n;
        
        }
        bool has_revisionsAlgorithmName_attr(){

            return m_has_revisionsAlgorithmName_attr;
        
        }
        void set_revisionsAlgorithmName_attr(const ns_s::ST_Xstring& _revisionsAlgorithmName_attr ){

            m_has_revisionsAlgorithmName_attr = true;
            m_revisionsAlgorithmName_attr = new ns_s::ST_Xstring(_revisionsAlgorithmName_attr);
        
        }
        const ns_s::ST_Xstring& revisionsAlgorithmName_attr(){

            if (m_revisionsAlgorithmName_attr)
            {
                return *m_revisionsAlgorithmName_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_revisionsHashValue_attr(){

            return m_has_revisionsHashValue_attr;
        
        }
        void set_revisionsHashValue_attr(const base64Binary& _revisionsHashValue_attr ){

        m_has_revisionsHashValue_attr = true;
        m_revisionsHashValue_attr = _revisionsHashValue_attr;
        
        }
        const base64Binary& revisionsHashValue_attr(){

            return type: ase64Binary\nname: \m_revisionsHashValue_attr\n;
        
        }
        bool has_revisionsSaltValue_attr(){

            return m_has_revisionsSaltValue_attr;
        
        }
        void set_revisionsSaltValue_attr(const base64Binary& _revisionsSaltValue_attr ){

        m_has_revisionsSaltValue_attr = true;
        m_revisionsSaltValue_attr = _revisionsSaltValue_attr;
        
        }
        const base64Binary& revisionsSaltValue_attr(){

            return type: ase64Binary\nname: \m_revisionsSaltValue_attr\n;
        
        }
        bool has_revisionsSpinCount_attr(){

            return m_has_revisionsSpinCount_attr;
        
        }
        void set_revisionsSpinCount_attr(const unsignedInt& _revisionsSpinCount_attr ){

        m_has_revisionsSpinCount_attr = true;
        m_revisionsSpinCount_attr = _revisionsSpinCount_attr;
        
        }
        const unsignedInt& revisionsSpinCount_attr(){

            return type: \unsignedInt\nname: \m_revisionsSpinCount_attr\n;
        
        }
        bool has_workbookAlgorithmName_attr(){

            return m_has_workbookAlgorithmName_attr;
        
        }
        void set_workbookAlgorithmName_attr(const ns_s::ST_Xstring& _workbookAlgorithmName_attr ){

            m_has_workbookAlgorithmName_attr = true;
            m_workbookAlgorithmName_attr = new ns_s::ST_Xstring(_workbookAlgorithmName_attr);
        
        }
        const ns_s::ST_Xstring& workbookAlgorithmName_attr(){

            if (m_workbookAlgorithmName_attr)
            {
                return *m_workbookAlgorithmName_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_workbookHashValue_attr(){

            return m_has_workbookHashValue_attr;
        
        }
        void set_workbookHashValue_attr(const base64Binary& _workbookHashValue_attr ){

        m_has_workbookHashValue_attr = true;
        m_workbookHashValue_attr = _workbookHashValue_attr;
        
        }
        const base64Binary& workbookHashValue_attr(){

            return type: ase64Binary\nname: \m_workbookHashValue_attr\n;
        
        }
        bool has_workbookSaltValue_attr(){

            return m_has_workbookSaltValue_attr;
        
        }
        void set_workbookSaltValue_attr(const base64Binary& _workbookSaltValue_attr ){

        m_has_workbookSaltValue_attr = true;
        m_workbookSaltValue_attr = _workbookSaltValue_attr;
        
        }
        const base64Binary& workbookSaltValue_attr(){

            return type: ase64Binary\nname: \m_workbookSaltValue_attr\n;
        
        }
        bool has_workbookSpinCount_attr(){

            return m_has_workbookSpinCount_attr;
        
        }
        void set_workbookSpinCount_attr(const unsignedInt& _workbookSpinCount_attr ){

        m_has_workbookSpinCount_attr = true;
        m_workbookSpinCount_attr = _workbookSpinCount_attr;
        
        }
        const unsignedInt& workbookSpinCount_attr(){

            return type: \unsignedInt\nname: \m_workbookSpinCount_attr\n;
        
        }

    private:
        static CT_WorkbookProtection* default_instance_ ;
        bool m_has_workbookPassword_attr ;
        ST_UnsignedShortHex* m_workbookPassword_attr ;
        bool m_has_workbookPasswordCharacterSet_attr ;
        string m_workbookPasswordCharacterSet_attr ;
        bool m_has_revisionsPassword_attr ;
        ST_UnsignedShortHex* m_revisionsPassword_attr ;
        bool m_has_revisionsPasswordCharacterSet_attr ;
        string m_revisionsPasswordCharacterSet_attr ;
        bool m_has_lockStructure_attr ;
        boolean m_lockStructure_attr ;
        bool m_has_lockWindows_attr ;
        boolean m_lockWindows_attr ;
        bool m_has_lockRevision_attr ;
        boolean m_lockRevision_attr ;
        bool m_has_revisionsAlgorithmName_attr ;
        ns_s::ST_Xstring* m_revisionsAlgorithmName_attr ;
        bool m_has_revisionsHashValue_attr ;
        base64Binary m_revisionsHashValue_attr ;
        bool m_has_revisionsSaltValue_attr ;
        base64Binary m_revisionsSaltValue_attr ;
        bool m_has_revisionsSpinCount_attr ;
        unsignedInt m_revisionsSpinCount_attr ;
        bool m_has_workbookAlgorithmName_attr ;
        ns_s::ST_Xstring* m_workbookAlgorithmName_attr ;
        bool m_has_workbookHashValue_attr ;
        base64Binary m_workbookHashValue_attr ;
        bool m_has_workbookSaltValue_attr ;
        base64Binary m_workbookSaltValue_attr ;
        bool m_has_workbookSpinCount_attr ;
        unsignedInt m_workbookSpinCount_attr ;

    }

    class CT_WebPublishing : public XSD::ComplexType{
    public:
        void clear(){

                m_has_css_attr = false;
                m_css_attr = false;
            
                m_has_thicket_attr = false;
                m_thicket_attr = false;
            
                m_has_longFileNames_attr = false;
                m_longFileNames_attr = false;
            
                m_has_vml_attr = false;
                m_vml_attr = false;
            
                m_has_allowPng_attr = false;
                m_allowPng_attr = false;
            
                m_has_targetScreenSize_attr = false;
                
        if (m_targetScreenSize_attr)
        {
            delete m_targetScreenSize_attr;
            m_targetScreenSize_attr = NULL;
        }
    
            
                m_has_dpi_attr = false;
                m_dpi_attr = 0;
            
                m_has_codePage_attr = false;
                m_codePage_attr = 0;
            
                m_has_characterSet_attr = false;
                m_characterSet_attr.clear();
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << XSD::BooleanStr(m_css_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_thicket_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_longFileNames_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_vml_attr) << \\\;
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_allowPng_attr) << \\\;
m_targetScreenSize_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << m_dpi_attr << \\\;
_outStream << _attrName << \=\\ << m_codePage_attr << \\\;
_outStream << _attrName << \=\\ << m_characterSet_attr << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_WebPublishing& default_instance(){

    if (!CT_WebPublishing::default_instance_)
    {
        CT_WebPublishing::default_instance_ = new CT_WebPublishing();
    }
    return *CT_WebPublishing::default_instance_;

        }
        bool has_css_attr(){

            return m_has_css_attr;
        
        }
        void set_css_attr(const boolean& _css_attr ){

        m_has_css_attr = true;
        m_css_attr = _css_attr;
        
        }
        const boolean& css_attr(){

            return type: oolean\nname: \m_css_attr\n;
        
        }
        bool has_thicket_attr(){

            return m_has_thicket_attr;
        
        }
        void set_thicket_attr(const boolean& _thicket_attr ){

        m_has_thicket_attr = true;
        m_thicket_attr = _thicket_attr;
        
        }
        const boolean& thicket_attr(){

            return type: oolean\nname: \m_thicket_attr\n;
        
        }
        bool has_longFileNames_attr(){

            return m_has_longFileNames_attr;
        
        }
        void set_longFileNames_attr(const boolean& _longFileNames_attr ){

        m_has_longFileNames_attr = true;
        m_longFileNames_attr = _longFileNames_attr;
        
        }
        const boolean& longFileNames_attr(){

            return type: oolean\nname: \m_longFileNames_attr\n;
        
        }
        bool has_vml_attr(){

            return m_has_vml_attr;
        
        }
        void set_vml_attr(const boolean& _vml_attr ){

        m_has_vml_attr = true;
        m_vml_attr = _vml_attr;
        
        }
        const boolean& vml_attr(){

            return type: oolean\nname: \m_vml_attr\n;
        
        }
        bool has_allowPng_attr(){

            return m_has_allowPng_attr;
        
        }
        void set_allowPng_attr(const boolean& _allowPng_attr ){

        m_has_allowPng_attr = true;
        m_allowPng_attr = _allowPng_attr;
        
        }
        const boolean& allowPng_attr(){

            return type: oolean\nname: \m_allowPng_attr\n;
        
        }
        bool has_targetScreenSize_attr(){

            return m_has_targetScreenSize_attr;
        
        }
        void set_targetScreenSize_attr(const ST_TargetScreenSize& _targetScreenSize_attr ){

            m_has_targetScreenSize_attr = true;
            m_targetScreenSize_attr = new ST_TargetScreenSize(_targetScreenSize_attr);
        
        }
        const ST_TargetScreenSize& targetScreenSize_attr(){

            if (m_targetScreenSize_attr)
            {
                return *m_targetScreenSize_attr;
            }
            return ST_TargetScreenSize::default_instance();
        
        }
        bool has_dpi_attr(){

            return m_has_dpi_attr;
        
        }
        void set_dpi_attr(const unsignedInt& _dpi_attr ){

        m_has_dpi_attr = true;
        m_dpi_attr = _dpi_attr;
        
        }
        const unsignedInt& dpi_attr(){

            return type: \unsignedInt\nname: \m_dpi_attr\n;
        
        }
        bool has_codePage_attr(){

            return m_has_codePage_attr;
        
        }
        void set_codePage_attr(const unsignedInt& _codePage_attr ){

        m_has_codePage_attr = true;
        m_codePage_attr = _codePage_attr;
        
        }
        const unsignedInt& codePage_attr(){

            return type: \unsignedInt\nname: \m_codePage_attr\n;
        
        }
        bool has_characterSet_attr(){

            return m_has_characterSet_attr;
        
        }
        void set_characterSet_attr(const string& _characterSet_attr ){

        m_has_characterSet_attr = true;
        m_characterSet_attr = _characterSet_attr;
        
        }
        const string& characterSet_attr(){

            return type: \string\nname: \m_characterSet_attr\n;
        
        }

    private:
        static CT_WebPublishing* default_instance_ ;
        bool m_has_css_attr ;
        boolean m_css_attr ;
        bool m_has_thicket_attr ;
        boolean m_thicket_attr ;
        bool m_has_longFileNames_attr ;
        boolean m_longFileNames_attr ;
        bool m_has_vml_attr ;
        boolean m_vml_attr ;
        bool m_has_allowPng_attr ;
        boolean m_allowPng_attr ;
        bool m_has_targetScreenSize_attr ;
        ST_TargetScreenSize* m_targetScreenSize_attr ;
        bool m_has_dpi_attr ;
        unsignedInt m_dpi_attr ;
        bool m_has_codePage_attr ;
        unsignedInt m_codePage_attr ;
        bool m_has_characterSet_attr ;
        string m_characterSet_attr ;

    }

    class CT_FunctionGroups : public XSD::ComplexType{
    public:
        CT_FunctionGroup* add_functionGroup(){

            vector<ChildGroup_1*> *pChildGroup = new ChildGroup_1();
            CT_FunctionGroup* pNewChild = pChildGroup->mutable_functionGroup();
            m_childGroupList_1.push_back(pChildGroup);
            return pNewChild;
        
        }
        void clear(){

                m_has_builtInGroupCount_attr = false;
                m_builtInGroupCount_attr = 0;
            
            vector<ChildGroup_1*>::iterator iter;
            for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
            {
                delete *iter;
            }
            m_childGroupList_1.clear();
        
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_builtInGroupCount_attr << \\\;
        _outStream << \>\;
    
        vector<ChildGroup_1*>::const_iterator iter;
        for (iter = m_childGroupList_1.begin(); iter != m_childGroupList_1.end(); ++iter)
        {
            if ((*iter)->has_functionGroup())
            {
                (*iter)->toXml(functionGroup, _outStream);
            }
        }
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_FunctionGroups& default_instance(){

    if (!CT_FunctionGroups::default_instance_)
    {
        CT_FunctionGroups::default_instance_ = new CT_FunctionGroups();
    }
    return *CT_FunctionGroups::default_instance_;

        }
        bool has_builtInGroupCount_attr(){

            return m_has_builtInGroupCount_attr;
        
        }
        void set_builtInGroupCount_attr(const unsignedInt& _builtInGroupCount_attr ){

        m_has_builtInGroupCount_attr = true;
        m_builtInGroupCount_attr = _builtInGroupCount_attr;
        
        }
        const unsignedInt& builtInGroupCount_attr(){

            return type: \unsignedInt\nname: \m_builtInGroupCount_attr\n;
        
        }

    private:
        vector<ChildGroup_1*> m_childGroupList_1 ;
        static CT_FunctionGroups* default_instance_ ;
        bool m_has_builtInGroupCount_attr ;
        unsignedInt m_builtInGroupCount_attr ;
        class ChildGroup_1{
        public:
            bool has_functionGroup(){

            return m_has_functionGroup;
        
            }
            CT_FunctionGroup* mutable_functionGroup(){

                
                m_has_functionGroup = true;
                if (!m_functionGroup)
                {
                    m_functionGroup = new CT_FunctionGroup();
                }
                return m_functionGroup;
            
            }
            const CT_FunctionGroup& functionGroup(){

            if (m_functionGroup)
            {
                return *m_functionGroup;
            }
            return CT_FunctionGroup::default_instance();
        
            }

        private:
            bool m_has_functionGroup ;
            CT_FunctionGroup* m_functionGroup ;

        }


    }

    class CT_FunctionGroup : public XSD::ComplexType{
    public:
        void clear(){

                m_has_name_attr = false;
                
        if (m_name_attr)
        {
            delete m_name_attr;
            m_name_attr = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    m_name_attr->toXml(_attrName, _outStream);
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_FunctionGroup& default_instance(){

    if (!CT_FunctionGroup::default_instance_)
    {
        CT_FunctionGroup::default_instance_ = new CT_FunctionGroup();
    }
    return *CT_FunctionGroup::default_instance_;

        }
        bool has_name_attr(){

            return m_has_name_attr;
        
        }
        void set_name_attr(const ns_s::ST_Xstring& _name_attr ){

            m_has_name_attr = true;
            m_name_attr = new ns_s::ST_Xstring(_name_attr);
        
        }
        const ns_s::ST_Xstring& name_attr(){

            if (m_name_attr)
            {
                return *m_name_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }

    private:
        static CT_FunctionGroup* default_instance_ ;
        bool m_has_name_attr ;
        ns_s::ST_Xstring* m_name_attr ;

    }

    class CT_WebPublishObjects : public XSD::ComplexType{
    public:
        bool has_webPublishObject(){

            return m_has_webPublishObject;
        
        }
        CT_WebPublishObject* mutable_webPublishObject(){

                m_has_webPublishObject = true;
                if (!m_webPublishObject)
                {
                    m_webPublishObject = new CT_WebPublishObject();
                }
                return m_webPublishObject;
            
        }
        const CT_WebPublishObject& webPublishObject(){

            if (m_webPublishObject)
            {
                return *m_webPublishObject;
            }
            return CT_WebPublishObject::default_instance();
        
        }
        void clear(){

                m_has_count_attr = false;
                m_count_attr = 0;
            
                m_has_webPublishObject = false;
                
        if (m_webPublishObject)
        {
            delete m_webPublishObject;
            m_webPublishObject = NULL;
        }
    
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_count_attr << \\\;
        _outStream << \>\;
    
                if (m_has_webPublishObject)
                {
                    m_webPublishObject->toXml(webPublishObject, _outStream);;
                }
            
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_WebPublishObjects& default_instance(){

    if (!CT_WebPublishObjects::default_instance_)
    {
        CT_WebPublishObjects::default_instance_ = new CT_WebPublishObjects();
    }
    return *CT_WebPublishObjects::default_instance_;

        }
        bool has_count_attr(){

            return m_has_count_attr;
        
        }
        void set_count_attr(const unsignedInt& _count_attr ){

        m_has_count_attr = true;
        m_count_attr = _count_attr;
        
        }
        const unsignedInt& count_attr(){

            return type: \unsignedInt\nname: \m_count_attr\n;
        
        }

    private:
        bool m_has_webPublishObject ;
        CT_WebPublishObject* m_webPublishObject ;
        static CT_WebPublishObjects* default_instance_ ;
        bool m_has_count_attr ;
        unsignedInt m_count_attr ;

    }

    class CT_WebPublishObject : public XSD::ComplexType{
    public:
        void clear(){

                m_has_id_attr = false;
                m_id_attr = 0;
            
                m_has_divId_attr = false;
                
        if (m_divId_attr)
        {
            delete m_divId_attr;
            m_divId_attr = NULL;
        }
    
            
                m_has_sourceObject_attr = false;
                
        if (m_sourceObject_attr)
        {
            delete m_sourceObject_attr;
            m_sourceObject_attr = NULL;
        }
    
            
                m_has_destinationFile_attr = false;
                
        if (m_destinationFile_attr)
        {
            delete m_destinationFile_attr;
            m_destinationFile_attr = NULL;
        }
    
            
                m_has_title_attr = false;
                
        if (m_title_attr)
        {
            delete m_title_attr;
            m_title_attr = NULL;
        }
    
            
                m_has_autoRepublish_attr = false;
                m_autoRepublish_attr = false;
            
        }
        void toXml(const string _elemName , ostream _outStream ){

        _outStream << \<\ << _elementName;
    _outStream << _attrName << \=\\ << m_id_attr << \\\;
m_divId_attr->toXml(_attrName, _outStream);
m_sourceObject_attr->toXml(_attrName, _outStream);
m_destinationFile_attr->toXml(_attrName, _outStream);
m_title_attr->toXml(_attrName, _outStream);
_outStream << _attrName << \=\\ << XSD::BooleanStr(m_autoRepublish_attr) << \\\;
        _outStream << \>\;
    
        _outStream << \</\ << _elementName << \>\;
    
        }
        const CT_WebPublishObject& default_instance(){

    if (!CT_WebPublishObject::default_instance_)
    {
        CT_WebPublishObject::default_instance_ = new CT_WebPublishObject();
    }
    return *CT_WebPublishObject::default_instance_;

        }
        bool has_id_attr(){

            return m_has_id_attr;
        
        }
        void set_id_attr(const unsignedInt& _id_attr ){

        m_has_id_attr = true;
        m_id_attr = _id_attr;
        
        }
        const unsignedInt& id_attr(){

            return type: \unsignedInt\nname: \m_id_attr\n;
        
        }
        bool has_divId_attr(){

            return m_has_divId_attr;
        
        }
        void set_divId_attr(const ns_s::ST_Xstring& _divId_attr ){

            m_has_divId_attr = true;
            m_divId_attr = new ns_s::ST_Xstring(_divId_attr);
        
        }
        const ns_s::ST_Xstring& divId_attr(){

            if (m_divId_attr)
            {
                return *m_divId_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_sourceObject_attr(){

            return m_has_sourceObject_attr;
        
        }
        void set_sourceObject_attr(const ns_s::ST_Xstring& _sourceObject_attr ){

            m_has_sourceObject_attr = true;
            m_sourceObject_attr = new ns_s::ST_Xstring(_sourceObject_attr);
        
        }
        const ns_s::ST_Xstring& sourceObject_attr(){

            if (m_sourceObject_attr)
            {
                return *m_sourceObject_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_destinationFile_attr(){

            return m_has_destinationFile_attr;
        
        }
        void set_destinationFile_attr(const ns_s::ST_Xstring& _destinationFile_attr ){

            m_has_destinationFile_attr = true;
            m_destinationFile_attr = new ns_s::ST_Xstring(_destinationFile_attr);
        
        }
        const ns_s::ST_Xstring& destinationFile_attr(){

            if (m_destinationFile_attr)
            {
                return *m_destinationFile_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_title_attr(){

            return m_has_title_attr;
        
        }
        void set_title_attr(const ns_s::ST_Xstring& _title_attr ){

            m_has_title_attr = true;
            m_title_attr = new ns_s::ST_Xstring(_title_attr);
        
        }
        const ns_s::ST_Xstring& title_attr(){

            if (m_title_attr)
            {
                return *m_title_attr;
            }
            return ns_s::ST_Xstring::default_instance();
        
        }
        bool has_autoRepublish_attr(){

            return m_has_autoRepublish_attr;
        
        }
        void set_autoRepublish_attr(const boolean& _autoRepublish_attr ){

        m_has_autoRepublish_attr = true;
        m_autoRepublish_attr = _autoRepublish_attr;
        
        }
        const boolean& autoRepublish_attr(){

            return type: oolean\nname: \m_autoRepublish_attr\n;
        
        }

    private:
        static CT_WebPublishObject* default_instance_ ;
        bool m_has_id_attr ;
        unsignedInt m_id_attr ;
        bool m_has_divId_attr ;
        ns_s::ST_Xstring* m_divId_attr ;
        bool m_has_sourceObject_attr ;
        ns_s::ST_Xstring* m_sourceObject_attr ;
        bool m_has_destinationFile_attr ;
        ns_s::ST_Xstring* m_destinationFile_attr ;
        bool m_has_title_attr ;
        ns_s::ST_Xstring* m_title_attr ;
        bool m_has_autoRepublish_attr ;
        boolean m_autoRepublish_attr ;

    }

    class calcChain : public CT_CalcChain : public Element{
    public:
        void toXml(ostream& _outStream ){

        CT_CalcChain::toXml(\calcChain\, _outStream);
    
        }

    private:

    }

    class comments : public CT_Comments : public Element{
    public:
        void toXml(ostream& _outStream ){

        CT_Comments::toXml(\comments\, _outStream);
    
        }

    private:

    }

    class MapInfo : public CT_MapInfo : public Element{
    public:
        void toXml(ostream& _outStream ){

        CT_MapInfo::toXml(\MapInfo\, _outStream);
    
        }

    private:

    }

    class connections : public CT_Connections : public Element{
    public:
        void toXml(ostream& _outStream ){

        CT_Connections::toXml(\connections\, _outStream);
    
        }

    private:

    }

    class pivotCacheDefinition : public CT_PivotCacheDefinition : public Element{
    public:
        void toXml(ostream& _outStream ){

        CT_PivotCacheDefinition::toXml(\pivotCacheDefinition\, _outStream);
    
        }

    private:

    }

    class pivotCacheRecords : public CT_PivotCacheRecords : public Element{
    public:
        void toXml(ostream& _outStream ){

        CT_PivotCacheRecords::toXml(\pivotCacheRecords\, _outStream);
    
        }

    private:

    }

    class pivotTableDefinition : public CT_pivotTableDefinition : public Element{
    public:
        void toXml(ostream& _outStream ){

        CT_pivotTableDefinition::toXml(\pivotTableDefinition\, _outStream);
    
        }

    private:

    }

    class queryTable : public CT_QueryTable : public Element{
    public:
        void toXml(ostream& _outStream ){

        CT_QueryTable::toXml(\queryTable\, _outStream);
    
        }

    private:

    }

    class sst : public CT_Sst : public Element{
    public:
        void toXml(ostream& _outStream ){

        CT_Sst::toXml(\sst\, _outStream);
    
        }

    private:

    }

    class headers : public CT_RevisionHeaders : public Element{
    public:
        void toXml(ostream& _outStream ){

        CT_RevisionHeaders::toXml(\headers\, _outStream);
    
        }

    private:

    }

    class revisions : public CT_Revisions : public Element{
    public:
        void toXml(ostream& _outStream ){

        CT_Revisions::toXml(evisions\, _outStream);
    
        }

    private:

    }

    class users : public CT_Users : public Element{
    public:
        void toXml(ostream& _outStream ){

        CT_Users::toXml(\users\, _outStream);
    
        }

    private:

    }

    class worksheet : public CT_Worksheet : public Element{
    public:
        void toXml(ostream& _outStream ){

        CT_Worksheet::toXml(\worksheet\, _outStream);
    
        }

    private:

    }

    class chartsheet : public CT_Chartsheet : public Element{
    public:
        void toXml(ostream& _outStream ){

        CT_Chartsheet::toXml(\chartsheet\, _outStream);
    
        }

    private:

    }

    class dialogsheet : public CT_Dialogsheet : public Element{
    public:
        void toXml(ostream& _outStream ){

        CT_Dialogsheet::toXml(\dialogsheet\, _outStream);
    
        }

    private:

    }

    class metadata : public CT_Metadata : public Element{
    public:
        void toXml(ostream& _outStream ){

        CT_Metadata::toXml(\metadata\, _outStream);
    
        }

    private:

    }

    class singleXmlCells : public CT_SingleXmlCells : public Element{
    public:
        void toXml(ostream& _outStream ){

        CT_SingleXmlCells::toXml(\singleXmlCells\, _outStream);
    
        }

    private:

    }

    class styleSheet : public CT_Stylesheet : public Element{
    public:
        void toXml(ostream& _outStream ){

        CT_Stylesheet::toXml(\styleSheet\, _outStream);
    
        }

    private:

    }

    class externalLink : public CT_ExternalLink : public Element{
    public:
        void toXml(ostream& _outStream ){

        CT_ExternalLink::toXml(\externalLink\, _outStream);
    
        }

    private:

    }

    class table : public CT_Table : public Element{
    public:
        void toXml(ostream& _outStream ){

        CT_Table::toXml(	able\, _outStream);
    
        }

    private:

    }

    class volTypes : public CT_VolTypes : public Element{
    public:
        void toXml(ostream& _outStream ){

        CT_VolTypes::toXml(olTypes\, _outStream);
    
        }

    private:

    }

    class workbook : public CT_Workbook : public Element{
    public:
        void toXml(ostream& _outStream ){

        CT_Workbook::toXml(\workbook\, _outStream);
    
        }

    private:

    }

}